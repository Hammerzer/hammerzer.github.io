<!DOCTYPE html><html lang="zh-CN"><head><script src="https://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/180-180.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/32-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/16-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hammerzer.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="CONTENT OUTLINE BootCDN  —  常见库Cdn React 中文官网 React 脚手架CRA   2023&#x2F;10&#x2F;21追加React的内容，需要做一些前端的开发   学习笔记 尚硅谷的React教程   源码：BaiduCloud  📢 愿你生活明朗，万物可爱🙏"><meta property="og:type" content="article"><meta property="og:title" content="React-起步"><meta property="og:url" content="https://hammerzer.github.io/2021/01/13/React-start/index.html"><meta property="og:site_name" content="Moustache&#39;s Blog"><meta property="og:description" content="CONTENT OUTLINE BootCDN  —  常见库Cdn React 中文官网 React 脚手架CRA   2023&#x2F;10&#x2F;21追加React的内容，需要做一些前端的开发   学习笔记 尚硅谷的React教程   源码：BaiduCloud  📢 愿你生活明朗，万物可爱🙏"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/1-1.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/1-3.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/1-4.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/1-2.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/2-1.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/2-4.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/2-2.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/2-3.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/3-1.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/3-2.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/3-3.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/two-1.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/weather.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720203721926.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720211554914.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720212505232.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720213304037.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720215332387.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720222147149.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210821102153009.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210821102622645.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/%E8%84%9A%E6%89%8B%E6%9E%B6.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210826092737826.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210826103418053.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-1.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-addtodo.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-mouse.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-update.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-detele.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210826160505813.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-all.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-clear.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210827091119837.png"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/7-1.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/%E8%BD%AC%E5%8F%91.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828065604542.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828070148865.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828071053508.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828072705747.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-github.gif"><meta property="og:image" content="https://hammerzer.github.io/2021/01/13/React-start/9-1.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210901142121047.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-navlink.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210903075753268.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-tworouter.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210904013342960.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-params.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906153042353.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906155217647.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906160940033.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-push.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-replace.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906231051190.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907180731157.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907181354552.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907181854774.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907200116517.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210909194446988.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210909194900532.png"><meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/12/16e5fd1597faec4d~tplv-t2oaga2asx-watermark.awebp"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210910094426268.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-redux-demo.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-redux-demo.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo1.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo1-2.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo1-3.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo2-1.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo2-2.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911114307684.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911115542647.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-lazyload-2.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-lazyload-3.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911123011304.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-hook-1.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-hook-2.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911151643934.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911152037120.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911161103300.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210914172936843.png"><meta property="article:published_time" content="2021-01-13T06:48:58.000Z"><meta property="article:modified_time" content="2025-01-19T03:19:15.903Z"><meta property="article:author" content="Moustache"><meta property="article:tag" content="框架与工具"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hammerzer.github.io/2021/01/13/React-start/1-1.png"><link rel="canonical" href="https://hammerzer.github.io/2021/01/13/React-start/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>React-起步 | Moustache's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Moustache's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Moustache's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">小胡子的私人空间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">36</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">79</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hammerzer.github.io/2021/01/13/React-start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/180-180.png"><meta itemprop="name" content="Moustache"><meta itemprop="description" content="我是小胡子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Moustache's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React-起步</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-01-13 14:48:58" itemprop="dateCreated datePublished" datetime="2021-01-13T14:48:58+08:00">2021-01-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-19 11:19:15" itemprop="dateModified" datetime="2025-01-19T11:19:15+08:00">2025-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-End/" itemprop="url" rel="index"><span itemprop="name">Front End</span></a> </span></span><span id="/2021/01/13/React-start/" class="post-meta-item leancloud_visitors" data-flag-title="React-起步" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> <span>℃</span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2021/01/13/React-start/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/01/13/React-start/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>71k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1:05</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><ul><li><a target="_blank" rel="noopener" href="https://www.bootcdn.cn/">BootCDN — 常见库Cdn</a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/">React 中文官网</a></li><li><a target="_blank" rel="noopener" href="https://create-react-app.dev/docs/setting-up-your-editor/">React 脚手架CRA</a></li></ul><blockquote><p>2023/10/21追加React的内容，需要做一些前端的开发</p></blockquote><ul><li><a target="_blank" rel="noopener" href="https://github.com/Hammerzer/react-study">学习笔记</a></li><li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wy4y1D7JT/?spm_id_from=333.337.search-card.all.click&vd_source=ad866fe26d18693e4132a3c33f8fba36">尚硅谷的React教程</a> 源码：BaiduCloud</li></ul><p>📢 愿你生活明朗，万物可爱🙏</p><span id="more"></span><h2 id="〇、React起步"><a href="#〇、React起步" class="headerlink" title="〇、React起步"></a>〇、React起步</h2><blockquote><p>入手初步内容来源于这个 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LV411m7cq?p=4">React 教程</a></p><p>源码可直取：<a target="_blank" rel="noopener" href="https://gitee.com/Hammerzer/react-resource">传送门</a></p></blockquote><h3 id="1、使用-React-的原因-技术选型理由"><a href="#1、使用-React-的原因-技术选型理由" class="headerlink" title="1、使用 React 的原因/技术选型理由"></a>1、使用 <code>React</code> 的原因/技术选型理由</h3><p>React，基于构建用户界面的 <code>JavaScript</code> 库</p><p>基于<code>React</code>的特点：声明式、组件化、一次学习随处编写</p><p><img src="./1-1.png"></p><p><img src="./1-3.png"></p><blockquote><p><strong>对于最后一个特性的理解：</strong></p><p>Web端应用：React + React DOM</p><p>移动端应用：React + React Native</p><p>PC端应用：React + React Electron</p><p>小程序：React + Taro</p><p>VR界面：React + React 360</p></blockquote><p><strong>1、易学，学习曲线稍难于 <code>Vue</code></strong></p><p><img src="./1-4.png"></p><p><strong>2、开发迅速</strong></p><p>采用流行的 <code>MVC</code> 架构，组件化，以及<code>React</code>周边生态的完善性，如各种UI库、路由库、脚手架、<code>Chrome-React-devTool</code>等等。</p><p>解决原生 <code>Javascript</code> 的痛点</p><p><strong>3、由 <code>Facebook</code> 大型公司提供维护</strong></p><p><img src="./1-2.png"></p><p><strong>4、受欢迎，拥有火热的<code>React</code>社区</strong></p><h3 id="2、Quick-Start"><a href="#2、Quick-Start" class="headerlink" title="2、Quick Start"></a>2、Quick Start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>项目中 <code>package.json</code> 中定义的启动脚本</p><p><img src="./2-1.png"></p><p>其中，<code>npm eject</code> 用于暴露 <code>webpack</code> 配置以手动配置 <code>webpack</code> 配置，但该操作不可逆；</p><p>除此之外，也有使用相应依赖来修改配置的选择，如 <code>customize-cra</code></p><p><img src="./2-4.png"></p><blockquote><p>当说到为什么 <code>CRA</code> 不把 <code>webpack</code> 配置暴露出来，<code>Dan Abramov</code> 是这样说的：</p></blockquote><p><img src="./2-2.png"></p><blockquote><p>这儿有关于这位大佬的自传，好喜欢这些传奇故事~~ <a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/my-decade-in-review/">传送门</a>在此</p></blockquote><p>另外，需要学会利用 <code>vscode</code> 进行代码调试，在目录新建 <code>.vscode</code> 文件夹，继续新建 <code>launch.js</code>，然后在编辑器 <code>debug</code> 中配置</p><p><img src="./2-3.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Chrome&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;chrome&quot;</span>,</span><br><span class="line">      <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">      <span class="string">&quot;webRoot&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/src&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceMapPathOverrides&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;webpack:///src/*&quot;</span>: <span class="string">&quot;$&#123;webRoot&#125;/*&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、JSX指引"><a href="#3、JSX指引" class="headerlink" title="3、JSX指引"></a>3、JSX指引</h3><p>① <code>JSX</code> 是<code>Javascript</code>的扩展语法</p><p>② <code>React Element</code> 是不可不变的对象（immutable）</p><blockquote><p>类似于<code>Object.freeze()</code> 方法，使得对象只可读</p></blockquote><p><img src="./3-1.png"></p><p>③ 经过 <code>Babel</code> 转译之后：</p><p><img src="./3-2.png"></p><p><img src="./3-3.png"></p><br><h2 id="一、尚硅谷React全家桶笔记"><a href="#一、尚硅谷React全家桶笔记" class="headerlink" title="一、尚硅谷React全家桶笔记"></a>一、尚硅谷React全家桶笔记</h2><h3 id="001、React-简介"><a href="#001、React-简介" class="headerlink" title="001、React 简介"></a>001、React 简介</h3><h3 id="002、Hello-react"><a href="#002、Hello-react" class="headerlink" title="002、Hello_react"></a>002、Hello_react</h3><p>1、要是再 <code>Html</code> 中的 <code>script</code> 中使用 <code>JSX</code>， 要求 <code>type = &quot;text/babel&quot;</code></p><p>2、<code>ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))</code> 是替换虚拟 <code>DOM</code>，而不是追加！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello_react<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入react核心库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入babel，用于将jsx转为js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span> &gt;</span><span class="language-javascript"> <span class="comment">/* 此处一定要写babel */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.创建虚拟DOM</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">/* 此处一定不要写引号，因为不是字符串 */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.渲染虚拟DOM到页面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h3 id="003、虚拟-DOM-创建方法"><a href="#003、虚拟-DOM-创建方法" class="headerlink" title="003、虚拟 DOM 创建方法"></a>003、虚拟 DOM 创建方法</h3><h4 id="1-创建虚拟-DOM"><a href="#1-创建虚拟-DOM" class="headerlink" title="1 创建虚拟 DOM"></a>1 创建虚拟 <code>DOM</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 js 创建虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = </span><br><span class="line">      <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">          <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">          &#123;<span class="attr">id</span>:<span class="string">&#x27;title&#x27;</span>&#125;,</span><br><span class="line">          <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>,&#123;&#125;,<span class="string">&#x27;Hello,React&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用 JSX 创建虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (  <span class="comment">/* 此处一定不要写引号，因为不是字符串 */</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><blockquote><p>使用JSX的优势：可以不适用嵌套的写法</p></blockquote><h4 id="2-真实DOM与虚拟DOM区别"><a href="#2-真实DOM与虚拟DOM区别" class="headerlink" title="2 真实DOM与虚拟DOM区别"></a>2 真实DOM与虚拟DOM区别</h4><p><strong>关于虚拟DOM：</strong></p><p>​ 1.本质是Object类型的对象（一般对象）</p><p>​ 2.虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。</p><p>​ 3.虚拟DOM最终会被React转化为真实DOM，呈现在页面上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (  <span class="comment">/* 此处一定不要写引号，因为不是字符串 */</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line"><span class="comment">//2.渲染虚拟DOM到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TDOM</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;虚拟DOM&#x27;</span>,<span class="variable constant_">VDOM</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable constant_">VDOM</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">VDOM</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;真实DOM&#x27;</span>,<span class="variable constant_">TDOM</span>);</span><br><span class="line"><span class="keyword">debugger</span>;</span><br></pre></td></tr></table></figure><p><img src="./two-1.png"></p><br><h3 id="004、JSX-语法规则"><a href="#004、JSX-语法规则" class="headerlink" title="004、JSX 语法规则"></a>004、JSX 语法规则</h3><ul><li>定义虚拟DOM，不能使用<code>“”</code></li><li>标签中混入JS表达式的时候使用<code>&#123;&#125;</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id = &#123;myId.<span class="title function_">toUpperCase</span>()&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&#123;myId.toUpperCase()&#125;</span> <span class="attr">className</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><ul><li>样式的类名指定不能使用class，使用<code>className</code></li><li>内敛样式要使用<code>&#123;&#123;&#125;&#125;</code>包裹【外侧代表使用JS，内层括号代表键值对】</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;skyblue&#x27;</span>,<span class="attr">fontSize</span>:<span class="string">&#x27;24px&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>不能有多个根标签，只能有一个根标签</li><li>标签必须闭合，自闭合也行</li><li>标签首字母：<ul><li>如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；</li><li>如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错</li></ul></li></ul><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h4><p>写在花括号里</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>小丞<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/*注释...*/&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h4><p>JSX 允许在模板中插入数组，数组自动展开全部成员</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>小丞<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>同学<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="tip-JSX-小练习"><a href="#tip-JSX-小练习" class="headerlink" title="tip: JSX 小练习"></a>tip: JSX 小练习</h4><p>根据动态数据生成 <code>li</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                data.map((item,index)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                    return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>,<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test&#x27;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>再次强调，<code>&#123;&#125;</code>中混入的是 <strong>JS表达式</strong></p><p>diff算法依赖<code>&lt;li&gt;</code>便签的key值</p></blockquote><br><h2 id="二、面向组件编程"><a href="#二、面向组件编程" class="headerlink" title="二、面向组件编程"></a>二、<a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B.md">面向组件编程</a></h2><h3 id="1-组件的使用"><a href="#1-组件的使用" class="headerlink" title="1 组件的使用"></a>1 组件的使用</h3><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p><blockquote><p><strong>注意：</strong></p><ol><li><p>组件名必须是首字母大写</p></li><li><p>虚拟DOM元素只能有一个根元素</p></li><li><p>虚拟DOM元素必须有结束标签 <code>&lt; /&gt;</code></p></li></ol></blockquote><p><strong>渲染类组件标签的基本流程</strong></p><ol><li><p>React 内部会创建组件实例对象</p></li><li><p>调用<code>render()</code>得到虚拟 DOM ,并解析为真实 DOM</p></li><li><p>插入到指定的页面元素内部</p></li></ol><h4 id="1-1-函数式组件"><a href="#1-1-函数式组件" class="headerlink" title="1.1 函数式组件"></a>1.1 函数式组件</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先创建函数，函数可以有参数，也可以没有，但是必须要有返回值 返回一个虚拟DOM</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 此处的this是undefined，babel编译后开启严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.进行渲染</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title class_">Render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Welcom</span> <span class="attr">name</span> = <span class="string">&quot;ljc&quot;</span> /&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div&quot;</span>));</span><br></pre></td></tr></table></figure><p>上面的代码经历了以下几步</p><ol><li>我们调用 <code>ReactDOM.render()</code> 函数，并传入 <code>&lt;Welcome name=&quot;ljc&quot; /&gt;</code> 作为参数。</li><li>React 调用 <code>Welcome</code> 组件，并将 <code>&#123;name: &#39;ljc&#39;&#125;</code> 作为 props 传入。</li><li><code>Welcome</code> 组件将 <code>Hello, ljc</code> 元素作为返回值。</li><li>React DOM 将 DOM 高效地更新为 <code>Hello,ljc</code>。</li></ol><h4 id="1-2-类式组件"><a href="#1-2-类式组件" class="headerlink" title="1.2 类式组件"></a>1.2 类式组件</h4><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/weather.gif" alt="weather"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>&#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;isHot&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot?&#x27;炎热&#x27;:&#x27;凉爽&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义方法：为了能使用到this，同vue，为了把函数挂在实例上，且能访问this</span></span><br><span class="line">    changeWeather = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isHot = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test&#x27;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>尚硅谷的React教程里详细讲了这个类里的构造器为什么可以不写？为什么state可以直接写？为什么change函数需要用箭头函数赋值？</p></blockquote><p><strong>在优化过程中遇到的问题</strong></p><ol><li><p>组件中的 render 方法中的 this 为组件实例对象</p></li><li><p>组件自定义方法中由于开启了严格模式，this 指向 <code>undefined</code> 如何解决</p><ol><li><p><strong>通过 bind 改变 this 指向</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在构造函数中</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">func</span> = <span class="variable language_">this</span>.<span class="property">func</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="comment">// bind函数做两件事:1.生成一个新函数2.修改新函数中的this</span></span><br><span class="line"><span class="comment">// 此操作在实例上生成一个func，实例原型上的func依然存在</span></span><br></pre></td></tr></table></figure></li><li><p>推荐采用箭头函数，箭头函数的 <code>this</code> 指向【<strong>箭头函数没有自己的this，但可以在函数体内部使用外层函数的this</strong>】</p></li></ol></li><li><p>state 数据不能直接修改或者更新</p></li></ol><h4 id="1-3-其他知识"><a href="#1-3-其他知识" class="headerlink" title="1.3 其他知识"></a>1.3 其他知识</h4><p>包含表单元素的组件分为非受控组件与受控组件</p><ul><li><strong>受控组件</strong>：表单组件的输入组件随着输入并将内容存储到状态中（随时更新）</li><li><strong>非受控组件</strong>：表单组件的输入组件的内容在有需求的时候才存储到状态中（即用即取）</li></ul><br><h3 id="2-组件实例三大属性"><a href="#2-组件实例三大属性" class="headerlink" title="2 组件实例三大属性"></a>2 组件实例三大属性</h3><blockquote><p>以前的只用类式组件才有三个属性，最新React推出的<code>Hooks</code>，使得函数组件也可以</p></blockquote><h4 id="2-1-state"><a href="#2-1-state" class="headerlink" title="2.1 state"></a>2.1 state</h4><blockquote><p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p><p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</p></blockquote><p>简单的说就是组件的状态，也就是该组件所存储的数据</p><p><strong>类式组件中的使用</strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720203721926.png" alt="image-20210720203721926"></p><p>使用的时候通过<code>this.state</code>调用<code>state</code>里的值</p><p>在类式组件中定义<code>state</code></p><ul><li>在构造器中初始化<code>state</code></li><li>在类中添加属性<code>state</code>来初始化</li></ul><p><strong>修改 state</strong></p><p>在<strong>类式组件</strong>的函数中，直接修改<code>state</code>值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">weather</span> = <span class="string">&#x27;凉爽&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>页面的渲染靠的是<code>render</code>函数</p></blockquote><p>这时候会发现页面内容不会改变，原因是 React 中不建议 <code>state</code>不允许直接修改，而是通过类的原型对象上的方法 <code>setState()</code></p><p><strong>setState()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(partialState, [callback]);</span><br></pre></td></tr></table></figure><ul><li><code>partialState</code>: 需要更新的状态的部分对象</li><li><code>callback</code>: 更新完状态后的回调函数</li></ul><p>有两种写法：写法1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">weather</span>: <span class="string">&quot;凉爽&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个函数，返回x需要修改成的对象，参数为当前的 state</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.<span class="property">count</span>+<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><code>setState</code>是一种合并操作，不是替换操作</p><hr><ul><li>在执行 <code>setState</code>操作后，React 会自动调用一次 <code>render()</code></li><li><code>render()</code> 的执行次数是 1+n (1 为初始化时的自动调用，n 为状态更新的次数)</li></ul><br><h4 id="2-2-props"><a href="#2-2-props" class="headerlink" title="2.2 props"></a>2.2 props</h4><p>与<code>state</code>不同，<code>state</code>是组件自身的状态，而<code>props</code>则是外部传入的数据</p><p><strong>类式组件中使用</strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720211554914.png" alt="image-20210720211554914"></p><p>在使用的时候可以通过 <code>this.props</code>来获取值 类式组件的 <code>props</code>:</p><ol><li>通过在组件标签上传递值，在组件中就可以获取到所传递的值</li><li>在构造器里的<code>props</code>参数里可以获取到 <code>props</code></li><li>可以分别设置 <code>propTypes</code> 和 <code>defaultProps</code> 两个属性来分别操作 <code>props</code>的规范和默认值，两者都是直接添加在类式组件的<strong>原型对象</strong>上的（所以需要添加 <code>static</code>）</li><li>同时可以通过<code>...</code>运算符来简化</li></ol><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720212505232.png" alt="image-20210720212505232"></p><p><strong>函数式组件中的使用</strong></p><blockquote><p>函数在使用props的时候，是作为参数进行使用的(props)</p></blockquote><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720213304037.png" alt="image-20210720213304037"></p><p>函数组件的 <code>props</code>定义:</p><ol><li>在组件标签中传递 <code>props</code>的值</li><li>组件函数的参数为 <code>props</code></li><li>对 <code>props</code>的限制和默认值同样设置在原型对象上</li></ol><br><h4 id="2-3-refs"><a href="#2-3-refs" class="headerlink" title="2.3 refs"></a>2.3 refs</h4><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p><blockquote><p>在我们正常的操作节点时，需要采用DOM API 来查找元素，但是这样违背了 React 的理念，因此有了<code>refs</code></p></blockquote><p>有三种操作<code>refs</code>的方法，分别为：</p><ul><li>字符串形式</li><li>回调形式</li><li><code>createRef</code>形式</li></ul><h5 id="1-字符串形式refs"><a href="#1-字符串形式refs" class="headerlink" title="1 字符串形式refs"></a>1 字符串形式<code>refs</code></h5><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720215332387.png" alt="image-20210720215332387"></p><p>虽然这个方法废弃了，但是还能用，还很好用hhh~【效率不高的问题】</p><h5 id="2-回调形式的refs"><a href="#2-回调形式的refs" class="headerlink" title="2 回调形式的refs"></a>2 回调形式的<code>refs</code></h5><p>组件实例的<code>ref</code>属性传递一个回调函数<code>c =&gt; this.input1 = c</code>（箭头函数简写），这样会在实例的属性中存储对DOM节点的引用，使用时可通过<code>this.input1</code>来使用</p><p><strong>使用方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">c</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">input1</span> = c &#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong>我的理解</strong></p><p><code>c</code>会接收到当前节点作为参数，<code>ref</code>的值为函数的返回值，也就是<code>this.input1 = c</code>，因此是给实例下的<code>input1</code>赋值</p><blockquote><p>这种用法会在每次重新更新虚拟DOM时，执行两次此处的内联函数，且第一次传入null，第二次传入DOM元素【React 16.8 依然存在】</p><p>可以将回调函数写成class的绑定函数来避免上面的问题</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="variable language_">this</span>.<span class="property">saveInput</span>&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在标签类中写</span></span><br><span class="line">saveInput = <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input1</span> = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但一般情况下，这个问题可以忽略</p></blockquote><h5 id="3-createRef-形式（推荐写法）"><a href="#3-createRef-形式（推荐写法）" class="headerlink" title="3 createRef 形式（推荐写法）"></a>3 createRef 形式（推荐写法）</h5><p>React 给我们提供了一个相应的API，它会自动的将该 DOM 元素放入实例对象中</p><p>我们先给DOM元素添加ref属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.MyRef&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击弹出&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.MyRef1&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击弹出&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过API，创建React的容器，会将DOM元素赋值给实例对象的名称为容器的属性的<code>current</code>，好烦..</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="title class_">MyRef1</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br></pre></td></tr></table></figure><p>注意：专人专用，一个节点创建一个容器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">btnOnClick = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//创建之后，将自身节点，传入current中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">MyRef</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我们不要过度的使用 ref，如果发生时间的元素刚好是需要操作的元素，就可以使用事件对象去替代。过度使用有什么问题我也不清楚，可能有 bug 吧</p><h4 id="2-4-事件处理"><a href="#2-4-事件处理" class="headerlink" title="2.4 事件处理"></a>2.4 事件处理</h4><ol><li><p>React 使用的是自定义事件，而不是原生的 DOM 事件</p></li><li><p>React 的事件是通过事件委托方式处理的（为了更加的高效）</p></li><li><p>可以通过事件的 <code>event.target</code>获取发生的 DOM 元素对象，可以尽量减少 <code>refs</code>的使用</p></li></ol><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210720222147149.png" alt="image-20210720222147149"></p><br><h3 id="3-收集表单数据"><a href="#3-收集表单数据" class="headerlink" title="3 收集表单数据"></a>3 收集表单数据</h3><ul><li>非受控组件：表单中的数据，现用现取，绑定事件：当提交时触发</li><li>受控组件：表单中的数据，现用现取，绑定事件：当改变时触发，拿到值放入state中维护【即Vue中的双向绑定】</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//创建组件</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>, <span class="comment">//用户名</span></span><br><span class="line">            <span class="attr">password</span>:<span class="string">&#x27;&#x27;</span> <span class="comment">//密码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存用户名到状态中</span></span><br><span class="line">        saveUsername = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">username</span>:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存密码到状态中</span></span><br><span class="line">        savePassword = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">password</span>:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表单提交的回调</span></span><br><span class="line">        handleSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">            event.<span class="title function_">preventDefault</span>() <span class="comment">//阻止表单提交</span></span><br><span class="line">            <span class="keyword">const</span> &#123;username,password&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">`你输入的用户名是：<span class="subst">$&#123;username&#125;</span>,你输入的密码是：<span class="subst">$&#123;password&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveUsername&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.savePassword&#125;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//渲染组件</span></span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><h3 id="5-高阶函数"><a href="#5-高阶函数" class="headerlink" title="5 高阶函数"></a>5 高阶函数</h3><blockquote><p>高阶函数：参数是函数，或者返回值是函数</p><p>Promise、setTimeOut、arr.map()</p></blockquote><p>链接<a target="_blank" rel="noopener" href="https://linjc.blog.csdn.net/article/details/116765732">高阶函数</a>，关于AOP，偏函数，柯里化都有不错的记录，感觉还是不错的</p><p><strong>函数柯里化</strong>：当onChange的回调函数需要传入参数时，需要在其回调函数中，返回一个回调函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>, <span class="comment">//用户名</span></span><br><span class="line">        <span class="attr">password</span>:<span class="string">&#x27;&#x27;</span> <span class="comment">//密码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存表单数据到状态中</span></span><br><span class="line">saveFormData = <span class="function">(<span class="params">dataType</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[dataType]:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表单提交的回调</span></span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>() <span class="comment">//阻止表单提交</span></span><br><span class="line">    <span class="keyword">const</span> &#123;username,password&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`你输入的用户名是：<span class="subst">$&#123;username&#125;</span>,你输入的密码是：<span class="subst">$&#123;password&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">username</span>&#x27;)&#125; <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">password</span>&#x27;)&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>不使用柯里化的写法</strong>：内联写法+箭头函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>, <span class="comment">//用户名</span></span><br><span class="line">        <span class="attr">password</span>:<span class="string">&#x27;&#x27;</span> <span class="comment">//密码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存表单数据到状态中</span></span><br><span class="line">saveFormData = <span class="function">(<span class="params">dataType,event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[dataType]:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表单提交的回调</span></span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>() <span class="comment">//阻止表单提交</span></span><br><span class="line">    <span class="keyword">const</span> &#123;username,password&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`你输入的用户名是：<span class="subst">$&#123;username&#125;</span>,你输入的密码是：<span class="subst">$&#123;password&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> this.saveFormData(&#x27;username&#x27;,event) &#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> this.saveFormData(&#x27;password&#x27;,event) &#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><br><br><h2 id="三、React-生命周期"><a href="#三、React-生命周期" class="headerlink" title="三、React 生命周期"></a>三、React 生命周期</h2><p>React 生命周期主要包括三个阶段：初始化阶段，更新阶段，销毁阶段</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>由ReactDom.render()触发—-初次渲染</p><h4 id="1-constructor-执行"><a href="#1-constructor-执行" class="headerlink" title="1. constructor 执行"></a>1. constructor 执行</h4><p><code>constructor</code> 在组件初始化的时候只会执行一次</p><p>通常它用于做这两件事</p><ol><li>初始化函数内部 <code>state</code></li><li>绑定函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入构造器&#x27;</span>);</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们通常不会使用 <code>constructor</code> 属性，而是改用类加箭头函数的方法，来替代 <code>constructor</code></p><p>例如，我们可以这样初始化 <code>state</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-static-getDerivedStateFromProps-执行-（新钩子）"><a href="#2-static-getDerivedStateFromProps-执行-（新钩子）" class="headerlink" title="2. static getDerivedStateFromProps 执行 （新钩子）"></a>2. static getDerivedStateFromProps 执行 （新钩子）</h4><p>这个是 React 新版本中新增的2个钩子之一，据说很少用。</p><p><code>getDerivedStateFromProps</code> 在初始化和更新中都会被调用，并且在 <code>render</code> 方法之前调用，它返回一个对象用来更新 <code>state</code></p><p><code>getDerivedStateFromProps</code> 是类上直接绑定的静态（<code>static</code>）方法，它接收两个参数 <code>props</code> 和 <code>state</code></p><p><code>props</code> 是即将要替代 <code>state</code> 的值，而 <code>state</code> 是当前未替代前的值</p><blockquote><p>注意：<code>state</code> 的值在任何时候都取决于传入的 <code>props</code> ，不会再改变</p></blockquote><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> props</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">count</span>=<span class="string">&quot;109&quot;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>count</code> 的值不会改变，一直是 109</p><h4 id="2-componentWillMount-执行（即将废弃）"><a href="#2-componentWillMount-执行（即将废弃）" class="headerlink" title="2. componentWillMount 执行（即将废弃）"></a>2. componentWillMount 执行（即将废弃）</h4><blockquote><p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code>。</p></blockquote><p>该方法只在挂载的时候调用一次，表示组件将要被挂载，并且在 <code>render</code> 方法之前调用。</p><p>这个方法在 React 18版本中将要被废弃，官方解释是在 React 异步机制下，如果滥用这个钩子可能会有 Bug</p><h4 id="3-render-执行"><a href="#3-render-执行" class="headerlink" title="3. render 执行"></a>3. render 执行</h4><p><code>render()</code> 方法是组件中必须实现的方法，用于渲染 DOM ，但是它不会真正的操作 DOM，它的作用是把需要的东西返回出去。</p><p>实现渲染 DOM 操作的是 <code>ReactDOM.render()</code></p><blockquote><p>注意：避免在 <code>render</code> 中使用 <code>setState</code> ，否则会死循环</p></blockquote><h4 id="4-componentDidMount-执行"><a href="#4-componentDidMount-执行" class="headerlink" title="4. componentDidMount 执行"></a>4. componentDidMount 执行</h4><p><code>componentDidMount</code> 的执行意味着初始化挂载操作已经基本完成，它主要用于组件挂载完成后做某些操作</p><p>这个挂载完成指的是：组件插入 DOM tree</p><h4 id="初始化阶段总结"><a href="#初始化阶段总结" class="headerlink" title="初始化阶段总结"></a>初始化阶段总结</h4><p>执行顺序 <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> 或者 <code>componentWillMount</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210821102153009.png" alt="image-20210821102153009"></p><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210821102622645.png" alt="image-20210821102622645"></p><p>这里记录新生命周期的流程</p><p><strong>1. getDerivedStateFromProps 执行</strong></p><p>执行生命周期<code>getDerivedStateFromProps</code>， 返回的值用于合并 <code>state</code>，生成新的<code>state</code>。【能接受默认参数：props；必须要有返回值，且为加static的静态方法】此方法用于一个罕见的用例，即state的值任何时候都却决于props。</p><p><strong>2. shouldComponentUpdat 执行</strong></p><p><code>shouldComponentUpdate()</code> 在组件更新之前调用，可以通过返回值来控制组件是否更新，允许更新返回 <code>true</code> ，反之不更新</p><p><strong>3. render 执行</strong></p><p>在控制是否更新的函数中，如果返回 <code>true</code> 才会执行 <code>render</code> ,得到最新的 <code>React element</code></p><p><strong>4. getSnapshotBeforeUpdate 执行</strong></p><p>在最近一次的渲染输出之前被提交之前调用，也就是即将挂载时调用</p><p>相当于淘宝购物的快照，会保留下单前的商品内容，在 React 中就相当于是 即将更新前的状态</p><blockquote><p>它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 <code>componentDidUpdate()</code>。如不需要传递任何值，那么请返回 null</p></blockquote><p><strong>5. componentDidUpdate 执行</strong></p><p>组件在更新完毕后会立即被调用，首次渲染不会调用</p><hr><p>到此更新阶段就结束了，在 React 旧版本中有两个与更新有关的钩子函数 <code>componentWillReceiveProps</code> 【组件将要收到新的参数的时候】和 <code>componentWillUpdate</code> 都即将废弃</p><p><code>componentWillReceiveProps</code> 我不太懂【课程39详解】</p><p><code>componentWillUpdate</code> 在 <code>render</code> 之前执行，表示组件将要更新</p><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p><strong>componentWillUnmount 执行</strong></p><p>在组件即将被卸载或销毁时进行调用。由ReactDom.unmountComponentAtNode()</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>初始化</strong></p><ul><li>constructor()</li><li>static getDerivedStateFromProps()</li><li>render()</li><li>componentDidMount() 【常用，初始化】</li></ul><p><strong>更新</strong></p><ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate()</li><li>componentDidUpdate()</li></ul><p><strong>销毁</strong></p><ul><li>componentWillUnmount() 【常用，收尾工作】</li></ul><br><h2 id="四、diff算法"><a href="#四、diff算法" class="headerlink" title="四、diff算法"></a>四、diff算法</h2><blockquote><p>可参考 <a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89--%20diffing%20%E7%AE%97%E6%B3%95.md">React diffing算法</a></p></blockquote><p><strong>开发注意以下即可</strong></p><ul><li>不要使用使用数据默认的index作为key</li></ul><p>diff 算法是 React 提升渲染性能的一种优化算法，在 React 中有着很重要的地位，也不止于 React ，在 Vue 中也有 diff 算法。</p><br><h2 id="五、认识脚手架"><a href="#五、认识脚手架" class="headerlink" title="五、认识脚手架"></a>五、认识脚手架</h2><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/%E8%84%9A%E6%89%8B%E6%9E%B6.png"></p><p><strong>🍕 1. 什么是 React 脚手架？</strong></p><p>在我们的 React 项目中，脚手架的作用与工地脚手架有异曲同工之妙【基于webpack】</p><p>React 脚手架其实是一个工具帮我们快速的生成项目的工程化结构，每个项目的结构其实大致都是相同的，所以 React 给我提前的搭建好了，这也是脚手架强大之处之一，也是用 React 创建 SPA 应用【Singel Page App】的最佳方式</p><p><strong>🍔 2. 为什么要用脚手架？</strong></p><p>在前面的介绍中，我们也有了一定的认知，脚手架可以帮助我们快速的搭建一个项目结构</p><p>在我之前学习 <code>webpack</code> 的过程中，每次都需要配置 <code>webpack.config.js</code> 文件，用于配置我们项目的相关 <code>loader</code> 、<code>plugin</code>，这些操作比较复杂，但是它的重复性很高，而且在项目打包时又很有必要，那 React 脚手架就帮助我们做了这些，它不需要我们人为的去编写 <code>webpack</code> 配置文件，它将这些配置文件全部都已经提前的配置好了。</p><p><strong>🍟 3. 怎么用 React 脚手架？</strong></p><p>这也是这篇文章的重点，如何去安装 React 脚手架，并且理解它其中的相关文件作用</p><blockquote><p>此处重装npm，更新镜像源的时候知道的<code>nrm</code>这个<a target="_blank" rel="noopener" href="https://blog.csdn.net/LYY1448019681/article/details/128031810">镜像源管理工具</a>，</p></blockquote><h3 id="1-安装-React-脚手架"><a href="#1-安装-React-脚手架" class="headerlink" title="1. 安装 React 脚手架"></a>1. 安装 React 脚手架</h3><p>首先确保安装了 <code>npm</code> 和<code>Node</code>，版本不要太古老，具体是多少不大清楚，建议还是用 <code>npm update</code> 更新一下</p><p>然后打开 cmd 命令行工具，全局安装 <code>create-react-app</code>【Facebook的一个react库，需要全局安装】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i create-react-app -g</span><br></pre></td></tr></table></figure><p>然后可以<strong>新建</strong>一个文件夹用于存放项目</p><p>在当前的文件夹下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app hello-react</span><br></pre></td></tr></table></figure><p><strong>快速搭建项目</strong></p><p>再在生成好的 <code>hello-react</code> 文件夹中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><strong>启动项目</strong></p><p>接下来我们看看这些文件都有什么作用</p><h3 id="2-脚手架项目结构"><a href="#2-脚手架项目结构" class="headerlink" title="2. 脚手架项目结构"></a>2. 脚手架项目结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hello-react</span><br><span class="line">├─ <span class="selector-class">.gitignore</span>               <span class="comment">// 自动创建本地仓库</span></span><br><span class="line">├─ package<span class="selector-class">.json</span>             <span class="comment">// 相关配置文件</span></span><br><span class="line">├─ public                   <span class="comment">// 公共资源 静态资源</span></span><br><span class="line">│  ├─ favicon<span class="selector-class">.ico</span>           <span class="comment">// 浏览器顶部的icon图标</span></span><br><span class="line">│  ├─ index<span class="selector-class">.html</span>            <span class="comment">// 应用的 index.html入口</span></span><br><span class="line">│  ├─ logo192<span class="selector-class">.png</span>           <span class="comment">// 在 manifest 中使用的logo图</span></span><br><span class="line">│  ├─ logo512<span class="selector-class">.png</span>           <span class="comment">// 同上</span></span><br><span class="line">│  ├─ manifest<span class="selector-class">.json</span>         <span class="comment">// 应用加壳的配置文件</span></span><br><span class="line">│  └─ robots<span class="selector-class">.txt</span>            <span class="comment">// 爬虫给协议文件</span></span><br><span class="line">├─ <span class="attribute">src</span>                      // 源码文件夹</span><br><span class="line">│  ├─ App<span class="selector-class">.css</span>               <span class="comment">// App组件的样式</span></span><br><span class="line">│  ├─ App<span class="selector-class">.js</span>                <span class="comment">// App组件</span></span><br><span class="line">│  ├─ App<span class="selector-class">.test</span><span class="selector-class">.js</span>           <span class="comment">// 用于给APP做测试</span></span><br><span class="line">│  ├─ index<span class="selector-class">.css</span>             <span class="comment">// 样式</span></span><br><span class="line">│  ├─ index<span class="selector-class">.js</span>              <span class="comment">// 入口文件</span></span><br><span class="line">│  ├─ logo<span class="selector-class">.svg</span>              <span class="comment">// logo图</span></span><br><span class="line">│  ├─ reportWebVitals<span class="selector-class">.js</span>    <span class="comment">// 页面性能分析文件</span></span><br><span class="line">│  └─ setupTests<span class="selector-class">.js</span>         <span class="comment">// 组件单元测试文件</span></span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure><p>再介绍一下public目录下的 <code>index.html</code> 文件中的代码意思</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- %PUBLIC_URL%代表public文件夹的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启理想视口，用于做移动端网页的适配 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;Web site created using create-react-app&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用于指定网页添加到手机主屏幕后的图标 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/logo192.png&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 应用加壳时的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;manifest&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/manifest.json&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 若llq不支持js则展示标签中的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-功能界面的组件化编码流程"><a href="#3-功能界面的组件化编码流程" class="headerlink" title="3 功能界面的组件化编码流程"></a>3 功能界面的组件化编码流程</h3><ol><li>拆分组件</li><li>实现静态组件</li><li>实现动态组件<ul><li>动态显示初始化数据</li><li>交互</li></ul></li></ol><br><h2 id="六、TodoList-案例"><a href="#六、TodoList-案例" class="headerlink" title="六、TodoList 案例"></a>六、TodoList 案例</h2><h3 id="一、拆分组件"><a href="#一、拆分组件" class="headerlink" title="一、拆分组件"></a>一、拆分组件</h3><p>首先第一步需要做的是将这个页面拆分成几个组件</p><p>首先顶部的输入框，可以完成添加项目的功能，可以拆分成一个 <strong>Header 组件</strong></p><p>中间部分可以实现一个渲染列表的功能，可以拆分成一个 <strong>List 组件</strong></p><p>在这部分里面，每一个待办事项都可以拆分成一个 <strong>Item 组件</strong></p><p>最后底部显示当前完成状态的部分，可以拆分成一个 <strong>Footer 组件</strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210826092737826.png" alt="image-20210826092737826"></p><p>在拆分完组件后，我们下一步要做的就是去实现这些组件的静态效果</p><h3 id="二、实现静态组件"><a href="#二、实现静态组件" class="headerlink" title="二、实现静态组件"></a>二、实现静态组件</h3><p>首先，我们可以先写好这个页面的静态页面，然后再分离组件，所以这就要求我们</p><p>以后写静态页面的时候，一定要有明确的规范</p><ol><li>打好注释</li><li>每个部分的 CSS 要写在一个地方，不要随意写</li><li>命名一定要规范</li><li>CSS 选择器不要关联太多层级</li><li>在写 HTML 时就要划分好布局</li></ol><p>这样有利于我们分离组件</p><p>首先，我们在 <code>src</code> 目录下，新建一个 <code>Components</code> 文件夹，用于存放我们的组件，然后在文件夹下，新建 <code>Header</code> 、<code>Item</code>、<code>List</code> 、<code>Footer</code> 组件文件夹，再创建其下的 <code>index.jsx</code>，<code>index.css</code> 文件，用于创建对应组件及其样式文件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">todolist</span><br><span class="line">├─ package.json</span><br><span class="line">├─ public</span><br><span class="line">│  ├─ favicon.ico</span><br><span class="line">│  └─ index.html</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ App.css</span><br><span class="line">│  ├─ App.jsx</span><br><span class="line">│  ├─ Components</span><br><span class="line">│  │  ├─ Footer</span><br><span class="line">│  │  │  ├─ index.css</span><br><span class="line">│  │  │  └─ index.jsx</span><br><span class="line">│  │  ├─ Header</span><br><span class="line">│  │  │  ├─ index.css</span><br><span class="line">│  │  │  └─ index.jsx</span><br><span class="line">│  │  ├─ item</span><br><span class="line">│  │  │  ├─ index.css</span><br><span class="line">│  │  │  └─ index.jsx</span><br><span class="line">│  │  └─ List</span><br><span class="line">│  │     ├─ index.css</span><br><span class="line">│  │     └─ index.jsx</span><br><span class="line">│  └─ index.js</span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure><p>最终目录结构如上</p><p>然后我们将每个组件，对应的 HTML 结构 CV 到对应组件的 <code>index.jsx</code> 文件中 <code>return</code> 出来，再将 CSS 样式添加到 <code>index.css</code> 文件中</p><p><strong>记得</strong>，在 <code>index.jsx</code> 中一定要引入 <code>index.css</code> 文件</p><p>实现了静态组件后，我们需要添加事件等，来实现动态组件</p><h3 id="三、实现动态组件"><a href="#三、实现动态组件" class="headerlink" title="三、实现动态组件"></a>三、实现动态组件</h3><h4 id="🍎-1-动态展示列表"><a href="#🍎-1-动态展示列表" class="headerlink" title="🍎 1. 动态展示列表"></a>🍎 1. 动态展示列表</h4><p>我们目前实现的列表项是固定的，我们需要它通过<strong>状态</strong>来维护，而不是通过<strong>组件标签</strong>来维护</p><p>首先我们知道，父子之间传递参数，可以通过 <code>state</code> 和 <code>props</code> 实现</p><p>我们通过在父组件也就是 <code>App.jsx</code> 中设置状态</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210826103418053.png" alt="image-20210826103418053"></p><p>再将它传递给对应的渲染组件 <code>List</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; todos &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">&lt;<span class="title class_">List</span> todos=&#123;todos&#125;/&gt;</span><br></pre></td></tr></table></figure><p>这样在 <code>List</code> 组件中就能通过 <code>props</code> 来获取到 <code>todos</code></p><p>我们通过解构取出 <code>todos</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; todos, updateTodo &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br></pre></td></tr></table></figure><p>再通过 <code>map</code> 遍历渲染 <code>Item</code> 数量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.<span class="title function_">map</span>(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span> &#123;<span class="attr">...todo</span>&#125;/&gt;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时由于我们的数据渲染最终是在 <code>Item</code> 组件中完成的，所以我们需要将数据传递给 <code>Item</code> 组件</p><p>这里有两个注意点</p><ol><li>关于 <code>key</code> 的作用在 diff 算法的文章中已经有讲过了，需要满足<strong>唯一性</strong></li><li>这里采用了简写形式 <code>&#123;...todo&#125;</code> ，这使得代码更加简洁，它代表的意思是</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = &#123;todo.<span class="property">id</span>&#125; name = &#123;todo.<span class="property">name</span>&#125; done = &#123;todo.<span class="property">done</span>&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Item</code> 组件中取出 <code>props</code> 即可使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, name, done &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br></pre></td></tr></table></figure><p>这样我们更改 <code>APP.jsx</code> 文件中的 <code>state</code> 就能驱动着 <code>Item</code> 组件的更新，如图</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-1.gif" alt="react-todolist-1"></p><p>同时这里需要注意的是</p><p>对于复选框的选中状态，这里采用的是 <code>defaultChecked = &#123;done&#125;</code>，相比于 <code>checked</code> 属性，这个设定的是默认值，能够更改</p><h4 id="🍍-2-添加事项功能"><a href="#🍍-2-添加事项功能" class="headerlink" title="🍍 2. 添加事项功能"></a>🍍 2. 添加事项功能</h4><p>首先我们需要在 Header 组件中，绑定键盘事件，判断按下的是否为回车，如果为回车，则将当前输入框中的内容传递给 APP 组件</p><blockquote><p>因为，在目前的学习知识中，Header 组件和渲染组件 List 属于兄弟组件，没有办法进行直接的数据传递，因此可以将数据传递给 APP 再由 APP 转发给 List。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header/index.jsx</span></span><br><span class="line">handleKeyUp = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 结构赋值获取 keyCode,target</span></span><br><span class="line">  <span class="keyword">const</span> &#123; keyCode, target &#125; = event</span><br><span class="line">  <span class="comment">// 判断是不是回车</span></span><br><span class="line">  <span class="keyword">if</span> (keyCode !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span>(target.<span class="property">value</span>.<span class="title function_">trim</span>() === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;输入不能为空&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 准备一个todo对象</span></span><br><span class="line">  <span class="keyword">const</span> todoObj = &#123; <span class="attr">id</span>: <span class="title function_">nanoid</span>(), <span class="attr">name</span>: target.<span class="property">value</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="comment">// 传递给app</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">addTodo</span>(todoObj)</span><br><span class="line">  <span class="comment">// 清空</span></span><br><span class="line">  target.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>App.jsx</code> 中添加了事件 <code>addTodo</code> ，这样可以将 Header 组件传递的参数，维护到 <code>App</code> 的状态中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line">addTodo = <span class="function">(<span class="params">todoObj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  <span class="comment">// 追加一个 todo</span></span><br><span class="line">  <span class="keyword">const</span> newTodos = [todoObj, ...todos]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">todos</span>: newTodos &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这小部分中，需要我们注意的是，我们新建的 <code>todo</code> 对象，一定要保证它的 <code>id</code> 的唯一性</p><p>这里采用的 <code>nanoid</code> 库，这个库的每一次调用都会返回一个唯一的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nanoid</span><br></pre></td></tr></table></figure><p>安装这个库，然后引入</p><p>通过 <code>nanoid()</code> 即可生成唯一值</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-addtodo.gif" alt="react-todolist-addtodo"></p><h4 id="🍋-3-实现鼠标悬浮效果"><a href="#🍋-3-实现鼠标悬浮效果" class="headerlink" title="🍋 3. 实现鼠标悬浮效果"></a>🍋 3. 实现鼠标悬浮效果</h4><p>接下来我们需要实现每个 <code>Item</code> 中的小功能</p><p>首先是鼠标移入时的变色效果</p><p>我的逻辑是，通过一个状态来维护是否鼠标移入，比如用一个 <code>mouse</code> 变量，值给 <code>false</code> 当鼠标移入时，重新设定状态为 <code>true</code> 当鼠标移出时设为 <code>false</code> ，然后我们只需要在 <code>style</code> 中用<code>mouse</code> 去设定样式即可</p><p>下面我们来代码实现</p><p>在 <code>Item</code> 组件中，先设定状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">mouse</span>: <span class="literal">false</span> &#125; <span class="comment">// 标识鼠标移入，移出</span></span><br></pre></td></tr></table></figure><p>给元素绑定上鼠标移入，移出事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li onMouseEnter=&#123;<span class="variable language_">this</span>.<span class="title function_">handleMouse</span>(<span class="literal">true</span>)&#125; onMouseLeave=&#123;<span class="variable language_">this</span>.<span class="title function_">handleMouse</span>(<span class="literal">false</span>)&#125; &gt;<span class="language-xml"><span class="tag">&lt;<span class="name">li</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>当鼠标移入时，会触发 <code>onMouseEnter</code> 事件，调用 <code>handleMouse</code> 事件传入参数 <code>true</code> 表示鼠标进入，更新组件状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleMouse = <span class="function"><span class="params">flag</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">mouse</span>: flag &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在 <code>li</code> 身上添加由 <code>mouse</code> 控制的背景颜色</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;&#123; <span class="attr">backgroundColor</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">mouse</span> ? <span class="string">&#x27;#ddd&#x27;</span> : <span class="string">&#x27;white&#x27;</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>同时通过 <code>mouse</code> 来控制删除按钮的显示和隐藏，做法和上面一样</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-mouse.gif" alt="react-todolist-mouse"></p><p>观察 mouse 的变化</p><h4 id="🍉-4-复选框状态维护"><a href="#🍉-4-复选框状态维护" class="headerlink" title="🍉 4. 复选框状态维护"></a>🍉 4. 复选框状态维护</h4><p>我们需要将当前复选框的状态，维护到 <code>state</code> 当中</p><p>我们的思路是</p><p>在复选框中添加一个 <code>onChange</code> 事件来进行数据的传递，当事件触发时我们执行 <code>handleCheck</code> 函数，这个函数可以向 App 组件中传递参数，这样再在 App 中改变状态即可</p><p>首先绑定事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item/index.jsx</span></span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> defaultChecked=&#123;done&#125; onChange=&#123;<span class="variable language_">this</span>.<span class="title function_">handleCheck</span>(id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>事件回调</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleCheck = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">updateTodo</span>(id, event.<span class="property">target</span>.<span class="property">checked</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们需要传递 <code>id</code> 来记录状态更新的对象，因此我们需要采用高阶函数的写法，不然函数会直接执行而报错，复选框的状态我们可以通过 <code>event.target.checked</code> 来获取</p><p>这样我们将我们需要改变状态的 <code>Item</code> 的 <code>id</code> 和改变后的状态，传递给了 App</p><p>内定义的<code>updateTodo</code> 事件，这样我们可以在 App 组件中操作改变状态</p><p>我们传递了两个参数 <code>id</code> 和 <code>done</code></p><p>通过遍历找出该 <code>id</code> 对应的 <code>todo</code> 对象，更改它的 <code>done</code> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line">updateTodo = <span class="function">(<span class="params">id, done</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  <span class="comment">// 处理</span></span><br><span class="line">  <span class="keyword">const</span> newTodos = todos.<span class="title function_">map</span>(<span class="function"><span class="params">todoObj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (todoObj.<span class="property">id</span> === id) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...todoObj, done &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> todoObj</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">todos</span>: newTodos &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更改的方式是 <code>&#123; ...todoObj, done &#125;</code>，首先会展开 <code>todoObj</code> 的每一项，再对 <code>done</code> 属性做覆盖</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-update.gif" alt="react-todolist-update"></p><h4 id="🍏-5-限制参数类型"><a href="#🍏-5-限制参数类型" class="headerlink" title="🍏 5. 限制参数类型"></a>🍏 5. 限制参数类型</h4><p>在我们前面写的东西中，我们并没有对参数的<strong>类型以及必要性</strong>进行限制</p><p>在前面我们也学过这个，我们需要借助 <code>propTypes</code> 这个库</p><p>首先我们需要引入这个库，然后对 <code>props</code> 进行限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header</span></span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  <span class="attr">addTodo</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Header 组件中需要接收一个 <code>addTodo</code> 函数，所以我们进行一下限制</p><p>同时在 List 组件中也需要进行对 <code>todos</code> 以及 <code>updateTodo</code> 的限制</p><p>如果传入的参数不符合限制，则会报 <strong>warning</strong></p><h4 id="🍒-6-删除按钮"><a href="#🍒-6-删除按钮" class="headerlink" title="🍒 6. 删除按钮"></a>🍒 6. 删除按钮</h4><p>现在我们需要实现删除按钮的效果</p><p>这个和前面的挺像的，首先我们分析一下，我们需要在 <code>Item</code> 组件上的按钮绑定点击事件，然后传入被点击事项的 <code>id</code> 值，通过 <code>props</code> 将它传递给父元素 <code>List</code> ，再通过在 <code>List</code> 中绑定一个 <code>App</code> 组件中的删除回调，将 <code>id</code> 传递给 <code>App</code> 来改变 <code>state</code></p><p>首先我们先编写 点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item/index.jsx</span></span><br><span class="line">handleDelete = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">deleteTodo</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定在点击事件的回调上</p><p>子组件想影响父组件的状态，需要父组件传递一个函数，因此我们在 <code>App</code> 中添加一个 <code>deleteTodo</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line">deleteTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  <span class="keyword">const</span> newTodos = todos.<span class="title function_">filter</span>(<span class="function"><span class="params">todoObj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todoObj.<span class="property">id</span> !== id</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">todos</span>: newTodos &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将这个函数传递给 List 组件，再传递给 Item</p><p>增加一个判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;确认删除&#x27;</span>)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">deleteTodo</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-detele.gif" alt="react-todolist-detele"></p><h4 id="🍓-7-获取完成数量"><a href="#🍓-7-获取完成数量" class="headerlink" title="🍓 7. 获取完成数量"></a>🍓 7. 获取完成数量</h4><p>我们在 App 中向 <code>Footer</code> 组件传递 <code>todos</code> 数据，再去统计数据</p><p>统计 <code>done</code>为 <code>true</code> 的个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doneCount = todos.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, todo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + (todo.<span class="property">done</span> ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>再渲染数据即可</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210826160505813.png" alt="image-20210826160505813"></p><h4 id="🍊-8-全选按钮"><a href="#🍊-8-全选按钮" class="headerlink" title="🍊 8. 全选按钮"></a>🍊 8. 全选按钮</h4><p>首先我们需要在按钮上绑定事件，由于子组件需要改变父组件的状态，所以我们的操作和之前的一样，先绑定事件，再在 App 中传一个函数个 Footer ，再在 Footer 中调用这个函数并传入参数即可</p><p>这里需要特别注意的是</p><p><code>defaulChecked</code> 只有第一次会起作用，所以我们需要将前面写的改成 <code>checked</code> 添加 <code>onChange</code> 事件即可</p><p>首先我们先在 App 中给 Footer 传入一个函数 <code>checkAllTodo</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line">checkAllTodo = <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  <span class="keyword">const</span> newTodos = todos.<span class="title function_">map</span>((<span class="function"><span class="params">todoObj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...todoObj, <span class="attr">done</span>: done &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">todos</span>: newTodos &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"> &lt;<span class="title class_">Footer</span> todos=&#123;todos&#125; checkAllTodo=&#123;<span class="variable language_">this</span>.<span class="property">checkAllTodo</span>&#125;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们需要在 Footer 中调用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleCheckAll = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">checkAllTodo</span>(event.<span class="property">target</span>.<span class="property">checked</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们传入了一个参数：当前按钮的状态，用于全选和取消全选</p><p>同时我们需要排除总数为0 时的干扰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> checked=&#123;doneCount === total &amp;&amp; total !== <span class="number">0</span>? <span class="literal">true</span> : <span class="literal">false</span>&#125; onChange=&#123;<span class="variable language_">this</span>.<span class="property">handleCheckAll</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-all.gif" alt="react-todolist-all"></p><h4 id="🥭-9-删除已完成"><a href="#🥭-9-删除已完成" class="headerlink" title="🥭 9. 删除已完成"></a>🥭 9. 删除已完成</h4><p>给删除按钮添加一个点击事件，回调中调用 App 中添加的删除已完成的函数，全都一个套路</p><p><strong>强烈建议这个自己打</strong></p><p>首先在 Footer 组件中调用传来的函数，在 App 中定义函数，过滤掉 <code>done</code> 为 <code>true</code> 的，再更新状态即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line">clearAllDone = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  <span class="keyword">const</span> newTodos = todos.<span class="title function_">filter</span>(<span class="function">(<span class="params">todoObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todoObj.<span class="property">done</span> !== <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">todos</span>: newTodos &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-todolist-clear.gif" alt="react-todolist-clear"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>注意：className、style 写法</li><li>父组件给子组件传递数据，采用 <code>props</code></li><li>子组件给父组件传递数据，通过 <code>props</code>，同时提前给子组件传递一个函数</li><li>注意 <code>defaultChecked</code> 和 <code>checked</code> 的区别</li></ol><br><h2 id="七、脚手架配置代理"><a href="#七、脚手架配置代理" class="headerlink" title="七、脚手架配置代理"></a>七、脚手架配置代理</h2><h3 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1 ajax"></a>1 ajax</h3><p>React 本身只关注于页面，并不包含发送 Ajax 请求的代码，所以一般都是集成第三方的包，或者自己封装的</p><p>自己封装的话，比较麻烦，而且也可能考虑不全</p><p>常用的有两个库，一个是JQuery，一个是 axios</p><ol><li>JQuery 这个比较重，因为 Ajax 服务也只是它这个库里的一小块功能，它主要做的还是 DOM 操作，而这不利于 React ，不推荐使用</li><li>axios 这个就比较轻，而且采用 Promise 风格，代码的逻辑会相对清晰，<strong>推荐使用</strong></li></ol><p>因此我们这里采用 axios 来发送客户端请求</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;.....&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);&#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-跨域问题"><a href="#2-跨域问题" class="headerlink" title="2 跨域问题"></a>2 跨域问题</h3><p>以前，我们在发送请求的时候，经常会遇到一个很重要的问题：跨域！</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210827091119837.png" alt="image-20210827091119837"></p><p>在我以前的学习中，基本上都需要操作后端服务器代码才能解决跨域的问题，配置请求头，利用 script，这些都需要后端服务器的配合，因此我们前端需要自己解决这个问题的话，就需要这个技术了：<strong>代理</strong>。</p><p>在说代理之前，先谈谈为什么会出现跨域？</p><p>这个应该是源于浏览器的同源策略。所谓同源（即指在同一个域）就是两个页面具有相同的协议，主机和端口号， 当一个请求 URL 的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面 URL 不同即为跨域 。</p><p>也就是说 <code>xxx:3000</code>和 <code>xxx:4000</code> 会有跨域问题，<code>xxx:3000</code> 与 <code>abc:3000</code> 有跨域问题。本质是使用了ajax引擎，导致了跨域问题</p><p><img src="./7-1.png"></p><p>那接下来我们采用<strong>配置代理</strong>的方式去解决这个问题</p><blockquote><p>实际生产环境中，一般后端使用cors解决跨域问题</p></blockquote><h4 id="2-1-全局代理"><a href="#2-1-全局代理" class="headerlink" title="2.1 全局代理"></a>2.1 全局代理</h4><p>第一种方法，我把它叫做全局代理，因为它直接将代理配置在了配置文件 <code>package.json</code> 中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:5000&quot;</span>  </span><br><span class="line"><span class="comment">// &quot;proxy&quot;:&quot;请求的地址&quot;</span></span><br></pre></td></tr></table></figure><p>这样配置代理时，首先会在抓原请求地址上访问，如果访问不到文件，就会转发到这里配置的地址上去请求</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/%E8%BD%AC%E5%8F%91.png" alt="转发"></p><p>我们需要做的就是在我们的请求代码中，将请求的地址改到转发的地址，即可</p><p>但是这样会有一些问题，它会先向我们请求的地址，也就是这里的 <code>3000</code> 端口下请求数据，如果在 <code>3000</code> 端口中存在我们需要访问的文件，会直接返回，<strong>不会再去转发</strong></p><p>因此这就会出现问题，同时因为这种方式采用的是全局配置的关系，导致<strong>只能转发到一个地址</strong>，不能配置多个代理</p><h4 id="2-2-单独配置"><a href="#2-2-单独配置" class="headerlink" title="2.2 单独配置"></a>2.2 单独配置</h4><p>这也是我自己起的名字，这种配置方式，可以给多个请求配置代理，非常不错</p><p>它的工作原理和全局配置是一样的，但是写法不同</p><p><strong>首先</strong>我们需要在 <code>src</code> 目录下，创建代理配置文件 <code>setupProxy.js</code></p><p>注意：这个文件只能叫这个名字，脚手架在启动的时候，会自动执行这些文件</p><p><strong>第二步</strong></p><p>配置具体的代理规则，我们大致讲讲这些是什么意思</p><ol><li><p>首先我们需要引入这个 <code>http-proxy-middleware</code> 中间件，然后需要导出一个对象，这里建议使用函数，使用对象的话兼容性不大好</p></li><li><p>然后我们需要在 <code>app.use</code> 中配置，我们的代理规则，首先 <code>proxy</code> 接收的第一个参数是需要转发的请求，我的理解是一个标志的作用，当有这个标志的时候，预示着我们需要采用代理，例如 <code>/api1</code> ，我们就需要在我们 <code>axios</code> 的请求路径中，加上 <code>/api1</code> ，这样所有添加了 <code>/api1</code> 前缀的请求都会转发到这</p></li><li><p>第二个参数接受的是一个对象，用于配置代理。</p><ul><li><code>target</code> 属性用于配置转发目标地址，也就是我们数据的地址</li><li><code>changeOrigin</code> 属性用于控制服务器收到的请求头中 <code>host</code> 字段，可以理解为一个伪装效果，为 <code>true</code> 时，收到的 <code>host</code> 就为请求数据的地址</li><li><code>pathRewrite</code> 属性用于去除请求前缀，因为我们通过代理请求时，需要在请求地址前添加一个标志，但是实际的地址是不存在这个标志的，所以我们<strong>一定要去除</strong>这个前缀，这里采用的有点类似于正则替换的方式</li></ul></li></ol><p>配置一个代理的完整代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  app.<span class="title function_">use</span>(</span><br><span class="line">    <span class="title function_">proxy</span>(<span class="string">&#x27;/api1&#x27;</span>, &#123;     <span class="comment">// 遇见/api1 即触发该代理配置</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">//配置转发目标地址</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值，避免被服务器限制再次出现跨域问题</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//去除请求前缀址(必须配置)</span></span><br><span class="line">    &#125;),</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="八、GitHub-搜索案例"><a href="#八、GitHub-搜索案例" class="headerlink" title="八、GitHub 搜索案例"></a>八、GitHub 搜索案例</h2><h3 id="1-实现静态组件"><a href="#1-实现静态组件" class="headerlink" title="1 实现静态组件"></a>1 实现静态组件</h3><p>和之前的 TodoList 案例一样，我们需要先实现静态组件，在实现静态组件之前，我们还需要拆分组件，这个页面的组件，我们可以将它拆成以下两个组件，第一个组件是 <code>Search</code>，第二个是 <code>List</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828065604542.png" alt="image-20210828065604542"></p><p>接下来我们需要将提前写好的静态页面，对应拆分到组件当中</p><p>注意：</p><ol><li>class 需要改成 className</li><li>style 的值需要使用双花括号的形式</li></ol><p>最重要的一点就是，<code>img</code> 标签，一定要<strong>添加</strong> <code>alt</code> 属性表示图片加载失败时的提示。</p><p>同时，<code>a</code> 标签要添加 <code>rel=&quot;noreferrer&quot;</code>属性，不然会有大量的警告出现</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828070148865.png" alt="image-20210828070148865"></p><blockquote><p>es6解构赋值的连写方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="attr">keyWordElement</span>: &#123;value&#125;&#125; = <span class="variable language_">this</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);    <span class="comment">// 正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keyWordElement);    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>个人感觉用处不大</p></blockquote><h3 id="2-axios-发送请求"><a href="#2-axios-发送请求" class="headerlink" title="2 axios 发送请求"></a>2 axios 发送请求</h3><p>在实现静态组件之后，我们需要通过向 <code>github</code> 发送请求，来获取相应的用户信息</p><p>但是由于短时间内多次请求，可能会导致请求不返回结果等情况发生，因此我们采用了一个事先搭建好的本地服务器</p><p>我们启动服务器，向这个地址发送请求即可</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828071053508.png" alt="image-20210828071053508"></p><p>这个请求类型是 GET 请求，我们需要传递一个搜索的关键字，去请求数据</p><p>我们首先要获取到用户点击搜索按钮后<strong>输入框中的值</strong></p><p>在需要触发事件的 <code>input</code> 标签中，添加 <code>ref</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">c</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">keyWordElement</span> = c&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;输入关键词点击搜索&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>this.keyWordElement</code> 属性来获取到这个当前节点，也就是这个 <code>input</code> 框</p><p>我们再通过 <code>value</code> 值，即可获取到当前 <code>input</code> 框中的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search 回调</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">keyWordElement</span>: &#123; <span class="attr">value</span>: keyWord &#125; &#125; = <span class="variable language_">this</span></span><br></pre></td></tr></table></figure><p>这里采用的是连续的解构赋值，最后将 <code>value</code> 改为 <code>keyWord</code> ，这样好辨别</p><p>获取到了 <code>keyWord</code> 值，接下来我们就需要发送请求了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">`http://localhost:3000/api1/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">updateAppState</span>(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">users</span>: response.<span class="property">data</span>.<span class="property">items</span> &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">updateAppState</span>(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.<span class="property">message</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们将 <code>keyWord</code> 接在请求地址的后面，来传递参数，以获得相关数据</p><p>这里会存在跨域的问题，因我我们是站在 3000 端口向 5000 端口发送请求的</p><p>因此我们需要配置代理来解决跨域的问题，我们需要在请求地址前，加上启用代理的标志 <code>/api1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setupProxy.js</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(</span><br><span class="line">        <span class="title function_">proxy</span>(<span class="string">&#x27;/api1&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能成功的获取到了数据</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210828072705747.png" alt="image-20210828072705747"></p><h3 id="3-渲染数据"><a href="#3-渲染数据" class="headerlink" title="3 渲染数据"></a>3 渲染数据</h3><p>在获取到了数据之后，我们需要对数据进行分析，并将这些数据渲染到页面上</p><p>比较重要的一点是，我们获取到的用户个数是动态的，因此我们需要通过遍历的方式去实现</p><p>同时我们的数据当前存在于 <code>Search</code> 组件当中，我们需要在 <code>List</code> 组件中使用，所以我们需要个 <code>Search</code> 组件传递一个函数，来实现子向父传递数据，再通过 <code>App</code> 组件，向<code>List</code> 组件传递数据即可得到 <code>data</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users.<span class="title function_">map</span>(<span class="function">(<span class="params">userObj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;userObj.id&#125;</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">&quot;noreferrer&quot;</span> <span class="attr">href</span>=<span class="string">&#123;userObj.html_url&#125;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">src</span>=<span class="string">&#123;userObj.avatar_url&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100px</span>&#x27; &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>&#123;userObj.login&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们通过 <code>map</code> 遍历整个返回的数据，来循环的添加 <code>card</code> 的个数</p><p>同时将一些用户信息添加到其中</p><h3 id="4-增加交互"><a href="#4-增加交互" class="headerlink" title="4 增加交互"></a>4 增加交互</h3><p>做到这里其实已经完成了一大半了，但是似乎少了点交互</p><ul><li>加载时的 loading 效果</li><li>第一次进入页面时 List 组件中的<strong>欢迎使用字样</strong></li><li>在报错时应该提示错误信息</li></ul><p>这一些都预示着我们不能单纯的将用户数据直接渲染，我们需要添加一些判断，什么时候该渲染数据，什么时候渲染 loading，什么时候渲染 err</p><p>首先我们需要增加一些状态，来指示我们该渲染什么，比如</p><ul><li>采用 <code>isFrist</code> 来判断页面是否第一次启动，初始值给 <code>true</code>，点击搜索后改为 <code>false</code></li><li>采用 <code>isLoading</code> 来判断是否应该显示 Loading 动画，初始值给 <code>false</code>，在点击搜索后改为 <code>true</code>，在拿到数据后改为 <code>false</code></li><li>采用 <code>err</code> 来判断是否渲染错误信息，当报错时填入报错信息，初始值<strong>给空</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">users</span>: [], <span class="attr">isFirst</span>: <span class="literal">true</span>, <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>这样我们就需要改变我先前采用的数据传递方式，采用更新状态的方式，接收一个状态对象来<strong>更新数据</strong>，这样就不用去指定什么时候更新什么，就可以减少很多<strong>不必要</strong>的函数声明</p><p>同时在 App 组件给 List 组件传递数据时，我们可以采用解构赋值的方式，这样可以减少代码量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="comment">// 接收一个状态对象</span></span><br><span class="line">updateAppState = <span class="function">(<span class="params">stateObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(stateObj)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Search</span> updateAppState=&#123;<span class="variable language_">this</span>.<span class="property">updateAppState</span>&#125; /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">List</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样我们只需要在 List 组件中，判断这些状态的值，来显示即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List/index.jsx</span></span><br><span class="line"><span class="comment">// 对象解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; users, isFirst, isLoading, err &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line">&#123;</span><br><span class="line">  isFirst ? <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>欢迎使用，输入关键字，点击搜索<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> :</span><br><span class="line">    isLoading ? <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> :</span><br><span class="line">      err ? <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span>&#123;err&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> :</span><br><span class="line">        users.<span class="title function_">map</span>(<span class="function">(<span class="params">userObj</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">           <span class="comment">// 渲染数据块</span></span><br><span class="line">           <span class="comment">//为了减少代码量，就不贴了</span></span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要先判断是否第一次，再判断是不是正在加载，再判断有没有报错，最后再渲染数据</p><p>我们的状态更新是在 Search 组件中实现的，在点击搜索之后数据返回之前，我们需要将 <code>isFirst</code> 改为 <code>false</code> ，<code>isLoading</code> 改为 <code>true</code></p><p>接收到数据后我们再将 <code>isLoading</code> 改为 <code>false</code> 即可</p><p>以上就是 Github 搜索案例的实现过程</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-github.gif" alt="react-github"></p><p>​</p><br><h2 id="九、消息发布订阅"><a href="#九、消息发布订阅" class="headerlink" title="九、消息发布订阅"></a>九、消息发布订阅</h2><p>这里我们就学习一下如何利用消息订阅发布来解决<strong>兄弟组件间的通信</strong></p><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><p>要解决上面的问题，我们可以借助发布订阅的机制，我们可以将 App 文件中的所有状态和方法全部去除，因为本来就不是在 App 组件中直接使用这些方法的，App 组件只是一个中间媒介而已</p><p>我们先简单的说一下<strong>消息订阅和发布的机制</strong></p><p>就拿我们平常订杂志来说，我们和出版社说我们要订一年的足球周刊，那每次有新的足球周刊，它都会寄来给你。换到代码层面上，我们订阅了一个消息假设为 A，当另一个人发布了 A 消息时，因为我们订阅了消息 A ，那么我们就可以拿到 A 消息，并获取数据</p><p>那我们要怎么实现呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 `pubsub-js`，我们需要先安装这个库</span></span><br><span class="line">npm install pubsub-js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入这个库 </span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PubSub</span> <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>订阅消息</strong></p><p>我们通过 <code>subscribe</code> 来订阅消息，它接收两个参数，第一个参数是消息的名称，第二个是消息成功的回调，回调中也接受两个参数，一个是消息名称，一个是返回的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;search&#x27;</span>,<span class="function">(<span class="params">msg,data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg,data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>发布消息</strong></p><p>我们采用 <code>publish</code> 来发布消息，用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;search&#x27;</span>,&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><p>有了这些基础，我们可以完善我们昨天写的 GitHub 案例</p><p>将数据的更新通过 <code>publish</code> 来传递，例如在发送请求之前，我们需要出现 loading 字样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前的写法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">updateAppState</span>(&#123; <span class="attr">isFirst</span>: <span class="literal">false</span>, <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// 改为发布订阅方式</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;search&#x27;</span>,&#123; <span class="attr">isFirst</span>: <span class="literal">false</span>, <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p>这样我们就能成功的在请求之前发送消息，我们只需要在 List 组件中订阅一下这个消息即可，并将返回的数据用于更新状态即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;search&#x27;</span>,<span class="function">(<span class="params">msg,stateObj</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(stateObj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;search&#x27;</span>,<span class="function">(<span class="params">_,stateObj</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(stateObj)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同时上面的代码会返回一个 <code>token</code> ，这个就类似于定时器的编号的存在，我们可以通过这个 <code>token</code> 值，来取消对应的订阅</p><p>通过 <code>unsubscribe</code> 来取消指定的订阅</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">unsubscribe</span>(<span class="variable language_">this</span>.<span class="property">token</span>)</span><br></pre></td></tr></table></figure><h3 id="扩展-–-Fetch"><a href="#扩展-–-Fetch" class="headerlink" title="扩展 – Fetch"></a>扩展 – Fetch</h3><blockquote><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003810652">Fetch非官方文档</a></p></blockquote><p>首先 fetch 也是一种发送请求的方式，它是在 xhr 之外的一种，我们平常用的 Jquery 和 axios 都是封装了 xhr 的第三方库，而 fetch 是官方自带的库，同时它也采用的是 Promise 的方式，大大简化了写法</p><p><img src="./9-1.png"></p><p>如何使用呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://xxx&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err)); </span><br></pre></td></tr></table></figure><p>它的使用方法和 axios 非常的类似，都是返回 Promise 对象，但是不同的是， fetch 关注分离，它在第一次请求时，不会直接返回数据，会先返回联系服务器的状态，在第二步中才能够获取到数据</p><p>我们需要在第一次 <code>then</code> 中返回 <code>response.json()</code> 因为这个是包含数据的 promise 对象，再调用一次 <code>then</code> 方法即可实现</p><p>原案例也可以改造为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#region 发送网络请求---使用axios发送</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">`/api1/search/users2?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//请求成功后通知List更新状态</span></span><br><span class="line">        <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;atguigu&#x27;</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">users</span>:response.<span class="property">data</span>.<span class="property">items</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//请求失败后通知App更新状态</span></span><br><span class="line">        <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;atguigu&#x27;</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">err</span>:error.<span class="property">message</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送网络请求---使用fetch发送（未优化）</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">`/api1/search/users2?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器成功了&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器失败了&#x27;</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// // 终止promise，否则返回undefined进入下一个then的成功分支</span></span><br><span class="line">    &#125;</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据成功了&#x27;</span>,response);&#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据失败了&#x27;</span>,error);&#125;</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送网络请求---使用fetch发送（优化）【上例中的error不用每次都处理】</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response= <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/api1/search/users2?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;atguigu&#x27;</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">users</span>:data.<span class="property">items</span>&#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求出错&#x27;</span>,error);</span><br><span class="line">    <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;atguigu&#x27;</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">err</span>:error.<span class="property">message</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么多次的调用 <code>then</code> 并不是我们所期望的，相信看过之前生成器的文章的伙伴，已经有了想法。</p><p>我们可以利用 <code>async</code> 和 <code>await</code> 配合使用，来简化代码</p><p>可以将 <code>await</code> 理解成一个自动执行的 <code>then</code> 方法，这样清晰多了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;https://xxx&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> reasponse.<span class="title function_">json</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后关于错误对象的获取可以采用 <code>try...catch</code> 来实现</p><p>关于 fetch 的更多内容：阮一峰老师的<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">博文</a></p><br><h2 id="十、React-路由"><a href="#十、React-路由" class="headerlink" title="十、React 路由"></a>十、React 路由</h2><h3 id="🍕-1-SPA"><a href="#🍕-1-SPA" class="headerlink" title="🍕 1. SPA"></a>🍕 1. SPA</h3><p>每个选项都要对应一个 HTML 文件，这样会很麻烦，甚至不友好，我们把这种称为 MPA 也叫多页面应用。而为了减少这样的情况，我们还有另一种应用，叫做 <strong>SPA ，单页应用程序</strong>。它比传统的 Web 应用程序更快，因为它们在 Web 浏览器本身而不是在服务器上执行逻辑。在初始页面加载后，<strong>只有数据来回发送</strong>，而不是整个 HTML，这会降低带宽。它们可以独立请求标记和数据，并直接在浏览器中呈现页面。</p><h3 id="🍔-2-什么是路由？"><a href="#🍔-2-什么是路由？" class="headerlink" title="🍔 2. 什么是路由？"></a>🍔 2. 什么是路由？</h3><p>路由是根据不同的 URL 地址展示不同的内容或页面</p><p>在 SPA 应用中，大部分页面结果不改变，只改变部分内容的使用</p><h4 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h4><ul><li>理解：value是function，用来处理客户端提交的请求；</li><li>注册路由：router.get(path, function(req, res))</li><li>工作过程：在node接受到一个请求时，根据请求路径匹配路由，调用路由中的函数来处理请求和响应数据</li></ul><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><ul><li>浏览器端路由：value是Component，用于展示页面</li><li>注册路由：<code>&lt;Router path=&quot;/test&quot; component=&#123;Test&#125;/&gt;</code></li><li>工作过程：当浏览器的<code>path</code>变为<code>/path</code>的时候，当前路由组件就会变成<code>Test</code>组件</li></ul><p><strong>前端路由的优缺点</strong></p><p><strong>优点</strong></p><p>用户体验好，不需要每次都从服务器全部获取整个 HTML，快速展现给用户</p><p><strong>缺点</strong></p><ol><li>SPA 无法记住之前页面滚动的位置，再次回到页面时无法记住滚动的位置</li><li>使用浏览器的前进和后退键会重新请求，没有合理利用缓存</li></ol><br><h3 id="🍟-3-路由的原理"><a href="#🍟-3-路由的原理" class="headerlink" title="🍟 3. 路由的原理"></a>🍟 3. 路由的原理</h3><blockquote><p>【<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wy4y1D7JT/?p=76&spm_id_from=pageDriver&vd_source=ad866fe26d18693e4132a3c33f8fba36">前端路由原理</a>】</p></blockquote><p>前端路由的主要依靠的是 <code>history</code> ，也就是浏览器的历史记录。浏览器的历史记录就类似于一个栈的数据结构，前进就相当于入栈，后退就相当于出栈，并且历史记录上可以采用 <code>listen</code> 来监听请求路由的改变，从而判断是否改变路径</p><blockquote><p>history 是 BOM 对象下的一个属性，在 H5 中新增了一些操作 history 的 API</p></blockquote><p>在 H5 中新增了 <code>createBrowserHistory</code> 的 API ，用于创建一个 history 栈，允许我们手动操作浏览器的历史记录</p><p>新增 API：<code>pushState</code> ，<code>replaceState</code>，原理类似于 Hash 实现。 用 H5 实现，单页路由的 URL 不会多出一个 <code>#</code> 号，这样会更加的美观，且兼容性更好，类似于锚点跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> history = <span class="title class_">History</span>.<span class="title function_">createHashHistory</span>();</span><br></pre></td></tr></table></figure><br><h3 id="🌭-4-路由的基本使用"><a href="#🌭-4-路由的基本使用" class="headerlink" title="🌭 4. 路由的基本使用"></a>🌭 4. 路由的基本使用</h3><h4 id="react-router-dom-的理解和使用"><a href="#react-router-dom-的理解和使用" class="headerlink" title="react-router-dom 的理解和使用"></a>react-router-dom 的理解和使用</h4><blockquote><p>专门给 web 人员使用的库【还有用于native、其他any的路由库 | <code>react-router</code>】</p><p><a target="_blank" rel="noopener" href="https://react-router.docschina.org/web/guides/philosophy">官方文档</a></p></blockquote><ol><li>一个 react 的仓库</li><li>很常用，基本是每个应用都会使用的这个库</li><li>专门来实现 SPA 应用</li></ol><p>首先我们要明确好页面的布局 ，分好导航区、展示区</p><p>要引入 <code>react-router-dom</code> 库，暴露一些属性 <code>Link、BrowserRouter...</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span>, <span class="title class_">BrowserRouter</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>导航区的 a 标签改为 Link 标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包裹在一个路由器中，一标签一路由器</span></span><br><span class="line">&lt;<span class="title class_">BrowserRouter</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">BrowserRouter</span>&gt;</span><br></pre></td></tr></table></figure><p>同时我们需要用 <code>Route</code> 标签，来进行路径的匹配，从而实现不同路径的组件切换</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册路由  编写路由链接</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/about&quot;</span> component=&#123;<span class="title class_">About</span>&#125;&gt;&lt;/<span class="title class_">Route</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样之后我们还需要一步，<strong>加个路由器</strong>，在上面我们写了两组路由，同时还会报错指示我们需要添加 <code>Router</code> 来解决错误，这就是需要我们添加路由器来管理路由，如果我们在 Link 和 Route 中分别用路由器管理，那这样是实现不了的，只有在一个路由器的管理下才能进行页面的跳转工作。</p><p>因此我们也可以在 Link 和 Route 标签的外层标签采用 BrowserRouter 包裹，但是这样当我们的路由过多时，我们要不停的更改标签包裹的位置，因此我们可以这么做</p><p>我们回到 App.jsx 目录下的 index.js 文件，将整个 App 组件标签采用 <code>BrowserRouter</code> 标签去包裹，这样整个 App 组件都在<strong>一个路由器</strong>的管理下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">&lt;<span class="title class_">BrowserRouter</span>&gt;</span><br><span class="line">&lt; <span class="title class_">App</span> /&gt;</span><br><span class="line">&lt;/<span class="title class_">BrowserRouter</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router.gif" alt="react-router"></p><br><h3 id="🍿-5-路由组件和一般组件"><a href="#🍿-5-路由组件和一般组件" class="headerlink" title="🍿 5. 路由组件和一般组件"></a>🍿 5. 路由组件和一般组件</h3><p>在我们前面的内容中，我们是把组件 Home 和组件 About 当成是一般组件来使用，我们将它们写在了 src 目录下的 components 文件夹下，但是我们又会发现它和普通的组件又有点不同，对于普通组件而言，我们在引入它们的时候我们是通过标签的形式来引用的。但是在上面我们可以看到，我们把它当作路由来引用时，我们是通过 <code>&#123;Home&#125;</code> 来引用的。</p><p>从这一点我们就可以认定一般组件和路由组件存在着差异</p><p>首先它们的写法不同</p><p><strong>一般组件</strong>：<code>&lt;Demo/&gt;</code>，<strong>路由组件</strong>：<code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></p><p>同时为了规范我们的书写，一般将路由组件放在 <code>pages</code> 文件夹中，路由组件放在 <code>components</code></p><p>而最重要的一点就是它们接收到的 <code>props</code> 不同，在一般组件中，如果我们不进行传递，就不会收到值。而对于路由组件而言，它会接收到 3 个固定属性 <code>history</code> 、<code>location</code> 以及 <code>match</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210901142121047.png" alt="image-20210901142121047"></p><br><h3 id="🍛-6-NavLink-标签"><a href="#🍛-6-NavLink-标签" class="headerlink" title="🍛 6. NavLink 标签"></a>🍛 6. NavLink 标签</h3><p>NavLink 标签是和 Link 标签作用相同的，但是它又比 Link 更加强大。</p><p>在前面的 demo 展示中，你可能会发现点击的按钮并没有出现高亮的效果，正常情况下我们给标签多添加一个 <code>active</code> 的类就可以实现高亮的效果</p><p>而 NavLink 标签正可以帮助我们实现这一步</p><p>当我们选中某个 NavLink 标签时，就会自动的在类上添加一个 <code>active</code> 属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> className=<span class="string">&quot;list-group-item&quot;</span> to=<span class="string">&quot;/about&quot;</span>&gt;<span class="title class_">About</span>&lt;/<span class="title class_">NavLink</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-navlink.gif" alt="react-router-navlink"></p><p>我们可以看到左侧的元素类名在不断的切换，当然 NavLink 标签是默认的添加上 <code>active</code> 类，我们也可以改变它，在标签上添加一个属性 <code>activeClassName</code></p><p>例如 <code>activeClassName=&quot;aaa&quot;</code> 在触发这个 NavLink 时，会自动添加一个 <code>aaa</code> 类</p><br><h3 id="🥩-7-NavLink-封装"><a href="#🥩-7-NavLink-封装" class="headerlink" title="🥩 7. NavLink 封装"></a>🥩 7. NavLink 封装</h3><p>在上面的 NavLink 标签种，我们可以发现我们每次都需要重复的去写这些样式名称或者是 <code>activeClassName</code> ，这并不是一个很好的情况，代码过于冗余。那我们是不是可以想想办法封装一下它们呢？</p><p>我们可以采用 <code>MyNavLink</code> 组件，对 NavLink 进行封装</p><p>首先我们需要新建一个 MyNavLink 组件，<code>return</code> 一个结构</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> className=<span class="string">&quot;list-group-item&quot;</span> &#123;...<span class="variable language_">this</span>.<span class="property">props</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>首先，有一点非常重要的是，我们在标签体内写的内容都会成为一个 <code>children</code> 属性，因此我们在调用 <code>MyNavLink</code> 时，在标签体中写的内容，都会成为 <code>props</code> 中的一部分，从而能够实现</p><p>接下来我们在调用时，直接写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyNavLink</span> to=<span class="string">&quot;/home&quot;</span>&gt;home&lt;/<span class="title class_">MyNavLink</span>&gt;</span><br></pre></td></tr></table></figure><p>即可实现相同的效果</p><br><h3 id="🍈-8-Switch-解决相同路径问题"><a href="#🍈-8-Switch-解决相同路径问题" class="headerlink" title="🍈 8. Switch 解决相同路径问题"></a>🍈 8. Switch 解决相同路径问题</h3><p>首先我们看一段这样的代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home&quot;</span> component=&#123;<span class="title class_">Home</span>&#125;&gt;&lt;/<span class="title class_">Route</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是两个路由组件，在2，3行中，我们同时使用了相同的路径 <code>/about</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210903075753268.png" alt="image-20210903075753268"></p><p>我们发现它出现了两个 <code>about</code> 组件的内容，那这是为什么呢？</p><p>其实是因为，<code>Route</code> 的机制，当匹配上了第一个 <code>/about</code> 组件后，<strong>它还会继续向下匹配</strong>，因此会出现两个 About 组件，这时我们可以采用 <code>Switch</code> 组件进行包裹</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>在使用 <code>Switch</code> 时，我们需要先从 <code>react-router-dom</code> 中暴露出 <code>Switch</code> 组件</p><p>这样我们就能成功的解决掉这个问题了</p><br><h3 id="🥟-9-解决二级路由样式丢失的问题"><a href="#🥟-9-解决二级路由样式丢失的问题" class="headerlink" title="🥟 9. 解决二级路由样式丢失的问题"></a>🥟 9. 解决二级路由样式丢失的问题</h3><p>当我们将路径改写成 <code>path=&quot;/ljc/about&quot;</code> 这样的形式时，我们会发现当我们强制刷新页面的时候，页面的 CSS 样式消失了。这是因为，我们在引入样式文件时，采取的是相对路径，当我们使用二级路由的时候，会使得请求的路径发生改变，浏览器会向 <code>localhost:3000/ljc</code> 下请求 css 样式资源，这并不是我们想要的，因为我们的样式存放于公共文件下的 CSS 文件夹中。</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-tworouter.gif" alt="react-router-tworouter"></p><p><strong>我们有几种方法，可以解决这个问题</strong></p><ol><li>将样式引入的路径改成绝对路径：<code>href=&quot;%PUBLIC_URL/css/bootstrap.css&quot;</code>【推荐，但该写法只适用于React】</li><li>引入样式文件时不带 <code>.</code>【推荐】</li><li>使用 <code>HashRouter</code>🔺少用</li></ol><p>我们一般采用<strong>第一种方式</strong>去解决</p><br><h3 id="🍑-10-路由的精准匹配和模糊匹配"><a href="#🍑-10-路由的精准匹配和模糊匹配" class="headerlink" title="🍑 10. 路由的精准匹配和模糊匹配"></a>🍑 10. 路由的精准匹配和模糊匹配</h3><p>路由的匹配有两种形式，一种是精准匹配一种是模糊匹配，React 中<strong>默认开启的是模糊匹配</strong></p><p>模糊匹配可以理解为，在匹配路由时，只要有匹配到的就好了</p><p>精准匹配就是，两者必须相同</p><p>我们展示一个模糊匹配的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyNavLink</span> to = <span class="string">&quot;/home/a/b&quot;</span> &gt;<span class="title class_">Home</span>&lt;/<span class="title class_">MyNavLink</span>&gt;</span><br></pre></td></tr></table></figure><p>这个标签匹配的路由，我们可以拆分成 home a b，将会根据这个先后顺序匹配路由</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home&quot;</span>component=&#123;<span class="title class_">Home</span>&#125;/&gt;</span><br></pre></td></tr></table></figure><p>就可以匹配到上面的这个路由，因为它匹配的是 home</p><p>当匹配的路由改成下面这样时，就会失败。它会按照第一个来匹配，如果第一个没有匹配上，那就会失败，这里的 a 和 home 没有匹配上，很显然会失败</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/a&quot;</span> component=&#123;<span class="title class_">Home</span>&#125;/&gt;</span><br></pre></td></tr></table></figure><p>当我们开启了精准匹配后，就我们的第一种匹配就不会成功，因为精准匹配需要的是完全一样的值，开启精准匹配采用的是 <code>exact</code> 来实现</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact=&#123;<span class="literal">true</span>&#125;  path=<span class="string">&quot;/home&quot;</span> component=&#123;<span class="title class_">Home</span>&#125;/&gt;</span><br></pre></td></tr></table></figure><br><h3 id="🍋-11-重定向路由"><a href="#🍋-11-重定向路由" class="headerlink" title="🍋 11. 重定向路由"></a>🍋 11. 重定向路由</h3><p>在我们写好了这些之后，我们会发现，我们需要点击任意一个按钮，才会去匹配一个组件，这并不是我们想要的，<strong>我们想要页面一加载上来，默认的就能匹配到一个组件。</strong></p><p>这个时候我们就需要时候 <code>Redirecrt</code> 进行默认匹配了。【兜底作用】</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放在路由注册的最下方</span></span><br><span class="line">&lt;<span class="title class_">Redirect</span> to=<span class="string">&quot;/home&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>当我们加上这条语句时，页面找不到指定路径时，就会重定向到 <code>/home</code> 页面下。因此当我们请求3000端口时，就会重定向到 <code>/home</code> 这样就能够实现我们想要的效果了</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210904013342960.png" alt="image-20210904013342960"></p><h3 id="🍓-12-嵌套路由"><a href="#🍓-12-嵌套路由" class="headerlink" title="🍓 12. 嵌套路由"></a>🍓 12. 嵌套路由</h3><p>嵌套路由也就是我们前面有提及的<strong>二级路由</strong>，但是嵌套路由包括了二级、三级…还有很<strong>多级路由</strong>，当我们需要在一个路由组件中添加两个组件，一个是头部，一个是内容区</p><p>我们将我们的嵌套内容写在相应的组件里面，这个是在 Home 组件的 return 内容</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home组件内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav nav-tabs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item &quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home/message&quot;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/news&quot;</span> <span class="attr">component</span>=<span class="string">&#123;News&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Message&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这里我们<strong>需要使用嵌套路由的方式</strong>，才能完成匹配</p><p>首先， React 中路由的注册是有顺序的，我们在匹配得时候，因为 Home 组件是先注册得，因此在匹配的时候先去找 home 路由【从头开始匹配】，由于是模糊匹配，会成功的匹配【所以才继续展示Home组件】</p><p>在 Home 组件里面去匹配相应的路由，从而找到 /home/news 进行匹配，因此找到 News 组件，进行匹配渲染</p><blockquote><p>如果开启精确匹配的话，第一步的 <code>/home/news</code> 匹配 <code>/home</code> 就会失败，这个时候连 Home 组件都不会展示！【因此，精确匹配一般在最深的路由上才开启】</p></blockquote><h2 id="十一、React-路由传参"><a href="#十一、React-路由传参" class="headerlink" title="十一、React 路由传参"></a>十一、React 路由传参</h2><h3 id="🍟-1-传递-params-参数"><a href="#🍟-1-传递-params-参数" class="headerlink" title="🍟 1. 传递 params 参数"></a>🍟 1. 传递 params 参数</h3><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-params.gif" alt="react-router-params"></p><p>首先我们需要实现的效果是，点击消息列表，展示出消息的详细内容</p><p>这个案例实现的方法有三种，第一种就是传递 params 参数，由于我们所显示的数据都是从数据集中取出来的，因此我们需要有数据的传输给 Detail 组件</p><p>我们首先需要将详细内容的数据列表，保存在 DetailData 中，将消息列表保存在 Message 的 state 中。</p><p>我们可以通过将数据拼接在路由地址末尾来实现数据的传递</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`/home/message/detail/<span class="subst">$&#123;msgObj.id&#125;</span>/<span class="subst">$&#123;msgObj.title&#125;</span>`</span>&#125;&gt;&#123;msgObj.<span class="property">title</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>如上，我们将消息列表的 id 和 title 写在了路由地址后面</p><blockquote><p>这里我们需要注意的是：需要采用模板字符串以及 <code>$</code> 符的方式来进行数据的获取</p></blockquote><p>在注册路由时，我们可以通过 <code>:数据名</code> 来接收数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home/message/detail/:id/:title&quot;</span> component=&#123;<span class="title class_">Detail</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>如上，使用了 <code>:id/:title</code> 成功的接收了由 Link 传递过来的 id 和 title 数据</p><p>这样我们既成功的实现了路由的跳转，又将需要获取的数据传递给了 Detail 组件</p><p>我们在 Detail 组件中打印 <code>this.props</code> 来查看当前接收的数据情况</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906153042353.png" alt="image-20210906153042353"></p><p>我们可以发现，我们传递的数据被接收到了对象的 match 属性下的 params 中</p><p>因此我们可以在 Detail 组件中获取到又 Message 组件中传递来的 params 数据</p><p>并通过 params 数据中的 <code>id</code> 值，在详细内容的数据集中查找出指定 <code>id</code> 的详细内容</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span></span><br><span class="line"><span class="keyword">const</span> findResult = <span class="title class_">DetailData</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">detailObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> detailObj.<span class="property">id</span> === id</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后渲染数据即可</p><br><h3 id="🍀-2-传递-search-参数"><a href="#🍀-2-传递-search-参数" class="headerlink" title="🍀 2. 传递 search 参数"></a>🍀 2. 传递 search 参数</h3><p>我们还可以采用传递 search 参数的方法来实现</p><p>首先我们先确定数据传输的方式</p><p>我们先在 Link 中采用 <code>?</code> 符号的方式来表示后面的为可用数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`/home/message/detail/?id=<span class="subst">$&#123;msgObj.id&#125;</span>&amp;title=<span class="subst">$&#123;msgObj.title&#125;</span>`</span>&#125;&gt;&#123;msgObj.<span class="property">title</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>采用 <code>search</code> 传递的方式，无需在 Route 中再次声明，可以在 Detail 组件中直接获取到</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906155217647.png" alt="image-20210906155217647"></p><p>我们可以发现，我们的数据保存在了 <code>location</code> 对象下的 <code>search</code> 中，是一种字符串的形式保存的，我们可以引用一个库来进行转化 <code>querystring</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;querystring&#x27;</span></span><br></pre></td></tr></table></figure><p>这个库是 React 中自带有的，它有两个方法，一个是 <code>parse</code> 一个是 <code>stringify</code></p><p>我们可以采用 <code>parse</code> 方法，将字符串转化为键值对形式的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; search &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = qs.<span class="title function_">parse</span>(search.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这样我们就能成功的获取数据，并进行渲染</p><blockquote><p>tips：无需声明接收</p></blockquote><br><h3 id="🌷-3-传递-state-参数"><a href="#🌷-3-传递-state-参数" class="headerlink" title="🌷 3. 传递 state 参数"></a>🌷 3. 传递 state 参数</h3><p>采用传递 state 参数的方法，是我觉得最完美的一种方法，<strong>因为它不会将数据携带到地址栏上，采用内部的状态来维护</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">&#x27;/home/message/detail&#x27;</span>, <span class="attr">state</span>: &#123; <span class="attr">id</span>: msgObj.<span class="property">id</span>, <span class="attr">title</span>: msgObj.<span class="property">title</span> &#125; &#125;&#125;&gt;&#123;msgObj.<span class="property">title</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>首先，我们需要在 Link 中注册跳转时，传递一个路由对象，包括一个 跳转地址名，一个 state 数据，这样我们就可以在 Detail 组件中获取到这个传递的 state 数据</p><blockquote><p>注意：采用这种方式传递，无需声明接收</p></blockquote><p>我们可以在 Detail 组件中的 location 对象下的 state 中取出我们所传递的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span>.<span class="property">state</span></span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906160940033.png" alt="image-20210906160940033"></p><p>直接使用即可~</p><blockquote><p>🔺问题：刷新浏览器，state属性会消失吗?</p><p>因为一直使用的是 <code>BrowserRouter</code>，其一直在维护<code>history</code>这个对象，而<code>location</code>属性同时也存在于<code>history</code>上</p><p>但是，当清除历史记录之后，history会消失，state也会消失，以下为解决报错</p></blockquote><p>解决清除缓存造成报错的问题，我们可以在获取不到数据的时候用空对象来替代，例如，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span>.<span class="property">state</span> || &#123;&#125;</span><br></pre></td></tr></table></figure><p>当获取不到 <code>state</code> 时，则用空对象代替</p><blockquote><p>这里的 state 和状态里的 state 有所不同</p></blockquote><br><h2 id="十二、React-路由跳转"><a href="#十二、React-路由跳转" class="headerlink" title="十二、React 路由跳转"></a>十二、React 路由跳转</h2><h3 id="1-push-与-replace-模式"><a href="#1-push-与-replace-模式" class="headerlink" title="1. push 与 replace 模式"></a>1. push 与 replace 模式</h3><p>默认情况下，开启的是 push 模式，也就是说，每次点击跳转，都会向栈中压入一个新的地址，在点击返回时，可以返回到上一个打开的地址，</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-push.gif" alt="react-router-push"></p><p>就像上图一样，我们每次返回都会返回到上一次点击的地址中</p><p>当我们在<strong>读消息的时候，有时候我们可能会不喜欢这种繁琐的跳转，我们可以开启 replace 模式</strong>，这种模式与 push 模式不同，它会将当前地址<strong>替换</strong>成点击的地址，也就是替换了新的栈顶</p><p>我们只需要在需要开启的链接上加上 <code>replace</code> 即可</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> replace to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">&#x27;/home/message/detail&#x27;</span>, <span class="attr">state</span>: &#123; <span class="attr">id</span>: msgObj.<span class="property">id</span>, <span class="attr">title</span>: msgObj.<span class="property">title</span> &#125; &#125;&#125;&gt;&#123;msgObj.<span class="property">title</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-replace.gif" alt="react-router-replace"></p><br><h3 id="2-编程式路由导航"><a href="#2-编程式路由导航" class="headerlink" title="2. 编程式路由导航"></a>2. 编程式路由导航</h3><blockquote><p>【举例：点击图片跳转，这种情况就不能直接使用Link、NavLink了】</p><p>当然，可以用Link包裹图片。但现在有一个需求，News 组件展示3秒之后，自动跳转 Message 组件，这就完全不能使用Link了！</p></blockquote><p>我们可以采用绑定事件的方式实现路由的跳转，我们在按钮上绑定一个 <code>onClick</code> 事件，当事件触发时，我们执行一个回调 <code>replaceShow</code> 【这个函数接收两个参数，用来仿制默认的跳转方式，一个是id ，另一个是title】</p><p>我们在回调中，调用 <code>this.props.location</code> 对象下的 replace 方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">replaceShow = <span class="function">(<span class="params">id, title</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">replace</span>(<span class="string">`/home/message/detail/<span class="subst">$&#123;id&#125;</span>/<span class="subst">$&#123;title&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push(path, state)</span></span><br><span class="line"><span class="comment">// replace(path, state)</span></span><br></pre></td></tr></table></figure><p>同时我们可以借助 <code>this.props.history</code> 身上的 API 实现路由的跳转，例如 <code>push</code>、<code>go(number)</code>、<code>goBack</code> 、<code>goForward</code></p><br><h3 id="3-withRouter"><a href="#3-withRouter" class="headerlink" title="3. withRouter"></a>3. withRouter</h3><p>当我们需要在页面内部添加回退前进等按钮时，由于这些组件我们一般通过一般组件的方式去编写，因此我们会遇到一个问题，<strong>无法获得 history 对象</strong>，这正是因为我们采用的是一般组件造成的。</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906231051190.png" alt="image-20210906231051190"></p><p>**只有路由组件才能获取到 history 对象!!! ** 因此我们需要如何解决这个问题呢？</p><p>我们可以利用 <code>react-router-dom</code> 对象下的 <code>withRouter</code> <u>函数</u>来对我们导出的 <code>Header</code> 组件进行包装，这样我们就能获得一个拥有 <code>history</code> 对象的一般组件</p><p>我们需要对哪个组件包装就在哪个组件下引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">// 在最后导出对象时，用 `withRouter` 函数对 index 进行包装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withRouter</span>(index);</span><br></pre></td></tr></table></figure><p>这样就能让一般组件获得路由组件所特有的 API</p><br><h3 id="4-BrowserRouter-和-HashRouter-的区别"><a href="#4-BrowserRouter-和-HashRouter-的区别" class="headerlink" title="4. BrowserRouter 和 HashRouter 的区别"></a>4. BrowserRouter 和 HashRouter 的区别</h3><h4 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h4><p><strong>它们的底层实现原理不一样</strong></p><p>对于 <code>BrowserRouter</code> 来说它使用的是 <code>React</code> 为它封装的 <code>history API</code> ，这里的 history 和浏览器中的 history 有所不同噢！通过操作这些 API 来实现路由的保存等操作，但是这些 API 是 H5 中提出的，因此不兼容 IE9 以下版本。</p><p>对于 <code>HashRouter</code> 而言，它实现的原理是通过 URL 的哈希值，但是这句话我不是很理解，用一个简单的解释就是我们可以理解为是锚点跳转，因为锚点跳转会保存历史记录，从而让 HashRouter 有了相关的前进后退操作，<code>HashRouter</code> 不会将 <code>#</code> 符号后面的内容发给服务器做请求。【兼容性更好！但基本所有框架写的，都不太容易兼容 IE6及以下】</p><h4 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h4><p><strong>path地址栏的表现形式不一样</strong></p><ul><li>HashRouter 的路径中包含 <code>#</code> ，例如 <code>localhost:3000/#/demo/test</code></li></ul><h4 id="区别三"><a href="#区别三" class="headerlink" title="区别三"></a>区别三</h4><p>🔺<strong>刷新后路由 state 参数改变</strong></p><ol><li>在BrowserRouter 中，state 保存在history 对象中，刷新不会丢失</li><li><strong>HashRouter 则刷新会丢失 state</strong></li></ol><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p><code>HashRouter</code> 也可以解决一些路径错误相关的问题。总之，<code>BrowserRouter</code> 用的较多，但如果就兼容性不放，<code>HashRouter</code> 也有用。</p><br><h2 id="十三、antd-组件库的基本使用"><a href="#十三、antd-组件库的基本使用" class="headerlink" title="十三、antd 组件库的基本使用"></a>十三、antd 组件库的基本使用</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在我们学习<code>JavaScript</code> 的时候，我们学习了一个 <code>bootstrap</code> 的组件库。可以让我们快速开发，但是我们现在学习了 React ，一种组件化编程方式，很少说会去贴大量的 HTML 代码，再配一下 CSS，JS。</p><p>我们也有一些现成的组件库可以使用，我们只需要写一个组件标签即可调用。这让我们 React 开发变得十分的快速，方便和整洁。我们这里学习的是 <code>Ant-design</code> ，它有很多的组件供我们使用</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907180731157.png" alt="image-20210907180731157"></p><p>按钮，日历，这些都是非常常用的组件，我们一起看看如何使用吧</p><blockquote><p>参考文档：<a target="_blank" rel="noopener" href="https://ant.design/components/button-cn/">官方文档</a> | <a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design">Git仓库</a></p><p>其他UI组件库，如 <code>Element-UI</code>，<code>Vant</code> 等</p></blockquote><br><h3 id="1-Antd-组件基本使用"><a href="#1-Antd-组件基本使用" class="headerlink" title="1. Antd 组件基本使用"></a>1. Antd 组件基本使用</h3><p>使用 <code>Antd</code> 组件非常的简单：<strong>引包 —– 暴露 —- 使用</strong></p><p>首先我们通过组件库来实现一个简单的按钮</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>安装并引入 <code>antd</code> 包</p><p>使用命令下载这个组件库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你的网络环境不佳，推荐使用 cnpm。</span></span><br></pre></td></tr></table></figure><p>在我们需要使用的文件下引入，我这里是在 <code>App.jsx</code> 内引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br></pre></td></tr></table></figure><p>在引入的同时，暴露出要使用的组件名 <code>Button</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907181354552.png" alt="image-20210907181354552"></p><p>现在我们可以在 App 中使用 <code>Button</code> 组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="title class_">App</span>..</span><br><span class="line">    &lt;<span class="title class_">Button</span> type=<span class="string">&quot;primary&quot;</span>&gt;<span class="title class_">Primary</span> <span class="title class_">Button</span>&lt;/<span class="title class_">Button</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>Default Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;dashed&quot;</span>&gt;</span>Dashed Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;link&quot;</span>&gt;</span>Link Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我这里使用了几种按钮，但是就这样你会发现按钮少了样式。因此，我们还需要引入 <code>antd</code> 的 CSS 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#x27;antd/dist/antd.css&#x27;</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;/node_modules/antd/dist/antd.less&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以在 <code>node_modules</code> 文件中的 <code>antd</code> 目录下的 <code>dist</code> 文件夹中找到相应的样式文件，引入即可</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907181854774.png" alt="image-20210907181854774"></p><p>即可成功引入 <code>antd</code> 组件。</p><h4 id="第二步：按需引入"><a href="#第二步：按需引入" class="headerlink" title="第二步：按需引入"></a>第二步：按需引入</h4><blockquote><p>2020.2-4.x的之后的文档不再详细阐述，故切换到 3.x 的版本【<a target="_blank" rel="noopener" href="https://3x.ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE">传送门</a>】</p><p>这个例子在实际开发中还有一些优化的空间，比如无法进行主题配置，而且上面的例子加载了全部的 antd 组件的样式（gzipped 后一共大约 60kb）【过大】。</p><p>此时我们需要对 <strong>create-react-app 的默认配置</strong>进行自定义，即需要修改 webpack 的默认配置，但脚手架默认隐藏，且保留 webpack 操作不可逆！【在空脚手架项目中，使用 <code>package.json</code> 中的 script：eject，执行后出现的 <code>jest</code> 文件夹下出现 <code>webpack.config.js</code>。但是，容易改坏，不建议！】</p></blockquote><p>这里我们使用 <a target="_blank" rel="noopener" href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> （一个对 create-react-app 进行自定义配置的社区解决方案）。引入 <code>react-app-rewired</code> 并修改 <code>package.json</code> 里的启动配置。由于新的 <a target="_blank" rel="noopener" href="https://github.com/timarney/react-app-rewired#alternatives">react-app-rewired@2.x</a> 版本的关系，你还需要安装 <a target="_blank" rel="noopener" href="https://github.com/arackaf/customize-cra">customize-cra</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn add react-app-rewired customize-cra</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package.json */</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">-   <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">+   <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-app-rewired start&quot;</span><span class="punctuation">,</span></span><br><span class="line">-   <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span></span><br><span class="line">+   <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-app-rewired build&quot;</span><span class="punctuation">,</span></span><br><span class="line">-   <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts test&quot;</span><span class="punctuation">,</span></span><br><span class="line">+   <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-app-rewired test&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后在项目根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">override</span>(<span class="params">config, env</span>) &#123;</span><br><span class="line">  <span class="comment">// do stuff with the webpack config...</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>customize-cra</code>：在不<code>eject</code>的情况下，使用 <code>config-overrides.js</code> 修改脚手架配置，修改之后不能使用 <code>npm run start</code> 启动脚手架了，只能使用 <code>react-app-rewired</code> 来启动脚手架</p></blockquote><p>使用 <code>babel-plugin-import</code> 尝试安装它并修改 <code>config-overrides.js</code> 文件</p><blockquote><p>具体详见<a target="_blank" rel="noopener" href="https://3x.ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE">此处</a></p></blockquote><p><strong>注意：</strong>5.X 已经自动按需引入</p><br><h3 id="2-自定义主题颜色"><a href="#2-自定义主题颜色" class="headerlink" title="2. 自定义主题颜色"></a>2. 自定义主题颜色</h3><p>由于这些组件采用的颜色，都是支付宝蓝，有时候我们不想要这样的颜色，想要用其他的配色，这当然是可以实现的，我们需要引用一些库和更改一些配置文件来实现。</p><blockquote><p>在视频中，老师讲解的是 <code>3.x</code> 版本中的<a target="_blank" rel="noopener" href="https://3x.ant.design/docs/react/use-with-create-react-app-cn#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98">实现方法</a>，这种方法需要去暴露 React 中的配置文件，这种操作是不可返回的，一旦暴露就不可回收。我觉得这不是一个好方法。下面是3.x版本按需引入和自定主题的笔记：</p><ol><li><p>安装依赖：<code>yarn add react-app-rewired customize-cra babel-plugin-import less less-loader</code></p></li><li><p>修改<code>package.json</code></p></li><li><p>根目录下创建<code>config-overrides.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置具体的修改规则</span></span><br><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports,addLessLoader&#125; = <span class="built_in">require</span>(<span class="string">&#x27;customize-cra&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">override</span>(</span><br><span class="line">    <span class="title function_">fixBabelImports</span>(<span class="string">&#x27;import&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">libraryName</span>: <span class="string">&#x27;antd&#x27;</span>,</span><br><span class="line">        <span class="attr">libraryDirectory</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">addLessLoader</span>(&#123;</span><br><span class="line">        <span class="attr">lessOptions</span>:&#123;</span><br><span class="line">            <span class="attr">javascriptEnabled</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">modifyVars</span>: &#123; <span class="string">&#x27;@primary-color&#x27;</span>: <span class="string">&#x27;green&#x27;</span> &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>备注：不用在组件里亲自引入样式了，即：import ‘antd/dist/antd.css’应该删掉</p></li></ol></blockquote><br><p>在 <code>antd</code> 最新版中，引入了 <code>craco</code> 库，我们可以使用 <code>craco</code> 来实现自定义的效果</p><p>首先我们需要安装 <code>craco</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @craco/craco</span><br></pre></td></tr></table></figure><p>同时我们需要更改 <code>package.json</code> 中的启动文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;craco start&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;craco build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;craco test&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;eject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>更改成 <code>craco</code> 执行</p><p>接下来我们需要在根目录下新建一个 <code>craco.config.js</code> 文件，用于配置自定义内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CracoLessPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;craco-less&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">plugin</span>: <span class="title class_">CracoLessPlugin</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">lessLoaderOptions</span>: &#123;</span><br><span class="line">          <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">            <span class="attr">modifyVars</span>: &#123; <span class="string">&#x27;@primary-color&#x27;</span>: <span class="string">&#x27;skyblue&#x27;</span> &#125;,</span><br><span class="line">            <span class="attr">javascriptEnabled</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实它就是用来操作 <code>less</code> 文件的全局颜色。简单的说，<code>antd</code> 组件是采用 <code>less</code> 编写的，我们需要通过重新配置的方式去更改它的值。同时我们需要将我们先前的 <code>App.css</code> 文件更改为 <code>App.less</code> 文件，在当中引入我们的 <code>less</code> 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;/node_modules/antd/dist/antd.less&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意一定要添加<strong>分号结尾</strong>，这是一个非常容易犯的错误</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210907200116517.png" alt="image-20210907200116517"></p><p>可见，我们成功的将主题色修改成了红色</p><br><h2 id="十四、Redux基本使用"><a href="#十四、Redux基本使用" class="headerlink" title="十四、Redux基本使用"></a>十四、Redux基本使用</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><p>在了解了 Antd 组件库之后，我们现在开始学习了 Redux ，在我们之前写的案例当中，例如：todolist 案例，GitHub 搜索案例当中，我们对于状态的管理，都是通过 state 来实现的，比如，我们在给兄弟组件传递数据时，需要<strong>先将数据传递给父组件，再由父组件转发给它的子组件</strong>。这个过程十分的复杂，后来我们又学习了<strong>消息的发布订阅</strong>，我们通过 <strong>pubsub</strong> 库，实现了消息的转发，直接将数据发布，由兄弟组件订阅，实现了兄弟组件间的数据传递。但是，随着我们的需求不断地提升，我们需要进行更加复杂的数据传递，更多层次的数据交换。<strong>因此我们为何不可以将所有的数据交给一个中转站，这个中转站独立于所有的组件之外，由这个中转站来进行数据的分发，这样不管哪个组件需要数据，我们都可以很轻易的给他派发。</strong></p><p>而有这么一个库就可以帮助我们来实现，那就是 Redux ：</p><ul><li>专门用于状态管理的<code>JS</code>库【不是<code>React</code>插件库】【可用于 <code>vue</code>、<code>React</code>、<code>Angular</code>，但vue中有vuex】</li><li>它可以帮助我们实现<strong>集中式状态管理</strong>【集中式管理react应用中多个组件共享的状态】</li></ul><blockquote><p>详细代码笔记在<a target="_blank" rel="noopener" href="https://gitee.com/Hammerzer/react-resource/tree/master/%E6%BA%90%E7%A0%81/redux_test">此处</a></p></blockquote><h3 id="1-什么情况使用-Redux"><a href="#1-什么情况使用-Redux" class="headerlink" title="1. 什么情况使用 Redux"></a>1. 什么情况使用 Redux</h3><p>首先，我们先明晰 <code>Redux</code> 的作用 ，实现集中式状态管理。</p><p><code>Redux</code> 适用于多交互、多数据源的场景。简单理解就是<strong>复杂</strong></p><p>从组件角度去考虑的话，当我们有以下的应用场景时，我们可以尝试采用 <code>Redux</code> 来实现</p><ol><li>某个组件的状态需要共享时</li><li>一个组件需要改变其他组件的状态时</li><li>一个组件需要改变全局的状态时</li></ol><p>除此之外，还有很多情况都需要使用 Redux 来实现（还没有学 hook，或许还有更好的方法）</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210909194446988.png" alt="image-20210909194446988"></p><blockquote><p>【从掘友的文章里截的图】这张图，非常形象的将纯 React 和 采用 Redux 的区别体现了出来</p></blockquote><br><h3 id="2-Redux-的工作流程"><a href="#2-Redux-的工作流程" class="headerlink" title="2. Redux 的工作流程"></a>2. Redux 的工作流程</h3><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210909194900532.png" alt="image-20210909194900532"></p><p>首先组件会通过 <code>Action Creators</code>【可暂时不借助API】，在 Redux 中派发一个 <code>action</code> 对象，通过调用 <code>store.dispatch</code> 方法，将 <code>action</code> 对象派发给 <code>store</code> ，当 <code>store</code> 接收到 <code>action</code> 对象时，会将先前的 <code>state</code> 与传来的 <code>action</code> 一同发送给 <code>reducer</code> ，<code>reducer</code> 在接收到数据后，进行数据的更改，返回一个新的状态给 <code>store</code> ，最后由 <code>store</code> 更改 <code>state</code> 。【<code>Reducer</code>同时负责初始化工作，<code>previousState = undefined</code>】</p><blockquote><p>【图来自掘金社区，侵删】</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/12/16e5fd1597faec4d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="3-Redux-三个核心概念"><a href="#3-Redux-三个核心概念" class="headerlink" title="3. Redux 三个核心概念"></a>3. Redux 三个核心概念</h3><h4 id="1-store"><a href="#1-store" class="headerlink" title="1. store"></a>1. store</h4><p><code>store</code> 是 Redux 的核心，可以理解为是 Redux 的数据中台【将state、action、reducer联系在一起】，我们可以将任何我们想要存放的数据放在 <code>store</code> 中，在我们需要使用这些数据时，我们可以从中取出相应的数据。因此我们需要先创建一个 <code>store</code> ，在 Redux 中可以使用 <code>createStore</code> API 来创建一个 <code>store</code></p><p>在生产中，我们需要在 <code>src</code> 目录下的 <code>redux</code> 文件夹中新增一个 <code>store.js</code> 文件，在这个文件中，创建一个 <code>store</code> 对象，并暴露它。因此我们需要从 <code>redux</code> 中暴露两个方法 【<strong>注意：2023/11/16 createStore已经废弃</strong>】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    createStore,</span><br><span class="line">    applyMiddleware</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br></pre></td></tr></table></figure><p>并引入为 count 组件服务的 reducer【<code>count_reduce.js</code> 与 <code>store.js</code> 同级】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./count_reducer&#x27;</span></span><br></pre></td></tr></table></figure><p>最后调用 <code>createStore</code> 方法来暴露 <code>store</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(countReducer, <span class="title function_">applyMiddleware</span>(thunk))</span><br></pre></td></tr></table></figure><p>这里采用了中间件，本文应该不会写到~</p><p>在 <code>store</code> 对象下有一些常用的内置方法，获取当前时刻的 <code>store</code> ，我们可以采用 <code>getStore</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = store.<span class="title function_">getState</span>();</span><br></pre></td></tr></table></figure><p>在前面我们的流程图中，我们需要通过 <code>store</code> 中的 <code>dispatch</code> 方法来派生一个 <code>action</code> 对象给 <code>store</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">`action对象`</span>)</span><br></pre></td></tr></table></figure><p>最后还有一个 <code>subscribe</code> 方法，这个方法可以帮助我们订阅 <code>store</code> 的改变，只要 <code>store</code> 发生改变，这个方法的回调就会执行【即通过生命周期钩子来检测 store 的改变，只要改变，就调用 render】。为了监听数据的更新，我们可以将 <code>subscribe</code> 方法绑定在组件挂载完毕生命周期函数上，但是这样，当我们的组件数量很多时，会比较的麻烦，因此我们可以直接将 <code>subscribe</code> 函数用来监听整个 <code>App</code>组件的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个组件都要写-----------不推荐</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//检测redux中状态的变化，只要变化，就调用render</span></span><br><span class="line">    store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在index.js中-----------推荐</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>( &lt; <span class="title class_">App</span> /&gt; , <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-action"><a href="#2-action" class="headerlink" title="2. action"></a>2. action</h4><p><code>action</code> 是 <code>store</code> 中唯一的数据来源，一般来说，我们会通过调用 <code>store.dispatch</code> 将 <code>action</code> 传到 <code>store</code> 。其中，我们需要传递的 <code>action</code> 是一个对象，它必须要有一个 <code>type</code> 值</p><p>例如，这里我们暴露了一个用于返回一个 <code>action</code> 对象的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createIncrementAction</span> = data =&gt; (&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">INCREMENT</span>,</span><br><span class="line">    data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们调用它时，会返回一个 <code>action</code> 对象</p><h4 id="3-reducer"><a href="#3-reducer" class="headerlink" title="3. reducer"></a>3. reducer</h4><p>在 <code>Reducer</code> 中，我们需要指定状态的操作类型，要做怎样的数据更新，因此这个类型是必要的。其作用如下：</p><ul><li>用于初始化状态、加工状态</li><li>加工时，根据旧的state和action，产生新的state的<strong>纯函数</strong></li></ul><p><code>reducer</code> 会根据 <code>action</code> 的指示，对 <code>state</code> 进行对应的操作，然后返回操作后的 <code>state</code> 。如下，我们对接收的 <code>action</code> 中传来的 <code>type</code> 进行判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">countReducer</span>(<span class="params">preState = initState, action</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        data</span><br><span class="line">    &#125; = action;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">            <span class="keyword">return</span> preState + data</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">            <span class="keyword">return</span> preState - data</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> preState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改数据，返回新的状态</p><h3 id="4-创建-constant-文件"><a href="#4-创建-constant-文件" class="headerlink" title="4. 创建 constant 文件"></a>4. 创建 constant 文件</h3><p>在我们正常的编码中，有可能会出现拼写错误的情况，但是我们会发现，拼写错误了不一定会报错，因此就会比较难搞。我们可以在 <code>redux</code> 目录下，创建一个 <code>constant</code> 文件，这个文件用于定义我们代码中常用的一些变量，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INCREMENT</span> = <span class="string">&#x27;increment&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">DECREMENT</span> = <span class="string">&#x27;decrement&#x27;</span></span><br></pre></td></tr></table></figure><p>将这两个单词写在 <code>constant</code> 文件中，并对外暴露，当我们需要使用时，我们可以引入这个文件，并直接使用它的名称即可【直接使用 <code>INCREMENT</code> 即可】</p><h3 id="5-实现异步-action"><a href="#5-实现异步-action" class="headerlink" title="5. 实现异步 action"></a>5. 实现异步 action</h3><p>一开始，我们直接调用一个异步函数，这虽然没有什么问题，但是难道 redux 就不可以实现了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">incrementAsync = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="variable language_">this</span>.<span class="property">selectNumber</span></span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: count + value * <span class="number">1</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以先尝试将它封装到 <code>action</code> 对象中调用</p><blockquote><p>一般情况下，action为Object时，是同步action；若action为Function时，是异步action</p><p>而且，异步action中都会调用同步action；异步action也不是必须用的！它只是封装方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在count_action.js</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    该文件专门为Count组件生成action对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">INCREMENT</span>,<span class="variable constant_">DECREMENT</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./constant&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步action，就是指action的值为Object类型的一般对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createIncrementAction</span> = data =&gt; (&#123;<span class="attr">type</span>:<span class="variable constant_">INCREMENT</span>,data&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createDecrementAction</span> = data =&gt; (&#123;<span class="attr">type</span>:<span class="variable constant_">DECREMENT</span>,data&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步action，就是指action的值为函数,异步action中一般都会调用同步action，异步action不是必须要用的。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createIncrementAsyncAction</span> = (<span class="params">data,time</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 初试版本 需要自己引入 store.js</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return ()=&gt;&#123;</span></span><br><span class="line"><span class="comment">        setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="comment">            store.dispatch(createIncrementAction(data))</span></span><br><span class="line"><span class="comment">        &#125;,time)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 其实不需要自己引入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">dispatch</span>(<span class="title function_">createIncrementAction</span>(data))</span><br><span class="line">        &#125;,time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们点击异步加操作时，我们会调用这个函数，在这个函数里接收一个延时加的时间，还有action所需的数据，和原先的区别只在于返回的是一个定时器函数。<strong>但是如果仅仅这样，很显然是会报错的，它默认需要接收一个对象。</strong></p><p>如果我们需要实现传入函数，那我们就需要告诉：你只需要默默的帮我执行以下这个函数就好！这时我们就需要<strong>引入中间件</strong>，在原生的 <code>redux</code> 中暴露出 <code>applyMiddleware</code> 中间件执行函数，并引入 <code>redux-thunk</code> 中间件（需要手动下载）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在store.js中，声明</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="comment">// 多引入一个函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">// 通过第二个参数传递下去就可以了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(countReducer, <span class="title function_">applyMiddleware</span>(thunk))</span><br></pre></td></tr></table></figure><p>注意：异步 action 不是必须要写的，完全可以自己等待异步任务的结果后再去分发同步action</p><blockquote><p>采用 <code>react-thunk</code> 能让异步代码像同步代码一样执行，在 <code>redux</code> 中我们也是可以实现异步的，但是这样我们的代码中会有很多异步的细节，这不是我们想看到的，利用 <code>react-thunk</code> 之类的库，就能让我们只关心我们的业务</p></blockquote><h3 id="6-Redux-三大原则"><a href="#6-Redux-三大原则" class="headerlink" title="6. Redux 三大原则"></a>6. Redux 三大原则</h3><p>理解好 Redux 有助于我们更好的理解接下来的 <code>React -Redux</code>【React插件库】</p><h4 id="第一个原则"><a href="#第一个原则" class="headerlink" title="第一个原则"></a>第一个原则</h4><p><strong>单向数据流</strong>：整个 Redux 中，数据流向是单向的</p><p>UI 组件 —&gt; action —&gt; store —&gt; reducer —&gt; store</p><h4 id="第二个原则"><a href="#第二个原则" class="headerlink" title="第二个原则"></a>第二个原则</h4><p><strong>state 只读</strong>：在 Redux 中不能通过直接改变 state ，来控制状态的改变，如果想要改变 state ，则需要触发一次 action。通过 action 执行 reducer</p><h4 id="第三个原则"><a href="#第三个原则" class="headerlink" title="第三个原则"></a>第三个原则</h4><p><strong>纯函数执行</strong>：每一个reducer 都是一个纯函数，不会有任何副作用，返回是一个新的 state，state 改变会触发 store 中的 subscribe</p><br><h2 id="十五-React-Redux-基本使用"><a href="#十五-React-Redux-基本使用" class="headerlink" title="十五 React-Redux 基本使用"></a>十五 React-Redux 基本使用</h2><p>在前面的案例中，我们如果把 store 直接写在了 React 应用的顶层 props 中，各个子组件，就能访问到顶层props</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;顶层组件 store=&#123;store&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/顶层组件/</span>&gt;</span><br></pre></td></tr></table></figure><p>这就类似于 React-Redux</p><h3 id="容器组件和-UI-组件"><a href="#容器组件和-UI-组件" class="headerlink" title="容器组件和 UI 组件"></a>容器组件和 UI 组件</h3><ol><li>所有的 UI 组件都需要有一个容器组件包裹</li><li>容器组件来负责和 Redux 打交道，可以随意使用 Redux 的API</li><li>UI 组件无任何 Redux API</li><li>容器组件用于处理逻辑，UI 组件只会负责渲染和交互，不处理逻辑</li></ol><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210910094426268.png" alt="image-20210910094426268"></p><p>在我们的生产当中，我们可以直接将 UI 组件写在容器组件的代码文件当中，这样就无需多个文件</p><p>首先，我们在 src 目录下，创建一个 <code>containers</code> 文件夹，用于存放各种容器组件，在该文件夹内创建 <code>Count</code> 文件夹，即表示即将创建 Count 容器组件，再创建 <code>index.jsx</code> 编写代码</p><p>要实现容器组件和 UI 组件的连接，我们需要通过 <code>connect</code> 来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入UI组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CountUI</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Count&#x27;</span></span><br><span class="line"><span class="comment">// 引入 connect 连接UI组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>()(<span class="title class_">CountUI</span>)</span><br></pre></td></tr></table></figure><blockquote><p>因此，规范的项目中，UI组件放入<code>components</code>，容器组件放入<code>containers</code>。需注意：</p><ul><li>容器组件需要借助 <code>React-redux</code></li><li>容器组件中需要的store，须在上一层组件【即App.js】中通过props传递</li><li>容器组件与UI组件的父子关系，不再由父子标签来体现，而由<code>connet()()</code>体现。第二个括号传递UI组件；第一个括号传递两个函数：<ul><li>第一个函数将返回值作为<strong>props状态</strong>传递给UI组件【传递状态】</li><li>第二个函数【传递操作状态的方法】</li></ul></li><li>如果想在容器组件中获取store值，即使用<code>store.getState()</code>，没有必要引入<code>stroe.js</code>，上面提到的第一个函数，其由React-redux默认传入state；同样，如果想在容器组件中dispatch一个action，没有必要引入<code>stroe.js</code>，上面提到的第二个函数，其由React-redux默认传入dispatch；</li></ul></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Count的UI组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CountUI</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Count&#x27;</span></span><br><span class="line"><span class="comment">//引入action</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    createIncrementAction,</span><br><span class="line">    createDecrementAction,</span><br><span class="line">    createIncrementAsyncAction</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;../../redux/count_action&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入connect用于连接UI组件与redux</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.mapStateToProps函数返回的是一个对象；</span></span><br><span class="line"><span class="comment">    2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</span></span><br><span class="line"><span class="comment">    3.mapStateToProps用于传递状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapStateToProps</span>(<span class="params">state</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:state&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.mapDispatchToProps函数返回的是一个对象；</span></span><br><span class="line"><span class="comment">    2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</span></span><br><span class="line"><span class="comment">    3.mapDispatchToProps用于传递操作状态的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapDispatchToProps</span>(<span class="params">dispatch</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">jia</span>:<span class="function"><span class="params">number</span> =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">createIncrementAction</span>(number)),</span><br><span class="line">        <span class="attr">jian</span>:<span class="function"><span class="params">number</span> =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">createDecrementAction</span>(number)),</span><br><span class="line">        <span class="attr">jiaAsync</span>:<span class="function">(<span class="params">number,time</span>) =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">createIncrementAsyncAction</span>(number,time)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用connect()()创建并暴露一个Count的容器组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="title class_">CountUI</span>)</span><br></pre></td></tr></table></figure><p>connect 方法是一个连接器，用于连接容器组件和 UI 组件，它第一次执行时，接收4个参数，这些参数都是<strong>可选的</strong>，它执行的执行的结果还是一个函数，第二次执行接收一个 UI 组件。第一次执行时的四个参数：<code>mapStateToProps</code> 、<code>mapDispatchToProps</code> 、<code>mergeProps</code>、<code>options</code></p><h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">count</span>: state &#125;)</span><br></pre></td></tr></table></figure><p>它接收 <code>state</code> 作为参数，并且返回一个对象，这个对象标识着 UI 组件的同名参数，返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为 props 的 value</p><p>如上面的代码，我们可以在 UI 组件中直接通过 props 来读取 <code>count</code> 值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;当前求和为：&#123;<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">count</span>&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h4><p>connect 接受的第二个参数是 <code>mapDispatchToProps</code> 它是用于建立 UI 组件的参数到 <code>store.dispacth</code> 方法的映射。我们可以把参数写成对象形式，在这里面定义 action 执行的方法，例如 <code>jia</code> 执行什么函数，<code>jian</code> 执行什么函数？</p><p>我们都可以在这个参数中定义，如下定义了几个方法对应的操作函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">jia</span>: createIncrementAction,</span><br><span class="line">    <span class="attr">jian</span>: createDecrementAction,</span><br><span class="line">    <span class="attr">jiaAsync</span>: createIncrementAsyncAction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="第一步优化"><a href="#第一步优化" class="headerlink" title="第一步优化"></a>第一步优化</h4><ul><li>【编码优化】function 函数可以优化为箭头函数</li><li>【编码优化】mapStateToProps等只是中间变量，可以直接优化</li><li>【API优化】第二个方法参数，可以之后优化为<code>key-value</code>形式【redux_action返回action对象后，React-Redux自动分发，无需手动dispatch】</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Count的UI组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CountUI</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Count&#x27;</span></span><br><span class="line"><span class="comment">//引入action</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    createIncrementAction,</span><br><span class="line">    createDecrementAction,</span><br><span class="line">    createIncrementAsyncAction</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;../../redux/count_action&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入connect用于连接UI组件与redux</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用connect()()创建并暴露一个Count的容器组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">    <span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>:state&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mapDispatchToProps的一般写法</span></span><br><span class="line">    <span class="comment">/* dispatch =&gt; (&#123;</span></span><br><span class="line"><span class="comment">        jia:number =&gt; dispatch(createIncrementAction(number)),</span></span><br><span class="line"><span class="comment">        jian:number =&gt; dispatch(createDecrementAction(number)),</span></span><br><span class="line"><span class="comment">        jiaAsync:(number,time) =&gt; dispatch(createIncrementAsyncAction(number,time)),</span></span><br><span class="line"><span class="comment">    &#125;) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//mapDispatchToProps的简写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">jia</span>:createIncrementAction,</span><br><span class="line">        <span class="attr">jian</span>:createDecrementAction,</span><br><span class="line">        <span class="attr">jiaAsync</span>:createIncrementAsyncAction,</span><br><span class="line">    &#125;</span><br><span class="line">)(<span class="title class_">Count</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h4 id="Provider【API优化】"><a href="#Provider【API优化】" class="headerlink" title="Provider【API优化】"></a>Provider【API优化】</h4><blockquote><p>由于React-Redux中<code>connect</code>的使用，不再需要在<code>index.js</code>中手动检测store变化并手动刷新；但是依然需要通过props传递store</p></blockquote><p>由于我们store中的状态<code>state</code>可能会被很多组件使用，所以 React-Redux 给我们提供了一个 <code>Provider</code> 组件，可以<strong>全局注入 redux 中的 store</strong> ，只需要把 <code>Provider</code> 注册在根部组件即可</p><p>例如，当以下组件都需要使用 store 时，我们需要这么做，但是这样徒增了工作量，很不便利</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Count</span> store=&#123;store&#125;/&gt;</span><br><span class="line">&#123;<span class="comment">/* 示例 */</span>&#125;</span><br><span class="line">&lt;<span class="title class_">Demo1</span> store=&#123;store&#125;/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo1</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo1</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo1</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo1</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;/</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可以这么做：在 src 目录下的 <code>index.js</code> 文件中，引入 <code>Provider</code> ，直接用 <code>Provider</code> 标签包裹 <code>App</code> 组件，将 <code>store</code> 写在 <code>Provider</code> 中即可</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样我们在 <code>App.jsx</code> 文件中，组件无需手写指定 <code>store</code> ，即可使用 <code>store</code></p><br><h3 id="完整开发【文件结构优化】"><a href="#完整开发【文件结构优化】" class="headerlink" title="完整开发【文件结构优化】"></a>完整开发【文件结构优化】</h3><blockquote><p>虽要求必须有容器组件和UI组件，但没说要分开写，故合并对用的容器组件和UI组件，并且合并在<code>containers</code> 的容器组件中</p><p>首先，出现了两次默认暴露 <code>export default</code>，这是不被允许的，故删除UI组件的默认暴露</p><p>然后，将文件中定义的UI组件类传入connect</p></blockquote><p>首先我们在 <code>containers</code> 文件夹中，直接编写我们的容器组件，无需编写 UI 组件【仅在<code>containers</code> 中定义组件】。先打 <code>rcc</code> 打出指定代码段，然后暴露出 <code>connect</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br></pre></td></tr></table></figure><p>从 <code>action</code> 文件中暴露创建 <code>action</code> 的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createIncrementAction&#125; <span class="keyword">from</span> <span class="string">&#x27;../../redux/count_action&#x27;</span></span><br></pre></td></tr></table></figure><p>编写 UI 组件，简单写个 demo，绑定 props 和方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>点我加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>调用 <code>connect</code> 包装暴露 UI 组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">    <span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state &#125;),<span class="comment">// 状态</span></span><br><span class="line">    &#123; <span class="attr">jia</span>: createIncrementAction &#125; <span class="comment">// 方法</span></span><br><span class="line">)(<span class="title class_">Count</span>);</span><br></pre></td></tr></table></figure><p>第一次执行的参数就直接传递 <code>state</code> 和一个指定 <code>action</code> 的对象</p><br><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>(1).容器组件和UI组件整合一个文件</p><p>​ (2).无需自己给容器组件传递store，给<app>包裹一个<provider store="{store}">即可。</provider></app></p><p>​ (3).使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。</p><p>​ (4).mapDispatchToProps也可以简单的写成一个对象</p><p>​ (5).一个组件要和redux“打交道”要经过哪几步？</p><p>​ (1).定义好UI组件—不暴露</p><p>​ (2).引入connect生成一个容器组件，并暴露，写法如下：</p><p>​ connect(</p><p>​ state =&gt; ({key:value}), //映射状态</p><p>​ {key:xxxxxAction} //映射操作状态的方法</p><p>​ )(UI组件)</p><p>​ (4).在UI组件中通过this.props.xxxxxxx读取和操作状态</p><br><blockquote><p>不想继续在前端上浪费时间了！！！</p><p>以下的是别人的笔记</p></blockquote><h2 id="十六-React-Redux-基本使用"><a href="#十六-React-Redux-基本使用" class="headerlink" title="十六 React-Redux 基本使用"></a>十六 React-Redux 基本使用</h2><h3 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h3><p>在写完了基本的 Redux 案例之后，我们可以尝试一些更实战性的操作，比如我们可以试试多组件间的状态传递，相互之间的交互</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-redux-demo.gif" alt="react-redux-demo"></p><p>如上动图所示，我们想要实现上面的案例，采用纯 React 来实现是比较困难的，我们需要<strong>很多层的数据交换</strong>才能实现，但是我们如果采用 Redux 来实现会变得非常简单</p><p>因为 Redux <strong>打通了组件间的隔阂</strong>，我们可以自由的进行数据交换，所有存放在 <code>store</code> 中的数据都可以实现共享，那我们接下来看看如何实现的吧~</p><h3 id="1-编写-Person-组件"><a href="#1-编写-Person-组件" class="headerlink" title="1. 编写 Person 组件"></a>1. 编写 Person 组件</h3><blockquote><p>上面的 Count 组件，已经在前面几篇写过了，但是我没有记录详细的实现过程，只是做了一些小小的总结（我摸鱼了）</p></blockquote><p>不管如何，我们先来实现一个 Person 组件吧</p><p>首先我们需要在 <code>containers</code> 文件夹下编写 Person 组件的<strong>容器组件</strong></p><p>如何编写一个容器组件呢？（上一篇也讲过了）</p><p>首先我们需要编写 <code>index.jsx</code> 文件，在这个文件里面编写 Person 组件的 <strong>UI 组件</strong>，并使用 <code>connect</code> 函数将它包装，<strong>映射它的状态和方法</strong></p><h4 id="编写-UI-组件架构"><a href="#编写-UI-组件架构" class="headerlink" title="编写 UI 组件架构"></a><strong>编写 UI 组件架构</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是 Person 组件,上方组件求和为:&#123;this.props.countAll&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;c</span> =&gt;</span> this.nameNode = c&#125; type=&quot;text&quot; placeholder=&quot;输入名字&quot; /&gt;</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;c</span> =&gt;</span> this.ageNode = c&#125; type=&quot;text&quot; placeholder=&quot;输入年龄&quot; /&gt;</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.addPerson&#125;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            this.props.persons.map((p) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;p.id&#125;</span>&gt;</span> &#123;p.name&#125;--&#123;p.age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到这里采用了 <code>ref</code> 来获取到当前事件触发的节点，并通过 <code>this.addPerson</code> 的方式给按钮绑定了一个点击事件</p><h4 id="编写点击事件回调"><a href="#编写点击事件回调" class="headerlink" title="编写点击事件回调"></a><strong>编写点击事件回调</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">addPerson = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="variable language_">this</span>.<span class="property">nameNode</span>.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> age = <span class="variable language_">this</span>.<span class="property">ageNode</span>.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> personObj = &#123; <span class="attr">id</span>: <span class="title function_">nanoid</span>(), name, age &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">add</span>(personObj)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nameNode</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ageNode</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们需要处理输入框中的数据，并且将这些数据用于创建一个 <code>action</code> 对象，传递给 <code>store</code> 进行状态的更新</p><p>在这里我们需要回顾的是，这里我们使用了一个 <code>nanoid</code> 库，这个库我们之前也有使用过</p><h5 id="下载，引入，暴露"><a href="#下载，引入，暴露" class="headerlink" title="下载，引入，暴露"></a><strong>下载，引入，暴露</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nanoid &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br></pre></td></tr></table></figure><p>暴露的 <code>nanoid</code> 是一个函数，我们每一次调用时，都会返回一个不重复的数，用于确保 <code>id</code> 的唯一性，同时在后面的 <code>map</code> 遍历的过程中，我们将 <code>id</code> 作为了 <code>key</code> 值，这样也确保了 <code>key</code> 的唯一性，关于 <code>key</code> 的作用，可以看看 <code>diffing</code> 算法的文章</p><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a><strong>状态管理</strong></h4><p>在这里我们需要非常熟练的采用 <code>this.props.add</code> 的方式来更新状态</p><p>那么它是如何实现状态更新的呢？我们来看看</p><p>在我们调用 <code>connect</code> 函数时，我们第一次调用时传入的第二个参数，就是用于传递方法的，我们传递了一个 <code>add</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">    <span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">persons</span>: state.<span class="property">person</span>, <span class="attr">countAll</span>: state.<span class="property">count</span> &#125;),<span class="comment">//映射状态</span></span><br><span class="line">    &#123; <span class="attr">add</span>: createAddPersonAction &#125;</span><br><span class="line">)(<span class="title class_">Person</span>);</span><br></pre></td></tr></table></figure><p>它的原词是：<strong>mapDispatchToProps</strong></p><p>我的理解是，传入的东西会被映射映射成 <code>props</code> 对象下的方法，这也是我们能够在 <code>props</code> 下访问到 <code>add</code> 方法的原因</p><blockquote><p>对于这一块 <code>connect</code> ，我们必须要能够形成自己的理解，这里非常的重要，它实现了数据的交互，不至于一个组件，而是全部组件</p></blockquote><h4 id="我是如何理解的呢？"><a href="#我是如何理解的呢？" class="headerlink" title="我是如何理解的呢？"></a><strong>我是如何理解的呢？</strong></h4><blockquote><p>想象一个 store 仓库，在我们这个案例当中，Count 组件需要存放 count 值在 store 中，Person 组件需要存放新增用户对象在 store 中，我们要把这两个数据存放在一个对象当中。当某个组件需要使用 store 中的值时，可以通过 connect 中的两个参数来获取，例如这里我们需要使用到 Count 组件的值，可以通过 <code>.count</code> 来从 store 中取值。</p></blockquote><p>也就是说，所有的值都存放在 store 当中，通过点运算符来获取，所有的操作 store 的方法都需要通过 action 来实现。<strong>当前组件需要使用的数据都需要在 <code>connect</code> 中暴露</strong></p><h3 id="2-编写-reducer"><a href="#2-编写-reducer" class="headerlink" title="2. 编写 reducer"></a>2. 编写 reducer</h3><p>首先，我们需要明确 reducer 的作用，它是用来干什么的？</p><p><strong>根据操作类型来指定状态的更新</strong></p><p>也就是说当我们点击了<strong>添加按钮</strong>后，会将输入框中的数据整合成一个对象，作为当前 action 对象的 data 传递给 reducer</p><p>我们可以看看我们编写的 action 文件，和我们想的一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">ADD_PERSON</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../constant&quot;</span>;</span><br><span class="line"><span class="comment">// 创建一个人的action 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createAddPersonAction</span> = (<span class="params">personObj</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">ADD_PERSON</span>,</span><br><span class="line">  <span class="attr">data</span>: personObj,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 reducer 接收到 action 对象时，会对 type 进行判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">personReducer</span>(<span class="params">preState = initState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, data &#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD_PERSON</span>:</span><br><span class="line">      <span class="keyword">return</span> [data,...preState]</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> preState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般都采用 <code>switch</code> 来编写</p><p><strong>这里有个值得注意的地方是</strong>，这个 <code>personReducer</code> 函数是一个纯函数，什么是纯函数呢？这个是高阶函数部分的知识了，纯<strong>函数是一个不改变参数的函数，也就是说，传入的参数是不能被改变的。</strong></p><p>为什么要提这个呢？在我们 return 时，有时候会想通过<strong>数组的 API</strong> 来在数组前面塞一个值，不也可以吗？</p><p>但是我们要采用 <code>unshirt</code> 方法，这个方法是会改变原数组的，也就是我们传入的参数会被改变，因此这样的方法是不可行的！</p><h3 id="3-打通数据共享"><a href="#3-打通数据共享" class="headerlink" title="3. 打通数据共享"></a>3. 打通数据共享</h3><p>写到这里，或许已经写完了，但是有些细节还是需要注意一下</p><p>采用 Redux 来进行组件的数据交互真的挺方便。</p><p>我们可以在 Count 组件中引入 Person 组件存在 store 中的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.<span class="property">count</span>, <span class="attr">personNum</span>: state.<span class="property">person</span>.<span class="property">length</span> &#125;),</span><br><span class="line">    &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">)(<span class="title class_">Count</span>)</span><br></pre></td></tr></table></figure><p>在这里我们将 store 中的 person 数组的长度暴露出来这样 Count 组件就可以直接通过 props 来使用了</p><p>同样的我们也可以在 Person 组件中使用 Count 组件的值</p><p>从而实现了我们的这个 Demo</p><h3 id="4-最终优化"><a href="#4-最终优化" class="headerlink" title="4. 最终优化"></a>4. 最终优化</h3><ol><li>利用对象的简写方法，将键名和键值同名，从而只写一个名即可</li><li>合并 reducer ，我们可以将多个 reducer文件 写在一个 index 文件当中，需要采用 <code>combineReducers</code> 来合并</li></ol><h3 id="5-项目打包"><a href="#5-项目打包" class="headerlink" title="5. 项目打包"></a>5. 项目打包</h3><p>执行 <code>npm run build</code> 命令，即可打包项目，打包完成后，会生成一个 <code>build</code> 文件，这个文件我们需要部署到服务器上才能运行</p><p>我们可以放在自己的服务器上即可</p><p>但是我遇到了一个问题</p><p>打包后的文件路径少了一个 <code>.</code> 导致文件无法找到，报错无法执行，我通过手动添加的方式解决了，不知道还有没有什么其他方法解决</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-redux-demo.gif" alt="react-redux-demo"></p><blockquote><p>也可以采用 <code>npm i serve -g</code> 安装，如何通过 serve ‘指定文件夹’ 来执行</p></blockquote><br><h2 id="十七-React-扩展"><a href="#十七-React-扩展" class="headerlink" title="十七 React 扩展"></a>十七 React 扩展</h2><h3 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h3><p>学到这里 React 已经学的差不多了，接下来就学习一些 React 扩展内容，可以帮助我们更好的开发和理解，这部分的知识还有很多的东西可以探寻，比如：网红 React-Hook，就是我们需要注意的地方，打了 100 多集的类式组件，出来一个 hooks ，现在用函数式组件偏多了………….</p><p>所以 Hooks 就需要我们深入的学习一下了，下面我们就一起来看看扩展部分有哪些内容吧</p><h3 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h3><h4 id="对象式-setState"><a href="#对象式-setState" class="headerlink" title="对象式 setState"></a>对象式 setState</h4><p>首先在我们以前的认知中，<code>setState</code> 是用来更新状态的，我们一般给它传递一个对象，就像这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: count + <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样每次更新都会让 <code>count</code> 的值加 1。这也是我们最常做的东西</p><p>这里我们做一个案例，点我加 1，一个按钮一个值，我要在控制台输出每次的 <code>count</code> 的值</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo1.gif" alt="react-extension-demo1"></p><p>那我们需要在控制台输出，要如何实现呢？</p><p>我们会考虑在 <code>setState</code> 更新之后 <code>log</code> 一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此可能会写出这样的代码，看起来很合理，在调用完 <code>setState</code> 之后，输出 <code>count</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo1-2.gif" alt="react-extension-demo1-2"></p><p>我们发现显示的 <code>count</code> 和我们控制台输出的 <code>count</code> 值是不一样的</p><p>这是因为，我们调用的 <code>setState</code> 是同步事件，但是它的作用是让 React 去更新数据，而 React 不会立即的去更新数据，这是一个异步的任务，因此我们输出的 <code>count</code> 值会是状态更新之前的数据。“React <strong>状态更新是异步的</strong>”</p><p>那我们要如何实现同步呢？</p><p>其实在 <code>setState</code> 调用的第二个参数，我们可以接收一个函数，这个函数会在状态更新完毕并且界面更新之后调用，我们可以试试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: count + <span class="number">1</span></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 <code>setState</code> 填上第二个参数，输出更新后的 <code>count</code> 值</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo1-3.gif" alt="react-extension-demo1-3"></p><p>这样我们就能成功的获取到最新的数据了，如果有这个需求我们可以在第二个参数输出噢~</p><h4 id="函数式-setState"><a href="#函数式-setState" class="headerlink" title="函数式 setState"></a>函数式 setState</h4><p>这种用法我也是第一次见，函数式的 <code>setState</code> 也是接收两个参数</p><p>第一个参数是 <code>updater</code> ，它是一个能够返回 <code>stateChange</code> 对象的函数</p><p>第二个参数是一个回调函数，用于在状态更新完毕，界面也更新之后调用</p><p>与对象式 <code>setState</code> 不同的是，我们传递的第一个参数 <code>updater</code> 可以接收到2个参数 <code>state</code> 和 <code>props</code></p><p>我们尝试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo2-1.gif" alt="react-extension-demo2-1"></p><p>我们也成功的实现了</p><p>我们在第一个参数中传入了一个函数，这个函数可以接收到 <code>state</code> ，我们通过更新 <code>state</code> 中的 <code>count</code> 值，来驱动页面的更新</p><p>利用函数式 <code>setState</code> 的优势还是很不错的，可以直接获得 <code>state</code> 和 <code>props</code></p><blockquote><p>可以理解为对象式的 <code>setState</code> 是函数式 <code>setState</code> 的语法糖</p></blockquote><h3 id="2-LazyLoad"><a href="#2-LazyLoad" class="headerlink" title="2. LazyLoad"></a>2. LazyLoad</h3><p>懒加载在 React 中用的最多的就是路由组件了，页面刷新时，所有的页面都会重新加载，这并不是我们想要的，我们想要实现点击哪个路由链接再加载即可，这样避免了不必要的加载</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-demo2-2.gif" alt="react-extension-demo2-2"></p><p>我们可以发现，我们页面一加载时，所有的路由组件都会被加载</p><p>如果我们有 100 个路由组件，但是用户只点击了几个，这就会有很大的消耗，因此我们需要做懒加载处理，<strong>我们点击哪个时，才去加载哪一个</strong></p><p>首先我们需要从 <code>react</code> 库中暴露一个 <code>lazy</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> ,lazy&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后我们需要更改引入组件的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Home&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./About&#x27;</span>))</span><br></pre></td></tr></table></figure><p>采用 <code>lazy</code> 函数包裹</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911114307684.png" alt="image-20210911114307684"></p><p>我们会遇到这样的错误，提示我们用一个标签包裹</p><p>这里是因为，当我们网速慢的时候，路由组件就会有可能加载不出来，页面就会白屏，它需要我们来指定一个路由组件加载的东西，相对于 loading</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>loading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在做这个案例的时候，一定不要设置重定向的东西，所有的路由我们要点击再加载</p></blockquote><p>初次登录页面的时候</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911115542647.png" alt="image-20210911115542647"></p><p>注意噢，这些文件都不是路由组件，当我们点击了对应组件之后才会加载</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-lazyload-2.gif" alt="react-extension-lazyload-2"></p><p>从上图我们可以看出，每次点击时，才会去请求 <code>chunk</code> 文件</p><p>那我们更改写的 <code>fallback</code> 有什么用呢？它会在页面还没有加载出来的时候显示</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-lazyload-3.gif" alt="react-extension-lazyload-3"></p><blockquote><p>注意：因为 loading 是作为一个兜底的存在，因此 loading 是 必须提前引入的，不能懒加载</p></blockquote><h3 id="3-Hooks"><a href="#3-Hooks" class="headerlink" title="3. Hooks"></a>3. Hooks</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p><code>hooks</code> 解决了函数式组件和类式组件的差异，让函数式组件拥有了类式组件所拥有的 <code>state</code> ，同时新增了一些 API ，让函数式组件，变得更加的灵活</p><p>首先我们需要明确一点，函数式组件<strong>没有</strong>自己的 <code>this</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count, setCount);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>点我加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Demo</span></span><br></pre></td></tr></table></figure><p>利用函数式组件完成的 <strong>点我加1</strong> 案例</p><p>这里利用了一个 Hook ：<code>useState</code></p><p>它让函数式组件能够维护自己的 <code>state</code> ，它<strong>接收一个参数</strong>，作为<strong>初始化</strong> <code>state</code> 的值，赋值给 <code>count</code>，因此 <code>useState</code> 的初始值只有<strong>第一次有效</strong>，它所映射出的两个变量 <code>count</code> 和 <code>setCount</code> 我们可以理解为 <code>setState</code> 来使用</p><blockquote><p><strong>useState 能够返回一个数组，第一个元素是 state ，第二个是更新 state 的函数</strong></p></blockquote><p>我们先看看控制台输出的什么</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911123011304.png" alt="image-20210911123011304"></p><p><code>count</code> 是初始化的值，而 <code>setCount</code> 就像是一个 <code>action</code> 对象驱动状态更新</p><p>我们可以通过 <code>setCount</code> 来更新 <code>count</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>在类式组件中，提供了一些声明周期钩子给我们使用，我们可以在组件的特殊时期执行特定的事情，例如 <code>componentDidMount</code> ，能够在组件挂载完成后执行一些东西</p><p>在函数式组件中也可以实现，它采用的是 <code>effectHook</code> ，它的语法更加的简单，同时融合了 <code>componentDidUpdata</code> 生命周期，极大的方便了我们的开发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被调用了&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于函数的特性，我们可以在函数中随意的编写函数，这里我们调用了 <code>useEffect</code> 函数，这个函数有多个功能</p><p>当我们像上面代码那样使用时，它相当于 <code>componentDidUpdata</code> 和 <code>componentDidMount</code> 一同使用，也就是在<strong>组件挂载和组件更新</strong>的时候都会调用这个函数</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-hook-1.gif" alt="react-extension-hook-1"></p><p>它还可以接收第二个参数，这个参数表示它要<strong>监测的数据</strong>，也就是他要监视哪个数据的变化</p><p>当我们不需要监听任何状态变化的时候，我们可以就<strong>传递一个空数组</strong>，这样它就能当作 <code>componentMidMount</code> 来使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被调用了&#x27;</span>);</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>这样我们只有在组件第一次挂载的时候触发</p><p>当然当页面中有多个数据源时，我们也可以选择个别的数据进行监测以达到我们想要的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被调用了&#x27;</span>);</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p>这样，我们就只<strong>监视 count 数据的变化</strong></p><p>当我们想要在卸载一个组件之前进行一些<strong>清除定时器</strong>的操作，在类式组件中，我们会调用生命周期钩子 <code>componentDidUnmount</code> 来实现，在函数式组件中，我们的写法更为简单，我们直接在 <code>useEffect</code> 的第一个参数的返回值中实现即可<br>也就是说，第一个参数的函数体相当于 <code>componentDidMount</code> 返回体相当于 <code>componentDidUnmount</code> ，这样我们就能实现在组件即将被卸载时输出一些东西了</p><p><strong>实现卸载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>卸载前输出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被调用了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我要被卸载了&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-extension-hook-2.gif" alt="react-extension-hook-2"></p><p>实现了在组件即将被卸载的时候输出</p><p>因此 <code>useEffect</code> 相当于三个生命周期钩子，<code>componentDidMount</code> 、<code>componentDidUpdata</code> 、<code>componentDidUnmount</code></p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>当我们想要获取组件内的信息时，在类式组件中，我们会采用 <code>ref</code> 的方式来获取。在函数式组件中，我们可以采用也可以采用 <code>ref</code> 但是，我们需要采用 <code>useRef</code> 函数来创建一个 ref 容器，这和 <code>createRef</code> 很类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;myRef&#125; /&gt;</span><br></pre></td></tr></table></figure><p>获取 ref 值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(myRef.<span class="property">current</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可成功的获取到 input 框中的值</p><h3 id="4-Fragment"><a href="#4-Fragment" class="headerlink" title="4. Fragment"></a>4. Fragment</h3><p>我们编写组件的时候每次都需要采用一个 <code>div</code> 标签包裹，才能让它正常的编译，但是这样会引发什么问题呢？我们打开控制台看看它的层级</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911151643934.png" alt="image-20210911151643934"></p><p>它包裹了几层无意义的 div 标签，我们可以采用 <code>Fragment</code> 来解决这个问题</p><p>首先，我们需要从 react 中暴露出 <code>Fragment</code> ，将我们所写的内容采用 <code>Fragment</code> 标签进行包裹，当它解析到 <code>Fragment</code> 标签的时候，就会把它去掉</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911152037120.png" alt="image-20210911152037120"></p><p>这样我们的内容就直接挂在了 <code>root</code> 标签下</p><blockquote><p>同时采用空标签，也能实现，但是它不能接收任何值，而 <code>Fragment</code> 能够接收 1 个值<code>key</code></p></blockquote><h3 id="5-Context"><a href="#5-Context" class="headerlink" title="5. Context"></a>5. Context</h3><h4 id="仅适用于类式组件"><a href="#仅适用于类式组件" class="headerlink" title="仅适用于类式组件"></a>仅适用于类式组件</h4><p>当我们想要给子类的子类传递数据时，前面我们讲过了 redux 的做法，这里介绍的 Context 我觉得也类似于 Redux</p><p>首先我们需要引入一个 <code>MyContext</code> 组件，我们需要引用<code>MyContext</code> 下的 <code>Provider</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span> &#125; = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure><p>用 <code>Provider</code> 标签包裹 A组件内的 B 组件，并通过 <code>value</code> 值，将数据传递给子组件，这样以 A 组件为父代组件的所有子组件都能够接受到数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=&#123;&#123; username, age &#125;&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><p>但是我们需要在使用数据的组件中引入 <code>MyContext</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> contextType = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure><p>在使用时，直接从 <code>this.context</code> 上取值即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;username,age&#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br></pre></td></tr></table></figure><h4 id="适用于函数和类式组件"><a href="#适用于函数和类式组件" class="headerlink" title="适用于函数和类式组件"></a>适用于函数和类式组件</h4><p>由于函数式组件没有自己 <code>this</code> ，所以我们不能通过 <code>this.context</code> 来获取数据</p><p>这里我们需要从 <code>Context</code> 身上暴露出一个 <code>Consumer</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span> ,<span class="title class_">Consumer</span>&#125; = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure><p>然后通过 <code>value</code> 取值即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是C组件，我从A接收到的数据 <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;(value) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return `$&#123;value.username&#125;,年龄是$&#123;value.age&#125;`;</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210911161103300.png" alt="image-20210911161103300"></p><blockquote><p>因此想要在函数式组件中使用，需要引入 <code>Consumer</code></p></blockquote><h3 id="6-PureComponent"><a href="#6-PureComponent" class="headerlink" title="6. PureComponent"></a>6. PureComponent</h3><p>在我们之前一直写的代码中，我们一直使用的<code>Component</code> 是有问题存在的</p><ol><li>只要执行 <code>setState</code> ，即使不改变状态数据，组件也会调用 <code>render</code></li><li>当前组件状态更新，也会引起子组件 <code>render</code></li></ol><p>而我们想要的是只有组件的 <code>state</code> 或者 <code>props</code> 数据发生改变的时候，再调用 <code>render</code></p><p>我们可以采用重写 <code>shouldComponentUpdate</code> 的方法，但是这个方法不能根治这个问题，当状态很多时，我们没有办法增加判断</p><p>我们可以采用 <code>PureComponent</code></p><p>我们可以从 <code>react</code> 身上暴露出 <code>PureComponent</code> 而不使用 <code>Component</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br></pre></td></tr></table></figure><p>就这~听了半天结果就只一个 <code>PureComponent</code></p><p><code>PureComponent</code> 会对比当前对象和下一个状态的 <code>prop</code> 和 <code>state</code> ，而这个比较属于浅比较，比较基本数据类型是否相同，而对于引用数据类型，<strong>比较的是它的引用地址是否相同，这个比较与内容无关</strong></p><h3 id="7-render-props"><a href="#7-render-props" class="headerlink" title="7. render props"></a>7. render props</h3><p>采用 render props 技术，我们可以像组件内部动态传入带有内容的结构</p><blockquote><p>当我们在一个组件标签中填写内容时，这个内容会被定义为 children props，我们可以通过 <code>this.props.children</code> 来获取</p></blockquote><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt;hello&lt;/A&gt;</span><br></pre></td></tr></table></figure><p>这个 hello 我们就可以通过 children 来获取</p><p>而我们所说的 render props 就是在组件标签中传入一个 render 方法，又因为属于 props ，因而被叫做了 render props</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A render=&#123;<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">C</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>你可以把 <code>render</code> 看作是 <code>props</code>，只是它有特殊作用，当然它也可以用其他名字来命名</p><p>在上面的代码中，我们需要在 A 组件中预留出 C 组件渲染的位置 在需要的位置上加上<code>&#123;this.props.render(name)&#125;</code></p><p>那我们在 C 组件中，如何接收 A 组件传递的 <code>name</code> 值呢？通过 <code>this.props.name</code> 的方式</p><h3 id="8-ErrorBoundary"><a href="#8-ErrorBoundary" class="headerlink" title="8. ErrorBoundary"></a>8. ErrorBoundary</h3><p>当不可控因素导致数据不正常时，我们不能直接将报错页面呈现在用户的面前，由于我们没有办法给每一个组件、每一个文件添加判断，来确保正常运行，这样很不现实，因此我们要用到<strong>错误边界</strong>技术</p><p><strong>错误边界就是让这块组件报错的影响降到最小，不要影响到其他组件或者全局的正常运行</strong></p><blockquote><p>例如 A 组件报错了，我们可以在 A 组件内添加一小段的提示，并把错误控制在 A 组件内，不影响其他组件</p></blockquote><ul><li>我们要对容易出错的组件的父组件做手脚，而不是组件本身</li></ul><p>我们在父组件中通过 <code>getDerivedStateFromError</code> 来配置<strong>子组件</strong>出错时的处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: error &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将 <code>hasError</code> 配置到状态当中，当 <code>hasError</code> 状态改变成 <code>error</code> 时，表明有错误发生，我们需要在组件中通过判断 <code>hasError</code> 值，来指定是否显示子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>出错啦<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在服务器中启动，才能正常看到效果</p></blockquote><p>可以在 <code>componentDidCatch</code> 中统计错误次数，通知编码人员进行 bug 解决</p><h3 id="9-组件通信方式总结"><a href="#9-组件通信方式总结" class="headerlink" title="9. 组件通信方式总结"></a>9. 组件通信方式总结</h3><ol><li>props<ul><li>children props</li><li>render props</li></ul></li><li>消息发布订阅<ul><li>利用 pubsub 库来实现</li></ul></li><li>集中式状态管理<ul><li>redux</li></ul></li><li>conText<ul><li>生成者-消费者</li></ul></li></ol><p><strong>选择方式</strong></p><p>父子组件采用：<code>props</code></p><p>兄弟组件采用：消息的发布订阅、redux</p><p>祖孙组件：消息发布订阅、redux、context</p><br><h2 id="十八-React核心-–-React-Hooks"><a href="#十八-React核心-–-React-Hooks" class="headerlink" title="十八 React核心 – React-Hooks"></a>十八 React核心 – React-Hooks</h2><h3 id="hooks-存在的意义"><a href="#hooks-存在的意义" class="headerlink" title="hooks 存在的意义"></a>hooks 存在的意义</h3><ol><li><p>hooks 之间的状态是独立的，有自己独立的上下文，不会出现混淆状态的情况</p></li><li><p>让函数有了状态管理</p></li><li><p>解决了 组件树不直观、类组件难维护、逻辑不易复用的问题</p></li><li><p>避免函数重复执行的副作用</p></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>利用 hooks 取代生命周期函数</li><li>让组件有了状态</li><li>组件辅助函数</li><li>处理发送请求</li><li>存取数据</li><li>做好性能优化</li></ol><h3 id="hooks-API"><a href="#hooks-API" class="headerlink" title="hooks API"></a>hooks API</h3><p>从 <code>react</code> 中引入</p><h4 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h4><p>给函数组件添加状态</p><ul><li>初始化以及更新组件状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>接收一个参数作为初始值，返回一个数组：第一个是状态变量，第二个是修改变量的函数</p><h4 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h4><p>副作用 hooks</p><ul><li>给没有生命周期的组件，添加结束渲染的信号</li></ul><p>注意：</p><ul><li>render 之后执行的 hooks</li></ul><p>第一个参数接收一个函数，在组件更新的时候执行</p><p>第二个参数接收一个数组，用来表示需要追踪的变量，依赖列表，只有依赖更新的时候才会更新内容</p><p>第一个参数的返回值，返回一个函数，在 <code>useEffect</code> 执行之前，都会先执行里面返回的函数</p><p>一般用于添加销毁事件，这样就能保证只添加一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被调用了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我要被卸载了&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p>打印</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210914172936843.png" alt="image-20210914172936843"></p><h4 id="3-useLayoutEffect"><a href="#3-useLayoutEffect" class="headerlink" title="3. useLayoutEffect"></a>3. useLayoutEffect</h4><p>和 <code>useEffect</code> 很类似</p><p>它的作用是：在 DOM 更新完成之后执行某个操作</p><p>注意：</p><ul><li>有 DOM 操作的副作用 hooks</li><li>在 DOM 更新之后执行</li></ul><blockquote><p>执行时机在 <code>useEffect</code> 之前，其他都和 <code>useEffect</code> 都相同</p></blockquote><p><code>useEffect</code> 执行时机在 <strong>render 之后</strong></p><p><code>useLayoutEffect</code> 执行时机在 <strong>DOM 更新之后</strong></p><h4 id="4-useMemo"><a href="#4-useMemo" class="headerlink" title="4. useMemo"></a>4. useMemo</h4><p>作用：让组件中的函数跟随状态更新</p><p>注意：优化函数组件中的功能函数</p><p><strong>为了避免由于其他状态更新导致的当前函数的被迫执行</strong></p><p>第一个参数接收一个函数，第二个参数为数组的依赖列表，返回一个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDoubleNum = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * num</span><br><span class="line">&#125;, [num])</span><br></pre></td></tr></table></figure><h4 id="5-useCallback"><a href="#5-useCallback" class="headerlink" title="5. useCallback"></a>5. useCallback</h4><p>作用：跟随状态更新执行</p><p>注意：</p><ul><li>只有依赖项改变时才执行</li><li><code>useMemo( () =&gt; fn, deps)</code> 相当于 <code>useCallback(fn, deps)</code></li></ul><p>不同点：</p><ol><li><code>useCallback</code> <strong>返回的是一个函数，不再是值</strong></li><li><code>useCallback</code> 缓存的是一个函数，<code>useMemo</code> 缓存的是一个值，<strong>如果依赖不更新，返回的永远是缓存的那个函数</strong></li><li>给子组件中传递 <code>props</code> 的时候，如果当前组件不更新，不会触发子组件的重新渲染</li></ol><h4 id="6-useRef"><a href="#6-useRef" class="headerlink" title="6. useRef"></a>6. useRef</h4><p>作用：长久保存数据</p><p>注意事项：</p><ul><li>返回一个子元素索引，这个索引在整个生命周期中保持不变</li><li>对象发生改变时，不通知，属性变更不重新渲染</li></ul><ol><li>保存一个值，在整个生命周期中维持不变</li><li>重新赋值 <code>ref.current</code> 不会触发重新渲染</li><li>相当于<strong>创建一个额外的容器来存储数据</strong>，我们可以在外部拿到这个值</li></ol><p>当我们通过正常的方式去获取计时器的 <code>id</code> 是无法获取的，需要通过 <code>ref</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.<span class="property">current</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setNum</span>(<span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">400</span>)</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;到十了&#x27;</span>);</span><br><span class="line">        <span class="built_in">clearInterval</span>(ref.<span class="property">current</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [num])</span><br></pre></td></tr></table></figure><h4 id="7-useContext"><a href="#7-useContext" class="headerlink" title="7. useContext"></a>7. useContext</h4><p>作用：带着子组件渲染</p><p>注意：</p><ul><li>上层数据发生改变，肯定会触发重新渲染</li></ul><ol><li>我们需要引入 <code>useContext</code> 和 <code>createContext</code> 两个内容</li><li>通过 <code>createContext</code> 创建一个 <code>Context</code> 句柄</li><li>通过 <code>Provider</code> 确定数据共享范围</li><li>通过 <code>value</code> 来分发数据</li><li>在子组件中，通过 <code>useContext</code> 来获取数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Hook</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [num, setNum] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            这是一个函数组件 - &#123;num&#125;</span></span><br><span class="line"><span class="language-xml">        // 确定范围</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;num&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Item1</span> <span class="attr">num</span>=<span class="string">&#123;num&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Item2</span> <span class="attr">num</span>=<span class="string">&#123;num&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Item1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件1  &#123;num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Item2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件2 &#123;num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-useReducer"><a href="#8-useReducer" class="headerlink" title="8. useReducer"></a>8. useReducer</h4><p>作用：去其他地方借资源</p><p>注意：函数组件的 Redux 的操作</p><ol><li>创建数据仓库 <code>store</code> 和管理者 <code>reducer</code></li><li>通过 <code>useReducer(store,dispatch)</code> 来获取 <code>state</code> 和 <code>dispatch</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, store)</span><br></pre></td></tr></table></figure><p>通过 <code>dispatch</code> 去派发 <code>action</code></p><h4 id="9-自定义-hooks"><a href="#9-自定义-hooks" class="headerlink" title="9. 自定义 hooks"></a>9. 自定义 hooks</h4><p>放在 <code>utils</code> 文件夹中，以 <code>use</code> 开头命名</p><p>例如：模拟数据请求的 Hooks</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useLoadData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setNum</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> [num, setNum];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useLoadData;</span><br></pre></td></tr></table></figure><p>减少代码耦合</p><p>我们希望 reducer 能让每个组件来使用，我们自己写一个 hooks</p><p>自定义一个自己的 LocalReducer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> store = &#123; <span class="attr">num</span>: <span class="number">1210</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;num&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">num</span>: action.<span class="property">num</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useLocalReducer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, store);</span><br><span class="line">  <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useLocalReducer;</span><br></pre></td></tr></table></figure><ol><li>引入 react 和自己需要的 hook</li><li>创建自己的hook函数</li><li>返回一个数组，数组中第一个内容是数据，第二个是修改数据的函数</li><li>暴露自定义 hook 函数出去</li><li>引入自己的业务组件</li></ol><br><br><br><br><h2 id="九九九、小问题"><a href="#九九九、小问题" class="headerlink" title="九九九、小问题"></a>九九九、小问题</h2><h3 id="1-ES6引入的形式问题"><a href="#1-ES6引入的形式问题" class="headerlink" title="1 ES6引入的形式问题"></a>1 ES6引入的形式问题</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种是在源文件中采用了默认暴露的方式：export default App</span></span><br><span class="line"><span class="comment">// 第二种是在源文件中采用了一般暴露的方式：export class Component</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span>     <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> extend <span class="title class_">Component</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入文件，只有后缀为 <code>js</code> 或 <code>jsx</code> 的文件才能省略后缀。</p><br><h3 id="2-VSCode的React插件"><a href="#2-VSCode的React插件" class="headerlink" title="2 VSCode的React插件"></a>2 VSCode的React插件</h3><p>**ES7 React/Redux/…**：支持代码片段：rcc rfc</p><br><br><br><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Moustache 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Moustache</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://hammerzer.github.io/2021/01/13/React-start/" title="React-起步">https://hammerzer.github.io/2021/01/13/React-start/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/" rel="tag"><i class="fa fa-tag"></i> 框架与工具</a> <a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/01/08/H5-application-cache/" rel="prev" title="H5离线缓存"><i class="fa fa-chevron-left"></i> H5离线缓存</a></div><div class="post-nav-item"><a href="/2023/01/09/java-base-1/" rel="next" title="Java基础语法及常见问题一">Java基础语法及常见问题一 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CONTENT-OUTLINE"><span class="nav-number">1.</span> <span class="nav-text">CONTENT OUTLINE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%87%E3%80%81React%E8%B5%B7%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text">〇、React起步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8-React-%E7%9A%84%E5%8E%9F%E5%9B%A0-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E7%90%86%E7%94%B1"><span class="nav-number">2.1.</span> <span class="nav-text">1、使用 React 的原因&#x2F;技术选型理由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Quick-Start"><span class="nav-number">2.2.</span> <span class="nav-text">2、Quick Start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81JSX%E6%8C%87%E5%BC%95"><span class="nav-number">2.3.</span> <span class="nav-text">3、JSX指引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B0%9A%E7%A1%85%E8%B0%B7React%E5%85%A8%E5%AE%B6%E6%A1%B6%E7%AC%94%E8%AE%B0"><span class="nav-number">3.</span> <span class="nav-text">一、尚硅谷React全家桶笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#001%E3%80%81React-%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">001、React 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#002%E3%80%81Hello-react"><span class="nav-number">3.2.</span> <span class="nav-text">002、Hello_react</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#003%E3%80%81%E8%99%9A%E6%8B%9F-DOM-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">003、虚拟 DOM 创建方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F-DOM"><span class="nav-number">3.3.1.</span> <span class="nav-text">1 创建虚拟 DOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%9C%9F%E5%AE%9EDOM%E4%B8%8E%E8%99%9A%E6%8B%9FDOM%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.2.</span> <span class="nav-text">2 真实DOM与虚拟DOM区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#004%E3%80%81JSX-%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">3.4.</span> <span class="nav-text">004、JSX 语法规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B3%A8%E9%87%8A"><span class="nav-number">3.4.1.</span> <span class="nav-text">1 注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B0%E7%BB%84"><span class="nav-number">3.4.2.</span> <span class="nav-text">2. 数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tip-JSX-%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="nav-number">3.4.3.</span> <span class="nav-text">tip: JSX 小练习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">二、面向组件编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">1 组件的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.1 函数式组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">4.1.2.</span> <span class="nav-text">1.2 类式组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">1.3 其他知识</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text">2 组件实例三大属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-state"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.1 state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-props"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2 props</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-refs"><span class="nav-number">4.2.3.</span> <span class="nav-text">2.3 refs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8Frefs"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">1 字符串形式refs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9B%9E%E8%B0%83%E5%BD%A2%E5%BC%8F%E7%9A%84refs"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">2 回调形式的refs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-createRef-%E5%BD%A2%E5%BC%8F%EF%BC%88%E6%8E%A8%E8%8D%90%E5%86%99%E6%B3%95%EF%BC%89"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">3 createRef 形式（推荐写法）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">4.2.4.</span> <span class="nav-text">2.4 事件处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.</span> <span class="nav-text">3 收集表单数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">5 高阶函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.</span> <span class="nav-text">三、React 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-number">5.1.</span> <span class="nav-text">初始化阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-constructor-%E6%89%A7%E8%A1%8C"><span class="nav-number">5.1.1.</span> <span class="nav-text">1. constructor 执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-static-getDerivedStateFromProps-%E6%89%A7%E8%A1%8C-%EF%BC%88%E6%96%B0%E9%92%A9%E5%AD%90%EF%BC%89"><span class="nav-number">5.1.2.</span> <span class="nav-text">2. static getDerivedStateFromProps 执行 （新钩子）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-componentWillMount-%E6%89%A7%E8%A1%8C%EF%BC%88%E5%8D%B3%E5%B0%86%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="nav-number">5.1.3.</span> <span class="nav-text">2. componentWillMount 执行（即将废弃）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-render-%E6%89%A7%E8%A1%8C"><span class="nav-number">5.1.4.</span> <span class="nav-text">3. render 执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-componentDidMount-%E6%89%A7%E8%A1%8C"><span class="nav-number">5.1.5.</span> <span class="nav-text">4. componentDidMount 执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.6.</span> <span class="nav-text">初始化阶段总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">5.2.</span> <span class="nav-text">更新阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="nav-number">5.3.</span> <span class="nav-text">销毁阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81diff%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">四、diff算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%AE%A4%E8%AF%86%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="nav-number">7.</span> <span class="nav-text">五、认识脚手架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85-React-%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="nav-number">7.1.</span> <span class="nav-text">1. 安装 React 脚手架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.2.</span> <span class="nav-text">2. 脚手架项目结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8A%9F%E8%83%BD%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">3 功能界面的组件化编码流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81TodoList-%E6%A1%88%E4%BE%8B"><span class="nav-number">8.</span> <span class="nav-text">六、TodoList 案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text">一、拆分组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">8.2.</span> <span class="nav-text">二、实现静态组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">8.3.</span> <span class="nav-text">三、实现动态组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%8E-1-%E5%8A%A8%E6%80%81%E5%B1%95%E7%A4%BA%E5%88%97%E8%A1%A8"><span class="nav-number">8.3.1.</span> <span class="nav-text">🍎 1. 动态展示列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%8D-2-%E6%B7%BB%E5%8A%A0%E4%BA%8B%E9%A1%B9%E5%8A%9F%E8%83%BD"><span class="nav-number">8.3.2.</span> <span class="nav-text">🍍 2. 添加事项功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%8B-3-%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%95%88%E6%9E%9C"><span class="nav-number">8.3.3.</span> <span class="nav-text">🍋 3. 实现鼠标悬浮效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%89-4-%E5%A4%8D%E9%80%89%E6%A1%86%E7%8A%B6%E6%80%81%E7%BB%B4%E6%8A%A4"><span class="nav-number">8.3.4.</span> <span class="nav-text">🍉 4. 复选框状态维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%8F-5-%E9%99%90%E5%88%B6%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.3.5.</span> <span class="nav-text">🍏 5. 限制参数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%92-6-%E5%88%A0%E9%99%A4%E6%8C%89%E9%92%AE"><span class="nav-number">8.3.6.</span> <span class="nav-text">🍒 6. 删除按钮</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%93-7-%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%88%90%E6%95%B0%E9%87%8F"><span class="nav-number">8.3.7.</span> <span class="nav-text">🍓 7. 获取完成数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%8D%8A-8-%E5%85%A8%E9%80%89%E6%8C%89%E9%92%AE"><span class="nav-number">8.3.8.</span> <span class="nav-text">🍊 8. 全选按钮</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A5%AD-9-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AE%8C%E6%88%90"><span class="nav-number">8.3.9.</span> <span class="nav-text">🥭 9. 删除已完成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">8.3.10.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">七、脚手架配置代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ajax"><span class="nav-number">9.1.</span> <span class="nav-text">1 ajax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">9.2.</span> <span class="nav-text">2 跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86"><span class="nav-number">9.2.1.</span> <span class="nav-text">2.1 全局代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%8D%95%E7%8B%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">9.2.2.</span> <span class="nav-text">2.2 单独配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81GitHub-%E6%90%9C%E7%B4%A2%E6%A1%88%E4%BE%8B"><span class="nav-number">10.</span> <span class="nav-text">八、GitHub 搜索案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">10.1.</span> <span class="nav-text">1 实现静态组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-axios-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-number">10.2.</span> <span class="nav-text">2 axios 发送请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE"><span class="nav-number">10.3.</span> <span class="nav-text">3 渲染数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A2%9E%E5%8A%A0%E4%BA%A4%E4%BA%92"><span class="nav-number">10.4.</span> <span class="nav-text">4 增加交互</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-number">11.</span> <span class="nav-text">九、消息发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PubSub"><span class="nav-number">11.1.</span> <span class="nav-text">PubSub</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-%E2%80%93-Fetch"><span class="nav-number">11.2.</span> <span class="nav-text">扩展 – Fetch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81React-%E8%B7%AF%E7%94%B1"><span class="nav-number">12.</span> <span class="nav-text">十、React 路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%95-1-SPA"><span class="nav-number">12.1.</span> <span class="nav-text">🍕 1. SPA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%94-2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="nav-number">12.2.</span> <span class="nav-text">🍔 2. 什么是路由？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%94%B1"><span class="nav-number">12.2.1.</span> <span class="nav-text">后端路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1"><span class="nav-number">12.2.2.</span> <span class="nav-text">前端路由</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%9F-3-%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">12.3.</span> <span class="nav-text">🍟 3. 路由的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8C%AD-4-%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">12.4.</span> <span class="nav-text">🌭 4. 路由的基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#react-router-dom-%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">12.4.1.</span> <span class="nav-text">react-router-dom 的理解和使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%BF-5-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%92%8C%E4%B8%80%E8%88%AC%E7%BB%84%E4%BB%B6"><span class="nav-number">12.5.</span> <span class="nav-text">🍿 5. 路由组件和一般组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%9B-6-NavLink-%E6%A0%87%E7%AD%BE"><span class="nav-number">12.6.</span> <span class="nav-text">🍛 6. NavLink 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%A5%A9-7-NavLink-%E5%B0%81%E8%A3%85"><span class="nav-number">12.7.</span> <span class="nav-text">🥩 7. NavLink 封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%88-8-Switch-%E8%A7%A3%E5%86%B3%E7%9B%B8%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">12.8.</span> <span class="nav-text">🍈 8. Switch 解决相同路径问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%A5%9F-9-%E8%A7%A3%E5%86%B3%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1%E6%A0%B7%E5%BC%8F%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">12.9.</span> <span class="nav-text">🥟 9. 解决二级路由样式丢失的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%91-10-%E8%B7%AF%E7%94%B1%E7%9A%84%E7%B2%BE%E5%87%86%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D"><span class="nav-number">12.10.</span> <span class="nav-text">🍑 10. 路由的精准匹配和模糊匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%8B-11-%E9%87%8D%E5%AE%9A%E5%90%91%E8%B7%AF%E7%94%B1"><span class="nav-number">12.11.</span> <span class="nav-text">🍋 11. 重定向路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%93-12-%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1"><span class="nav-number">12.12.</span> <span class="nav-text">🍓 12. 嵌套路由</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81React-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="nav-number">13.</span> <span class="nav-text">十一、React 路由传参</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%9F-1-%E4%BC%A0%E9%80%92-params-%E5%8F%82%E6%95%B0"><span class="nav-number">13.1.</span> <span class="nav-text">🍟 1. 传递 params 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8D%80-2-%E4%BC%A0%E9%80%92-search-%E5%8F%82%E6%95%B0"><span class="nav-number">13.2.</span> <span class="nav-text">🍀 2. 传递 search 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8C%B7-3-%E4%BC%A0%E9%80%92-state-%E5%8F%82%E6%95%B0"><span class="nav-number">13.3.</span> <span class="nav-text">🌷 3. 传递 state 参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81React-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="nav-number">14.</span> <span class="nav-text">十二、React 路由跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-push-%E4%B8%8E-replace-%E6%A8%A1%E5%BC%8F"><span class="nav-number">14.1.</span> <span class="nav-text">1. push 与 replace 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA"><span class="nav-number">14.2.</span> <span class="nav-text">2. 编程式路由导航</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-withRouter"><span class="nav-number">14.3.</span> <span class="nav-text">3. withRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-BrowserRouter-%E5%92%8C-HashRouter-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.4.</span> <span class="nav-text">4. BrowserRouter 和 HashRouter 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%80"><span class="nav-number">14.4.1.</span> <span class="nav-text">区别一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%BA%8C"><span class="nav-number">14.4.2.</span> <span class="nav-text">区别二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%89"><span class="nav-number">14.4.3.</span> <span class="nav-text">区别三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">14.4.4.</span> <span class="nav-text">备注</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81antd-%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">十三、antd 组件库的基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">15.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Antd-%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">15.2.</span> <span class="nav-text">1. Antd 组件基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="nav-number">15.2.1.</span> <span class="nav-text">第一步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5"><span class="nav-number">15.2.2.</span> <span class="nav-text">第二步：按需引入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2"><span class="nav-number">15.3.</span> <span class="nav-text">2. 自定义主题颜色</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81Redux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">16.</span> <span class="nav-text">十四、Redux基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-1"><span class="nav-number">16.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8-Redux"><span class="nav-number">16.2.</span> <span class="nav-text">1. 什么情况使用 Redux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Redux-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">16.3.</span> <span class="nav-text">2. Redux 的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Redux-%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">16.4.</span> <span class="nav-text">3. Redux 三个核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-store"><span class="nav-number">16.4.1.</span> <span class="nav-text">1. store</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-action"><span class="nav-number">16.4.2.</span> <span class="nav-text">2. action</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-reducer"><span class="nav-number">16.4.3.</span> <span class="nav-text">3. reducer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%9B%E5%BB%BA-constant-%E6%96%87%E4%BB%B6"><span class="nav-number">16.5.</span> <span class="nav-text">4. 创建 constant 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5-action"><span class="nav-number">16.6.</span> <span class="nav-text">5. 实现异步 action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Redux-%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">16.7.</span> <span class="nav-text">6. Redux 三大原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="nav-number">16.7.1.</span> <span class="nav-text">第一个原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="nav-number">16.7.2.</span> <span class="nav-text">第二个原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="nav-number">16.7.3.</span> <span class="nav-text">第三个原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%94-React-Redux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">17.</span> <span class="nav-text">十五 React-Redux 基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E5%92%8C-UI-%E7%BB%84%E4%BB%B6"><span class="nav-number">17.1.</span> <span class="nav-text">容器组件和 UI 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mapStateToProps"><span class="nav-number">17.1.1.</span> <span class="nav-text">mapStateToProps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mapDispatchToProps"><span class="nav-number">17.1.2.</span> <span class="nav-text">mapDispatchToProps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="nav-number">17.1.3.</span> <span class="nav-text">第一步优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Provider%E3%80%90API%E4%BC%98%E5%8C%96%E3%80%91"><span class="nav-number">17.1.4.</span> <span class="nav-text">Provider【API优化】</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91%E3%80%90%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%E3%80%91"><span class="nav-number">17.2.</span> <span class="nav-text">完整开发【文件结构优化】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">17.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AD-React-Redux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">18.</span> <span class="nav-text">十六 React-Redux 基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-2"><span class="nav-number">18.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BC%96%E5%86%99-Person-%E7%BB%84%E4%BB%B6"><span class="nav-number">18.2.</span> <span class="nav-text">1. 编写 Person 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99-UI-%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">18.2.1.</span> <span class="nav-text">编写 UI 组件架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="nav-number">18.2.2.</span> <span class="nav-text">编写点击事件回调</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%8C%E6%9A%B4%E9%9C%B2"><span class="nav-number">18.2.2.1.</span> <span class="nav-text">下载，引入，暴露</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">18.2.3.</span> <span class="nav-text">状态管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">18.2.4.</span> <span class="nav-text">我是如何理解的呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99-reducer"><span class="nav-number">18.3.</span> <span class="nav-text">2. 编写 reducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%89%93%E9%80%9A%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-number">18.4.</span> <span class="nav-text">3. 打通数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%80%E7%BB%88%E4%BC%98%E5%8C%96"><span class="nav-number">18.5.</span> <span class="nav-text">4. 最终优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85"><span class="nav-number">18.6.</span> <span class="nav-text">5. 项目打包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%83-React-%E6%89%A9%E5%B1%95"><span class="nav-number">19.</span> <span class="nav-text">十七 React 扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-3"><span class="nav-number">19.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-setState"><span class="nav-number">19.2.</span> <span class="nav-text">1. setState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%8F-setState"><span class="nav-number">19.2.1.</span> <span class="nav-text">对象式 setState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F-setState"><span class="nav-number">19.2.2.</span> <span class="nav-text">函数式 setState</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-LazyLoad"><span class="nav-number">19.3.</span> <span class="nav-text">2. LazyLoad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Hooks"><span class="nav-number">19.4.</span> <span class="nav-text">3. Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useState"><span class="nav-number">19.4.1.</span> <span class="nav-text">useState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useEffect"><span class="nav-number">19.4.2.</span> <span class="nav-text">useEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useRef"><span class="nav-number">19.4.3.</span> <span class="nav-text">useRef</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Fragment"><span class="nav-number">19.5.</span> <span class="nav-text">4. Fragment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Context"><span class="nav-number">19.6.</span> <span class="nav-text">5. Context</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%85%E9%80%82%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">19.6.1.</span> <span class="nav-text">仅适用于类式组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">19.6.2.</span> <span class="nav-text">适用于函数和类式组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-PureComponent"><span class="nav-number">19.7.</span> <span class="nav-text">6. PureComponent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-render-props"><span class="nav-number">19.8.</span> <span class="nav-text">7. render props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-ErrorBoundary"><span class="nav-number">19.9.</span> <span class="nav-text">8. ErrorBoundary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">19.10.</span> <span class="nav-text">9. 组件通信方式总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AB-React%E6%A0%B8%E5%BF%83-%E2%80%93-React-Hooks"><span class="nav-number">20.</span> <span class="nav-text">十八 React核心 – React-Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hooks-%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">20.1.</span> <span class="nav-text">hooks 存在的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">20.2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hooks-API"><span class="nav-number">20.3.</span> <span class="nav-text">hooks API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useState"><span class="nav-number">20.3.1.</span> <span class="nav-text">1. useState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useEffect"><span class="nav-number">20.3.2.</span> <span class="nav-text">2. useEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-useLayoutEffect"><span class="nav-number">20.3.3.</span> <span class="nav-text">3. useLayoutEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-useMemo"><span class="nav-number">20.3.4.</span> <span class="nav-text">4. useMemo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-useCallback"><span class="nav-number">20.3.5.</span> <span class="nav-text">5. useCallback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-useRef"><span class="nav-number">20.3.6.</span> <span class="nav-text">6. useRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-useContext"><span class="nav-number">20.3.7.</span> <span class="nav-text">7. useContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-useReducer"><span class="nav-number">20.3.8.</span> <span class="nav-text">8. useReducer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E8%87%AA%E5%AE%9A%E4%B9%89-hooks"><span class="nav-number">20.3.9.</span> <span class="nav-text">9. 自定义 hooks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E4%B9%9D%E4%B9%9D%E3%80%81%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="nav-number">21.</span> <span class="nav-text">九九九、小问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ES6%E5%BC%95%E5%85%A5%E7%9A%84%E5%BD%A2%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">21.1.</span> <span class="nav-text">1 ES6引入的形式问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-VSCode%E7%9A%84React%E6%8F%92%E4%BB%B6"><span class="nav-number">21.2.</span> <span class="nav-text">2 VSCode的React插件</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Moustache" src="/images/180-180.png"><p class="site-author-name" itemprop="name">Moustache</p><div class="site-description" itemprop="description">我是小胡子</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">79</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/hammerzer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hammerzer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:stellar_lzu@163.com" title="E-Mail → mailto:stellar_lzu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Chase</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">1.9m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">29:30</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script size="300" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JRehDoQ6pHXV1zKg09AMNLFt-gzGzoHsz',
      appKey     : 'cRAt4W15KiQdrIuHlQrRrtIl',
      placeholder: "Just go go",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>