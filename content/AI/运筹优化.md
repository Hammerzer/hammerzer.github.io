---
title: 运筹优化
description: 运筹优化知识笔记，涵盖核心原理、算法与实际应用思路。
urlname: Operations-Research-Optimization
date: 2025-09-27
tags:
  - 算法
  - 优化问题
categories:
  - AI
draft:
---

> [!note]
> 
> - `Gurobi`求解器
> - `Gurobi`优化求解器使用手册完整版
> - 岗位JD
> 

# 一 `Gurobi`求解器

## 1 入门操作

一般来说，求解一个数学规划模型的时候，通常会按照如下步骤解决问题:

1. 设置变量：`addVar()`
2. 更新变量空间：`update()`
3. 设定目标函数：`setObjective()`
4. 设定约束条件：`addConstr()`
5. 执行最优化：`optimize()`

**创建模型：**

```python
import gurobipy
model = gurobipy.Model('LP模型测试1')  # 创建一个模型
```

**(1) 设置决策变量**

一次创建一个变量:

```python
x = model.addVar(lb=0.0, ub=gurobipy.GRB.INFINITY, vtype=gurobipy.GRB.CONTINUOUS, name="")
# lb=0.0:变量的下界，默认为0.0。       					lower bound
# ub=gurobipy.GRB.INFINITY:变量的上界，默认为无穷大。   	   upper bound
# vtype=gurobipy.GRB.CONTINUOUS:变量的类型，默认为连续型号。变为GRB.BINARY则是0-1变量，变为GRB.INTEGER则为整数变量。 
# name="":变量名，默认为空。 
```

一次创建多个变量:

```python
x = model.addVars(*indexes, lb=0, ub=gurobipy.GRB.INFINITY, vtype=gurobipy.GRB.CONTINUOUS, name="")

# 示例:次性生成3x4x5个变量。x包含了3x4x5个变量，可以通过x[i,j,k]来访问单个的变量。
x = model.addVars(3, 4, 5, vtype=gurobipy.GRB.BINARY, name="C")
```

**(2)更新变量空间**

```python
model.update()
```

**(3)设定目标函数**

单目标优化：

```python
model.setObjective(expression,sense=None)
# expression:表达式，可以是一次或者二次函数的类型。 
# sense:求解类型，GRB.MINIMIZE则为最小值，GRB.MAXMIZE则为最大值。
#示例：
model.setObjective(8 * x1 + 10 * x2 + 7 * x3 + 6 * x4 + 11 * x5 + 9 * x6, gurobipy.GRB.MINIMIZE)
```

多目标优化代码：

```python
model.setObjectiveN(expression, index, priority=0, weight=1.0, abstol=0, reltol=0, name="")

#示例：
# expression:表达式，可以是一次或者二次函数类型。 
# index:目标函数对应的序号(默认0,1,2,...),以index=0作为目标函数的值,其余值需要另外设置参数。 
# priority:分层序列法多目标决策的优先级，值越大优先级越高。 
# weight:线性加权多目标决策权重(在优先级相同的时候发挥作用)。 
# abstol:分层序列法多目标决策时允许的目标函数值的最大降低量。 
# reltol:分层序列法多目标决策时允许的目标函数值的最大降低比率。
```

**(4)添加约束条件：**

创建一个约束条件

```python
model.addConstr(expression, name="")
# expression: 布尔表达式，可以是一次或二次函数类型
# name: 约束式的名称 

# 示例：
model.addConstr(12 * x1 + 9 * x2 + 25 * x3 + 20 * x4 + 17 * x5 + 13 * x6 >= 60, "c0")
```

创建多个约束条件：

```python
model.addConstrs(expressions, name="")
```

创建一个指示变量约束：

```python
model.addGenConstrIndicator(binvar, binval, expression, name="")
# 指示变量 binvar 的值取 binval 时, 进行约束 expression 

# 或者 
# 方法1: 构造指示变量，则上述约束转化为: (M是一个很大的数，可以取1000)
# 方法2:转化为二次约束，但是如果矩阵为非正定矩阵，则无法求解:
```

**(5)执行最优化**

```python
model.Params.LogToConsole=True # 显示求解过程
model.Params.MIPGap=0.0001 # 百分比界差
model.Params.TimeLimit=100 # 限制求解时间为 100s
model.Params.Presolve = -1 # 预处理程度, 0关闭,1保守,2激进
model.Params.MIPFocus = 0 # 求解侧重点. 1快速找到可行解, 2证明最有, 3侧重边界提升, 0均衡搜索
model.Params.SolutionLimit = inf # 求解数量, 默认求所有解, 比较出最优的结果, 只需要可行解时可以设置该参数为1
model.Params.NonConvex = 1  # 默认求解器，改为 2 时可以解决非凸二次优化问题

model.optimize()
```

**(6)查看模型优化结果**

查看函数值以及变量值：

```python
# 查看单目标规划模型的目标函数值
print("Optimal Objective Value", model.objVal)  
# 查看多目标规划模型的目标函数值
for i in range(model.NumObj):
  MODEL.setParam(gurobipy.GRB.Param.ObjNumber, i)
  print(f"Obj {i+1} = {model.ObjNVal}")  
# 查看变量取值
for var in model.getVars():
   print(f"{var.varName}: {round(var.X, 3)}")
```

**(7)辅助函数**

quicksum相当于sum及其求和符号，效率更高。

```python
for i in I:
    model.addConstr(quicksum(x[i,j] for j in J) <= 5)
```

此外，它还支持迭代器、生成器协议，也就是说，可以通过下面的代码，实现更为复杂的过滤、求和方法。

```python
for c in C:
  model.addConstr(gurobipy.quicksum(x[d,i,j] for d in D for i in range(0, 24) for j in range(i + 1, 25) if i <= c < j) >= R[c])
```





<br>



# 二 [Gurobi优化求解器使用手册完整版](https://blog.csdn.net/weixin_42601547/article/details/148546331?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-148546331-blog-132745408.235^v43^pc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

## 1 线性规划、混合整数规划、二次规划和数学优化问题的基础

### 1.1 优化问题的基本概念

在运筹学和应用数学领域，线性规划（Linear Programming, LP）、混合整数规划（Mixed Integer Programming, MIP）、二次规划（Quadratic Programming, QP）是常见的数学优化问题形式。

- 线性规划主要涉及线性目标函数和线性约束条件；
- 而混合整数规划则在此基础上加入整数和二进制变量的约束，增加了问题的复杂性和实用性。
- 二次规划则涉及到目标函数为二次函数的情况，这类问题在经济学、工程学和数据科学等领域有广泛应用。

### 1.2 优化问题的分类与应用场景

- 线性规划适用于资源分配、产品混合优化等场景；
- 混合整数规划扩展了线性规划，适用于设备更新、生产计划等问题，在IT行业中也广泛应用于任务调度、网络设计等领域；
- 二次规划则通常用于金融投资组合优化、机器学习中的正则化问题等。这些优化问题的解决能够显著提升业务流程的效率和资源的优化配置。

### 1.3 求解方法简介

对于这些数学优化问题，存在多种求解方法，例如单纯形法（Simplex Method）、内点法（Interior-Point Method）等，以及分支定界法（Branch and Bound）等用于混合整数规划的算法。

随着计算能力的增强和算法的发展，优化问题的求解速度和规模都有了极大的提升。对于更复杂的实际问题，常常需要借助强大的优化软件工具进行求解，如Gurobi Optimization提供的解决方案。

这些章节提供了对线性、混合整数和二次规划问题基础的概述，为后续章节中深入探讨Gurobi API的应用和优化模型的构建打下理论基础。

## 2 Gurobi API的使用方法

### 2.1 Gurobi API概述

#### 2.1.1 Gurobi API的核心功能

Gurobi Optimization 是一家专注于数学优化问题的公司，其产品Gurobi求解器是一个高性能的数学优化引擎，广泛应用于线性规划、整数规划、二次规划等问题。Gurobi API即Gurobi的编程接口，允许用户在不同的编程语言中使用Gurobi强大的优化功能。

Gurobi API的核心功能包括但不限于：

1. 构建和修改优化模型，如添加变量、约束和目标函数。 
2. 自动选择和配置适当的求解算法。
3. 实时监控求解过程并获取中间结果。
4. 获取详细的结果报告和诊断信息。

> Gurobi API提供了多个语言的接口，如Python, Java, C++, C#等，以便用户根据自己熟悉的编程语言进行开发。
>

#### 2.1.2 Gurobi API与其他优化工具的对比

与市场上其他优化工具如`CPLEX`, `GLPK`等相比，Gurobi API有几个显著的优势：

- 性能优势 ：Gurobi在求解速度和问题规模的扩展性上通常领先于竞争对手。
- 易用性 ：Gurobi API提供了丰富的文档和示例，用户友好性好，学习曲线相对平缓。
- 技术支持 ：Gurobi提供专业的技术支持团队，帮助用户解决使用中的问题。

当然，选择适合的优化工具需要根据具体问题、开发环境和预算等多方面因素综合考量。

### 2.2 Gurobi API在不同编程语言中的应用

#### 2.2.1 Python中的Gurobi API使用实例

Python作为近年来数据分析和机器学习领域非常流行的语言，使用Gurobi API可以非常方便地解决优化问题。以下是使用Python的Gurobi API的一个简单示例：

```python
from gurobipy import Model, GRB
 
# 创建模型
model = Model()
 
# 添加变量
x = model.addVar(name="x")
y = model.addVar(name="y", vtype=GRB.BINARY)
 
# 添加约束条件
model.addConstr(x + y <= 1, "c0")
 
# 设置目标函数
model.setObjective(x + y, GRB.MAXIMIZE)
 
# 求解模型
model.optimize()
 
# 输出结果
print('最优解：')
for v in model.getVars():
    print('%s %g' % (v.varName, v.x))
print('目标函数值:', model.objVal)
```

在这段代码中，我们首先导入了Gurobi Python模块，并创建了一个模型。然后我们添加了两个变量x和y，并为它们添加了一条约束条件。接下来我们设置了目标函数，调用 `optimize() `方法求解模型，并打印出最优解和目标函数值。

##### 2.2.3 C++中的Gurobi API使用实例

C++是另一种性能强大的编程语言，广泛用于系统编程和高性能计算。以下是使用C++解决同样问题的代码示例：

```python
#include <gurobi_c++.h>
#include <iostream>
 
int main() {
    try {
        GRBEnv env = GRBEnv();
        GRBModel model = GRBModel(env);
 
        GRBVar x = model.addVar(0.0, 1.0, 0.0, GRB_CONTINUOUS, "x");
        GRBVar y = model.addVar(0.0, 1.0, 0.0, GRB_BINARY, "y");
 
        GRBLinExpr expr;
        expr.addTerm(1.0, x);
        expr.addTerm(1.0, y);
        model.addConstr(expr, GRB_LESS_EQUAL, 1.0, "c0");
 
        model.setObjective(expr, GRB_MAXIMIZE);
 
        model.optimize();
 
        std::cout << "最优解：" << std::endl;
        std::cout << "x: " << x.get(GRB_StringAttr_VNAMES) << " " << x.get(GRB_DoubleAttr_X) << std::endl;
        std::cout << "y: " << y.get(GRB_StringAttr_VNAMES) << " " << y.get(GRB_DoubleAttr_X) << std::endl;
        std::cout << "目标函数值: " << model.get(GRB_DoubleAttr_OBJVAL) << std::endl;
    } catch(GRBException e) {
        std::cout << "Gurobi异常: " << e.getMessage() << std::endl;
    }
 
    return 0;
}
```

在C++代码中，我们创建了环境和模型对象，定义了变量和约束，设置了目标函数，并求解了模型。输出最优解和目标函数值。需要注意的是，异常处理和内存管理在C++中非常重要，需要确保Gurobi库的正确初始化和释放。

### 2.3 Gurobi API的高级功能探索

#### 2.3.1 Gurobi环境与模型对象的管理

管理`Gurobi`环境和模型对象是高效运行优化问题的关键。

- `Gurobi`环境对象管理着求解器的全局设置，如日志文件路径、时间限制等。
- 模型对象则负责特定问题的所有细节，包括变量、约束和目标函数。

以下是一个管理Gurobi环境和模型对象的示例：

```python
GRBEnv env = new GRBEnv();
try
{
    // 开启环境的日志记录
    env.Set(GRB.StringParam.LogFile, "gurobi.log");
    // 创建模型对象，并设置目标函数和变量
    using(GRBModel model = new GRBModel(env))
    {
        GRBVar x = model.AddVar(0.0, 1.0, 0.0, GRB.VariableType.Continuous, "x");
        // ... 其他代码设置变量和约束 ...
 
        // 求解模型
        model.Optimize();
        // 检查模型是否被成功求解
        if(model.Get(GRB.IntAttr.Status) == GRB.Status.OPTIMAL)
        {
            // 输出优化结果
        }
    }
}
finally
{
    // 环境对象使用完毕后，确保释放资源
    env.Dispose();
}
```

在这段代码中，我们首先创建了一个环境对象，并设置了日志文件。然后在 using 语句块中创建了模型对象， using 语句确保模型在使用完毕后能够正确地释放资源。注意，在C#中， using 语句块中的对象会在结束时自动调用 Dispose 方法，这有助于避免资源泄露。

#### 2.3.2 Gurobi API中事件处理与日志记录

Gurobi API提供了丰富的事件处理机制，允许用户在求解过程中自定义处理各种事件，如模型构建、参数修改、求解进度、优化结束等。

以下是一个自定义事件处理和日志记录的例子：

```python
from gurobipy import Model, GRB
 
def callback(model, where):
    if where == GRB.Callback.MIP:
        # 每次调用混合整数规划求解器时执行的代码
        if model.getAttr(GRB.Attr.NodeCount) % 100 == 0:
            print('当前节点数: %d' % model.getAttr(GRB.Attr.NodeCount))
 
# 创建模型
model = Model()
 
# 添加变量和约束
# ...
 
# 添加一个回调函数
model.optimize(callback)
 
# 输出结果
# ...
```

在这个例子中，我们定义了一个名为 callback 的函数，它将在求解过程中的每100个节点处被调用。通过这种机制，我们可以实时监控求解过程，并根据需要进行干预。

对于日志记录，Gurobi API允许我们记录到控制台、文件或者直接记录到Gurobi的服务器上。这对于问题调试和后期的分析非常重要。

```python
model.setParam('LogFile', 'gurobi.log') # 将日志记录到文件
```

通过设置适当的参数，可以将详细的求解日志记录到指定的日志文件中，便于后续分析。

在本章节中，我们讨论了Gurobi API的使用方法，包括核心功能、与其他优化工具的对比，以及在不同编程语言中的应用。我们还探讨了Gurobi API的高级功能，如环境和模型对象管理，以及事件处理和日志记录功能。通过这些示例和代码块，读者应该能更好地了解如何在实际项目中应用Gurobi API，优化模型的构建和求解过程。在下一章节中，我们将深入探讨决策变量、目标函数和约束条件的定义，这是构建优化模型的基石。

## 3 决策变量、目标函数和约束条件的定义

### 3.1 决策变量的定义和类型

在优化模型中，决策变量是基础的组成部分，它们代表了问题中的可选择参数，是模型求解过程中的未知数。决策变量的选择直接影响到模型的解以及解的质量。

#### 3.1.1 线性规划中的变量类型与定义

线性规划问题是最常见的优化问题类型，它包含两种类型的决策变量：

1. 连续变量：可以取任何实数值的变量，通常在某个区间内，如 [0, ∞)。
2. 离散变量：只能取整数值的变量，可以进一步分为二进制变量和整数变量。

在定义线性规划模型中的变量时，需要考虑实际问题的特性。例如，在生产调度问题中，生产数量可能是连续变量，而生产设备的选择则可能是二进制变量。

```python
from gurobipy import Model, GRB
 
# 创建一个模型实例
model = Model('example')
 
# 定义连续变量
x = model.addVar(lb=0, ub=float('inf'), vtype=GRB.CONTINUOUS, name="x")
 
# 定义二进制变量
y = model.addVar(vtype=GRB.BINARY, name="y")
 
# 定义整数变量
z = model.addVar(vtype=GRB.INTEGER, name="z")
```

#### 3.1.2 整数和二进制变量的特殊应用

在某些特定的场景中，整数变量和二进制变量尤为关键。例如，在组合优化问题中，整数变量可以表示选择的策略或路径的数量，而二进制变量则常用来表示决策的开关状态。

整数规划和混合整数规划问题在求解时要比纯线性规划问题复杂得多。这主要是因为整数变量的离散性质导致解空间的非连续性，这使得优化算法需要额外的计算步骤来处理这种离散性。

```python
# 定义混合整数线性规划模型
model = Model('mip_example')
 
# 添加决策变量
x = model.addVar(lb=0, ub=None, vtype=GRB.INTEGER, name="x")
y = model.addVar(lb=0, ub=None, vtype=GRB.CONTINUOUS, name="y")
 
# 将y变量设置为二进制变量
y.vtype = GRB.BINARY
 
# 添加约束和目标函数（此处省略）
# ...
```

### 3.2 目标函数的构建技巧

目标函数是优化模型中要最大化或最小化的表达式。根据问题的需求，目标函数可以是线性的或非线性的。构建一个好的目标函数对求解优化问题至关重要。

#### 3.2.1 目标函数的线性和非线性建模

- 线性目标函数是最常见的类型，它由决策变量的线性组合构成。由于线性问题的特殊性质，求解速度快，适用于许多实际情况。
- 非线性目标函数则更为复杂，可能包括决策变量的乘积、除法、指数和对数等操作。求解非线性规划问题通常需要采用更复杂的算法，并且可能面临多局部最优解的问题。

```python
# 定义线性目标函数
model.setObjective(x + 2*y, GRB.MINIMIZE)
 
# 定义非线性目标函数（例如，包含乘积和指数）
model.setObjective(x*y + 10*np.exp(-x), GRB.MINIMIZE)
```

#### 3.2.2 目标函数中的权重和优先级设置

在多个目标函数的多目标优化问题中，权重和优先级的设定至关重要。它们可以帮助我们将多目标问题转化为单目标问题，以便于求解。

通常，权重是根据决策者的偏好来设定的，它们可以是确定的数值，也可以是不确定的区间值。优先级则表示不同目标间的相对重要性，可以用来构建分层优化模型。

```python
# 假设有两个目标函数，f1 和 f2
# 定义权重并设置目标函数
model.setObjective(0.6 * f1 + 0.4 * f2, GRB.MINIMIZE)
 
# 如果优先级不同，可以通过设置较大的权重来表示更高的优先级
model.setObjective(100 * f1 + f2, GRB.MINIMIZE)
```

### 3.3 约束条件的表达与优化

约束条件是优化模型中必须满足的条件或规则，它们定义了决策变量必须遵循的限制。没有合适的约束，模型可能无法找到有意义的解决方案。

#### 3.3.1 常见约束类型的表达方法

在构建模型时，常见的约束类型包括等式约束和不等式约束，它们可以是线性的也可以是非线性的。

- 线性等式约束可以用来表达资源的限制，例如，资源消耗不超过资源总量。
- 线性不等式约束可以用来确保满足某些条件的最小或最大限制，如生产量不低于市场需求。

```python
# 线性等式约束示例
model.addConstr(x + y == 10, "constr1")
 
# 线性不等式约束示例
model.addConstr(2*x + 3*y <= 12, "constr2")
```

#### 3.3.2 约束条件与目标函数的协同优化

在实际应用中，约束条件和目标函数之间往往存在某种协同关系。例如，某个目标函数的优化可能导致某些约束条件变得过于严格，从而使得模型无解。

因此，在定义约束条件时，需要考虑目标函数的特性，确保约束条件既能够反映实际问题的限制，又不至于过分限制模型的优化空间。

```python
# 添加约束同时考虑目标函数的优化空间
model.addConstr(x + y <= 5, "constr3")  # 与目标函数相关的约束
model.addConstr(x >= 0, "constr4")      # 非负约束条件
```

在上述内容中，我们详细探讨了决策变量、目标函数以及约束条件的定义和构建，这些都是构建优化模型时不可或缺的部分。在下一章节中，我们将通过介绍GAMS以及 `gurobipy `库来展示如何将这些理论应用到实践中去。

<br>

## 4 使用`GAMS`或 `gurobipy` 库构建优化模型

### 4.1 `GAMS`与`Gurobi`的整合使用

GAMS (General Algebraic Modeling System) 是一种高级建模系统，它专门用于构建和解决线性和非线性数学优化模型。GAMS与Gurobi的整合能够充分利用两者的优势，实现复杂问题的高效求解。

> `Algebraic` ：代数

#### 4.1.1 `GAMS`概述与`Gurobi`的连接

GAMS将复杂模型转化为内部求解器能够理解的格式。Gurobi则是一个高性能的数学优化求解器，能够解决线性规划、整数规划、二次规划等问题。通过GAMS与Gurobi的整合，用户可以更加方便地定义模型，而求解器的选择与配置可以更加灵活。

#### 4.1.2 `GAMS`脚本中的`Gurobi`求解器配置

在GAMS中使用Gurobi作为求解器，需要在模型定义之后的选项设置部分指明求解器为Gurobi，并且设置Gurobi参数（如时长、节点数限制等）。以下是一个简单的配置示例：

```python
Model MyModel /all/;
Solve MyModel using LP minimizing obj using Gurobi;
```

在上面的脚本中， `using LP `指定了问题类型为线性规划， `minimizing obj `表示最小化目标函数 `obj `。 `using Gurobi `则是指出使用Gurobi作为求解器。GAMS的灵活性允许在需要时更改求解器设置。

### 4.2 `gurobipy` 库的详细介绍

`gurobipy` 是Gurobi提供的Python接口，它允许用户在Python环境中直接构建和求解优化问题。 gurobipy 库遵循了Python的惯用语法，使得在Python中使用Gurobi变得更加简单和自然。

#### 4.2.1 gurobipy 库的安装和配置

gurobipy 可以通过Python的包管理器pip直接安装，也可以从Gurobi官网下载相应的安装包安装。以下是安装和配置的一个基本流程：

```python
pip install gurobipy
```

安装完成后，在Python脚本中导入 `gurobipy `模块：

```python
from gurobipy import Model, GRB
```

#### 4.2.2 `gurobipy `在Python脚本中的应用实例

下面是一个使用 `gurobipy `解决一个简单的线性规划问题的示例：

```python
# 创建模型
m = Model('lp_example')
 
# 添加变量
x = m.addVar(name='x')
y = m.addVar(name='y')
 
# 添加目标函数
m.setObjective(x + y, GRB.MAXIMIZE)
 
# 添加约束条件
m.addConstr(x + y <= 10, "c0")
m.addConstr(x <= 5, "c1")
m.addConstr(y <= 7, "c2")
m.addConstr(x >= 0, "c3")
m.addConstr(y >= 0, "c4")
 
# 求解模型
m.optimize()
 
# 输出结果
print('最优解：')
print('x = %g' % x.X)
print('y = %g' % y.X)
```

<br>

### 4.3 模型构建的实践技巧与案例分析

#### 4.3.1 从理论到实践的模型构建过程

构建优化模型通常遵循以下步骤： 

1. 确定问题的决策变量。 
2. 构建目标函数，它是优化模型的目标。
3. 定义模型的约束条件。
4. 调用求解器来求解问题。
5. 分析结果并验证模型的正确性。

在实践中，问题的复杂性可能要求我们不断地迭代上述步骤，直至找到满意的解决方案。

#### 4.3.2 面向实际问题的模型构建案例

以一个经典的供应链优化问题为例，我们可能会有如下模型构建步骤：

1. 变量定义 ：定义决策变量，例如：各个工厂的生产量、仓库的库存量、运输路径和数量等。
2. 目标函数 ：最小化总成本（包括生产成本、运输成本和库存成本等）。
3. 约束条件 ：满足需求约束、生产能力和限制、运输能力限制等。
4. 求解与分析 ：使用Gurobi求解该问题，并对结果进行敏感性分析，以评估不同参数变化对最优解的影响。

通过这个案例分析，我们可以了解如何将实际问题转化为数学模型，并通过`GAMS`或 `gurobipy` 等工具构建和求解。

下面的代码描述了一个运输问题（Transportation Problem）优化模型，属于线性规划（LP）的经典应用。它模拟了从多个生产工厂向多个市场运输产品的场景，目标是在满足供需约束的前提下，找到总运输成本最低的方案。

**（1）定义集合（Sets）**：集合是 GAMS 中定义 “对象类别” 的基础，这里`i`代表所有供应点（工厂），`j`代表所有需求点（市场）。

```python
Set i canning plants / seattle, san-diego /;  % 生产工厂集合：西雅图、圣地亚哥
Set j markets / new-york, chicago, topeka /;  % 市场集合：纽约、芝加哥、托皮卡
```

**（2）定义参数（数据）**

```gams
% 工厂i对各市场的供应能力（单位：箱）
Table a(i,j)  capacity of plant i in case j can be supplied
          new-york       chicago      topeka
    seattle          325           300           275
    san-diego       300           350           250 ;

% 各市场的需求量（单位：箱）
Table d(j) demand at market j
          new-york       chicago      topeka
              325           300           275 ;

% 从工厂i到市场j的运输成本（单位：千美元/箱），这里用10-20之间的随机数生成
Parameter c(i,j) transport cost in thousands of dollars per case;
          c(i,j) = uniform(10,20);
```

- `a(i,j)`：表示工厂`i`可向市场`j`供应的最大数量（实际中可理解为工厂的分市场产能）。
- `d(j)`：表示市场`j`的总需求（必须被满足的最低数量）。
- `c(i,j)`：表示运输成本，这里用`uniform(10,20)`随机生成 10 到 20 之间的数值，模拟不同路线的成本差异。

**（3）定义变量（Variables）**

```gams
Variables x(i,j) shipment quantities in cases  % 从工厂i到市场j的运输量（单位：箱）
          z total transportation costs in thousands of dollars;  % 总运输成本（单位：千美元）

Positive Variable x;  % 约束运输量x不能为负数（不可能运输负数量的产品）
```

- `x(i,j)`：决策变量，即我们需要优化的 “从工厂 i 运到市场 j 的数量”。
- `z`：目标变量，即总运输成本，是我们要最小化的对象。
- `Positive Variable x`：确保运输量非负，符合实际业务逻辑。

**（4）定义约束条件（Equations）**

```gams
Equations cost define objective function  % 目标函数（总成本）
          supply(i) define supply constraints  % 供应约束（工厂产能限制）
          demand(j) define demand constraints;  % 需求约束（市场需求满足）

% 目标函数：总运输成本 = 各路线运输量 × 对应成本的总和
cost ..    z  =e=  sum((i,j), c(i,j)*x(i,j));

% 供应约束：每个工厂运出的总量 ≤ 该工厂的总产能（各市场可供应量之和）
supply(i) .. sum(j, x(i,j)) =l= a(i,'new-york') + a(i,'chicago') + a(i,'topeka');

% 需求约束：每个市场收到的总量 ≥ 该市场的需求量
demand(j) .. sum(i, x(i,j)) =g= d(j);
```

- 目标函数（cost）：定义总运输成本`z`的计算方式，是所有运输路线的 “运输量 × 单位成本” 之和，目标是最小化`z`。
- 供应约束（supply (i)）：每个工厂`i`向所有市场运输的总量，不能超过该工厂的总产能（这里用工厂对各市场的可供应量之和表示总产能）。
- 需求约束（demand (j)）：每个市场`j`从所有工厂收到的总量，必须至少等于该市场的需求量（确保需求被满足）。

**（5）模型求解**

```gams
Model transport /all/;  % 定义模型“transport”，包含所有方程

Solve transport using LP minimizing z;  % 用线性规划（LP）方法求解，目标是最小化总成本z
```

- `Model transport /all/`：将上述定义的变量、约束和目标函数整合为一个名为 “transport” 的模型。
- `Solve ...`：调用线性规划求解器（GAMS 会自动调用默认 solver，也可指定 Gurobi 等），求解最小化总运输成本的方案。

**（6）结果输出**

```gams
% 计算每个市场的总接收量（验证需求是否被满足）
Parameter results;
results('new-york') = x('seattle','new-york') + x('san-diego','new-york');
results('chicago')  = x('seattle','chicago')  + x('san-diego','chicago');
results('topeka')   = x('seattle','topeka')   + x('san-diego','topeka');

% 输出结果：各市场总接收量、各路线运输量、总运输成本
Display results, x.l, z.l;
```

- `results`：计算每个市场实际收到的总产品量，用于验证需求是否被满足。
- `Display`：输出关键结果：
  - `results`：各市场总接收量；
  - `x.l`：各运输路线的最优运输量（`.l`表示变量的最优解 “水平值”）；
  - `z.l`：最小化的总运输成本（最优目标值）。

**模型核心逻辑**：这是一个典型的**运输问题**，核心是在 “供应有限” 和 “需求必须满足” 的约束下，通过优化运输量分配，实现总运输成本最低。这类模型广泛应用于物流、供应链管理等领域，帮助企业制定最优运输策略。

通过整合GAMS与Gurobi，我们能够在面对复杂决策问题时，快速构建并求解优化模型。这样的实践不仅能够帮助理解理论知识，更能在实际应用中起到重要的作用。

<br>

## 5 理解`Gurobi`求解算法

### 5.1 Gurobi算法基础

#### 5.1.1 `Simplex`法和内点法的基本原理

在数学优化领域，`Simplex`法和内点法是解决线性规划问题的两种经典算法。它们各自有不同的工作原理和应用场景。

（1）`Simplex`法 （单纯型算法）： `Simplex`法是一种用于线性规划问题的迭代算法，由George Dantzig于1947年提出。

它的工作原理是通过遍历可行解空间的顶点来寻找最优解。

在每一步迭代中，`Simplex`算法都会选择进入基（基础解）的变量和退出基的变量，使得目标函数的值朝着最优方向改进。这个过程一直持续到找到最优解或者证明问题无界。

> [单纯型法详解！](https://cloud.tencent.com/developer/article/1087679)

（2）内点法 ： 内点法是一种利用问题结构和中心路径概念来寻找线性规划问题最优解的方法。

- 与`Simplex`法不同，内点法不沿着问题的边界移动，而是沿着可行解的内部路径进行迭代。这种方法的每一步迭代都在可行域内部，最终逼近最优解所在的边界点。内点法以其多项式时间复杂度，在处理大规模问题时具有优势。

在Gurobi中，这两种方法可以根据问题的特性和求解器的配置选择使用。例如，对于大型稀疏问题，内点法可能更快，但对于具有某些特殊结构的问题，`Simplex`法可能更有效。

> [内点法详解与动机必看！](https://zhuanlan.zhihu.com/p/528000562)

<br>

#### 5.1.2 `Branch-and-Cut` 算法的工作机制

当遇到混合整数线性规划问题时，单纯形法和内点法就不足以求解了。这时，需要使用到 `Branch-and-Cut` 算法，它是解决这类问题的一种强大工具。

`Branch-and-Cut` 算法是混合整数规划问题的标准算法。它包括两部分：分支（`Branching`）和割（`Cutting`）。

1. 分支过程是指在搜索树的每个节点上，选择一个整数变量，将其取值范围分割为两部分（上界和下界），从而产生新的子问题。
2. 割的过程则是引入额外的线性不等式（割平面），用于剪枝和加速收敛。

算法每次选择一个节点进行求解，如果该节点被证实是整数可行的，则记录下解并向上或向下分支；如果节点不可行，尝试添加割平面来改进解。这个过程在树上不断重复，直到找到最优整数解或证明问题无解。

在Gurobi中，`Branch-and-Cut` 算法是求解混合整数规划问题的核心。用户可以通过配置算法参数来控制分支策略和割平面的添加，以优化特定问题的求解过程。

以下为关于 `Branch-and-Cut` 算法的详解：

> 文献①：[用Branch-and-Cut 解混合整数规划](https://blog.csdn.net/weixin_39610085/article/details/110381067) 中对于分支定界的解释很不错。

1. 从最初的MIP开始，首先删除所有的整数约束，得到的LP称为原始MIP的线性规划松弛。
2. 我们解这个LP，如果结果恰好满足所有整数限制，太幸运了，该解决方案是原始MIP的最优解，运算终止；如果结果没有满足所有整数限制(大多数是这种情况)，需要选择某个整数约束、实际是小数值的变量进行branch。
   - 为了便于说明，假设这个变量是x，它在LP松弛中的值是5.7。
3. 然后，我们可以通过施加x≤5.0和x≥6.0的限制来排除该值5.7。

如果原始MIP问题用 P0 表示，那么用 P1 表示新的MIP(x≤5.0)，用 P2 表示新的MIP(x≥6.0)。

变量x被称为分支变量，并且我们在x上已经进行了分支，产生了两个子MIP P1 和 P2 。

很明显，如果我们可以计算 P1 和 P2 的最优解，那么较好的解就是原始问题 P0 的最优解。通过这种方式，我们用两个较简单(或更少整数限制)的MIP取代了 P0 。

我们现在将相同的思想应用于这两个子MIP，并在必要时选择新的分支变量，这样生成所谓的搜索树。搜索过程生成的MIP称为树的节点， P0 为根节点，树的叶子是尚未branch的所有节点。如果我们可以解决或处置了所有叶节点，那么就求解了原始MIP问题。

<br>

### 5.2 Gurobi算法的高级特性

#### 5.2.1 启发式与割平面技术

在解决实际的优化问题时，Gurobi求解器运用启发式和割平面技术，以提高找到可行解的效率和质量。

启发式方法 ： 启发式方法是一种寻找问题近似解的策略，它可以在可接受的时间内给出一个好的解决方案，尽管这个解不一定是最优的。Gurobi中的启发式技术，例如Heuristics参数，可以加快问题的求解过程，尤其在求解大型整数规划问题时更为有效。

割平面技术 ： 割平面是一种用来改进线性规划松弛问题解的技术。通过引入额外的约束条件，可以限制搜索空间，有助于更快地找到整数解。Gurobi的Cutting Planes参数允许用户开启或关闭特定的割平面生成器，以优化求解过程。

### 5.3 算法调优与实际性能分析

#### 5.3.1 算法参数设置对求解效率的影响

Gurobi提供了大量的参数设置，供用户调整算法行为以适应特定问题的需要。参数的选择对求解效率和解的质量有直接影响。

参数调整 ： 例如，MIPFocus参数可以用来指导求解器在混合整数规划问题上投入更多的计算资源来改善优化进度。设置不同的参数值，可以让求解器在寻找快速可行解、改进当前解或找到全局最优解之间做权衡。

参数优化 ： 参数优化通常涉及多个试验和测试，可以手动进行，也可以使用Gurobi的参数调优工具（如自动参数调优）来自动生成最优或近似最优的参数设置。

#### 5.3.2 实际问题中算法选择的策略

在面对实际问题时，选择正确的算法是至关重要的。算法选择策略涉及对问题特征的理解，以及对可能算法效率的评估。

问题特征分析 ： 首先需要分析问题的规模、稀疏性、整数变量的数量和类型等因素。针对不同的问题特性，Gurobi提供了多种求解器和算法，例如单纯形法适合解决线性规划问题，而`CPLEX`求解器可能更适合解决某些特定类型的混合整数规划问题。

算法评估 ： 对于问题的求解，推荐在初步尝试后，根据Gurobi的统计信息来评估各个算法的表现。用户可以比较不同算法在解决同一问题时的性能指标，如求解时间、节点数和解的质量等，来选择最佳的求解策略。

## 6 Gurobi性能监控和解决方案质量分析

在使用Gurobi解决复杂的数学优化问题时，性能监控和解决方案质量分析是至关重要的两个环节。有效的监控可以帮助我们了解求解过程中的瓶颈和可能的性能瓶颈，而解决方案质量分析则确保了我们得到的答案既可行又具有最优性。

### 6.1 Gurobi性能监控工具介绍

#### 6.1.1 Gurobi日志文件的解读与分析

Gurobi提供了一个非常强大的日志系统，用于记录求解过程中产生的信息。这些信息包括进度更新、警告、错误和性能指标等。通过解读日志文件，开发者可以获得以下关键信息：

- 迭代次数和处理时间
- 收敛到当前解决方案的速度
- 算法中使用的策略和技巧（如分支策略、剪枝等）
- 求解器在每个时间点的性能评估

让我们来看一个简单的日志文件示例：

```python
Nodes    | Current Node    | Objective Bounds      | Work
Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

   0     0        -        -    1000.0000   1000.0000      -     -    0s
H    0     0                       800.0000   1000.0000  25.0%     -    0s
   0     0        -        -    800.0000   1000.0000  25.0%     -    0s
   0     0        -        -    800.0000   1000.0000  25.0%     -    0s
   0     0        -        -    800.0000   1000.0000  25.0%     -    0s
   0     0        -        -    800.0000    875.0000  9.38%     -    0s
   0     0        -        -    800.0000    875.0000  9.38%     -    0s
   0     0        -        -    800.0000    875.0000  9.38%     -    0s

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 8 (of 8 available processors)

Solution count 1: 800
```

此日志文件提供了模型求解过程的详细信息。例如，列出了目标值的上下界，中间节点的探索情况，以及解的质量和性能指标。通过分析这些数据，开发者可以调整模型或求解器的参数来优化求解过程。

#### 6.1.2 Gurobi仪表板的功能与应用

除了日志文件，Gurobi还提供了一个交互式的仪表板（Gurobi Dashboard），可以帮助用户更直观地监控求解过程。仪表板能够展示求解过程中的关键性能指标，例如：

- 目标函数值随时间的变化

- 约束条件的利用率
- 迭代次数和求解时间
- 求解器参数对求解过程的影响

用户还可以自定义仪表板，以监控特定于他们模型的指标。通过这种方式，用户能够快速识别出求解过程中的问题和瓶颈，进而采取措施优化求解器的配置。

仪表板的使用非常直观，用户仅需启动Gurobi求解器，然后在Gurobi的界面中选择“Dashboard”即可进入。

### 6.2 解决方案质量的评估方法

#### 6.2.1 解决方案的可行性与最优性判断

解决方案的评估不仅仅要检查解是否可行，还需要判断解是否具有最优性。Gurobi通过提供的日志和各种指标帮助用户完成这个评估过程。例如：

- 可行性判断 ：Gurobi通过确保所有约束条件在最终解决方案中得到满足来保证解的可行性。用户应仔细检查模型中的任何提示或警告信息，确保没有违反约束。
- 最优性判断 ：通过目标函数的上下界差距来判断解的最优性。在得到一个可行解之后，如果目标函数的上界和下界差距很小或为零，那么解是“最优”的。否则，可能需要对模型或求解参数进行调整，以获得更好的解。

### 6.3 高级特性的应用与案例研究

#### 6.3.1 回调函数与动态模型构建

Gurobi支持在求解过程中使用回调函数，允许用户在某些关键求解事件发生时进行干预。这对于动态调整模型或参数尤其有用。例如，如果一个模型需要在求解过程中动态地添加新的约束，回调函数便可以在检测到某些条件满足时触发这一行为。

下面是一个使用Python实现回调函数的基本示例：

```python
from gurobipy import Model, GRB
 
def mycallback(model, where):
    if where == GRB.Callback.MIPSOL:
        # 每当发现一个新的整数解时，打印解的质量
        print('Obj:', model.cbGet(GRB.Callback.MIPSOL_OBJ))
 
m = Model()
m.optimize(mycallback)
 
m.addVar(name="x")
m.addVar(name="y")
m.setObjective(5*x + 4*y, GRB.MAXIMIZE)
m.addConstr(4*x + 2*y <= 10, "c0")
m.addConstr(x + y <= 5, "c1")
m.addConstr(x <= 3, "c2")
m.optimize()
```

#### 6.3.2 自定义剪枝技术在优化中的应用

Gurobi的MIP优化引擎支持许多高级技术，包括自定义剪枝（Custom Cutting Planes）。这一技术允许用户根据模型的特定知识定义额外的约束条件来剪掉不可行或非最优的分支。这在处理非常大的或特别复杂的优化问题时尤其有用，因为它可以显著减少求解器需要探索的解空间。

将自定义剪枝技术应用到优化中的基本步骤包括：

1. 根据模型的特定知识创建剪枝候选列表。
2. 在求解过程中，根据运行时的某些指标或条件，选择性地激活剪枝规则。
3. 观察剪枝对求解过程的影响，并根据实际结果调整剪枝策略。

<br>

# 三 岗位JD

（26届秋招）算法工程师-运筹方向-深圳

广东·深圳市

发布于 2025-07-29

职位描述

工作职责：

1、供应链核心优化：负责网络规划、干线车辆调度、首末公里路线、站内作业排程、资源排班排产等运筹优化问题的建模与求解；

2、拆解业务指标，设计 MILP/LP/MINLP 或分层混合模型，输出可解释、可落地的决策方案；

3、算法实现与系统工程化：使用 MILP / LP / MINLP 与 Branch‑and‑Price、Column Generation、Benders 等分解技术攻克大规模复杂问题；

4、针对针对大规模 VRP、JSSP、装箱/装载、库存补货等 NP‑Hard 问题，自研或改进 GA、SA、TS、ALNS、LNS、GRASP 等启发式/元启发式算法，并进行 GPU / 多核并行加速；

5、跟进 LLM‑辅助组合优化 (LLM4CO)、在线/分布式随机优化、RL+OR 等前沿方向，验证业务价值；



工作要求：

1、2025 年 9 月至 2026 年 8 月毕业的硕士及以上，运筹学、工业工程、物流工程、计算机、应用数学、人工智能等相关专业（优秀本科生亦可）；

2、扎实的线性/整数规划、网络流、组合优化、概率统计基础；

3、熟悉至少 1‑2 类典型运筹问题（VRP、JSSP、TSLP、库存补货、网络设计等）的建模与求解；

4、掌握启发式算法（GA、SA、TS、ALNS 等）与 MIP 分解技术（Column Generation、Benders、Branch‑and‑Price 等）；

<br>

# 四 启发式/元启发式算法

## 1 SA(模拟退火算法)

[【智能优化算法】 —— 一文搞懂模拟退火](https://zhuanlan.zhihu.com/p/13070788243)

