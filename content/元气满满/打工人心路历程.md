---
title: 打工人心路历程
description: 打工人的一步一步艰难险阻
date: 2025-10-22 15:29:11
urlname: The-mental-journey-of-a-wage-earner
tags:
  - 面试
  - Thoughts
categories:
  - Thoughts
---

# CONTENT OUTLINE

<span style="background:#a2ecfc;"><i class="fas fa-star-half-alt " style="margin-right:10px;"></i>打工人心路历程</span>

<!-- end_of_excerpt -->

# 〇 目录

- 写在前面
- `Gurobi`优化求解器使用手册完整版
- 岗位JD



<br>

# 写在前面

这是相对私人的博客，反正没人会看到，那我自由发挥了，都是一路走来的辛酸泪，无人可说，无人可诉，只能往前走。

<br>



# 1 面试：运筹优化算法工程师

> 2025/10/22：中国燃气

纠着简历中写的无人机路径规划项目问，问的不是我主要负责的。

问你们无人机的路径规划与其他常规交通中的路径规划的有什么不同？

答：无人机的路径规划的可选方向是空间立体，有六向（上下、左右、前后）。

然后一直追问，这个问题，说实话，本来就不是擅长的，直接说，“那面试可以结束了”。吓得我话都不敢说，Over。

> 太菜了太菜了！优化算法，再见！

<br>

## 问题：A*做路径规划的时候，可选方向有哪些？

### 1 平面规划

#### （1）正方形网格（最常用，如栅格地图）

适用于二维平面的离散化场景（如游戏地图、室内机器人导航），根据移动是否允许对角线方向，分为两种：

1. **四方向（4 - 连通）**：仅允许水平和垂直移动，方向为「上、下、左、右」。
   - 特点：路径由直角转折组成，无斜向移动，适合对移动方向有严格限制的场景（如轮式机器人无法斜向行驶）。
2. **八方向（8 - 连通）**：在四方向基础上增加对角线移动，方向为「上、下、左、右、左上、右上、左下、右下」。
   - 特点：路径更灵活，可能存在斜向捷径，但需注意对角线移动的代价计算（通常为√2 倍的横向 / 纵向单位代价，避免算法优先选择不合理的斜向路径）。

#### （2）六边形网格（6 - 连通）

适用于需要更均匀距离度量的场景（如无人机区域覆盖、策略游戏），每个节点有 6 个相邻方向（相邻六边形的中心连线方向）。

- 特点：各方向距离均等（无正方形网格中「边距≠对角线距」的问题），方向对称性更好，路径平滑度优于正方形网格。

#### （3）连续空间（离散化方向）

在非网格的连续空间中（如室外大范围路径规划），A * 通常会将方向**离散化为若干角度**（避免无限方向导致的计算爆炸），例如：

- 按固定角度间隔划分（如每 15°、30° 或 45° 一个方向），形成 8 方向、12 方向、24 方向等。
- 方向数量越多，路径越接近最优连续路径，但搜索复杂度也会增加。

#### （4）带约束的方向（如移动方向限制）

在实际场景中，可能因障碍物、机器人运动学约束（如履带式机器人转向受限）进一步限制方向，例如：

- 仅允许「前、后、左前 45°、右前 45°」等有限方向；
- 方向需与当前运动方向关联（如只能向当前方向的 ±30° 范围内转向）。

### 2 三维规划

无人机路径规划在三维空间中的方向设计，需结合其**三维运动特性**（可沿 x、y、z 轴自由移动）和**物理约束**（如最小转弯半径、爬升 / 俯冲角限制等），常见的方向划分方式主要有以下几类：

#### （1）三维网格离散化方向（基于立方体网格模型）

适用于将三维空间离散为立方体栅格（如室内 / 城市复杂环境避障），方向设计以 “当前栅格节点到相邻栅格节点的移动路径” 为基准，常见有 3 种：

- **6 方向（6 - 连通）**：仅允许沿三维坐标轴的正负方向移动，即「±x（前后）、±y（左右）、±z（上下）」。
  - 特点：移动路径为轴对齐的直线，方向简单直观，计算量小；但路径可能较 “生硬”（多直角转折），适合对算力有限制或运动方向受限的小型无人机（如室内微型无人机）。

- **12 方向（12 - 连通）**：在 6 方向基础上，增加 “面对角线” 方向，即沿立方体每个面的对角线移动（如 x+y、x-y、x+z、x-z、y+z、y-z，及对应的反方向）。
  - 特点：方向更灵活，路径可包含斜向移动（如在同一高度面内斜向飞行，或同时改变水平位置和高度），比 6 方向更接近无人机实际运动轨迹，但需注意对角线移动的代价计算（如距离为√2 倍轴长，避免路径代价失真）。

- **26 方向（26 - 连通）**：包含立方体所有相邻节点的移动方向，除 6 个轴方向、12 个面对角线方向外，再增加 8 个 “空间对角线” 方向（如 x+y+z、x+y-z 等）。
  - 特点：方向覆盖最全面，路径灵活性最高，能适应复杂三维障碍物环境（如密集建筑群、峡谷）；但方向数量多，会增加 A * 等算法的搜索复杂度，适合对路径平滑度要求高的场景（如户外中型无人机）。

#### （2）球面坐标角度离散化方向（连续空间近似）

适用于大范围三维空间（如室外空旷区域、低空飞行），不依赖栅格划分，而是将方向按**球面坐标（方位角 θ、俯仰角 φ）** 离散为有限角度组合：

- **方位角 θ**：绕 z 轴（竖直方向）的旋转角度（0°~360°），通常按固定间隔划分（如每 15°、30° 或 45° 一个方向）；
- **俯仰角 φ**：与水平面的夹角（-90°~90°，负角为俯冲，正角为爬升），通常按无人机物理性能限制划分（如 ±15°、±30°，避免过大仰角导致失速）。

例如：方位角每 30° 划分（12 个方向），俯仰角每 15° 划分（7 个方向），可形成 12×7=84 个方向。

特点：方向精度可灵活调整（角度间隔越小，方向越密集，路径越接近最优连续路径），但计算量随方向数量呈指数增长，需在精度与效率间平衡。

#### （3）带运动学约束的方向（贴合无人机物理特性）

实际无人机受自身动力、机动性限制（如最小转弯半径、最大角速度），方向选择需满足运动学约束，常见有：

- **基于 “航向角 - 俯仰角” 的有限方向集**：

限制无人机的转向角度（如相邻路径段的航向角变化不超过 30°，俯仰角变化不超过 15°），方向仅在当前航向的 “允许转向范围内” 选取（如当前航向为 0°，则下一个航向只能在 - 30°~30° 范围内）。

- **“速度矢量” 方向约束**：

无人机的运动方向需与速度矢量一致，且速度大小在合理范围内（如最小速度 v_min、最大速度 v_max），方向变化需满足 “加速度不超过最大允许值”（避免过载）。

特点：方向设计更贴近无人机实际飞行能力，规划出的路径可直接用于控制执行（无需后续平滑处理），适合工程化应用（如物流无人机、植保无人机）。

<br>

# 2 笔试：服务端开发

> 2025-10-23 20:07:25 点点游戏

世界上的毕业生都这么聪明吗？这题？

## 问题：定时器设计与优化

每30s刷新一波小兵，游戏开始5分钟刷新Boss（单次任务），支持随时取消未触发的boss任务。

（1）请设计定时节点的数据结构

（2）选择有序数组或者最小堆实现定时器节点的添加

（3）实现定时器逻辑，可用伪代码实现

## AI回答

### （1）定时节点的数据结构设计

定时节点需要包含任务的核心信息：触发时间、任务类型、重复属性、唯一标识（用于取消）及执行逻辑。设计如下：

```cpp
struct TimerNode {
    int64_t trigger_time;       // 触发时间（绝对时间戳，单位：毫秒）
    int task_id;                // 任务唯一ID（用于取消任务）
    bool is_repeat;             // 是否重复任务（true：重复，false：单次）
    int repeat_interval;        // 重复间隔（单位：毫秒，仅repeat为true时有效）
    enum TaskType {             // 任务类型
        MINION_REFRESH,         // 小兵刷新
        BOSS_REFRESH            // BOSS刷新
    } task_type;
    std::function<void()> callback;  // 任务执行的回调函数（如刷新小兵/BOSS的逻辑）
};
```

**核心字段说明**：

- `trigger_time`：用绝对时间戳统一管理，避免相对时间计算误差；
- `task_id`：唯一标识任务，支持精准取消（尤其是 BOSS 这类单次任务）；
- `is_repeat` 和 `repeat_interval`：区分单次 / 重复任务（如小兵每 30s 刷新，repeat_interval=30000ms）；
- `callback`：封装任务执行逻辑，解耦定时器与业务。

### （2）选择最小堆实现定时器节点的添加

**选择最小堆而非有序数组的原因**：

- **插入效率**：最小堆插入的时间复杂度为 `O(log n)`，而有序数组插入需移动元素，复杂度为 `O(n)`，在任务数量较多时堆更高效；
- **获取最近触发任务**：两者均能 `O(1)` 获取（堆顶 / 数组首元素），但堆的整体操作更均衡；
- **支持取消任务**：结合哈希表（`task_id -> 堆中节点索引`），可将取消操作优化为 `O(log n)`（找到节点后执行堆的删除操作），而有序数组取消需 `O(n)` 查找 + 删除。

### （3）定时器逻辑实现（伪代码）

定时器核心逻辑：维护最小堆管理任务，循环处理到期任务，支持动态添加 / 取消任务。

```cpp
#include <vector>
#include <unordered_map>
#include <functional>
#include <chrono>
#include <thread>
#include <iostream>
#include <stdint.h>  // 用于int64_t

// 任务类型枚举
enum class TaskType {
    MINION_REFRESH,  // 小兵刷新
    BOSS_REFRESH     // BOSS刷新
};

// 定时任务节点
struct TimerNode {
    int64_t trigger_time;       // 触发时间（绝对时间戳，单位：毫秒）
    int task_id;                // 任务唯一ID（用于取消）
    bool is_repeat;             // 是否重复任务
    int repeat_interval;        // 重复间隔（毫秒，仅重复任务有效）
    TaskType task_type;         // 任务类型
    std::function<void()> callback;  // 任务执行逻辑
};

// 定时器管理器（核心类）
class TimerManager {
    private:
    std::vector<TimerNode> min_heap;  // 最小堆：按trigger_time升序
    std::unordered_map<int, size_t> id_map;  // task_id -> 堆中索引（快速查找）

    // 工具函数：获取当前时间戳（毫秒）
    int64_t get_current_time() const {
        auto now = std::chrono::system_clock::now();
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            now.time_since_epoch()
        );
        return ms.count();
    }

    // 堆调整：上浮（维护最小堆）
    void heapify_up(size_t idx) {
        while (idx > 0) {
            size_t parent = (idx - 1) / 2;
            if (min_heap[idx].trigger_time >= min_heap[parent].trigger_time) {
                break;  // 父节点更小，堆序正确
            }
            // 交换父子节点
            std::swap(min_heap[idx], min_heap[parent]);
            // 更新哈希表索引
            id_map[min_heap[idx].task_id] = idx;
            id_map[min_heap[parent].task_id] = parent;
            idx = parent;
        }
    }

    // 堆调整：下沉（维护最小堆）
    void heapify_down(size_t idx) {
        size_t heap_size = min_heap.size();
        while (true) {
            size_t left = 2 * idx + 1;
            size_t right = 2 * idx + 2;
            size_t smallest = idx;

            if (left < heap_size && min_heap[left].trigger_time < min_heap[smallest].trigger_time) {
                smallest = left;
            }
            if (right < heap_size && min_heap[right].trigger_time < min_heap[smallest].trigger_time) {
                smallest = right;
            }
            if (smallest == idx) {
                break;  // 子节点均不更小，堆序正确
            }
            // 交换节点
            std::swap(min_heap[idx], min_heap[smallest]);
            // 更新哈希表索引
            id_map[min_heap[idx].task_id] = idx;
            id_map[min_heap[smallest].task_id] = smallest;
            idx = smallest;
        }
    }

    public:
    TimerManager() = default;

    // 添加任务
    void add_task(const TimerNode& task) {
        // 检查task_id唯一性（实际场景需确保调用者传入唯一ID）
        if (id_map.count(task.task_id)) {
            std::cerr << "Task ID " << task.task_id << " already exists!\n";
            return;
        }
        // 插入堆尾
        min_heap.push_back(task);
        size_t idx = min_heap.size() - 1;
        id_map[task.task_id] = idx;
        // 上浮调整堆
        heapify_up(idx);
    }

    // 取消任务（通过task_id）
    bool cancel_task(int task_id) {
        if (!id_map.count(task_id)) {
            return false;  // 任务不存在
        }
        // 获取任务在堆中的索引
        size_t idx = id_map[task_id];
        size_t last_idx = min_heap.size() - 1;

        // 用最后一个元素覆盖当前元素
        min_heap[idx] = min_heap[last_idx];
        id_map[min_heap[idx].task_id] = idx;  // 更新最后元素的索引

        // 删除最后一个元素
        min_heap.pop_back();
        id_map.erase(task_id);

        // 调整堆（根据情况选择下沉或上浮）
        if (idx < min_heap.size()) {
            heapify_down(idx);
            heapify_up(idx);
        }
        return true;
    }

    // 启动定时器主循环
    void run() {
        while (true) {
            if (min_heap.empty()) {
                // 无任务时休眠100ms，避免空轮询
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            }

            // 获取堆顶任务（最早触发的任务）
            TimerNode top = min_heap[0];
            int64_t current = get_current_time();
            int64_t wait_ms = top.trigger_time - current;

            if (wait_ms > 0) {
                // 未到触发时间，休眠至触发时间
                std::this_thread::sleep_for(std::chrono::milliseconds(wait_ms));
            }

            // 执行任务
            top.callback();

            // 处理任务后续逻辑
            if (top.is_repeat) {
                // 重复任务：更新触发时间后重新加入堆
                cancel_task(top.task_id);  // 先删除原任务
                TimerNode new_task = top;
                new_task.trigger_time = get_current_time() + top.repeat_interval;  // 基于当前时间更新
                add_task(new_task);
            } else {
                // 单次任务：直接删除
                cancel_task(top.task_id);
            }
        }
    }
};
```

<br>

## 第二题：实现高精度定时器模块

在 Linux 环境下，基于 `timefd` 和 `epoll` 可以实现高精度定时器模块（支持微秒 / 纳秒级精度）。`timefd` 是 Linux 提供的将时间事件抽象为文件描述符的机制，配合 `epoll` 的 I/O 多路复用能力，可高效监听超时事件，避免传统定时器的空轮询损耗。以下是具体实现：

### 核心设计思路

1. **高精度时间源**：使用 `timefd` 作为时间触发源，其基于 Linux 内核时钟（`CLOCK_MONOTONIC`，单调递增，不受系统时间调整影响），支持纳秒级精度。
2. **任务管理**：延续最小堆存储定时任务，快速获取最近触发的任务；用哈希表映射 `task_id` 与堆索引，支持快速取消。
3. **事件驱动**：通过 `epoll` 监听 `timefd` 的读事件，当超时时间到达时，`epoll` 唤醒进程处理任务，避免无效轮询。
4. **动态更新**：每次任务处理后，根据新的堆顶任务更新 `timefd` 的超时时间，确保下一次触发精准。

### 实现代码

```cpp
#include <vector>
#include <unordered_map>
#include <functional>
#include <sys/epoll.h>
#include <sys/timerfd.h>
#include <unistd.h>
#include <cstdint>
#include <chrono>
#include <mutex>
#include <iostream>
#include <stdexcept>
#include <algorithm>

// 任务类型枚举
enum class TaskType {
    MINION_REFRESH,  // 小兵刷新
    BOSS_REFRESH     // BOSS刷新
};

// 定时任务节点（高精度版）
struct TimerNode {
    int64_t trigger_time_ns;    // 触发时间（绝对时间戳，单位：纳秒）
    int task_id;                // 任务唯一ID
    bool is_repeat;             // 是否重复任务
    int64_t repeat_interval_ns; // 重复间隔（纳秒，仅重复任务有效）
    TaskType task_type;         // 任务类型
    std::function<void()> callback;  // 任务执行逻辑
};

// 高精度定时器管理器
class HighResTimerManager {
private:
    std::vector<TimerNode> min_heap;  // 最小堆（按trigger_time_ns升序）
    std::unordered_map<int, size_t> id_map;  // task_id -> 堆索引
    int epoll_fd;  // epoll实例句柄
    int time_fd;   // timefd句柄
    std::mutex mtx;  // 保护堆和哈希表的线程锁

    // 获取当前单调时间（纳秒，不受系统时间调整影响）
    int64_t get_current_time_ns() const {
        struct timespec ts;
        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1) {
            throw std::runtime_error("clock_gettime failed");
        }
        return (int64_t)ts.tv_sec * 1000000000 + ts.tv_nsec;
    }

    // 堆调整：上浮
    void heapify_up(size_t idx) {
        while (idx > 0) {
            size_t parent = (idx - 1) / 2;
            if (min_heap[idx].trigger_time_ns >= min_heap[parent].trigger_time_ns) {
                break;
            }
            std::swap(min_heap[idx], min_heap[parent]);
            id_map[min_heap[idx].task_id] = idx;
            id_map[min_heap[parent].task_id] = parent;
            idx = parent;
        }
    }

    // 堆调整：下沉
    void heapify_down(size_t idx) {
        size_t heap_size = min_heap.size();
        while (true) {
            size_t left = 2 * idx + 1;
            size_t right = 2 * idx + 2;
            size_t smallest = idx;

            if (left < heap_size && min_heap[left].trigger_time_ns < min_heap[smallest].trigger_time_ns) {
                smallest = left;
            }
            if (right < heap_size && min_heap[right].trigger_time_ns < min_heap[smallest].trigger_time_ns) {
                smallest = right;
            }
            if (smallest == idx) {
                break;
            }
            std::swap(min_heap[idx], min_heap[smallest]);
            id_map[min_heap[idx].task_id] = idx;
            id_map[min_heap[smallest].task_id] = smallest;
            idx = smallest;
        }
    }

    // 更新timefd的超时时间（基于堆顶任务）
    void update_timefd() {
        std::lock_guard<std::mutex> lock(mtx);
        if (min_heap.empty()) {
            // 无任务时，禁用timefd（设置为永久超时）
            struct itimerspec new_value = {0};
            timerfd_settime(time_fd, 0, &new_value, nullptr);
            return;
        }

        // 堆顶任务的触发时间
        int64_t target_ns = min_heap[0].trigger_time_ns;
        int64_t now_ns = get_current_time_ns();
        int64_t delay_ns = std::max(int64_t(0), target_ns - now_ns);  // 确保非负

        // 设置timefd超时时间（绝对时间）
        struct itimerspec new_value;
        new_value.it_interval = {0, 0};  // 仅一次超时
        new_value.it_value.tv_sec = delay_ns / 1000000000;
        new_value.it_value.tv_nsec = delay_ns % 1000000000;

        if (timerfd_settime(time_fd, 0, &new_value, nullptr) == -1) {
            throw std::runtime_error("timerfd_settime failed");
        }
    }

public:
    HighResTimerManager() {
        // 初始化epoll
        epoll_fd = epoll_create1(EPOLL_CLOEXEC);
        if (epoll_fd == -1) {
            throw std::runtime_error("epoll_create1 failed");
        }

        // 初始化timefd（CLOCK_MONOTONIC保证时间单调递增）
        time_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
        if (time_fd == -1) {
            close(epoll_fd);
            throw std::runtime_error("timerfd_create failed");
        }

        // 将timefd添加到epoll监听（水平触发，读事件）
        struct epoll_event ev;
        ev.events = EPOLLIN;
        ev.data.fd = time_fd;
        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, time_fd, &ev) == -1) {
            close(time_fd);
            close(epoll_fd);
            throw std::runtime_error("epoll_ctl failed");
        }
    }

    ~HighResTimerManager() {
        close(time_fd);
        close(epoll_fd);
    }

    // 添加任务（线程安全）
    void add_task(const TimerNode& task) {
        std::lock_guard<std::mutex> lock(mtx);
        if (id_map.count(task.task_id)) {
            std::cerr << "Task ID " << task.task_id << " already exists!\n";
            return;
        }
        // 插入堆并调整
        min_heap.push_back(task);
        size_t idx = min_heap.size() - 1;
        id_map[task.task_id] = idx;
        heapify_up(idx);
        // 若新任务是堆顶，更新timefd
        if (idx == 0) {
            update_timefd();
        }
    }

    // 取消任务（线程安全）
    bool cancel_task(int task_id) {
        std::lock_guard<std::mutex> lock(mtx);
        if (!id_map.count(task_id)) {
            return false;
        }
        size_t idx = id_map[task_id];
        size_t last_idx = min_heap.size() - 1;

        // 用最后一个元素覆盖当前元素
        min_heap[idx] = min_heap[last_idx];
        id_map[min_heap[idx].task_id] = idx;

        // 删除最后一个元素
        min_heap.pop_back();
        id_map.erase(task_id);

        // 调整堆
        if (idx < min_heap.size()) {
            heapify_down(idx);
            heapify_up(idx);
        }

        // 若堆顶变化，更新timefd
        update_timefd();
        return true;
    }

    // 启动定时器主循环（阻塞，处理事件）
    void run() {
        const int MAX_EVENTS = 10;
        struct epoll_event events[MAX_EVENTS];

        while (true) {
            // 等待epoll事件（阻塞，直到timefd超时或被信号中断）
            int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
            if (nfds == -1) {
                if (errno == EINTR) continue;  // 被信号中断，继续等待
                throw std::runtime_error("epoll_wait failed");
            }

            // 处理事件（仅关注timefd的读事件）
            for (int i = 0; i < nfds; ++i) {
                if (events[i].data.fd == time_fd && (events[i].events & EPOLLIN)) {
                    // 读取timefd的值（清除事件，否则会一直触发）
                    uint64_t exp;
                    read(time_fd, &exp, sizeof(exp));

                    // 处理所有已超时的任务
                    process_expired_tasks();
                }
            }
        }
    }

    // 处理所有已超时的任务
    void process_expired_tasks() {
        std::lock_guard<std::mutex> lock(mtx);
        int64_t now_ns = get_current_time_ns();

        // 循环处理堆顶已超时的任务
        while (!min_heap.empty() && min_heap[0].trigger_time_ns <= now_ns) {
            TimerNode top = min_heap[0];
            // 执行任务回调（注意：若回调耗时较长，可考虑异步执行）
            top.callback();

            // 移除当前堆顶任务
            cancel_task(top.task_id);  // 内部已加锁，此处lock仍有效

            // 处理重复任务：更新时间后重新添加
            if (top.is_repeat) {
                TimerNode new_task = top;
                new_task.trigger_time_ns = now_ns + top.repeat_interval_ns;  // 基于当前时间更新
                add_task(new_task);  // 内部已加锁
            }
        }

        // 更新timefd为下一个任务的超时时间
        update_timefd();
    }
};
```

### 场景使用示例

```cpp
int main() {
    try {
        HighResTimerManager timer;
        int64_t start_ns = timer.get_current_time_ns();

        // 1. 添加小兵刷新任务（每30s重复，高精度）
        TimerNode minion_task{
            .trigger_time_ns = start_ns + 30 * 1000000000LL,  // 30秒后首次触发（纳秒）
            .task_id = 1001,
            .is_repeat = true,
            .repeat_interval_ns = 30 * 1000000000LL,  // 30秒间隔
            .task_type = TaskType::MINION_REFRESH,
            .callback = []() {
                std::cout << "高精度刷新小兵！\n";
            }
        };
        timer.add_task(minion_task);

        // 2. 添加BOSS刷新任务（5分钟后单次，可取消）
        TimerNode boss_task{
            .trigger_time_ns = start_ns + 5 * 60 * 1000000000LL,  // 5分钟后触发
            .task_id = 2001,
            .is_repeat = false,
            .repeat_interval_ns = 0,
            .task_type = TaskType::BOSS_REFRESH,
            .callback = []() {
                std::cout << "高精度刷新BOSS！\n";
            }
        };
        timer.add_task(boss_task);

        // 模拟：3分钟后取消BOSS任务
        std::thread cancel_thread([&timer]() {
            std::this_thread::sleep_for(std::chrono::minutes(3));
            bool success = timer.cancel_task(2001);
            if (success) {
                std::cout << "已取消高精度BOSS任务！\n";
            }
        });
        cancel_thread.detach();

        // 启动定时器主循环
        timer.run();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
```

<br>

# 3 笔试：嵌入式应用工程师

> 好像没投过，什么杉川机器人。

## 3.1 递归函数的时间复杂度

核心是分析递归调用的次数以及每次递归中基本操作的执行次数。以下是常用的分析方法和步骤：

**主方法（Master Theorem）**：针对形如 `(T(n) = aT(n/b) + f(n))` 的递推关系，直接套用公式（适用于分治类递归）。

**1、建立递推公式**

- 设 \(T(n)\) 为问题规模为 n 时的时间复杂度。
- 若每次递归将问题分解为 a 个规模为 \(n/b\) 的子问题，且合并子问题的时间为 \(f(n)\)，则递推公式为：`(T(n) = aT(n/b) + f(n))`
- 例：斐波那契递归 \(F(n) = F(n-1) + F(n-2)\)，递推公式为 `T(n) = T(n-1) + T(n-2) + O(1)`。

**2、求解递推公式**

- 递归树法：

  画出递归树，每层节点数为 \(a^k\)（k 为层数），每层子问题规模为 \(n/b^k)，直到规模为 1（终止条件）。总时间为所有层的操作数之和。

  例：归并排序 \(T(n) = 2T(n/2) + O(n)\)，递归树每层操作数均为 \(O(n)\)，共 (log n\) 层，故 T(n) = O(n log n)。

- 主方法：

  ![](3-1.png)

- **代入法**：

  猜测一个复杂度，代入递推公式验证是否成立。

  例：猜测 \(T(n) = T(n-1) + O(1)\) 的解为 \(O(n)\)，代入得 \(T(n) = O(n-1) + O(1) = O(n)\)，成立。

例如：

1. **阶乘递归**：\(fact(n) = n \cdot fact(n-1)\)

   递推：\(T(n) = T(n-1) + O(1)\)，解为 \(O(n)\)（共 n 次调用）。

2. **斐波那契递归（ naive 版）**：\(F(n) = F(n-1) + F(n-2)\)

   递归树呈指数增长，总调用次数约 \(2^n\)，故 \(T(n) = O(2^n)\)。

3. **快速排序（平均情况）**：\(T(n) = 2T(n/2) + O(n)\)，由主方法得 \(O(n \log n)\)。

## 3.2 手撕：二叉树的最大路径和

[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

## 3.3 fork相关

```cpp
for(int i=0;i<4;i++) {
    fork();    
    print("-") ;
}    
```

要计算这段代码打印的`-`的数量，需要分析`fork()`系统调用的作用：**`fork()`会创建一个新进程（子进程），并且父子进程会从`fork()`之后的代码继续执行**。

1. **初始进程**：程序开始时，有 1 个初始进程（设为 P0）。

2. **循环执行过程**：循环变量`i`从 0 到 3（共 4 次循环），每次循环先调用`fork()`，再打印`-`。

   - **`i=0`时**：

     P0 调用`fork()`，创建子进程 P1。此时 P0 和 P1 都会执行`print("-")`，共打印 **2 个`-`**。

   - **`i=1`时**：

     现有进程：P0、P1（共 2 个进程）。

     每个进程调用`fork()`，各自创建 1 个子进程（共新增 2 个进程），此时总进程数为 4。

     这 4 个进程都会执行`print("-")`，共打印 **4 个`-`**。

   - **`i=2`时**：

     现有进程：4 个。

     每个进程调用`fork()`，新增 4 个进程，总进程数为 8。

     这 8 个进程都会执行`print("-")`，共打印 **8 个`-`**。

   - **`i=3`时**：

     现有进程：8 个。

     每个进程调用`fork()`，新增 8 个进程，总进程数为 16。

     这 16 个进程都会执行`print("-")`，共打印 **16 个`-`**。

总打印数量：每次循环的打印数依次为`2、4、8、16`，总和为：2+4+8+16=30
