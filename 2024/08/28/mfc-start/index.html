<!DOCTYPE html><html lang="zh-CN"><head><script src="https://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/180-180.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/32-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/16-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hammerzer.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="CONTENT OUTLINE  MFC必备  〇 目录 MFC初识 MFC程序开发流程 简单绘图与文本编程 菜单栏与工具栏 MFC总体理解 对话框 常用控件"><meta property="og:type" content="article"><meta property="og:title" content="MFC快速入门"><meta property="og:url" content="https://hammerzer.github.io/2024/08/28/mfc-start/index.html"><meta property="og:site_name" content="Moustache&#39;s Blog"><meta property="og:description" content="CONTENT OUTLINE  MFC必备  〇 目录 MFC初识 MFC程序开发流程 简单绘图与文本编程 菜单栏与工具栏 MFC总体理解 对话框 常用控件"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hammerzer.github.io/.io//1-1.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//1-2.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//1-3.png"><meta property="og:image" content="https://hammerzer.github.io/.io//2-1.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//3-1.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//3-2.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//3-3.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//3-4.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//3-5.PNG"><meta property="og:image" content="https://hammerzer.github.io/.io//4-1.png"><meta property="og:image" content="https://hammerzer.github.io/.io//4-2.png"><meta property="og:image" content="https://hammerzer.github.io/.io//5-1.gif"><meta property="og:image" content="https://hammerzer.github.io/.io//5-2.png"><meta property="og:image" content="https://hammerzer.github.io/.io//6-1.png"><meta property="og:image" content="https://hammerzer.github.io/.io//6-2.png"><meta property="og:image" content="https://hammerzer.github.io/.io//6-3.png"><meta property="og:image" content="https://hammerzer.github.io/.io//6-6.png"><meta property="og:image" content="https://hammerzer.github.io/.io//6-4.png"><meta property="og:image" content="https://hammerzer.github.io/.io//6-5.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-1.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-2.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-3.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-4.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-5.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-6.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-7.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-8.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-9.png"><meta property="og:image" content="https://hammerzer.github.io/.io//7-10.png"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image063.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image065.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image067.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image069.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image071.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image073.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image075.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image077.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image079.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image082.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image084.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image086.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image087.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image089.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image091.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image093.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image094.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image098.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image100.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image101.gif"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image103.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image104.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image106.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image108.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image110.jpg"><meta property="og:image" content="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image112.jpg"><meta property="article:published_time" content="2024-08-28T02:20:07.000Z"><meta property="article:modified_time" content="2025-01-19T03:19:15.786Z"><meta property="article:author" content="Moustache"><meta property="article:tag" content="操作系统与框架"><meta property="article:tag" content="MFC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hammerzer.github.io/.io//1-1.PNG"><link rel="canonical" href="https://hammerzer.github.io/2024/08/28/mfc-start/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>MFC快速入门 | Moustache's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Moustache's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Moustache's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">小胡子的私人空间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">34</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">78</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hammerzer.github.io/2024/08/28/mfc-start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/180-180.png"><meta itemprop="name" content="Moustache"><meta itemprop="description" content="我是小胡子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Moustache's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MFC快速入门</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-08-28 10:20:07" itemprop="dateCreated datePublished" datetime="2024-08-28T10:20:07+08:00">2024-08-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-19 11:19:15" itemprop="dateModified" datetime="2025-01-19T11:19:15+08:00">2025-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a> </span></span><span id="/2024/08/28/mfc-start/" class="post-meta-item leancloud_visitors" data-flag-title="MFC快速入门" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> <span>℃</span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2024/08/28/mfc-start/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2024/08/28/mfc-start/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>148k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2:15</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote><p><span style="background:#ff0">MFC必备</span></p></blockquote><h2 id="〇-目录"><a href="#〇-目录" class="headerlink" title="〇 目录"></a>〇 目录</h2><ol><li>MFC初识</li><li>MFC程序开发流程</li><li>简单绘图与文本编程</li><li>菜单栏与工具栏</li><li>MFC总体理解</li><li>对话框</li><li>常用控件</li></ol><span id="more"></span><br><h2 id="一-MFC初识"><a href="#一-MFC初识" class="headerlink" title="一 MFC初识"></a>一 MFC初识</h2><h3 id="1-1-MFC是什么"><a href="#1-1-MFC是什么" class="headerlink" title="1.1 MFC是什么"></a>1.1 MFC是什么</h3><p><code>Microsoft Foundation Classes</code>，是微软公司提供的类库，以C++类的形式封装了Windows API，也是一个应用程序框架，用以减少应用程序开发人员的工作量。</p><h3 id="1-2-学习MFC的意义"><a href="#1-2-学习MFC的意义" class="headerlink" title="1.2 学习MFC的意义"></a>1.2 学习MFC的意义</h3><ul><li>满足windows应用开发需求【PC端软件】</li><li>满足外包开发需求</li><li>就业需要：今日头条、深信服、传统行业【修改编译参数后，可编译为XP至win10】</li><li>学习方法<ul><li>掌握理论【C++多态、Windows消息循环，即<code>msg loop</code>】</li><li>学会查询文档：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/">微软文档</a></li><li>谷歌浏览器 chrome</li><li>参考教材：孙鑫的《深入理解VC++》 参考</li></ul></li></ul><br><h3 id="1-3-MFC开发环境搭建和就业方向"><a href="#1-3-MFC开发环境搭建和就业方向" class="headerlink" title="1.3  MFC开发环境搭建和就业方向"></a>1.3 MFC开发环境搭建和就业方向</h3><ul><li>visual studio 2019 社区版</li><li>help viewer (MSDN library)</li></ul><p><strong>MFC就业方向</strong>：桌面应用开发、数控行业、公司内部的一些桌面软件、监控行业</p><blockquote><p>上位机：最典型的就是打印机。</p></blockquote><p><img src="/.io//1-1.PNG" alt="img"></p><p><strong>工作负载</strong>：在修改界面中，选择使用C++的桌面开发，然后在安装详细信息处勾选组件</p><ul><li>C++ ALT for v142 生成工具</li><li>C++ MFC for v142 生成工具</li><li>Help Viewer</li></ul><br><h3 id="1-4-MFC的前身：Win32"><a href="#1-4-MFC的前身：Win32" class="headerlink" title="1.4 MFC的前身：Win32"></a>1.4 MFC的前身：Win32</h3><p>【完全手写Win32窗口程序】选择空项目，并手写Win32窗口程序：</p><blockquote><p>由于WCHAR与CHAR的相关问题，该程序不能直接运行，理解思想即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MFC  ： 1 C++的多态性 类   2 消息机制  3 面向对象的思想</span></span><br><span class="line"><span class="comment">//窗口：屏幕上的一块矩形区域</span></span><br><span class="line"><span class="comment">//程序员：代码搬运工  说明书使用王者</span></span><br><span class="line"><span class="comment">//参数坑爹</span></span><br><span class="line"><span class="comment">//VA  visual assist</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> LPCSTR clsName = <span class="string">&quot;clsFeng&quot;</span>;</span><br><span class="line"> LPCSTR msgName = <span class="string">&quot;哔哩哔哩&quot;</span>;</span><br><span class="line"> LPCSTR msgUrl = <span class="string">&quot;https://www.bilibili.com/&quot;</span>;</span><br><span class="line"> <span class="comment">// 窗口交互响应处理函数声明</span></span><br><span class="line"> <span class="function">LRESULT CALLBACK <span class="title">WinSunProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     HWND  hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">     UINT  uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">     WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE prevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 定义和配置窗口对象</span></span><br><span class="line">    WNDCLASS wndcls;  <span class="comment">//alt + G </span></span><br><span class="line">    wndcls.cbClsExtra = <span class="literal">NULL</span>;</span><br><span class="line">    wndcls.cbWndExtra = <span class="literal">NULL</span>;</span><br><span class="line">    wndcls.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wndcls.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">    wndcls.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wndcls.hInstance = hInstance;</span><br><span class="line">    <span class="comment">// 定义交互响应</span></span><br><span class="line">    wndcls.lpfnWndProc = WinSunProc; <span class="comment">//回调</span></span><br><span class="line">    <span class="comment">// 定义窗口代号</span></span><br><span class="line">    wndcls.lpszClassName = clsName;</span><br><span class="line">    wndcls.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wndcls.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    <span class="comment">//2 注册窗口</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wndcls);</span><br><span class="line">    <span class="comment">//3 创建窗口  句柄：标识？？  创建对象的一个标识： 图标 线程  应用 OVERLAPP</span></span><br><span class="line"></span><br><span class="line">    HWND hwnd;</span><br><span class="line">    hwnd = <span class="built_in">CreateWindow</span>(clsName, msgName, WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//4 显示和刷新窗口</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, SW_SHOWNORMAL);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 消息循环</span></span><br><span class="line">     <span class="comment">// 定义消息结构体，开始消息循环</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口交互响应处理</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinSunProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:</span><br><span class="line">        <span class="type">char</span> szChar[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">sprintf_s</span>(szChar, <span class="string">&quot;您刚按下了: %c&quot;</span>, wParam);</span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, szChar, <span class="string">&quot;char&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="string">&quot;检测到鼠标左键被按下&quot;</span>, <span class="string">&quot;message&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        PAINTSTRUCT ps;</span><br><span class="line">        hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;ps);</span><br><span class="line">        <span class="built_in">TextOut</span>(hdc, <span class="number">0</span>, <span class="number">0</span>, msgUrl, <span class="built_in">strlen</span>(msgUrl));</span><br><span class="line">        <span class="built_in">EndPaint</span>(hwnd, &amp;ps);</span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="string">&quot;重绘&quot;</span>, <span class="string">&quot;message&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        ret = <span class="built_in">MessageBox</span>(hwnd, <span class="string">&quot;是否真的结束？&quot;</span>, <span class="string">&quot;message&quot;</span>, MB_YESNO);</span><br><span class="line">        <span class="keyword">if</span> (ret == IDYES)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>(hwnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📋程序骨架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WinMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 设计窗口外观及交互响应，注册，申请专利</span></span><br><span class="line">   <span class="built_in">RegisterClass</span>(...)</span><br><span class="line">   <span class="comment">// 生产窗口</span></span><br><span class="line">   <span class="built_in">CreateWindow</span>(...)</span><br><span class="line">   <span class="comment">// 展示窗口</span></span><br><span class="line">   <span class="built_in">ShowWindow</span>(...)</span><br><span class="line">   <span class="comment">// 粉刷窗口</span></span><br><span class="line">   <span class="built_in">UpdateWindow</span>(...)</span><br><span class="line">   <span class="comment">// 进入消息循环</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(...)) &#123;</span><br><span class="line">     <span class="comment">// 消息转换</span></span><br><span class="line">     <span class="built_in">TranslateMessage</span>(...);</span><br><span class="line">     <span class="comment">// 消息分发</span></span><br><span class="line">     <span class="built_in">DispatchMessage</span>(...);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面是自动生成的【Windows桌面应用程序】模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// win32_demo.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;win32_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量:</span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明:</span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _In_ <span class="type">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(hPrevInstance);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此处放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    <span class="built_in">LoadStringW</span>(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    <span class="built_in">LoadStringW</span>(hInstance, IDC_WIN32DEMO, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    <span class="built_in">MyRegisterClass</span>(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化:</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">InitInstance</span> (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = <span class="built_in">LoadAccelerators</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDC_WIN32DEMO));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环:</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">TranslateAccelerator</span>(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">            <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目标: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="built_in">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = <span class="built_in">LoadIcon</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDI_WIN32DEMO));</span><br><span class="line">    wcex.hCursor        = <span class="built_in">LoadCursor</span>(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW<span class="number">+1</span>);</span><br><span class="line">    wcex.lpszMenuName   = <span class="built_in">MAKEINTRESOURCEW</span>(IDC_WIN32DEMO);</span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = <span class="built_in">LoadIcon</span>(wcex.hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterClassExW</span>(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目标: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = <span class="built_in">CreateWindowW</span>(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">ShowWindow</span>(hWnd, nCmdShow);</span><br><span class="line">   <span class="built_in">UpdateWindow</span>(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目标: 处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> wmId = <span class="built_in">LOWORD</span>(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择:</span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                <span class="built_in">DialogBox</span>(hInst, <span class="built_in">MAKEINTRESOURCE</span>(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                <span class="built_in">DestroyWindow</span>(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line">            <span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LOWORD</span>(wParam) == IDOK || <span class="built_in">LOWORD</span>(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">EndDialog</span>(hDlg, <span class="built_in">LOWORD</span>(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//1-2.PNG"></p><br><h3 id="1-5-重要概念"><a href="#1-5-重要概念" class="headerlink" title="1.5 重要概念"></a>1.5 重要概念</h3><h4 id="1-5-1-API与SDK"><a href="#1-5-1-API与SDK" class="headerlink" title="1.5.1 API与SDK"></a>1.5.1 API与SDK</h4><ul><li><code>Application Programming Interface</code> 应用程序编程接口。</li><li><code>Software Development Kit</code> 软件开发工具包，一般会包括API接口文档，示例文档，帮助文档，使用手册，相关工具等。</li></ul><br><h4 id="1-5-2-窗口与句柄-窗口类对象"><a href="#1-5-2-窗口与句柄-窗口类对象" class="headerlink" title="1.5.2 窗口与句柄/窗口类对象"></a>1.5.2 窗口与句柄/窗口类对象</h4><ul><li>窗口就是屏幕上的一片区域，接收用户的输入，显示程序的输出。可以包含标题栏，菜单栏，工具栏，控件等。</li><li>句柄【handle】【资源的编号，二级指针，门把手】：窗口句柄、文件句柄、数据库连接句柄。<ul><li><code>Void*</code>的句柄设计，有点之一在于将具体的头文件编译脱钩【如使用了<code>CFile</code>类，需要<code>CFile*</code>指针指明是CFile类才可以正常编译；但使用<code>Void*</code>后，隐藏了类细节，且保证编译通过，编程人员无需关心CFile类的变更迭代】</li><li>在具体的API函数中，填写<code>Void*</code>的句柄后，编译器根据函数定义中的对应形参要求，将填写的句柄指针自动转为所需类型。</li></ul></li></ul><blockquote><p>句柄设计的优势：编译脱钩、细节屏蔽。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++窗口类对象</span></span><br><span class="line">Cwnd Mywnd; </span><br><span class="line"><span class="comment">// 系统真实对象</span></span><br><span class="line">m_wnd</span><br></pre></td></tr></table></figure><p>C++窗口类对象与窗口并不是一回事，它们之间惟一的关系是C++窗口类对象内部定义了一个窗口句柄变量，保存了与这个C++窗口类对象相关的那个窗口的句柄。</p><blockquote><p>窗口销毁时，与之对应的C++窗口类对象销毁与否，要看其生命周期是否结束。但C++窗口类对象销毁时，与之相关的窗口也将销毁。</p></blockquote><br><h4 id="1-5-3-消息循环"><a href="#1-5-3-消息循环" class="headerlink" title="1.5.3 消息循环"></a>1.5.3 消息循环</h4><blockquote><p>Windows消息循环机制是Windows操作系统中GUI编程的核心部分，它是事件驱动编程模型的基础。</p></blockquote><p>每个运行中的Windows应用程序都有与之关联的一个消息队列，当产生消息后【比如点击鼠标就会产生鼠标按下的消息，由操作系统识别消息并分发】，操作系统会将消息放入消息队列，应用程序【通过getMessage函数获取消息，进入消息循环】会循环从消息队列中检索消息并处理。这就是Windows消息循环机制。</p><blockquote><p>有了消息队列以后，线程需要不断的去队列中取消息，并分发给各个GDI对象【图形设备接口】。因此，需要一个while循环，该循环称之为消息循环。</p></blockquote><p>在消息循环中，可以对消息做一些简单的过滤和处理，也可以什么都不做，直接将消息分发到对应想窗口消息处理函数中。</p><p>一个简单的消息循环包含调用以下三个函数：<code>GetMessage</code>，<code>TranslateMessage</code>，和<code>DispatchMessage</code>。</p><p><img src="/.io//1-3.png"></p><blockquote><p>左图为银行业务简单示例，右图为Windows消息循环。</p></blockquote><br><h4 id="1-5-4-回调函数"><a href="#1-5-4-回调函数" class="headerlink" title="1.5.4 回调函数"></a>1.5.4 回调函数</h4><blockquote><p>A君去某公司面试完后，人事经理说，” 不要打电话给我，我会打电话给你 “</p></blockquote><p>相对于轮询模式，回调的方式系统开销更小，即每当事件发生，才通知去处理。</p><br><h3 id="1-7-变量命名约定"><a href="#1-7-变量命名约定" class="headerlink" title="1.7 变量命名约定"></a>1.7 变量命名约定</h3><table><thead><tr><th>前缀</th><th>含义</th><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>数组 array</td><td>b</td><td>布尔值 bool</td></tr><tr><td>by</td><td>无符号字符(字节)</td><td>c</td><td>字符(字节)</td></tr><tr><td>cb</td><td>字节计数，即长度【count byte】</td><td>rgb</td><td>保存颜色值的长整型</td></tr><tr><td>cx,cy</td><td>短整型(计算x,y的长度)</td><td>dw</td><td>无符号长整型</td></tr><tr><td>fn</td><td>函数</td><td>h</td><td>句柄</td></tr><tr><td>i</td><td>整形(integer)</td><td>m_</td><td>类的数据成员member</td></tr><tr><td>n</td><td>短整型或整型</td><td>np</td><td>近指针</td></tr><tr><td>p</td><td>指针(pointer)</td><td>l</td><td>长整型(long)</td></tr><tr><td>lp</td><td>长指针，可能是其他线程或栈上的数据</td><td>s</td><td>字符串string</td></tr><tr><td>sz</td><td>以零结尾的字符串</td><td>tm</td><td>正文大小</td></tr><tr><td>w</td><td>无符号整型</td><td>x,y</td><td>无符号整型(表示x,y的坐标)</td></tr><tr><td>g_</td><td>全局变量</td><td></td><td></td></tr></tbody></table><br><h2 id="二-MFC程序开发流程"><a href="#二-MFC程序开发流程" class="headerlink" title="二 MFC程序开发流程"></a>二 MFC程序开发流程</h2><h3 id="2-1-项目创建"><a href="#2-1-项目创建" class="headerlink" title="2.1 项目创建"></a>2.1 项目创建</h3><ol><li><p>新建项目【MFC应用】，根据需要选择MFC应用程序类型【单个文档 | 多个文档 | 基于对话框 | 多个顶层文档】，此处选择对话框。</p><ul><li>基于对话框的程序：无菜单栏、工具栏，界面较为简单，可使用此类型对话框【典型的例子就是计算器】。</li><li>基于文档/视图的程序：标准的windows应用界面，含菜单栏、工具栏、状态栏等【如Word、WPS】。</li></ul></li><li><p>使用MFC，选择【在静态库中使用MFC】，可编译生成exe文件，可移植性较高，但编译后的体积大；而选择【在共享DLL中使用MFC】编译体积小</p></li><li><p>在【用户界面功能】中选择相应功能：粗框架、最大/最小化框、系统菜单【顶层窗口右键出现的菜单】、关于框，填写对话框标题。</p></li><li><p>高级功能选择默认，提供一些崩溃处理【后四个】。除此以外，勾选Windows套接字；且不需要打印。</p></li><li><p>资源视图中的<code>Dialog</code>文件下，选择 <code>IDD_MFCAPP_DIALOG</code> ，出现控件拖放界面。</p></li><li><p>在控件拖放界面打开类视图，右键单击 <code>CMFCAppDlg</code>，选择属性。在属性界面选择筛选项为消息，此时可查看可供使用的消息类型。【此处添加 <code>OnLButtonDown</code> 消息处理】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MFCAppDlg.cpp中，自动生成刚添加的消息处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCAppDlg::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;你好！&quot;</span>));</span><br><span class="line">    CDialogEx::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同文件的中的消息匹配【自动生成】：作用同win32中的switch_case</span></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMFCAppDlg, CDialogEx)</span><br><span class="line">    <span class="built_in">ON_WM_SYSCOMMAND</span>()</span><br><span class="line">    <span class="built_in">ON_WM_PAINT</span>()</span><br><span class="line">    <span class="built_in">ON_WM_QUERYDRAGICON</span>()</span><br><span class="line">    <span class="built_in">ON_WM_LBUTTONDOWN</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>不推荐勾选【解决方案与项目在同一文件夹】。不勾选时，一个解决方案可以有多个项目。</p></blockquote><br><h3 id="2-2-MFC与win32开发方式的区别"><a href="#2-2-MFC与win32开发方式的区别" class="headerlink" title="2.2 MFC与win32开发方式的区别"></a>2.2 MFC与win32开发方式的区别</h3><p>MFC适合Windows下的界面开发，是对<code>win32</code>的封装；而不需要界面的应用，最好用win32。</p><ul><li>定制界面的区别【手写代码 vs 拖放控件】</li><li>响应键盘、鼠标的区别【窗口处理函数 vs 消息映射机制】<ul><li>Win32中使用的窗口交互响应处理函数，其中使用 <code>switch_case</code> 处理消息。</li><li>MFC中使用消息映射机制</li></ul></li></ul><br><h3 id="2-3-MFC消息映射机制"><a href="#2-3-MFC消息映射机制" class="headerlink" title="2.3 MFC消息映射机制"></a>2.3 MFC消息映射机制</h3><p>📋<code>2.1</code>中的第六步，添加的是全局消息处理函数【左键按下消息】。</p><p>同样，可以双击控件，添加点击消息处理函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息映射表【自动生成】：作用同win32中的switch_case</span></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMFCAppDlg, CDialogEx)</span><br><span class="line">    <span class="built_in">ON_WM_SYSCOMMAND</span>()</span><br><span class="line">    <span class="built_in">ON_WM_PAINT</span>()</span><br><span class="line">    <span class="built_in">ON_WM_QUERYDRAGICON</span>()</span><br><span class="line">    <span class="built_in">ON_WM_LBUTTONDOWN</span>()</span><br><span class="line">    <span class="built_in">ON_BN_CLICKED</span>(IDOK, &amp;CMFCAppDlg::OnBnClickedOk)<span class="comment">//!!!</span></span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//MFCAppDlg.cpp中，自动生成刚添加的消息处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCAppDlg::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;你好！&quot;</span>));<span class="comment">// 提示内容，而标题title，默认为项目名【MFCApp】</span></span><br><span class="line">    CDialogEx::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCAppDlg::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// MessageBox(提示内容,提示框标题title,取消处理函数)</span></span><br><span class="line">    UINT ret = <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;确认吗？&quot;</span>), _T(<span class="string">&quot;退出确认&quot;</span>), MB_OKCANCEL);</span><br><span class="line">    <span class="keyword">if</span> (ret == IDOK)</span><br><span class="line">    &#123;</span><br><span class="line">        CDialogEx::<span class="built_in">OnOK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【<code>MFCAppDlg.cpp</code>】自动生成：消息映射表</li><li>【<code>MFCAppDlg.cpp</code>】自动生成：消息响应函数</li><li>自动在头文件【<code>MFCAppDlg.h</code>】中生成：消息响应函数的声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMFCAppDlg 对话框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCAppDlg</span> : <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMFCAppDlg</span>(CWnd* pParent = <span class="literal">nullptr</span>);	<span class="comment">// 标准构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; IDD = IDD_MFCAPP_DIALOG &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;	<span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    HICON m_hIcon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成的消息映射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnSysCommand</span><span class="params">(UINT nID, LPARAM lParam)</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnPaint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg HCURSOR <span class="title">OnQueryDragIcon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span>;<span class="comment">//#############</span></span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnBnClickedOk</span><span class="params">()</span></span>;<span class="comment">//######################################</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/.io//2-1.PNG"></p><br><h3 id="2-4-体会MFC程序的运行过程"><a href="#2-4-体会MFC程序的运行过程" class="headerlink" title="2.4 体会MFC程序的运行过程"></a>2.4 体会MFC程序的运行过程</h3><blockquote><p>此小节紧接在第三章创建MFCPaint应用之后。</p></blockquote><h4 id="2-4-1-断点逐过程执行Main函数"><a href="#2-4-1-断点逐过程执行Main函数" class="headerlink" title="2.4.1 断点逐过程执行Main函数"></a>2.4.1 断点逐过程执行Main函数</h4><p>为了体会MFC应用的运行过程，双击类视图中的 <code>CMFCPaintApp</code> ，出现头文件，包含<code>CMFCPaintApp</code>的定义。</p><p>右键菜单选择该类的代码实现，转到 <code>MFCPaint.cpp</code>，在 <code>BOOL CMFCPaintApp::InitInstance()</code> 该函数的第一行代码处打上断点，然后逐过程执行代码。</p><ol><li><p>可以看到，首先进入了MFC框架内部的<code>main</code>函数【即<code>appmoudl.cpp</code>中的<code>_tWinMain()</code>】，并返回<code>AfxWinMain()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> WINAPI</span><br><span class="line">_tWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">    _In_ LPTSTR lpCmdLine, _In_ <span class="type">int</span> nCmdShow)</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(suppress: 4985)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// call shared/exported WinMain</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AfxWinMain</span>(hInstance, hPrevInstance, lpCmdLine, nCmdShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>AfxWinMain</code>函数中，会执行应用的初始化函数<code>InitInstance()</code>，初始化成功时进入线程的运行状态。在初始化函数中，包含了窗口的初始化、显示、更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> AFXAPI <span class="title">AfxWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPTSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(hPrevInstance == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nReturnCode = <span class="number">-1</span>;</span><br><span class="line">    CWinThread* pThread = <span class="built_in">AfxGetThread</span>();</span><br><span class="line">    CWinApp* pApp = <span class="built_in">AfxGetApp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AFX internal initialization</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxWinInit</span>(hInstance, hPrevInstance, lpCmdLine, nCmdShow))</span><br><span class="line">        <span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// App global initializations (rare)</span></span><br><span class="line">    <span class="keyword">if</span> (pApp != <span class="literal">NULL</span> &amp;&amp; !pApp-&gt;<span class="built_in">InitApplication</span>())</span><br><span class="line">        <span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform specific initializations</span></span><br><span class="line">    <span class="keyword">if</span> (!pThread-&gt;<span class="built_in">InitInstance</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pThread-&gt;m_pMainWnd != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: Destroying non-NULL m_pMainWnd\n&quot;</span>);</span><br><span class="line">            pThread-&gt;m_pMainWnd-&gt;<span class="built_in">DestroyWindow</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        nReturnCode = pThread-&gt;<span class="built_in">ExitInstance</span>();</span><br><span class="line">        <span class="keyword">goto</span> InitFailure;</span><br><span class="line">    &#125;</span><br><span class="line">    nReturnCode = pThread-&gt;<span class="built_in">Run</span>();<span class="comment">//#############线程运行状态###############</span></span><br><span class="line"></span><br><span class="line">InitFailure:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">// Check for missing AfxLockTempMap calls</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AfxGetModuleThreadState</span>()-&gt;m_nTempMapLock != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: Temp map lock count non-zero (%ld).\n&quot;</span>,</span><br><span class="line">            <span class="built_in">AfxGetModuleThreadState</span>()-&gt;m_nTempMapLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AfxLockTempMaps</span>();</span><br><span class="line">    <span class="built_in">AfxUnlockTempMaps</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AfxWinTerm</span>();</span><br><span class="line">    <span class="keyword">return</span> nReturnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程结束，则AfxWinMain函数结束。</p></li></ol><br><h4 id="2-4-2-结合绘图过程再谈消息映射机制"><a href="#2-4-2-结合绘图过程再谈消息映射机制" class="headerlink" title="2.4.2 结合绘图过程再谈消息映射机制"></a>2.4.2 结合绘图过程再谈消息映射机制</h4><p>MFCPaint要实现的最简单的功能是：在DocView控件中画出直线。</p><p>剖析该功能的运行过程：</p><ol><li>产生两个事件：鼠标左键按下、拖动、松开，操作系统收到事件后，投递给MFC应用。</li><li>MFC应用将事件转为相应的消息，并投递给应用中的所有控件。</li><li>除了点击消息坐标相符的控件会响应以外，其他控件都不会处理该消息，即最终经过层层投递，DocView控件接收到消息并处理【每次处理一个消息】。</li></ol><br><h2 id="三-简单绘图与文本编程"><a href="#三-简单绘图与文本编程" class="headerlink" title="三 简单绘图与文本编程"></a>三 简单绘图与文本编程</h2><h3 id="3-1-项目创建与引入"><a href="#3-1-项目创建与引入" class="headerlink" title="3.1 项目创建与引入"></a>3.1 项目创建与引入</h3><p>首先创建本节的MFC项目：</p><ul><li><p>此处创建新项目<code>MFCPaint</code>，项目应用程序类型选择【单个文档】，项目样式默认【Visual Stdio】，视觉样式和颜色选择【Windows Native/Default】，选择在静态库中使用MFC。</p></li><li><p>在文档模板属性中，若填写文件扩展名，则该扩展名的文件都会使用本程序打开。</p></li><li><p>在高级功能中勾选套接字，最近文件列表数修改为16【按需】，无需打印。</p></li><li><p>在生成的类中，文件名推荐为默认即可。</p></li></ul><p>在单文档视图结构中，四个重要的类：</p><ul><li>APP：MFC应用的入口函数，其包含main函数，但被隐藏。</li><li>MainFrame：主框架，包括菜单栏、工具栏、状态栏等。</li><li>View：控制显示，文档视图。</li><li>Doc：文档，为View提供内容。</li></ul><blockquote><p>而在多文档结构中，只是在单文档结构的基础上，多了调度的部分，允许主框架中有多了文档和视图。</p></blockquote><p><img src="/.io//3-1.PNG" alt="img"></p><blockquote><p>初学者会在解决方案资源管理器中看多众多cpp和头文件，其实无需头疼，只需关注【类视图】，见上图右，具体的各个类的用途稍后详述，该项目的初始运行截图见下图。</p></blockquote><p><img src="/.io//3-2.PNG" alt="img"></p><br><p>🔺这种架构属于MVC，即Model、View、Controller，模型、视图和控制。</p><ul><li>模型即纯数据</li><li>视图：目之所见。</li><li>控制器：控制模型数据显示在视图之上，包括数据的增删改查，否则数据就是固定写死的。</li></ul><p>所有带<code>View</code>的都是视图，需要在 <code>MFCPaintView</code> 中编写代码。</p><br><h3 id="3-2-画线"><a href="#3-2-画线" class="headerlink" title="3.2 画线"></a>3.2 画线</h3><p>关键信息：</p><ul><li>屏幕坐标点和客户坐标点</li><li>设备上下文【Device Content, DC】</li><li>事件</li></ul><p>起点和终点：</p><ul><li>如何捕捉这两点？ 【鼠标左键按下：起点， 鼠标左键抬起：终点】</li><li>点如何表示：CPoint【MFC内置类】<ol><li>记录起始点的坐标【鼠标左键按下】</li><li>记录结束点的坐标【鼠标左键起来】</li></ol></li></ul><br><p>上面提到，需要在 <code>MFCPaintView.cpp</code> 中编写代码。故依次操作：</p><ol><li><p>打开类视图，右键单击 <code>CMFCPaintView</code> ，在右键菜单中选择属性，在属性控件中选择【消息】，查看可处理的消息类型。</p></li><li><p>此处要实现画线功能，故需要关注鼠标左键按下和松开的两个事件【<code>WM_LBUTTONDOWN</code> | <code>WM_LBUTTONUP</code>】。</p></li><li><p>在两个事件标记右侧点击箭头，选择Add Message，即可在<code>MFCPaintView.cpp</code>中添加消息处理函数。</p></li><li><p>考虑到两个不同的消息，会产生两个不同的坐标，故需要在<code>MFCPaintView.h</code>中定义<code>protected</code>的变量来保存两个坐标。</p><ul><li>此处使用<code>m_start</code>/<code>m_stop</code>，并在消息处理函数中记录两个点坐标。</li><li>调试：可以在消息处理函数中的赋值处，打上断点，通过调试查看是否记录坐标】</li></ul><p><img src="/.io//3-3.PNG" alt="img"></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MFCPaintView.cpp中的消息处理函数</span></span><br><span class="line"><span class="comment">// CMFCPaintView 消息处理程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_start = point;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);	<span class="comment">// 默认的消息处理，继续往下传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_stop = point;</span><br><span class="line">    CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的有：</p><ul><li>此处的<code>CPoint</code>类，继承自一个包含横纵坐标的结构体。可以看到，C++中的类和struct是一回事，唯一区别在于权限。</li><li>此处得到的坐标为用户坐标，即相对于MFC应窗口的坐标。</li><li>在消息处理函数处理完点击消息，依然需要默认的消息处理函数，即需要继续往下传递消息。最典型的例子就是<code>Destroy</code>消息，如果不继续传递，可能某些子控件无法销毁，从而导致内存泄漏或崩溃。</li></ul><br><p>在画直线之前，需要知道：</p><p>📋什么是上下文？</p><ul><li>以绘制直线为例，上下文包括：画笔的宽度、线型、颜色等，背景、范围坐标、状态【最大化|最小化】等。</li><li>窗口上下文包括：窗口位置、状态、注册消息、消息响应函数等。</li></ul><p>📋什么是设备上下文？</p><ul><li>此处的设备，特指显示设备，可以超出窗口之外。</li><li>获取设备上下文：<code>CDC *cdc = getDC()；</code></li></ul><br><p>下面，我们来画直线：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_start = point;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);	<span class="comment">// 默认的消息处理，继续往下传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_stop = point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CDC: The device context</span></span><br><span class="line">    <span class="comment">// 获取设备上下文</span></span><br><span class="line">    CDC* pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">    <span class="comment">// 移动画笔</span></span><br><span class="line">    pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">    <span class="comment">// 画直线</span></span><br><span class="line">    pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line">    <span class="comment">// 释放CDC【CDC是独占式使用的】</span></span><br><span class="line">    <span class="built_in">ReleaseDC</span>(pDC);</span><br><span class="line">    <span class="comment">// 此时只有在点击-&gt;拖动-&gt;松开鼠标之后才出现直线，拖动过程中无展示</span></span><br><span class="line"></span><br><span class="line">    CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，只有在点击 -&gt; 拖动 -&gt; 松开鼠标之后才出现直线，拖动过程中无展示。</p><p>为了在拖动过程中也展示直线状态，做以下工作：</p><ul><li>添加<code>BOOL</code>的新类成员变量：<code>m_status</code>【需要在<code>CMFCPaintView</code> 类的构造函数中对<code>m_status</code>初始化为<code>FALSE</code>】</li><li>新增消息处理函数：<code>WM_MOUSEMOVE</code>【鼠标移动：当<code>m_status</code>开启则绘制线条预览，否则什么都不做】</li><li>上面的消息不是最好的选择，因为其绘画状态线一直在闪动，且会刷新之前的画线。<ul><li>鼠标移动时，线条闪动原因：每次鼠标移动，都会运行<code>InvalidateRect(NULL)</code> 触发重绘，重绘会调用<code>OnDraw()</code>。如果在<code>OnDraw()</code>中再次绘制预览线，会非常顺滑，即【刷新 <code>-&gt;</code> <code>OnDraw()</code>绘制预览直线】；如果在鼠标移动处理函数中绘制预览线，会闪动，即【刷新 <code>-&gt;</code> <code>OnDraw()</code>空函数 <code>-&gt;</code> 回调函数返回并绘制预览线】。</li></ul></li><li>最好的办法是在 <code>OnDraw()</code>中显示预览。【需要在<code>CMFCPaintView</code>的构造函数中对<code>m_start</code>、<code>m_stop</code>、<code>m_cur</code>初始化，并在鼠标移动的消息处理中为<code>m_cur</code>赋值】</li><li>如果不想清除上一次画的线，就需要在<code>OnDraw()</code>中使用列表来存储。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line">    <span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line">    <span class="keyword">if</span> (!pDoc)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">    <span class="keyword">if</span> (m_status)</span><br><span class="line">    &#123;</span><br><span class="line">        pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">        pDC-&gt;<span class="built_in">LineTo</span>(m_cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">        pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_start = point;</span><br><span class="line">    m_status = TRUE;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);	<span class="comment">// 默认的消息处理，继续往下传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_stop = point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CDC: The device context</span></span><br><span class="line">    <span class="comment">// 获取设备上下文</span></span><br><span class="line">    CDC* pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">    <span class="comment">// 移动画笔</span></span><br><span class="line">    pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">    <span class="comment">// 画直线</span></span><br><span class="line">    pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line">    <span class="comment">// 释放CDC【CDC是独占式使用的】</span></span><br><span class="line">    <span class="built_in">ReleaseDC</span>(pDC);</span><br><span class="line">    <span class="comment">// 此时只有在点击-&gt;拖动-&gt;松开鼠标之后才出现直线，拖动过程中无展示</span></span><br><span class="line"></span><br><span class="line">    m_status = FALSE;</span><br><span class="line"></span><br><span class="line">    CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_status)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cur = point;</span><br><span class="line">        <span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);<span class="comment">//重绘【触发界面刷新清空】触发OnDraw()</span></span><br><span class="line">        <span class="comment">/*CDC* pDC = GetDC();</span></span><br><span class="line"><span class="comment">        pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">        pDC-&gt;LineTo(point);</span></span><br><span class="line"><span class="comment">        ReleaseDC(pDC);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这种写法也会刷新之前画的线，也存在问题</span></span><br><span class="line">    <span class="comment">// 最好的办法是在 OnDraw()中显示预览</span></span><br><span class="line">    </span><br><span class="line">    CView::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//3-4.PNG"></p><br><h3 id="3-3-画笔"><a href="#3-3-画笔" class="headerlink" title="3.3 画笔"></a>3.3 画笔</h3><p>调整上一节的代码，将绘制任务集中在 <code>OnDraw()</code> 函数中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_start = point;</span><br><span class="line">    m_status = TRUE;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);	<span class="comment">// 默认的消息处理，继续往下传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    m_stop = point;</span><br><span class="line">    m_status = FALSE;</span><br><span class="line">    <span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);<span class="comment">//异步触发重绘，绘制目标直线</span></span><br><span class="line">    </span><br><span class="line">    CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_status)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cur = point;</span><br><span class="line">        <span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);<span class="comment">//重绘【触发界面刷新清空】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CView::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>OnDraw()</code>中修改画笔属性并选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPen类定义的构造函数原型</span></span><br><span class="line"><span class="built_in">CPen</span>(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, COLORREF crColor);<span class="comment">//笔形，线宽，颜色</span></span><br><span class="line"><span class="comment">//PS_SOLID 实线， PS_DASH 虚线， PS_DOT 点线， PS_DOTDASH 点划线</span></span><br></pre></td></tr></table></figure><blockquote><p>当线宽大时，会看不出线形的变化，即只能在线宽为1时，才可以清晰看到线形。</p><p>如果想保留线形，还想加宽，可以尝试画多条1像素宽的垂直位移1像素的相同线条。当然这种办法也会出现新的问题，相应解决即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line">    <span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line">    <span class="keyword">if</span> (!pDoc)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">    <span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">1</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    CPen* pOldPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);	<span class="comment">// 上下文选择画笔，返回原画笔，用完即还原</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证查看原画笔线形</span></span><br><span class="line">    LOGPEN logpen;</span><br><span class="line">    pOldPen-&gt;<span class="built_in">GetLogPen</span>(&amp;logpen);</span><br><span class="line">    <span class="built_in">TRACE</span>(<span class="string">&quot;\n%d  Color:%08x  width=%d\r\n&quot;</span>, logpen.lopnStyle, logpen.lopnColor, logpen.lopnWidth);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_status)</span><br><span class="line">    &#123;</span><br><span class="line">        pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">        pDC-&gt;<span class="built_in">LineTo</span>(m_cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">        pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line">    &#125;</span><br><span class="line">    pDC-&gt;<span class="built_in">SelectObject</span>(pOldPen);	<span class="comment">//还原画笔，pen作为局部变量也会被析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意此处的 <code>TRACE()</code> 的调试方法，在【输出】窗口出现调试信息，双击可跳转到对应的<code>TRACE</code>语句。</p></blockquote><br><h3 id="3-4-画刷【填充】"><a href="#3-4-画刷【填充】" class="headerlink" title="3.4 画刷【填充】"></a>3.4 画刷【填充】</h3><p>本节画矩形并填充颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMFCPaintView 绘图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line">    <span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line">    <span class="keyword">if</span> (!pDoc)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">    <span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">1</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    CPen* pOldPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);	<span class="comment">// 上下文选择画笔，返回原画笔，用完即还原</span></span><br><span class="line"></span><br><span class="line">    <span class="function">CBrush <span class="title">brush</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">    <span class="function">CBrush <span class="title">brush2</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    CBrush* pOldBrush = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;brush);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">        pDC-&gt;LineTo(m_cur);*/</span></span><br><span class="line">        pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_cur), &amp;brush);<span class="comment">//此处的brush可以为NULL，默认使用上下文画刷</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">        pDC-&gt;LineTo(m_stop);*/</span></span><br><span class="line">        pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_stop), &amp;brush2);<span class="comment">// 鼠标左键松开后使用brush2</span></span><br><span class="line">    &#125;</span><br><span class="line">    pDC-&gt;<span class="built_in">SelectObject</span>(pOldPen);	<span class="comment">//还原画笔，pen作为局部变量也会被析构</span></span><br><span class="line">    pDC-&gt;<span class="built_in">SelectObject</span>(pOldBrush);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//3-5.PNG" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考</span></span><br><span class="line"><span class="function">CBrush <span class="title">brush</span><span class="params">(RBG(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CClientDC【上下文的初始化方式】：从this复制一份</span></span><br><span class="line"><span class="comment">// class CClientDC : public CDC</span></span><br><span class="line"><span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dc.<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(起点，终点)， &amp;brush);</span><br></pre></td></tr></table></figure><br><h3 id="3-5-文本编程"><a href="#3-5-文本编程" class="headerlink" title="3.5 文本编程"></a>3.5 文本编程</h3><blockquote><p>MFC的对象基本都有几个阶段：</p><ol><li>构造阶段：初始化成员变量。</li><li>创建阶段Create：将对象和窗口绑定。</li><li>可选状态：二选一<ol><li>showWindow阶段：如View，用于显示。</li><li>DoModal阶段：如Dialog，须要执行一些操作。</li></ol></li><li>Destroy销毁阶段：使对象和窗口无效。</li><li>Delete：删除对象 。</li></ol></blockquote><p>文本编程的光标，需要在Create阶段加入View。</p><blockquote><p>故在 <code>MFCPaintView.cpp</code> 中添加 <code>Create</code> 的【<strong>重构</strong>】函数【与消息按钮同一列】。此处错误！</p></blockquote><blockquote><p>准确的说，应该在Create阶段结束，将光标加入。故在 <code>MFCPaintView.cpp</code> 中添加 <code>OnCreate</code> 的消息处理函数。</p></blockquote><p>📋第一步：创建插入符并且显示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOOL CMFCPaintView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"><span class="comment">    return CView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CMFCPaintView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CView::<span class="built_in">OnCreate</span>(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">    <span class="comment">//CreateSolidCaret(3, 20);// 创建固定大小光标，但实际上光标大小与上下文DC有关</span></span><br><span class="line">    <span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//度量 该函数把程序的当前字体信息，存放到TEXTMETRIC</span></span><br><span class="line">    TEXTMETRICW tm;</span><br><span class="line">    <span class="comment">// GetTextMetrics函数转到定义发现是宏定义，其实不是。可以在CClientDC或CDC的成员函数中找到。</span></span><br><span class="line">    <span class="comment">// BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const; </span></span><br><span class="line">    <span class="comment">// 其参数为 LPTEXTMETRIC，转到定义，其本质是个tagTEXTMETRICW结构体。</span></span><br><span class="line">    <span class="comment">/*typedef struct tagTEXTMETRICW</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        LONG        tmHeight;			// 高</span></span><br><span class="line"><span class="comment">        LONG        tmAveCharWidth;		// 平均字符宽度</span></span><br><span class="line"><span class="comment">        LONG        tmMaxCharWidth;		// 最大字符宽度</span></span><br><span class="line"><span class="comment">        LONG        tmWeight;			// 字体磅数</span></span><br><span class="line"><span class="comment">        BYTE        tmItalic;			// 是否是斜体</span></span><br><span class="line"><span class="comment">        BYTE        tmUnderlined;		// 是否下划线</span></span><br><span class="line"><span class="comment">        BYTE        tmStruckOut;		// 是否突出</span></span><br><span class="line"><span class="comment">        BYTE        tmCharSet;			//字符集</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    dc.<span class="built_in">GetTextMetrics</span>(&amp;tm);</span><br><span class="line">    <span class="comment">//为系统插入一个 插入符</span></span><br><span class="line">    <span class="built_in">CreateSolidCaret</span>(tm.tmAveCharWidth / <span class="number">8</span>,tm.tmHeight);<span class="comment">// 宽可以固定为3</span></span><br><span class="line">    <span class="built_in">ShowCaret</span>();<span class="comment">// 展示光标</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此处可能存在失去焦点后，光标丢的是BUG，后期再说。</p></blockquote><p>📋第二步：<code>onchar</code>消息处理函数处理：文字键入</p><blockquote><p>该消息处理函数会接收到字符键入，需要有成员变量来暂存字符，故在 <code>MFCPaintView.h</code> 中定义<code>protected</code>的类成员变量：<code>CString m_strText;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnChar</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    <span class="built_in">TRACE</span>(<span class="string">&quot;%c\r\n&quot;</span>,nChar);</span><br><span class="line">    <span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    m_strText += (TCHAR)nChar;	<span class="comment">// 创建的MFC项目默认为宽字符，允许有UNICODE出现</span></span><br><span class="line">    dc.<span class="built_in">TextOut</span>(<span class="number">0</span>,<span class="number">0</span>,m_strText);	<span class="comment">// 输出、绘制，【不支持多行显示】，换行回车需要额外处理</span></span><br><span class="line">    </span><br><span class="line">    CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时存在一些问题：1、有闪动的情况；2、无法处理回车；3、光标始终在最开始的位置。</p></blockquote><p>解决方法：</p><ol><li>将绘制函数 <code>dc.TextOut</code> 直接追加至 <code>onDraw</code> 中，在 <code>OnChar</code> 处理函数仅仅刷新界面触发 <code>onDraw</code> 即可。</li><li>在<code>onDraw</code> 中对换行符做特殊处理。</li><li>调整光标位置。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnChar</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    <span class="comment">//TRACE(&quot;%c\r\n&quot;, nChar);</span></span><br><span class="line">    <span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    m_strText += (TCHAR)nChar;	<span class="comment">// 创建的MFC项目默认为宽字符，允许有UNICODE出现</span></span><br><span class="line">    <span class="comment">//dc.TextOut(0,0,m_strText);	// 输出</span></span><br><span class="line">    <span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);</span><br><span class="line">    CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CMFCPaintView 绘图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line">    <span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line">    <span class="keyword">if</span> (!pDoc)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">    <span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">1</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    CPen* pOldPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);	<span class="comment">// 上下文选择画笔，返回原画笔，用完即还原</span></span><br><span class="line"></span><br><span class="line">    <span class="function">CBrush <span class="title">brush</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">    <span class="function">CBrush <span class="title">brush2</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    CBrush* pOldBrush = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;brush);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">        pDC-&gt;LineTo(m_cur);*/</span></span><br><span class="line">        pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_ptStart, m_ptCur), &amp;brush);<span class="comment">//此处的brush可以为NULL，默认使用上下文画刷</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">        pDC-&gt;LineTo(m_stop);*/</span></span><br><span class="line">        pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_ptStart, m_ptStop), &amp;brush2);<span class="comment">// 鼠标左键松开后使用brush2</span></span><br><span class="line">    &#125;</span><br><span class="line">    pDC-&gt;<span class="built_in">SelectObject</span>(pOldPen);	<span class="comment">//还原画笔，pen作为局部变量也会被析构</span></span><br><span class="line">    pDC-&gt;<span class="built_in">SelectObject</span>(pOldBrush);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【文本编辑】</span></span><br><span class="line">    <span class="comment">// 1固定输出；2只能单行输出</span></span><br><span class="line">    <span class="comment">//pDC-&gt;TextOut(0, 0, m_strText);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最简单的做法就是：遍历</span></span><br><span class="line">    CString sub = _T(<span class="string">&quot;&quot;</span>);<span class="comment">// 存储需要输出的无换行的一行字符</span></span><br><span class="line">    <span class="comment">// 关于此处的_T()，因为本项目为宽字符集的编程，而&quot;&quot;本质是const char[],为多字符集</span></span><br><span class="line">    <span class="comment">// 故需要用到_T宏，会根据字符集设置添加一个L：#define __T(x)      L ## x</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;	<span class="comment">//存储行数，实际上为显示的纵坐标</span></span><br><span class="line">    <span class="comment">// 思路：遍历字符串。不是回车则加入sub；如果是，则输出sub，并置空sub，行数/行高增加，跳过该字符。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_strText.<span class="built_in">GetLength</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调试发现没有\n，只有\r。【还留着\n是处理复制粘贴到\n的情况】</span></span><br><span class="line">        <span class="keyword">if</span> ((m_strText.<span class="built_in">GetAt</span>(i) == <span class="string">&#x27;\n&#x27;</span>) || (m_strText.<span class="built_in">GetAt</span>(i) == <span class="string">&#x27;\r&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, y, sub);</span><br><span class="line">            CSize sz = pDC-&gt;<span class="built_in">GetTextExtent</span>(sub);<span class="comment">// 必须在sub.Empty之前，此时y=20</span></span><br><span class="line">            sub.<span class="built_in">Empty</span>();</span><br><span class="line">            <span class="comment">//CSize sz = pDC-&gt;GetTextExtent(sub);// 此时y=0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//y += 20;</span></span><br><span class="line">            y = y + sz.cy + <span class="number">3</span>;<span class="comment">// + 字符高 + 行距</span></span><br><span class="line">            <span class="comment">//TRACE(&quot;y=%d\n\r&quot;, sz.cy);</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sub += m_strText.<span class="built_in">GetAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sub.<span class="built_in">IsEmpty</span>() == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, y, sub);<span class="comment">//最后一次输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【设置光标位置】: 1功能函数 2思考使用细节</span></span><br><span class="line">    CSize sz = pDC-&gt;<span class="built_in">GetTextExtent</span>(sub);<span class="comment">// 获取sub的扩展信息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CPoint pt;</span></span><br><span class="line"><span class="comment">    pt.y = y;</span></span><br><span class="line"><span class="comment">    // 由于字符宽度不一致，如w的宽度是l的几倍。故需要借助pDC来计算</span></span><br><span class="line"><span class="comment">    pt.x = sz.cx;</span></span><br><span class="line"><span class="comment">    SetCaretPos(pt);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">SetCaretPos</span>(<span class="built_in">CPoint</span>(sz.cx + <span class="number">2</span>, y));<span class="comment">//简写</span></span><br><span class="line">    <span class="comment">//::SetCaretPos(sz.cx + 2, y);// 直接使用系统API，而非MFC的API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建插入符并且显示</span></span><br><span class="line"><span class="comment">//2、onchar  文字消息</span></span><br><span class="line">    <span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建字体</span></span><br><span class="line">    CFont font;</span><br><span class="line">    font.<span class="built_in">CreatePointFont</span>(<span class="number">300</span>, _T(<span class="string">&quot;华文行楷&quot;</span>),<span class="literal">NULL</span>);</span><br><span class="line">    CFont* pOldFont = dc.<span class="built_in">SelectObject</span>(&amp;font);</span><br><span class="line">    <span class="comment">// 该函数把程序的当前字体信息，存放到TEXTMETRIC 123</span></span><br><span class="line">    TEXTMETRIC tm;</span><br><span class="line">    dc.<span class="built_in">GetTextMetrics</span>(&amp;tm);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0X08</span> == nChar) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//退格</span></span><br><span class="line">        COLORREF clr = dc.<span class="built_in">SetTextColor</span>(dc.<span class="built_in">GetBkColor</span>()); </span><br><span class="line">        dc.<span class="built_in">TextOut</span>(m_ptorigin.x, m_ptorigin.y, m_strline);</span><br><span class="line">        m_strline = m_strline.<span class="built_in">Left</span>(m_strline.<span class="built_in">GetLength</span>() - <span class="number">1</span>);</span><br><span class="line">        dc.<span class="built_in">SetTextColor</span>(clr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0X0D</span> == nChar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//回车键</span></span><br><span class="line">        m_strline.<span class="built_in">Empty</span>();</span><br><span class="line">        m_ptorigin.y += tm.tmHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_strline += <span class="type">__wchar_t</span>(nChar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 坐标右移 1.1得到字体的大小 1.2找到原始坐标   </span></span><br><span class="line">    CSize sz = dc.<span class="built_in">GetTextExtent</span>(m_strline); </span><br><span class="line">    CPoint pt;</span><br><span class="line">    pt.x = m_ptorigin.x + sz.cx;</span><br><span class="line">    pt.y = m_ptorigin.y ;</span><br><span class="line">    <span class="comment">// 2 插入符右移</span></span><br><span class="line">    <span class="built_in">SetCaretPos</span>(pt);</span><br><span class="line">    <span class="comment">//3 显示插入的文字</span></span><br><span class="line">    dc.<span class="built_in">TextOut</span>(m_ptorigin.x, m_ptorigin.y,m_strline);</span><br><span class="line">    dc.<span class="built_in">SelectObject</span>(pOldFont);</span><br><span class="line">    CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br></pre></td></tr></table></figure><p>需要注意几点：</p><ul><li>注意此处成员变量的命名规范，MFC和Windows都遵循这样的命名规范。<ul><li>如 <code>m_bStatus</code> ：表示成员变量，类型为BOOL，变量名原始名为 <code>status</code>。</li></ul></li><li>很多处理加入到 <code>OnDraw</code> 处理函数中，便不会受窗口最大化最小化、窗口的变形遮挡等操作的影响，消息一旦发出便会绘制关键信息，保证绘制内容一直都在。</li><li>关于此处的<code>_T()</code>：<ul><li>因为本项目为宽字符集的编程，而<code>&quot;&quot;</code>本质是<code>const char[]</code>，是多字符集。 故需要用到<code>_T</code>宏，其会根据字符集设置添加一个L：<code>#define __T(x) L ## x</code></li><li><code>_T</code>宏在宽字符集和多字符集之间切换时非常有用，可以不改变源码。</li></ul></li><li>经过调试发现，回车触发的<code>OnChar</code> 只捕获到了<code>\r</code>，而没有捕获到<code>\n</code>。<ul><li>在<code>if</code>中除了<code>\r</code>，依然留着<code>\n</code>，是为了处理复制粘贴到<code>\n</code>的情况。</li><li>另一个处理思路：在数据源头上将<code>\r</code>转为<code>\n</code>。当然怎么选择取决于业务环境和需求。</li><li>MFC编程的核心其实在于对于消息处理的经验。</li><li>编写代码时，下断点、单步调试、设置监视变量等，都是必备技巧。</li></ul></li></ul><br><h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><p>MFC 中绝大多数处理的都是默认消息，其处理思路如下：</p><ol><li><p>确认响应什么消息【除了可以简单理解的，还需要注意 <code>WM_CREATE</code>、<code>WM_PAINT</code> 等】</p></li><li><p>添加消息响应函数</p></li><li><p>追加消息响应内容</p></li></ol><blockquote><p>关于<code>WM_PAINT</code>，在显示窗口之后，即调用 <code>showWindow</code>或<code>DoModel</code> 绘制主框架后，就会发出一个绘制消息<code>WM_PAINT</code>给窗口中的所有控件和子控件，各自绘制各自的View【菜单栏、工具栏、左边栏、右边栏、下边栏、内容区、状态栏】</p></blockquote><p>难点在于：</p><ol><li>难以确认涉及的消息【通过学习和查资料】</li><li>每个消息的处理约束难以掌握</li></ol><br><h2 id="四-菜单与工具栏"><a href="#四-菜单与工具栏" class="headerlink" title="四 菜单与工具栏"></a>四 菜单与工具栏</h2><h3 id="4-1-基本菜单操作"><a href="#4-1-基本菜单操作" class="headerlink" title="4.1 基本菜单操作"></a>4.1 基本菜单操作</h3><p>📋新建子菜单和菜单项，并修改相关属性</p><ol><li><p>资源视图 –&gt; <code>Menu</code> –&gt; <code>IDR_MAINFRAME</code>， 双击打开菜单编辑器。</p></li><li><p>插入【绘图】顶层菜单，并在右侧属性栏编辑：</p><ol><li>Caption描述：<code>绘图(&amp;P)</code>，显示为<code>绘图(P)</code>【快捷键】。</li></ol></li><li><p>在绘图下添加菜单项，添加快捷键【Alt + 按键】、对ID命名，修改【属性：弹出菜单Popup】为False，否则无法添加事件处理程序，也无法修改ID</p><ol><li>添加子菜单【画直线】，快捷键为<code>L</code>，按命名规范对<code>ID</code>进行命名【<code>ID_DRAW_LINE</code>】</li><li>添加子菜单【画矩形】，快捷键为<code>R</code>，按命名规范对<code>ID</code>进行命名【<code>ID_DRAW_RECT</code>】</li><li>添加子菜单【画椭圆】，快捷键为<code>E</code>，按命名规范对<code>ID</code>进行命名【<code>ID_DRAW_ELLIPSE</code>】</li><li>添加子菜单【画笔】，快捷键为<code>P</code>，按命名规范对<code>ID</code>进行命名【<code>ID_PEN</code>】</li></ol><p><img src="/.io//4-1.png"></p></li></ol><blockquote><p><code>ID</code>命名技巧：程序中会用到多种资源，在为资源确定其ID号时，为了明确区分资源类型，一般都遵循这样一个原则：在“ID”字符串后加上一个标识资源类型的字母。</p><p>例如，<code>IDM_</code>，M表示这是<code>Menu</code>，即菜单资源。其他诸如光标(Cursor)资源，使用 <code>IDC_</code>；图标资源(Icon)，使用 <code>IDI_</code>。</p></blockquote><br><h3 id="4-2-添加事件处理程序"><a href="#4-2-添加事件处理程序" class="headerlink" title="4.2 添加事件处理程序"></a>4.2 添加事件处理程序</h3><p>📋为菜单项添加事件处理程序</p><ol><li><p>右键【画直线】菜单项，添加事件处理程序</p></li><li><p>在对话框中，类列表【相应控件】选择 <code>CMFCPaintView</code>，消息类型默认选择 <code>COMMAND</code>【菜单栏中绝大多数消息都为<code>COMMAND</code>，诸如按钮、选项、列表、复选框、单选框等，该消息需要带上ID才能绑定到指定按钮】。</p><ol><li><p>选择确定后，会在 <code>MFCPaintView.cpp</code> 和 <code>MFCPaintView.h</code> 中创建相应的成员函数，即事件处理函数；并在 <code>MFCPaintView.cpp</code> 中加入消息Map：<code>ON_COMMAND</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MFCPaintView.cpp</span></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMFCPaintView, CView)</span><br><span class="line">    <span class="built_in">ON_WM_CONTEXTMENU</span>()</span><br><span class="line">    <span class="built_in">ON_WM_RBUTTONUP</span>()</span><br><span class="line">    <span class="built_in">ON_WM_LBUTTONDOWN</span>()</span><br><span class="line">    <span class="built_in">ON_WM_LBUTTONUP</span>()</span><br><span class="line">    <span class="built_in">ON_WM_MOUSEMOVE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CHAR</span>()</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_DRAW_LINE, &amp;CMFCPaintView::OnDrawLine)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br></pre></td></tr></table></figure></li><li><p>在事件处理函数中，打印日志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\r\n&quot;</span>, __FILE__,__LINE__,__FUNCTION__);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>添加【测试菜单】菜单项，为其添加四个类列表的事件处理函数，来测试相应优先级【<code>CMFCPaintView</code>、<code>CMFCPaintDoc</code>、<code>CMainFrame</code>、<code>CMFCPaintApp</code>】。</p></li></ol><blockquote><p>双击TRACE调试语句的输出，可以跳转到相应的TRACE代码。</p></blockquote><blockquote><p>响应菜单命令顺序：View &gt; Doc &gt; 框架【CMainFrame】 &gt; App【CMFCPaintApp】</p></blockquote><br><h3 id="4-3-菜单命令路由及其优先级"><a href="#4-3-菜单命令路由及其优先级" class="headerlink" title="4.3 菜单命令路由及其优先级"></a>4.3 菜单命令路由及其优先级</h3><blockquote><p>如果对于同一个菜单项，设置了多个事件处理函数，那么他们具有固定的触发顺序。</p></blockquote><p>菜单路由【C++ 继承】</p><ol><li>有view和doc，触发了view，但是没有触发doc；</li><li>去掉view类的菜单响应函数，打开doc类的响应函数。</li><li>去掉doc类的菜单响应函数，打开框架类的响应函数。</li><li>去掉框架类的菜单响应函数，打开app类的响应函数。</li></ol><p><strong>小结：</strong></p><ul><li>与显示有关的，肯定先是View响应；</li><li>第二个肯定是Doc，因为它是View的底层数据</li><li>响应菜单命令顺序：View &gt; Doc &gt; 框架【CMainFrame】 &gt; 【CMFCPaintApp】</li></ul><br><h3 id="4-4-工具栏基本操作"><a href="#4-4-工具栏基本操作" class="headerlink" title="4.4 工具栏基本操作"></a>4.4 工具栏基本操作</h3><ol><li><p>资源视图 –&gt; <code>Toolbar</code> –&gt; <code>IDR_MAINFRAME</code>， 双击打开工具栏编辑器。</p></li><li><p>添加：在两个编辑器中绘制新位图，最好对应添加。</p><ol><li><code>IDR_MAINFRAME</code>和<code>IDR_MAINFRAME_256</code>需要同步添加，其适用于不同的显示模式，256是色彩模式。</li><li>在两个编辑器中添加按钮，绘制位图即可。</li><li>在属性栏修改对应图标的ID和提示。如果是菜单里面有的，可以填入对应的ID；如果是新的，可以仿照菜单处理。</li></ol><p><img src="/.io//4-2.png"></p></li><li><p>删除刚添加工具按钮：拖出工具栏范围即可【并非右键删除】</p></li></ol><br><h2 id="五-MFC总体理解"><a href="#五-MFC总体理解" class="headerlink" title="五 MFC总体理解"></a>五 MFC总体理解</h2><h3 id="5-1-MFC类视图和MFC所有的类"><a href="#5-1-MFC类视图和MFC所有的类" class="headerlink" title="5.1 MFC类视图和MFC所有的类"></a>5.1 MFC类视图和MFC所有的类</h3><p>搜索MFC层次图：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/mfc/hierarchy-chart?view=msvc-170">传送门</a></p><p>【<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/mfc/hierarchy-chart?view=msvc-170%E3%80%91">https://learn.microsoft.com/zh-cn/cpp/mfc/hierarchy-chart?view=msvc-170】</a></p><blockquote><p>继承示例：生物 →动物 →人类 →男人类→小男孩类</p></blockquote><blockquote><p>父类记录公共特征，子类记录与父类的差异</p></blockquote><p>继承的好处：</p><ul><li>代码重用：通过继承，子类可以直接使用父类的属性和方法，避免了重复编写相同的代码，提高了代码的复用性和开发效率。</li><li>扩展性：子类可以在继承基础上添加新的属性和方法，从而扩展父类的功能。这使得代码可以更容易地进行修改和扩展，而无需对已有的代码进行大规模的修改。</li><li>统一和一致性：通过继承，可以创建具有相似行为和特性的类层次结构。这样可以使代码更加一致和易于理解，提高了代码的可维护性和可读性。</li><li>多态性：继承是实现多态性的基础。多态性允许不同的对象对相同的消息做出不同的响应。通过继承，可以创建不同的子类对象，并对它们使用相同的父类接口，实现多态的效果。</li></ul><br><p><code>CObject</code> 基类：提供一些公共服务：</p><ol><li><p>支持序列化<code>CArchive</code>。以CPoint为例，序列化就是：</p><ol><li>将结构化数据中的x放入前一部分字节，y放入后一部分字节，连同总长度打成包，变成序列【如协议、网络协议，因为一般网络上只能以字节为单位传输】；</li><li>或者将结构化数据按一定的约定转为文本字符串，也叫序列化；【如Json，用于网络传输】</li><li>甚至直接将结构体内存复制过去，其本质也是连续的内存空间，也可以称为序列化。</li></ol></li><li><p>支持运行时提供类信息，包括该类的类名、父类等。【用于定位运行时错误的位置】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> CRuntimeClass* PASCAL _GetBaseClass();</span><br><span class="line"><span class="function"><span class="type">static</span> CRuntimeClass* PASCAL <span class="title">GetThisClass</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>支持动态创建以及支持对象诊断输出</p><ol><li>如MFC的关于按钮，一开始并不会创建，而是点击按钮后动态创建的对话框；不创建就不会占用内存，不会占用资源。</li><li>支持动态创建，一般都需要基类的存在，否则无法实现多态，也就无法动态创建子类。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Diagnostic Support  诊断支持</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AssertValid</span><span class="params">()</span> <span class="type">const</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dump</span><span class="params">(CDumpContext&amp; dc)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>此节的内容属于内功，是MFC框架开发团队的全部顶层设计，也不是一般企业和团队能完成的。</p></blockquote><br><h3 id="5-2-MFC框架理论"><a href="#5-2-MFC框架理论" class="headerlink" title="5.2 MFC框架理论"></a>5.2 MFC框架理论</h3><h4 id="5-2-1-关键类"><a href="#5-2-1-关键类" class="headerlink" title="5.2.1 关键类"></a>5.2.1 关键类</h4><blockquote><p>最关键的四个类：<code>CWinApp</code>、<code>CFrameWnd</code>、<code>CView</code>、<code>CDocument</code>。</p></blockquote><p>🔺<code>CWinApp</code>：MFC应用程序抽象类，是所有类的核心，统筹全局。</p><ul><li>作用非常重要，整个程序的启动、初始化以及其他关键类都依附于 <code>CWinApp</code>。</li><li>也正是因为其太重要，故MFC编程几乎不会用到该类，由MFC框架全权封装。</li><li>管理<code>Document</code>模板。</li><li>可以用于同时联动其他三个关键类。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaint.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCPaintApp</span> : <span class="keyword">public</span> CWinAppEx&#123;...&#125;</span><br><span class="line"><span class="comment">// afxwinappex.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CWinAppEx</span> : <span class="keyword">public</span> CWinApp&#123;...&#125;</span><br></pre></td></tr></table></figure><p>🔺 <code>CFrameWnd</code>：框架窗口，负责创建应用主窗口，包含标题栏、菜单栏、工具栏【上、左、右】、状态栏等。</p><ul><li>只负责窗口结构，而非内容。比如菜单栏的文字，其实属于Menu。</li><li>主要目的是限制窗口内的布局。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainFrm.h: CMainFrame 类的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMainFrame</span> : <span class="keyword">public</span> CFrameWndEx&#123;...&#125;</span><br><span class="line"><span class="comment">// afxframewndex.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFrameWndEx</span> : <span class="keyword">public</span> CFrameWnd&#123;...&#125;</span><br></pre></td></tr></table></figure><p>🔺<code>CView</code>：负责展示应用数据，View其实是一个没有边框的窗口, 客户区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaintView.h: CMFCPaintView 类的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCPaintView</span> : <span class="keyword">public</span> CView&#123;...&#125;</span><br></pre></td></tr></table></figure><p>🔺<code>CDocument：负责存储应用数据。</code></p><ul><li>将数据提供给View显示。</li><li>数据由<code>CWinApp</code>管理。<code>CWinApp</code> 有<code>Document</code>模板，比如单文档模板、多文档模板、网页文档、富文本、交互式等。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaintDoc.h: CMFCPaintDoc 类的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCPaintDoc</span> : <span class="keyword">public</span> CDocument&#123;...&#125;</span><br></pre></td></tr></table></figure><br><p>打开类试图，可以看到可见的程序唯一入口类：<code>CMFCPaintApp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaint.h 中需要注意的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MFCPaint.cpp 中的实现：CMFCPaintApp 初始化</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMFCPaintApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果一个运行在 Windows XP 上的应用程序清单指定要</span></span><br><span class="line">    <span class="comment">// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，</span></span><br><span class="line">    <span class="comment">//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。</span></span><br><span class="line">    INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">    InitCtrls.dwSize = <span class="built_in">sizeof</span>(InitCtrls);</span><br><span class="line">    <span class="comment">// 将它设置为包括所有要在应用程序中使用的</span></span><br><span class="line">    <span class="comment">// 公共控件类。</span></span><br><span class="line">    InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line">    <span class="built_in">InitCommonControlsEx</span>(&amp;InitCtrls);</span><br><span class="line"></span><br><span class="line">    CWinAppEx::<span class="built_in">InitInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxSocketInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>(IDP_SOCKETS_INIT_FAILED);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 OLE 库</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxOleInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>(IDP_OLE_INIT_FAILED);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AfxEnableControlContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnableTaskbarInteraction</span>(FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 RichEdit 控件需要 AfxInitRichEdit2()</span></span><br><span class="line">    <span class="comment">// AfxInitRichEdit2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准初始化</span></span><br><span class="line">    <span class="comment">// 如果未使用这些功能并希望减小</span></span><br><span class="line">    <span class="comment">// 最终可执行文件的大小，则应移除下列</span></span><br><span class="line">    <span class="comment">// 不需要的特定初始化例程</span></span><br><span class="line">    <span class="comment">// 更改用于存储设置的注册表项</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 应适当修改该字符串，</span></span><br><span class="line">    <span class="comment">// 例如修改为公司或组织名</span></span><br><span class="line">    <span class="built_in">SetRegistryKey</span>(_T(<span class="string">&quot;应用程序向导生成的本地应用程序&quot;</span>));</span><br><span class="line">    <span class="built_in">LoadStdProfileSettings</span>(<span class="number">4</span>);  <span class="comment">// 加载标准 INI 文件选项(包括 MRU)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitContextMenuManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitKeyboardManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitTooltipManager</span>();</span><br><span class="line">    CMFCToolTipInfo ttParams;</span><br><span class="line">    ttParams.m_bVislManagerTheme = TRUE;</span><br><span class="line">    theApp.<span class="built_in">GetTooltipManager</span>()-&gt;<span class="built_in">SetTooltipParams</span>(AFX_TOOLTIP_TYPE_ALL,</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCToolTipCtrl), &amp;ttParams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册应用程序的文档模板。  文档模板</span></span><br><span class="line">    <span class="comment">// 将用作文档、框架窗口和视图之间的连接</span></span><br><span class="line">    CSingleDocTemplate* pDocTemplate;</span><br><span class="line">    pDocTemplate = <span class="keyword">new</span> <span class="built_in">CSingleDocTemplate</span>(</span><br><span class="line">        IDR_MAINFRAME,</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCPaintDoc),</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMainFrame),       <span class="comment">// 主 SDI 框架窗口</span></span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCPaintView));</span><br><span class="line">    <span class="keyword">if</span> (!pDocTemplate)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">AddDocTemplate</span>(pDocTemplate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析标准 shell 命令、DDE、打开文件操作的命令行</span></span><br><span class="line">    CCommandLineInfo cmdInfo;</span><br><span class="line">    <span class="built_in">ParseCommandLine</span>(cmdInfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度在命令行中指定的命令。  如果</span></span><br><span class="line">    <span class="comment">// 用 /RegServer、/Register、/Unregserver 或 /Unregister 启动应用程序，则返回 FALSE。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ProcessShellCommand</span>(cmdInfo))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一的一个窗口已初始化，因此显示它并对其进行更新</span></span><br><span class="line">    m_pMainWnd-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    m_pMainWnd-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，第61行至68行，开始注册应用程序的文档模板，将用作文档、框架窗口和视图之间的连接。</p></blockquote><br><h4 id="5-2-2-关键类之间的关系"><a href="#5-2-2-关键类之间的关系" class="headerlink" title="5.2.2 关键类之间的关系"></a>5.2.2 关键类之间的关系</h4><p>深究 <code>CWinApp</code>，其继承自一个线程类。其实，应用程序就是由一个或者多个子线程构成的，其中一个叫做主线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaint.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCPaintApp</span> : <span class="keyword">public</span> CWinAppEx&#123;...&#125;</span><br><span class="line"><span class="comment">// afxwinappex.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CWinAppEx</span> : <span class="keyword">public</span> CWinApp&#123;...&#125;</span><br><span class="line"><span class="comment">// afxwin.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CWinApp</span> : <span class="keyword">public</span> CWinThread&#123;...&#125;</span><br><span class="line"><span class="comment">// 根深的父类依次是：-&gt; CCmdTarget -&gt; CObject</span></span><br></pre></td></tr></table></figure><p>🔺<code>CDocTemplate</code>、<code>CDocument</code>、<code>CView</code>、<code>CFrameWnd</code>关联关系</p><ul><li><p>在 <code>CWinApp</code> 类声明中拥有一个对象指针：<code>CDocManager * m_pDocManager</code>，存储所有的文档模板。</p></li><li><p><code>CDocManager</code>类中【继承自<code>CObject</code>】，拥有一个指针链表成员，用来维护一系列的文档模板<code>DocumentTemplate</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CDocManager</span> : <span class="keyword">public</span> CObject&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CPtrList m_templateList;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用程序在 <code>CMFCPaintApp::InitInstance()</code> 中以 <code>AddDocTemplate</code> 将文档模板【此处为单文档模板 <code>CSingleDocTemplate</code>】加入到有<code>CDocManager</code>所维护的链表之中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaint.cpp 中的实现：CMFCPaintApp 初始化</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMFCPaintApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 注册应用程序的文档模板。  文档模板</span></span><br><span class="line">    <span class="comment">// 将用作文档、框架窗口和视图之间的连接</span></span><br><span class="line">    CSingleDocTemplate* pDocTemplate;</span><br><span class="line">    pDocTemplate = <span class="keyword">new</span> <span class="built_in">CSingleDocTemplate</span>(</span><br><span class="line">        IDR_MAINFRAME,</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCPaintDoc),</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMainFrame),       <span class="comment">// 主 SDI 框架窗口</span></span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCPaintView));</span><br><span class="line">    <span class="keyword">if</span> (!pDocTemplate)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">AddDocTemplate</span>(pDocTemplate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CDocTemplate</code> 拥有的成员变量中，分别持有<code>Document</code>、<code>View</code>、<code>Frame</code>的<code>CRuntimeClass</code>指针，另有一个成员变量<code>m_nIDResource</code>，为资源ID【此处的单文档子类中为<code>nIDResource</code>，此处填入的<code>IDR_MAINFRAME</code>，来自于资源视图：<code>Toobar</code>】，用来表示此<code>Document</code>显示时应该采用的UI对象，其实就是菜单。</p></li><li><p>这四份数据在<code>CMFCPaintApp::InitInstance</code>函数构造<code>CDocTemplate</code>时指定，称为构造函数的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleDocTemplate</span> : <span class="keyword">public</span> CDocTemplate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DECLARE_DYNAMIC</span>(CSingleDocTemplate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSingleDocTemplate</span>(UINT nIDResource, </span><br><span class="line">                       CRuntimeClass* pDocClass,</span><br><span class="line">                       CRuntimeClass* pFrameClass, </span><br><span class="line">                       CRuntimeClass* pViewClass);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// class CDocTemplate creates documents</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDocTemplate</span> : <span class="keyword">public</span> CCmdTarget</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">CDocTemplate</span>(UINT nIDResource, CRuntimeClass* pDocClass,</span><br><span class="line">        CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    UINT m_nIDResource;						<span class="comment">// IDR_ for frame/menu/accel as well</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    CRuntimeClass* m_pDocClass;				<span class="comment">// class for creating new documents</span></span><br><span class="line">    CRuntimeClass* m_pFrameClass;			<span class="comment">// class for creating new frames</span></span><br><span class="line">    CRuntimeClass* m_pViewClass;			<span class="comment">// class for creating new views</span></span><br><span class="line">    </span><br><span class="line">    CRuntimeClass* m_pOleFrameClass;        <span class="comment">// class for creating in-place frame</span></span><br><span class="line">    CRuntimeClass* m_pOleViewClass;			<span class="comment">// class for creating in-place view</span></span><br><span class="line">    CRuntimeClass* m_pPreviewFrameClass;	<span class="comment">// class for creating in-place preview frame</span></span><br><span class="line">    CRuntimeClass* m_pPreviewViewClass;		<span class="comment">// class for creating in-place preview view</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>CRuntimeClass</code>的类，会在运行时保留自己的类名，可以在运行时获得自己的类名，方便调试。</p><p>【应用场景】：很多类比有必要在一开始就创建出对象，比如VS2022中的不同视图，有众多可选项，就可以在运行时动态创建，使用同一个基类创建函数 <code>CreateObject()</code>，只是参数不同就可以创建出不同视图窗口。</p><p>其实，这种设计实现了消息发送和创建过程的解耦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CRuntimeClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Attributes</span></span><br><span class="line">    LPCSTR m_lpszClassName;	<span class="comment">//!!! 记住自己的类名</span></span><br><span class="line">    <span class="type">int</span> m_nObjectSize;		<span class="comment">//！！记住自己的对象大小</span></span><br><span class="line">    UINT m_wSchema; <span class="comment">// schema number of the loaded class</span></span><br><span class="line">    <span class="comment">// 自己的构造函数，抽象函数，必须指向具体实现才能使用</span></span><br><span class="line">    CObject* (PASCAL* m_pfnCreateObject)(); <span class="comment">// NULL =&gt; abstract class</span></span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AFXDLL</span></span><br><span class="line">    CRuntimeClass* (PASCAL* m_pfnGetBaseClass)();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    CRuntimeClass* m_pBaseClass;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations</span></span><br><span class="line">    <span class="function">CObject* <span class="title">CreateObject</span><span class="params">()</span></span>;	<span class="comment">// 本身的构造函数：自己创建自己</span></span><br><span class="line">    <span class="function">BOOL <span class="title">IsDerivedFrom</span><span class="params">(<span class="type">const</span> CRuntimeClass* pBaseClass)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>在<code>CMFCPaintDoc</code>类中，其基类<code>CDocument</code>有两个成员变量需要注意：</p><ol><li>一个成员变量 <code>CDocTemplate * m_pDocTemplate</code>，回指其文档模板【DocumentTemplate】；</li><li>另外有一个成员变量指针链表<code>CPtrList m_viewList</code>，表示它可以同时维护一组<code>Views</code>，即<span style="background-color:#ff0">一个文档可以对应多个视图。</span></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCPaintDoc</span> : <span class="keyword">public</span> CDocument&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDocument</span> : <span class="keyword">public</span> CCmdTarget&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    CDocTemplate* m_pDocTemplate;</span><br><span class="line">    CPtrList m_viewList;                <span class="comment">// list of views</span></span><br><span class="line">    <span class="comment">//...     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CFrameWnd</code>有一个成员变量<code>CView * m_pViewActive</code>，指向当前活动的View，保存目前被激活的视图。</p><p><code>CView</code>有一个成员变量<code>CDocument * m_pDocument</code>，指向相关的Document，一对一，只能关联一个文档。</p><p><img src="/.io//5-1.gif" alt="docTemp_relation"></p><br><blockquote><p>上面提到的都是几个关键类之间的静态关联，下面MFC启动时的动态关联。</p></blockquote><p>🔺MFC应用启动流程分析：</p><ul><li>以逐语句的调试方法开启调试，可看到MFC的入口Main函数。</li><li>跟踪方法：MFC静态库， 调试模式中查看函数栈</li></ul><p><img src="/.io//5-2.png" alt="mfc-startup"></p><blockquote><p>MFC的框架设计，是非常值得细品设计模式。</p></blockquote><br><p>具体流程解析如下：</p><ol><li><p><code>appmoudul.cpp</code>中的框架Main函数入口：<code>_tWinMain()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appmoudul.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> WINAPI</span><br><span class="line">_tWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">    _In_ LPTSTR lpCmdLine, _In_ <span class="type">int</span> nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// call shared/exported WinMain</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AfxWinMain</span>(hInstance, hPrevInstance, lpCmdLine, nCmdShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再到系统提供的主函数： <code>AfxWinMain()</code>，在其中：</p><ol><li>创建 <code>pThread</code>线程</li><li>创建 <code>pApp</code></li><li>初始化创建当前应用程序主线程</li><li>初始化<code>Application</code>：<code>CWinApp::InitApplication()</code>【初始化<code>CWinApp</code>类的一些内部东西，对编程人员来说无意义】</li><li>MFC应用程序初始化【pThread指向本项目程序】：<code>CMFCPaintApp::InitInstance()</code></li><li>MFC应用线程运行Run，直到结束。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// winmain.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> AFXAPI <span class="title">AfxWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPTSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(hPrevInstance == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nReturnCode = <span class="number">-1</span>;</span><br><span class="line">    CWinThread* pThread = <span class="built_in">AfxGetThread</span>();	<span class="comment">//【1】</span></span><br><span class="line">    CWinApp* pApp = <span class="built_in">AfxGetApp</span>();			<span class="comment">//【2】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AFX internal initialization			//【3】</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxWinInit</span>(hInstance, hPrevInstance, lpCmdLine, nCmdShow))</span><br><span class="line">        <span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// App global initializations (rare)	//【4】</span></span><br><span class="line">    <span class="keyword">if</span> (pApp != <span class="literal">NULL</span> &amp;&amp; !pApp-&gt;<span class="built_in">InitApplication</span>())</span><br><span class="line">        <span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform specific initializations</span></span><br><span class="line">    <span class="keyword">if</span> (!pThread-&gt;<span class="built_in">InitInstance</span>())			<span class="comment">//【5】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pThread-&gt;m_pMainWnd != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: Destroying non-NULL m_pMainWnd\n&quot;</span>);</span><br><span class="line">            pThread-&gt;m_pMainWnd-&gt;<span class="built_in">DestroyWindow</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        nReturnCode = pThread-&gt;<span class="built_in">ExitInstance</span>();</span><br><span class="line">        <span class="keyword">goto</span> InitFailure;</span><br><span class="line">    &#125;</span><br><span class="line">    nReturnCode = pThread-&gt;<span class="built_in">Run</span>();			<span class="comment">//【6】</span></span><br><span class="line"></span><br><span class="line">InitFailure:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">// Check for missing AfxLockTempMap calls</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AfxGetModuleThreadState</span>()-&gt;m_nTempMapLock != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: Temp map lock count non-zero (%ld).\n&quot;</span>,</span><br><span class="line">            <span class="built_in">AfxGetModuleThreadState</span>()-&gt;m_nTempMapLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AfxLockTempMaps</span>();</span><br><span class="line">    <span class="built_in">AfxUnlockTempMaps</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AfxWinTerm</span>();</span><br><span class="line">    <span class="keyword">return</span> nReturnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在 <code>CMFCPaintApp::InitInstance()</code> 中，具体分为一下几步：</p><ol><li>调用父类初始化函数：<code>CWinAppEx::InitInstance()</code></li><li>套接字初始化</li><li>初始化Activity的 OLE 库</li><li>初始化Manager的容器</li><li>解决win7系统中，Windows底部任务栏互动的重大Bug【Win7下如果有底部任务栏互动的功能，需要设为True】</li><li>初始化注册表</li><li>加载 <code>ini</code> 的配置文件</li><li>加载上下文菜单Manager、键盘Manager、工具提示Manager。</li><li>添加模板 DocTemplate</li><li>如果是命令行启动，需要从此处处理</li><li>显示空白窗口</li><li>更新窗口：显示View内容</li><li>返回系统提供的主函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MFCPaint.cpp 中的实现：CMFCPaintApp 初始化</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMFCPaintApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果一个运行在 Windows XP 上的应用程序清单指定要</span></span><br><span class="line">    <span class="comment">// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，</span></span><br><span class="line">    <span class="comment">//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。</span></span><br><span class="line">    INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">    InitCtrls.dwSize = <span class="built_in">sizeof</span>(InitCtrls);</span><br><span class="line">    <span class="comment">// 将它设置为包括所有要在应用程序中使用的</span></span><br><span class="line">    <span class="comment">// 公共控件类。</span></span><br><span class="line">    InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line">    <span class="built_in">InitCommonControlsEx</span>(&amp;InitCtrls);</span><br><span class="line"></span><br><span class="line">    CWinAppEx::<span class="built_in">InitInstance</span>();					<span class="comment">//【1】</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxSocketInit</span>())						<span class="comment">//【2】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>(IDP_SOCKETS_INIT_FAILED);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 OLE 库							 //【3】</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxOleInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>(IDP_OLE_INIT_FAILED);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AfxEnableControlContainer</span>();				<span class="comment">//【4】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnableTaskbarInteraction</span>(FALSE);			<span class="comment">//【5】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 RichEdit 控件需要 AfxInitRichEdit2()</span></span><br><span class="line">    <span class="comment">// AfxInitRichEdit2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准初始化</span></span><br><span class="line">    <span class="comment">// 如果未使用这些功能并希望减小</span></span><br><span class="line">    <span class="comment">// 最终可执行文件的大小，则应移除下列</span></span><br><span class="line">    <span class="comment">// 不需要的特定初始化例程</span></span><br><span class="line">    <span class="comment">// 更改用于存储设置的注册表项</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 应适当修改该字符串，</span></span><br><span class="line">    <span class="comment">// 例如修改为公司或组织名</span></span><br><span class="line">    <span class="built_in">SetRegistryKey</span>(_T(<span class="string">&quot;应用程序向导生成的本地应用程序&quot;</span>));	<span class="comment">//【6】</span></span><br><span class="line">    <span class="built_in">LoadStdProfileSettings</span>(<span class="number">4</span>);  <span class="comment">// 加载标准 INI 文件选项(包括 MRU)//【7】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitContextMenuManager</span>();					<span class="comment">//【8】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitKeyboardManager</span>();						<span class="comment">//【8】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitTooltipManager</span>();						<span class="comment">//【8】</span></span><br><span class="line">    CMFCToolTipInfo ttParams;</span><br><span class="line">    ttParams.m_bVislManagerTheme = TRUE;</span><br><span class="line">    theApp.<span class="built_in">GetTooltipManager</span>()-&gt;<span class="built_in">SetTooltipParams</span>(AFX_TOOLTIP_TYPE_ALL,</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCToolTipCtrl), &amp;ttParams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册应用程序的文档模板。  文档模板</span></span><br><span class="line">    <span class="comment">// 将用作文档、框架窗口和视图之间的连接</span></span><br><span class="line">    CSingleDocTemplate* pDocTemplate;			<span class="comment">//【9】</span></span><br><span class="line">    pDocTemplate = <span class="keyword">new</span> <span class="built_in">CSingleDocTemplate</span>(</span><br><span class="line">        IDR_MAINFRAME,</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCPaintDoc),</span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMainFrame),       <span class="comment">// 主 SDI 框架窗口</span></span><br><span class="line">        <span class="built_in">RUNTIME_CLASS</span>(CMFCPaintView));</span><br><span class="line">    <span class="keyword">if</span> (!pDocTemplate)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">AddDocTemplate</span>(pDocTemplate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析标准 shell 命令、DDE、打开文件操作的命令行	//【10】</span></span><br><span class="line">    CCommandLineInfo cmdInfo;</span><br><span class="line">    <span class="built_in">ParseCommandLine</span>(cmdInfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度在命令行中指定的命令。  如果</span></span><br><span class="line">    <span class="comment">// 用 /RegServer、/Register、/Unregserver 或 /Unregister 启动应用程序，则返回 FALSE。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ProcessShellCommand</span>(cmdInfo))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一的一个窗口已初始化，因此显示它并对其进行更新	</span></span><br><span class="line">    m_pMainWnd-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);			<span class="comment">//【11】</span></span><br><span class="line">    m_pMainWnd-&gt;<span class="built_in">UpdateWindow</span>();					<span class="comment">//【12】</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;								<span class="comment">//【13】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="5-3-MFC消息分类"><a href="#5-3-MFC消息分类" class="headerlink" title="5.3 MFC消息分类"></a>5.3 MFC消息分类</h3><blockquote><p>打开类视图，右键单击 <code>CMFCPaintView</code>，选择属性。在属性界面选择筛选项为消息。</p><p>此时可查看几乎所有的标准消息，当然不包括COMMAND消息。</p></blockquote><p>消息的分类：标准消息、命令消息、通告消息。</p><ul><li><p>标准消息：除<code>WM_COMMAND</code>之外，所有以<code>WM_</code>开头的消息。</p><ul><li>从<code>CWnd</code>类派生的类都可以接收到这一消息。</li></ul></li><li><p>命令消息：来自菜单或菜单项、加速键或工具栏按钮的消息。这类消息都以<code>WM_COMMAND</code>呈现。</p><ul><li>在MFC中，通过菜单项的标识（ID）来区分不同的命令消息；</li><li>在SDK中，通过消息的<code>wParam</code>参数识别。</li><li>从CCmdTarget【CWnd的父类】派生的类都可以接收到这一类消息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMFCPaintView.cpp 中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNCREATE</span>(CMFCPaintView, CView)</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMFCPaintView, CView)</span><br><span class="line">    <span class="built_in">ON_WM_CONTEXTMENU</span>()</span><br><span class="line">    <span class="built_in">ON_WM_RBUTTONUP</span>()</span><br><span class="line">    <span class="built_in">ON_WM_LBUTTONDOWN</span>()</span><br><span class="line">    <span class="built_in">ON_WM_LBUTTONUP</span>()</span><br><span class="line">    <span class="built_in">ON_WM_MOUSEMOVE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CHAR</span>()</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_DRAW_LINE, &amp;CMFCPaintView::OnDrawLine)<span class="comment">//命令消息</span></span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_DRAW_RECT, &amp;CMFCPaintView::OnDrawRect)<span class="comment">//命令消息</span></span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 此处的命令消息来自4.2节中的菜单项</span></span><br><span class="line"><span class="comment">// ON_COMMAND 定义如下：ON_COMMAND(控件id，响应函数)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON_COMMAND(id, memberFxn) \</span></span><br><span class="line"><span class="meta">    &#123; WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSigCmd_v, \</span></span><br><span class="line"><span class="meta">        static_cast<span class="string">&lt;AFX_PMSG&gt;</span> (memberFxn) &#125;,</span></span><br></pre></td></tr></table></figure></li><li><p>通告消息：由控件产生的消息。例如，保存按钮的单击、列表框的选择等均产生此类消息，为的是向其父窗口【通常是对话框】通知事件的发生。</p><ul><li>通告消息更像是需要框架来转发给其他控件，也可以是自己，如禁用本按钮的可用状态。</li><li>这类消息也是以WM_COMMAND形式呈现。</li><li>从CCmdTarget【CWnd的父类】派生的类都可以接收到这一类消息。</li></ul></li></ul><p><strong>总结：</strong></p><ul><li>凡是从<code>CWnd</code>派生的类，既可以接收标准消息，也可以接收命令消息和通告消息。</li><li>而对于那些从CCmdTarget派生的类，则只能接收命令消息和通告消息，不能接收标准消息。</li></ul><br><h2 id="六-对话框"><a href="#六-对话框" class="headerlink" title="六 对话框"></a>六 对话框</h2><h3 id="6-1-对话框基本知识"><a href="#6-1-对话框基本知识" class="headerlink" title="6.1 对话框基本知识"></a>6.1 对话框基本知识</h3><p>对话框的定位：与用户进行交互的控件，如文件对话框、字体对话框、颜色对话框等，一般用于告示、提醒等。</p><blockquote><p>Windows应用程序的基本工作流程，是从用户那里得到数据【鼠标点击、键盘输入、文件拖入等】，经过相应的处理之后，再把处理结果输出到屏幕、打印机或者其他输出设备。这就需要用到Windows应用程序的用户接口对话框。</p></blockquote><ul><li><p>对话框就是一个窗口，它不仅可以接收消息，而且还可以被移动和关闭，甚至可以在它的客户区中进行绘图。</p></li><li><p>其相当于一个窗口，在它上面能够拖放各种标准控件和扩展控件。</p></li><li><p>上面的所有控件都是由CWnd类派生来。</p><br></li></ul><p>常见的标准控件：</p><blockquote><p>MFCApp项目中，打开视图【工具箱】，双击资源视图下的<code>MFCApp.rc</code> -&gt; <code>Dialog</code> -&gt; <code>IDD_MFCAPP_DIALOG</code>，会展示所有可用控件。</p></blockquote><table><thead><tr><th>控件</th><th>功能</th><th>对应的控件类</th></tr></thead><tbody><tr><td>静态文本框（Static Text）</td><td>显示文本，一般不能接受输入信息</td><td>CStatic</td></tr><tr><td>图像控件（Picture）</td><td>显式位图、图标、方框和图元文件，一般不能接受输入信息</td><td>CStatic</td></tr><tr><td>编辑框（Edit Box）</td><td>输入并编辑正文，支持单行和多行编辑</td><td>CEdit</td></tr><tr><td>按钮（Button）</td><td>响应用户的输入，触发相应的事件</td><td>CButton</td></tr><tr><td>复选框（Check Box）</td><td>用作选择标记，可以有选中、未选中和不确定三种状态</td><td>CButton</td></tr><tr><td>单选按钮（Radio Button）</td><td>用来从两个或多个选项中选中一项</td><td>CButton</td></tr><tr><td>组框（Group Box）</td><td>显示正文和方框，主要用来将相关的一些控件(用于共同的目的)组织在一起</td><td>CButton</td></tr><tr><td>列表框（List Box）</td><td>显示一个列表，用户可以从该列表中选择一项或多项</td><td>CListBox</td></tr><tr><td>组合框（Combo Box）</td><td>是一个编辑框和一个列表框的组合。分为简易式、下拉式和下拉列表式</td><td>CComboBox</td></tr><tr><td>滚动条（Scroll Bar）</td><td>主要用来从一个预定义范围值中迅速而有效地选取一个整数值</td><td>CScrollBar</td></tr></tbody></table><blockquote><p>Rich Text 富文本框需要初始化，否则报错。</p></blockquote><br><h3 id="6-2-对话框的创建和显示"><a href="#6-2-对话框的创建和显示" class="headerlink" title="6.2 对话框的创建和显示"></a>6.2 对话框的创建和显示</h3><p>最简单的创建对话框的方式：资源视图下，右键【<code>MFCApp.rc</code> -&gt; <code>Dialog</code>】，选择插入，会自动插入 <code>IDD_DIALOG1</code>。</p><p>🔺最常用最推荐的创建方式：资源视图下右键<code>Dialog</code>，选择添加资源。在对话框中打开<code>Dialog</code>的可选项，进行选择添加。【也可以选择顶层 <code>Dialog</code>，直接点新建，即可添加 <code>IDD_DIALOG1</code>】</p><ul><li>IDD_DIALOGBAR：对话条</li><li>IDD_FORMVIEW：视图对话框</li><li>IDD_PROPPAGE：不同大小的属性页。</li></ul><blockquote><p>一个博主说：我不会告诉你们，他们都是一样的。</p></blockquote><ul><li><p>在属性页，修改对话框ID为<code>IDD_DLG_XIN</code>【资源文件的属性有限】</p></li><li><p>点击可视化拖放页面中的Dialog，在属性页中修改相应的属性。以下是需要特别说明的常用属性：</p><ul><li>Caption：描述文字，标题。</li><li>……</li></ul></li><li><p>在Dialog可视化页面右键，选择添加类。类名 <code>CMyDialog</code>，基类一般选择 <code>CDialogEx</code> 或 <code>CDialog</code> 【较简单】，其他的多用于复杂的对话框，默认不勾选自动化支持和Active Accessibility支持。</p><ul><li>非正常的创建对话框类的方式就是直接创建相应的头文件和cpp文件，不熟悉MFC的情况下不可尝试。</li><li>特别注意：类名 <code>CMyDialog</code>，基类需要与 <code>MFCAppDlg</code> 类的父类保持一致，否则报错，需将其基类修改正确【此处为 <code>CDialog</code>】。</li></ul><blockquote><p><code>Ex</code> 意为 <code>Extent</code>，扩展。</p></blockquote></li><li><p>打开 <code>MFCAppDlg.cpp</code>，编辑 <code>CMFCAppDlg::OnBnClickedOk()</code>：【此处涉及对话框的两种类型：模态/非模态，见<code>7.2.1</code>】</p></li></ul><br><h4 id="6-2-1-模态和非模态对话框"><a href="#6-2-1-模态和非模态对话框" class="headerlink" title="6.2.1 模态和非模态对话框"></a>6.2.1 模态和非模态对话框</h4><p>🔺模态【Model】对话框：指当其显示时，程序会暂停执行，直到关闭这个模态对话框后，才能继续执行程序中其它任务。当一个模态对话框打开时，用户只能与该对话框进行交互，而其它用户界面对象接收不到输入信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 在主窗口中创建模态对话框：MFCAppDlg.cpp</span></span><br><span class="line">CMyDialog dlg;</span><br><span class="line">dlg.<span class="built_in">DoModal</span>();    <span class="comment">//DoMal()会阻塞主窗口程序</span></span><br></pre></td></tr></table></figure><br><p>🔺非模态【Modeless】对话框：当其显示时，允许执行程序中其它任务，而不用关闭这个对话框，即不阻塞主窗口执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2 创建非模态对话框</span></span><br><span class="line"><span class="comment">// 在 MFCAppDlg.h 中声明：CMyDialog dlg;</span></span><br><span class="line"><span class="comment">// 并添加头文件：#include &quot;CMyDialog.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在主窗口中显示非模态对话框即可</span></span><br><span class="line">dlg.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时主窗口正常运行，但点击确定，非模态对话框报错：Debug Assertion Failed【C++ Runtime Library】</span></span><br><span class="line"><span class="comment">//即仅仅是在类声明时定义了变量dlg，但并没有创建真正的窗口</span></span><br><span class="line"><span class="comment">// 故需要在主窗口的初始化函数中，以IDD_DLG_XIN为模板，创建dlg</span></span><br><span class="line"><span class="comment">// 若依然在 CMFCAppDlg::OnBnClickedOk()中，声明dlg变量，且以IDD_DLG_XIN为模板创建dlg</span></span><br><span class="line"><span class="comment">// 此时此非模态窗口只会闪一下消失【消息处理程序结束，dlg被析构】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CMFCAppDlg 消息处理程序</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMFCAppDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">    dlg.<span class="built_in">Create</span>(IDD_DLG_XIN, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>与模态对话框的创建不同，非模态对话框的对象应该声明为全局变量，或主窗口类的成员变量【<code>MFCAppDlg.h</code>中】。</li><li><code>dlg</code> 变量需要在主窗口初始化函数中创建，并指定创建模板。</li><li>在MFC中，对资源的操作通常都是通过一个与资源相关的类来完成【对话框资源对应CDialog基类】。</li></ul><blockquote><p>非模态对话框用于关于文档、帮助文档等，不会影响主程序的事务；而模态对话框用于设置等会影响主窗口的事务。</p></blockquote><h3 id="6-3-动态创建按钮"><a href="#6-3-动态创建按钮" class="headerlink" title="6.3 动态创建按钮"></a>6.3 动态创建按钮</h3><p>在资源视图下，【<code>MFCApp.rc</code> -&gt; <code>Dialog</code>】选择 <code>IDD_DLG_XIN</code> 进行后续操作。</p><p>创建按钮的方法：</p><ol><li>直接从右侧工具箱拖拽进对话框【<code>Delete</code> 删除】【静态方式添加】</li><li>动态添加按钮【动态方式添加】</li></ol><p><strong>按钮的属性：</strong></p><ul><li>外观：<ul><li>Caption【标题】：，按钮显示文字；可以使用【<code>按钮内容(&amp;B)</code>】的方式添加快捷键【Alt + B】。</li><li>Bitmap【位图】：是否有图标位图。</li><li>Client Edge【客户端边缘】：是否有一个凹陷的边框效果，False时为平面图效果。</li><li>Modal Frame【模式框架】：是否有一个突出的边框效果，False时为平面图效果。</li><li>Static Edge【静态边缘】：是否有静态边框，True时为多边框。</li><li>Flat【平面】：是否为平面图。</li><li>Transparent：是否透明。</li><li>Horizontal Align：水平对齐。</li><li>Vertical Align：垂直对齐。</li><li>Icon：是否只显示图标，不显示文本。</li><li>MultiLine【多行】：是否多行文本。</li><li>Notify【通知】：是否主动通知父窗口，此时本按钮获得焦点，如获得焦点后出现蓝色边框。</li><li>Right Align Text【文本右对齐】：是否为右对齐的文本对齐方式。</li><li>Right To Left Reading Order【从右到左阅读顺序】：阅读顺序，只对英文有效果。</li></ul></li><li>动态布局：<ul><li>调整大小类型：当调整对话框大小时，按钮是否随之调整大小，默认无。</li><li>移动类型类似。</li></ul></li><li>行为：<ul><li>Accept File【接受文件】：是否运行拖入文件。</li><li>Default Button【默认按钮】：默认被激活，如确认按钮，按回车即可触发消息处理函数。</li><li>Disabled【已禁用】：是否禁用。</li><li>HelpID【帮助ID】：是否有对应的帮助文档。</li><li>Owner Draw【所有者描述】：是否使用手动绘制该按钮。若为False，则采用MFC默认的绘制方式。</li><li>Visuable【可见】：是否可见，否则为隐藏。</li></ul></li><li>杂项：<ul><li>Group【组】：如果使用了Group Box控件，可以设置组。</li><li>ID：控件ID。</li><li>Tabstop【制表位】：是否允许Tab键停留。Tab可以切换焦点，False时不参与到切换列表。</li></ul></li></ul><p><img src="/.io//6-1.png"></p><blockquote><p>点击可预览设计的对话框界面。</p></blockquote><p>双击按钮，为按钮添加消息处理函数。在消息处理函数中，动态添加另一个按钮。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMyDialog.h中</span></span><br><span class="line"><span class="comment">// CMyDialog 对话框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDialog</span> : <span class="keyword">public</span> CDialog</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CButton m_button;<span class="comment">//----需要成员变量------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;    <span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnBnClickedButton1</span><span class="params">()</span></span>;	<span class="comment">// 静态创建按钮的消息处理函数【声明】</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMyDialog.cpp 中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\r\n&quot;</span>,__FILE__, __LINE__,__FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (m_button.m_hWnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// dwStyle可选值：WS为控件通用风格，BS为按钮独有风格【点击查看更多风格】</span></span><br><span class="line">        <span class="comment">//在对话框上动态添加一个按钮</span></span><br><span class="line">        m_button.<span class="built_in">Create</span>(_T(<span class="string">&quot;动态创建按钮&quot;</span>), BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, <span class="built_in">CRect</span>(<span class="number">200</span>, <span class="number">50</span>, <span class="number">400</span>, <span class="number">90</span>), <span class="keyword">this</span>, <span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态创建按钮，需要注意的是：</p><ul><li>需要创建类成员变量【不建议使用Public，建议Protected】</li><li>动态创建按钮的应用场景：根据用户输入改变UI。</li><li>Create函数的参数中，nID不可以重复，否则可能会有未知错误。</li><li>优势在于：不使用时不会创建，不会占用资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CButton类，Create函数原型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CButton</span> : <span class="keyword">public</span> CWnd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DECLARE_DYNAMIC</span>(CButton)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CButton</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">Create</span><span class="params">(LPCTSTR lpszCaption, DWORD dwStyle,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> RECT&amp; rect, CWnd* pParentWnd, UINT nID)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="6-4-控件的访问"><a href="#6-4-控件的访问" class="headerlink" title="6.4 控件的访问"></a>6.4 控件的访问</h3><p>使用前面的 <code>MFCApp</code> 项目，继续在 <code>IDD_DLG_XIN</code> 的UI编辑页面添加控件。添加三个编辑框的方式有以下几种：</p><ol><li>直接多次拖放；</li><li>拖放一次，然后复制粘贴；</li><li>按住Ctrl后点击Edit Contrl【编辑框控件】，然后在设计界面多次点击即可【再次点击指针工具取消此状态】。</li></ol><p>然后，为三个编辑框更改ID，此处修改为<code>IDC_EDIT_ONE</code>，以此类推。</p><p>🔺下面的任务是：为三个编辑框设置初始文本。如何访问拖放添加的控件呢？</p><p>类试图中选择<code>CMyDialog</code>类，在属性页中点击重写，选择重写 <code>OnInitDialog</code> 函数。</p><p>而编辑框控件编程，有六种实现方式：如下。</p><h4 id="6-4-1-Get-SetWindowText"><a href="#6-4-1-Get-SetWindowText" class="headerlink" title="6.4.1 Get/SetWindowText"></a>6.4.1 Get/SetWindowText</h4><p><code>Get/SetWindowText()</code> 合用，设置和获取编辑框文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    CWnd* pEdit01 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_ONE);</span><br><span class="line">    CWnd* pEdit02 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_TWO);</span><br><span class="line">    CWnd* pEdit03 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_THREE);</span><br><span class="line">    <span class="comment">// 设置初始文本</span></span><br><span class="line">    <span class="keyword">if</span> (pEdit01 !=  <span class="literal">NULL</span>)</span><br><span class="line">        pEdit01-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;100&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (pEdit02 != <span class="literal">NULL</span>)</span><br><span class="line">        pEdit02-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;200&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (pEdit03 != <span class="literal">NULL</span>)</span><br><span class="line">        pEdit03-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;300&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取文本</span></span><br><span class="line">    CString strText;</span><br><span class="line">    pEdit01-&gt;<span class="built_in">GetWindowText</span>(strText);</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">    <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>初次代码编写时，编辑器会识别不了 <code>IDD_EDIT_ONE</code> 等ID，需要一次编译后，才会将ID自动在 <code>Resource.h</code> 中生成。</li><li><code>SetWindowText</code> 本身是一个宏，会根据是否为UNICODE，自动切换为<code>SetWindowTextW</code>和<code>SetWindowTextA</code>。【这种使用宏定义的方式实现跨编码的编程，在Windows中非常常见】</li></ul><br><h4 id="6-4-2-Get-SetDlgItemText"><a href="#6-4-2-Get-SetDlgItemText" class="headerlink" title="6.4.2 Get/SetDlgItemText"></a>6.4.2 Get/SetDlgItemText</h4><p><code>GetDlgItemText()</code> 和 <code>SetDlgItemText()</code> 合用，设置和获取编辑框文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    CWnd* pEdit01 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_ONE);</span><br><span class="line">    CWnd* pEdit02 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_TWO);</span><br><span class="line">    CWnd* pEdit03 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_THREE);</span><br><span class="line">    <span class="comment">// 设置初始文本</span></span><br><span class="line">    CString strText;</span><br><span class="line">    <span class="keyword">if</span> (pEdit01 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//pEdit01-&gt;SetWindowText(_T(&quot;100&quot;));</span></span><br><span class="line">        <span class="built_in">SetDlgItemText</span>(IDC_EDIT_ONE, _T(<span class="string">&quot;100&quot;</span>));<span class="comment">//与上等效</span></span><br><span class="line">        <span class="built_in">GetDlgItemText</span>(IDC_EDIT_ONE, strText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="6-4-3-Get-SetDlgItemInt"><a href="#6-4-3-Get-SetDlgItemInt" class="headerlink" title="6.4.3 Get/SetDlgItemInt"></a>6.4.3 Get/SetDlgItemInt</h4><p>Get/SetDlgItemInt() 设置整型数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetDlgItemInt</span>(IDC_EDIT_THREE, <span class="number">300</span>);</span><br><span class="line">    <span class="comment">//是否传输成功的标志；也可以不填，默认0，即不报告是否传输成功</span></span><br><span class="line">    BOOL isTrans = FALSE;</span><br><span class="line">    UINT ret = <span class="built_in">GetDlgItemInt</span>(IDC_EDIT_THREE,&amp;isTrans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">    <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="6-4-4-控件与数据变量相关联"><a href="#6-4-4-控件与数据变量相关联" class="headerlink" title="6.4.4 控件与数据变量相关联"></a>6.4.4 控件与数据变量相关联</h4><p>首先，为控件添加变量：在UI编辑页，右键点击编辑框ONE，选择添加变量。在对话框中选择类别为值，名称为<code>m_value1</code>，访问类型public，变量类型为int，添加注释【可选】。点击下一步，设置最大值和最小值，最后点击完成。</p><p>上面的操作，等价于以下变化：</p><ul><li><p>在 <code>CMyDialog.h</code> 中，添加 <code>public</code> 的 <code>int</code> 型成员变量<code>m_value1</code>。</p></li><li><p>在 <code>CMyDialog.cpp</code>中，构造函数对成员变量初始化 + 数据转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyDialog::<span class="built_in">CMyDialog</span>(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">    : <span class="built_in">CDialog</span>(IDD_DLG_XIN, pParent)</span><br><span class="line">    , <span class="built_in">m_value1</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">    <span class="built_in">DDX_Text</span>(pDX, IDC_EDIT_ONE, m_value1);</span><br><span class="line">    <span class="built_in">DDV_MinMaxInt</span>(pDX, m_value1, <span class="number">-9999</span>, <span class="number">9999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同理，继续为其余两个编辑框控件添加变量<code>m_value2</code>和<code>m_value3</code>，访问类型<code>public</code>，变量类型为<code>int</code>，为<code>m_value2</code>设置最大值和最小值。</p><p>双击本UI对话框的确定按钮，为其添加消息处理函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cBOOL <span class="title">CMyDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    CWnd* pEdit01 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_ONE);</span><br><span class="line">    CWnd* pEdit02 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_TWO);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pEdit01 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">SetDlgItemText</span>(IDC_EDIT_ONE, _T(<span class="string">&quot;100&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pEdit02 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pEdit02-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;200&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SetDlgItemInt</span>(IDC_EDIT_THREE, <span class="number">400</span>);</span><br><span class="line">    <span class="comment">//是否传输成功的标志；也可以不填，默认0，即不报告是否传输成功</span></span><br><span class="line">    BOOL isTrans = FALSE;</span><br><span class="line">    UINT ret = <span class="built_in">GetDlgItemInt</span>(IDC_EDIT_THREE,&amp;isTrans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">    <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="comment">/*CDialog::OnOK();*/</span></span><br><span class="line">    <span class="comment">// 此时两个编辑框显示为100、200、400</span></span><br><span class="line">    <span class="built_in">UpdateData</span>();		<span class="comment">// 更新数据，将控件值填至变量</span></span><br><span class="line">    m_value3 = m_value1 + m_value2;</span><br><span class="line">    <span class="built_in">UpdateData</span>(FALSE);	<span class="comment">// 更新数据，将变量填至控件值</span></span><br><span class="line">    <span class="comment">//此时,为100\200\300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="6-4-5-控件与控件变量相关联"><a href="#6-4-5-控件与控件变量相关联" class="headerlink" title="6.4.5 控件与控件变量相关联"></a>6.4.5 控件与控件变量相关联</h4><p>与上一节类似，为编辑框控件添加控件变量。在对话框中选择类别为控件，名称为<code>m_edit1/2/3</code>，访问类型public，变量类型默认为<code>CEdit</code>。</p><p>上面的操作，等价于以下变化：</p><ul><li><p>在 <code>CMyDialog.h</code> 中，添加 <code>public</code> 的 <code>CEdit</code> 型成员变量。</p></li><li><p>在 <code>CMyDialog.cpp</code>中，数据转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">    <span class="built_in">DDX_Text</span>(pDX, IDC_EDIT_ONE, m_value1);</span><br><span class="line">    <span class="built_in">DDV_MinMaxInt</span>(pDX, m_value1, <span class="number">-9999</span>, <span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">DDX_Text</span>(pDX, IDC_EDIT_TWO, m_value2);</span><br><span class="line">    <span class="built_in">DDV_MinMaxInt</span>(pDX, m_value2, <span class="number">-9999</span>, <span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">DDX_Text</span>(pDX, IDC_EDIT_THREE, m_value3);</span><br><span class="line">    <span class="built_in">DDX_Control</span>(pDX, IDC_EDIT_ONE, m_edit1);</span><br><span class="line">    <span class="built_in">DDX_Control</span>(pDX, IDC_EDIT_TWO, m_edit2);</span><br><span class="line">    <span class="built_in">DDX_Control</span>(pDX, IDC_EDIT_THREE, m_edit3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>双击本UI对话框的确定按钮，为其添加消息处理函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="comment">/*CDialog::OnOK();*/</span></span><br><span class="line">    <span class="comment">// 此时两个编辑框显示为100、200、400</span></span><br><span class="line">    CString str1, str2, str3;</span><br><span class="line">    m_edit<span class="number">1.</span><span class="built_in">GetWindowText</span>(str1);</span><br><span class="line">    m_edit<span class="number">2.</span><span class="built_in">GetWindowText</span>(str2);</span><br><span class="line">    <span class="type">int</span> t = _wtoi(str1) + _wtoi(str2);</span><br><span class="line">    TCHAR buf[<span class="number">32</span>] = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//str3 = _itow(t, buf, 10);//十进制,t转为str</span></span><br><span class="line">    <span class="type">int</span> err_no = _itow_s(t, buf, <span class="number">10</span>);</span><br><span class="line">    str3 = buf;</span><br><span class="line">    m_edit<span class="number">3.</span><span class="built_in">SetWindowText</span>(str3);</span><br><span class="line">    <span class="comment">// 此时两个编辑框显示为100、200、300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="6-4-6-SendMessage通用方法"><a href="#6-4-6-SendMessage通用方法" class="headerlink" title="6.4.6 SendMessage通用方法"></a>6.4.6 SendMessage通用方法</h4><p>Windows是基于消息的系统，SendMessage是其进程通信的方式之一。本质上，以上的控件访问方式也是对SendMessage的封装。</p><p>在 <code>CMyDialog.cpp</code> 中，写在Button1的消息处理函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\r\n&quot;</span>,__FILE__, __LINE__,__FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (m_button.m_hWnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// dwStyle可选值：WS为控件通用风格，BS为按钮独有风格【点击查看更多风格】</span></span><br><span class="line">        m_button.<span class="built_in">Create</span>(_T(<span class="string">&quot;动态创建按钮&quot;</span>), BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, <span class="built_in">CRect</span>(<span class="number">200</span>, <span class="number">50</span>, <span class="number">400</span>, <span class="number">90</span>), <span class="keyword">this</span>, <span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCHAR buf[<span class="number">20</span>] = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 系统的全局函数:发消息获取其内容</span></span><br><span class="line">    ::<span class="built_in">SendMessage</span>(m_edit<span class="number">1.</span>m_hWnd, WM_GETTEXT, <span class="number">20</span>, (LPARAM)buf);<span class="comment">//此时buf=100</span></span><br><span class="line">    m_edit<span class="number">1.</span><span class="built_in">SendMessage</span>(WM_SETTEXT,<span class="built_in">sizeof</span>(buf),(LPARAM)buf);</span><br><span class="line">    <span class="comment">// CMyDialog类的SendMessage,相当于this.SendMessage,该控件发出消息:获取</span></span><br><span class="line">    <span class="built_in">SendMessage</span>(WM_GETTEXT, <span class="number">20</span>, (LPARAM)buf);<span class="comment">//此时buf=MyDialog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>此处的 <code>SendMessage</code> 函数为Windows系统函数，并非类内函数，故加 <code>::</code> 表示全局函数</li></ul><br><h3 id="6-5-对话框伸缩功能的实现"><a href="#6-5-对话框伸缩功能的实现" class="headerlink" title="6.5 对话框伸缩功能的实现"></a>6.5 对话框伸缩功能的实现</h3><p>使用前面的 <code>MFCApp</code> 项目，继续在 <code>IDD_DLG_XIN</code> 的UI编辑页面添加控件。</p><p>本节添加两个按钮，Caption标题为方法、缩小，修改ID为 <code>IDC_BTN_LARGE</code> 和 <code>IDC_BTN_SMALL</code>。然后双击按钮添加消息处理函数。</p><p>对于窗口放大缩小，需要在 <code>CMyDialog.h</code> 中定义一个范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMyDialog.h</span></span><br><span class="line"><span class="comment">// CMyDialog 对话框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDialog</span> : <span class="keyword">public</span> CDialog</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnBnClickedBtnLarge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnBnClickedBtnSmall</span><span class="params">()</span></span>;</span><br><span class="line">    CRect m_large;	<span class="comment">// 放大范围</span></span><br><span class="line">    CRect m_small;	<span class="comment">// 缩小范围</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>CRect由left、top、right、bottom位置坐标构成一个矩形。</p><p><img src="/.io//6-2.png"></p></blockquote><p>然后在 <code>CMyDialog.cpp</code> 的 <code>OnInitDialog()</code> 中初始化，最后在按钮的消息处理函数中处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyDialog::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="built_in">GetWindowRect</span>(m_large);	<span class="comment">// 获取窗口大小</span></span><br><span class="line">    m_small = m_large;</span><br><span class="line">    m_small.right = m_small.left + m_small.<span class="built_in">Width</span>() / <span class="number">2</span>;</span><br><span class="line">    m_small.bottom = m_small.top + m_small.<span class="built_in">Height</span>() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedBtnLarge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    CRect curRect;</span><br><span class="line">    <span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line">    <span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top, m_large.<span class="built_in">Width</span>(),</span><br><span class="line">        m_large.<span class="built_in">Height</span>(), SWP_NOMOVE | SWP_NOZORDER);<span class="comment">//不移动|不改变窗口顺序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedBtnSmall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    CRect curRect;</span><br><span class="line">    <span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line">    <span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top, m_small.<span class="built_in">Width</span>(),</span><br><span class="line">        m_small.<span class="built_in">Height</span>(), SWP_NOMOVE | SWP_NOZORDER);<span class="comment">//不移动|不改变窗口顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码重复率太高，下面优化代码，使得一个按钮实现两个功能【对缩小按钮改造】：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyDialog::OnBnClickedBtnSmall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    CRect curRect;</span><br><span class="line">    <span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line">    CWnd* pBtn = <span class="built_in">GetDlgItem</span>(IDC_BTN_SMALL);</span><br><span class="line">    CString title;</span><br><span class="line">    <span class="keyword">if</span> (pBtn) &#123;</span><br><span class="line">        pBtn-&gt;<span class="built_in">GetWindowText</span>(title);</span><br><span class="line">        <span class="keyword">if</span> (title == _T(<span class="string">&quot;缩小&quot;</span>) &amp;&amp; !m_small.<span class="built_in">IsRectEmpty</span>()) &#123;</span><br><span class="line">            pBtn-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;放大&quot;</span>));</span><br><span class="line">            <span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top, m_small.<span class="built_in">Width</span>(),</span><br><span class="line">                m_small.<span class="built_in">Height</span>(), SWP_NOMOVE | SWP_NOZORDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (title == _T(<span class="string">&quot;放大&quot;</span>) &amp;&amp; !m_large.<span class="built_in">IsRectEmpty</span>()) &#123;</span><br><span class="line">            pBtn-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;缩小&quot;</span>));</span><br><span class="line">            <span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top, m_large.<span class="built_in">Width</span>(),</span><br><span class="line">                m_large.<span class="built_in">Height</span>(), SWP_NOMOVE | SWP_NOZORDER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li><p>改变窗口的大小和位置：<code>Wnd::SetWindowPos()</code> 从父类继承。</p><ul><li><p>设置全局的置顶显示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetWindowPos</span>(&amp;wndTopMost, curRect.left, curRect.top, m_large.<span class="built_in">Width</span>(),</span><br><span class="line">                m_large.<span class="built_in">Height</span>(), SWP_NOMOVE);</span><br><span class="line"><span class="comment">// wndTop：置顶</span></span><br><span class="line"><span class="comment">// wndBottom：移动至最底层【z-order：窗口叠加顺序】</span></span><br><span class="line"><span class="comment">// wndTopMost：总是置顶</span></span><br><span class="line"><span class="comment">// wndNoTopMost</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断一个矩形是否为空：</p><ul><li><code>IsRectEmpty()</code>：判断矩形面积是否为空。</li><li><code>IsRectNull()</code>：判断矩形的四个坐标值是否为0，不关心是否能做为一个矩形。</li></ul></li></ul><br><h3 id="6-6-对话框项目：逃跑按钮"><a href="#6-6-对话框项目：逃跑按钮" class="headerlink" title="6.6 对话框项目：逃跑按钮"></a>6.6 对话框项目：逃跑按钮</h3><p>在上一节 <code>MFCApp</code> 的主界面，加入一个按钮，点击后跳转本项目的对话框。</p><ol><li><p>在 <code>IDD_MFCAPP_DIALOG</code> 中创建按钮，修改ID为 <code>IDC_BTN_PROJ</code>，修改Caption为：逃跑按钮项目，最后双击添加消息处理函数 <code>OnBnClickedBtnProj()</code>。</p></li><li><p>【回顾6.2创建和添加视图和类】新增视图 <code>IDD_DLG_PROJ</code>，右键创建类，类名为<code>CProjectRun</code>，基类类型为<code>CDialog</code>。</p></li><li><p>本项目为模态对话框，故不需要设置为全局变量来保存窗口。直接在按钮消息处理函数中，打开本项目的对话框即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCAppDlg::OnBnClickedBtnProj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="comment">//创建模态对话框</span></span><br><span class="line">    CProjectRun dlgProj;</span><br><span class="line">    dlgProj.<span class="built_in">DoModal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始本项目的内容：【基本核心功能】两个按钮，当不捕获到鼠标悬浮事件，则隐藏该按钮，显示另一个按钮。</p><ul><li>自定义按钮类，重写Button，但由于与标准类区别不太，故只从 <code>CButton</code> 派生即可【单独加一个鼠标移动消息的功能】</li><li>定义一个成员，专门用来指向另外一个按钮。</li></ul></li></ol><p><img src="/.io//6-3.png"></p><br><p>具体操作如下：</p><ol><li><p>新建两个按钮，修改UI，修改Caption标题和 ID【<code>IDC_BTN_LEFT</code> | <code>IDC_BTN_RIGHT</code>】</p><ul><li><code>shift</code>点选或框选，可选中两个按钮。</li><li>再 <code>Ctrl</code> 点选可设置为参考控件，从而可以使用右上角的快捷功能：位置对齐、大小相同、高度相同、宽度相同等。</li></ul></li><li><p>右键为两个按钮添加变量：【只能是控件】，控件名称为<code>m_btn_left</code> 和 <code>m_btn_right</code>。</p></li><li><p>设置右侧按钮属性为不可见：Visible。</p></li><li><p>重载CButton：</p><ol><li>类试图下右键<code>MFCApp</code>，选择类向导，左侧点击添加类，下拉菜单选择添加MFC类。</li><li>基类选择<code>CButton</code>，类名修改为<code>CMyButton</code>，现阶段不需要Activity自动化的内容。</li><li>类试图下选中<code>CMyButton</code>，添加 <code>OnMouseMove</code> 消息响应函数。</li><li>在<code>CMyButton.h</code>中加入一个指针，指向另一个按钮：<code>CMyButton* m_btn;</code></li></ol></li><li><p>在 <code>CProjectRun.h</code> 中引入 <code>CMyButton</code> 的头文件，替换成员为 <code>CMyButton</code>类型；并在初始化函数中初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CProjectRun.cpp中</span></span><br><span class="line">CProjectRun::<span class="built_in">CProjectRun</span>(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">    : <span class="built_in">CDialog</span>(IDD_DLG_PROJ, pParent)</span><br><span class="line">&#123;</span><br><span class="line">    m_btn_left.m_btn = &amp;m_btn_right;</span><br><span class="line">    m_btn_right.m_btn = &amp;m_btn_left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑CMybutton下添加的<code>OnMouseMove</code> 消息响应函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyButton::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(SW_HIDE);<span class="comment">// 隐藏自己</span></span><br><span class="line">    <span class="keyword">if</span> (m_btn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_btn-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    &#125;</span><br><span class="line">    CButton::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><br><p>🔺着重说明一个错误的实现思路：在 <code>CProjectRun.cpp</code> 中添加 <code>OnMouseMove</code> 的消息响应函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CProjectRun::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRect left, right;</span><br><span class="line">    m_btn_left.<span class="built_in">GetWindowsRect</span>(left);</span><br><span class="line">    <span class="keyword">if</span>(right.<span class="built_in">PtInRect</span>(point) == TRUE)&#123;    <span class="comment">// 如果鼠标坐标在按钮矩形内</span></span><br><span class="line">        m_btn_left.<span class="built_in">ShowWindow</span>(SW_HIDE);    <span class="comment">// 隐藏左侧按钮</span></span><br><span class="line">        m_btn_right.<span class="built_in">ShowWindow</span>(SW_SHOW);<span class="comment">// 显示右侧按钮</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Trace</span>(<span class="string">&quot;%s(%d)%s:(%d,%d)&quot;</span>,__FILE__,__LINE__,__FUNCTION__,point.x, point.y);</span><br><span class="line">    CDialog::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="background-color:orange">编译运行发现，鼠标移动会触发消息打印日志，但移动到按钮处停止打印。</span></p><p><span style="background-color:green">原因</span>：按钮显示在父窗口之上，鼠标移动的消息会被按钮所捕获，不会传递到父窗口【正在打印日志的窗口】。</p><br><h3 id="6-7-项目：职业调查"><a href="#6-7-项目：职业调查" class="headerlink" title="6.7 项目：职业调查"></a>6.7 项目：职业调查</h3><p>MFC对话框定制开发，本项目目标：</p><ol><li>第一个对话框实现两个单选：选择语言和企业；</li><li>第二个对话框实现复选框：选择多个技能；</li><li>第三个对话框下拉菜单选择期望薪资；</li><li>第四个对话框给出结果。</li></ol><p><img src="/.io//6-6.png" alt="img"></p><br><h4 id="6-7-1-创建三个属性页"><a href="#6-7-1-创建三个属性页" class="headerlink" title="6.7.1 创建三个属性页"></a>6.7.1 创建三个属性页</h4><p>在上一节的项目一样，在 <code>MFCApp</code> 的主界面，加入一个按钮，点击后跳转本项目的对话框。</p><ol><li><p>在 <code>IDD_MFCAPP_DIALOG</code> 中创建按钮，修改ID为 <code>IDC_BTN_QUERY</code>，修改Caption为：职业调查，最后双击添加消息处理函数 <code>OnBnClickedBtnQuery()</code>。</p></li><li><p>在资源视图【<code>MFCApp.rc</code> -&gt; <code>Dialog</code>】下，新增资源视图，选择<code>Dialog</code>下的<span style="background-color:#ff0">属性页</span><code>IDD_PROPAGE_SMALL</code>【<code>_Large</code>或<code>_middle</code>也行，只是大小的区别】，ID重命名为 <code>_PROP_01</code>，Caption为【语言和公司】。</p><ol><li>添加一个GroupBox，修改Caption为【请选择你的语言：】</li><li>添加三个Radio Button，修改Caption为【C++ | JAVA | Python】，修改位置使三个按钮左对齐，垂直均匀分布【右上角处：左对齐工具、垂直工具和纵向工具】，修改相应的ID为<code>IDC_RADIO_CPP/JAVA/PYTHON</code>。</li><li>右侧添加一个静态文本Static，修改Caption为【请选择你的公司：】</li><li>下面加入一个List Box，修改ID为<code>IDC_LIST_COMPANY</code>。</li></ol></li><li><p>右键该属性页，选择类向导。类向导对话框中，打开右侧添加类的下拉菜单，选择MFC类，基类选择 <code>CPropertyPage</code>，类名命名为<code>PROP_01</code>【保证资源识别出的ID与上一步创建的属性页ID一致】。</p></li><li><p>为该属性页中的控件添加值变量：</p><ul><li><p>为C++ Radio添加变量，类别为值，访问属性public，变量类型BOOL，变量名<code>m_lang</code>，变量名注释为【开发语言状态】。</p></li><li><p>由于为三个Radio添加三个变量的做法，太过低效，故修改 <code>PROP_01.h</code> 中的public变量 <code>m_lang</code> 为 <code>m_lang[3]</code>，并修改 <code>PROP_01.cpp</code> 中的两处变量初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROP_01.cpp 中</span></span><br><span class="line">PROP_01::<span class="built_in">PROP_01</span>()</span><br><span class="line">    : <span class="built_in">CPropertyPage</span>(IDD_PROP_01)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(m_lang, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_lang));<span class="comment">//此处修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PROP_01::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPropertyPage::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">    <span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_CPP, m_lang[<span class="number">0</span>]);<span class="comment">//此处修改</span></span><br><span class="line">    <span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_JAVA, m_lang[<span class="number">1</span>]);<span class="comment">//此处修改</span></span><br><span class="line">    <span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_PYTHON, m_lang[<span class="number">2</span>]);<span class="comment">//此处修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>初始化该属性页中的List Box：类视图下选中<code>PROP_01</code>，右侧属性页选择重写，重写该属性页的初始化函数 <code>OnInitDialog</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_01::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPropertyPage::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="comment">// GetDlgItem 返回CWnd指针，而CWnd是CListBox的父类，我们需要更具体子类</span></span><br><span class="line">    CListBox* pListBox= (CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST_COMPANY);</span><br><span class="line">    <span class="keyword">if</span> (pListBox) &#123;</span><br><span class="line">        pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;阿里巴巴&quot;</span>));</span><br><span class="line">        pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">        pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;腾讯&quot;</span>));</span><br><span class="line">        pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;京东&quot;</span>));</span><br><span class="line">        pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;百度&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">    <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/.io//6-4.png"></p><p>至此，第一个属性页基本添加完毕。下面添加第二个属性页：</p><ol><li><p>在资源视图下添加资源，选择<code>Dialog</code>下的<span style="background-color:#ff0">属性页</span><code>IDD_PROPAGE_SMALL</code>，ID重命名为 <code>_PROP_02</code>，Caption为【技能选择】。</p></li><li><p>添加Group Box，，修改Caption为【请选择你的技能：】</p></li><li><p>添加四个Check Box，进行对齐，修改Caption为【网络编程 | MFC | 操作系统 | 数据结构】</p></li><li><p>右键选择类向导，添加类选择MFC类，基类选择 <code>CPropertyPage</code>，类名命名为<code>PROP_02</code>。</p></li><li><p>为该属性页中的控件添加变量：</p><ol><li><p>为第一个复选框添加变量，类别为值，访问属性public，变量类型BOOL，变量名<code>m_skill</code>，注释为【工作技能】</p></li><li><p>由于为四个复选框添加四个变量的做法，太过低效，故修改 <code>PROP_02.h</code> 中的public变量 <code>m_skill</code> 为 <code>m_skill[4]</code>，并修改 <code>PROP_02.cpp</code> 中的两处变量初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROP_02.cpp 中</span></span><br><span class="line">PROP_02::<span class="built_in">PROP_02</span>()</span><br><span class="line">    : <span class="built_in">CPropertyPage</span>(IDD_PROP_02)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(m_skill, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_skill));	<span class="comment">// 此处修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PROP_02::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPropertyPage::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CHECK1, m_skill[<span class="number">0</span>]);<span class="comment">// 网络编程</span></span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CHECK2, m_skill[<span class="number">1</span>]);<span class="comment">// MFC</span></span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CHECK3, m_skill[<span class="number">2</span>]);<span class="comment">// 操作系统</span></span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CHECK4, m_skill[<span class="number">3</span>]);<span class="comment">// 数据结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>至此，第二个属性页基本添加完毕。下面添加第三个属性页：</p><ol><li><p>在资源视图下添加资源，选择<code>Dialog</code>下的<span style="background-color:#ff0">属性页</span><code>IDD_PROPAGE_SMALL</code>，ID重命名为 <code>_PROP_03</code>，Caption为【选择薪资水平】。</p></li><li><p>添加组合框Combo Box，修改ID为<code>IDC_COMBO_MONEY</code></p><ul><li><p>点击下拉箭头，纵向拉伸组合框大小【下拉菜单出现时，尽可能不因为显示不下而出现滚轮】。</p></li><li><p>编辑此控件属性【数据Data】，以英文分号间隔，显示为下拉选项。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">10000</span>元以下;<span class="number">10000</span>~<span class="number">15000</span>元;<span class="number">15000</span>~<span class="number">20000</span>元;<span class="number">20000</span>元以上</span><br></pre></td></tr></table></figure></li></ul></li><li><p>右键选择类向导，添加类选择MFC类，基类选择 <code>CPropertyPage</code>，类名命名为<code>PROP_03</code>。</p></li><li><p>为该属性页中的组合框添加变量：类别为值，访问属性public，变量类型BOOL，变量名<code>m_money</code>，注释为【薪资范围】。</p></li></ol><br><h4 id="6-7-2-创建属性表单"><a href="#6-7-2-创建属性表单" class="headerlink" title="6.7.2 创建属性表单"></a>6.7.2 创建属性表单</h4><p>本节创建属性表单，整合三个属性页。</p><ol><li><p>类视图，右键 <code>MFCApp</code> 选择类向导，添加MFC类。基类选择 <code>CPropertySheet</code>，类名<code>CMyPropSheet</code>，头文件和cpp文件命名为 <code>MyPropSheet.h/cpp</code>。</p><ul><li>注意：CMyPropSheet类的构造函数有两个，后续需要分别处理。</li></ul></li><li><p>在 <code>MyPropSheet.h</code> 中加入三个属性页：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyPropSheet</span> : <span class="keyword">public</span> CPropertySheet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PROP_01 m_prop1;</span><br><span class="line">    PROP_02 m_prop2;</span><br><span class="line">    PROP_03 m_prop3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>MyPropSheet.cpp</code> 中的构造函数添加属性页：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用【ID、父窗口指针、被选中的属性页】构造</span></span><br><span class="line">CMyPropSheet::<span class="built_in">CMyPropSheet</span>(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">    :<span class="built_in">CPropertySheet</span>(nIDCaption, pParentWnd, iSelectPage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AddPage</span>(&amp;m_prop1);</span><br><span class="line">    <span class="built_in">AddPage</span>(&amp;m_prop2);</span><br><span class="line">    <span class="built_in">AddPage</span>(&amp;m_prop3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用【字符串、父窗口指针、被选中的属性页】构造</span></span><br><span class="line">CMyPropSheet::<span class="built_in">CMyPropSheet</span>(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">    :<span class="built_in">CPropertySheet</span>(pszCaption, pParentWnd, iSelectPage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AddPage</span>(&amp;m_prop1);</span><br><span class="line">    <span class="built_in">AddPage</span>(&amp;m_prop2);</span><br><span class="line">    <span class="built_in">AddPage</span>(&amp;m_prop3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回到上一节最开始，在 <code>MFCAppDlg.cpp</code> 中编辑消息处理函数 <code>OnBnClickedBtnQuery()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">CMFCAppDlg::OnBnClickedBtnQuery</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="function">CMyPropSheet <span class="title">dlg</span><span class="params">(_T(<span class="string">&quot;职业调查&quot;</span>),<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 正常的PropertySheet是Tab页的格式，此处使用向导模式：</span></span><br><span class="line">    dlg.<span class="built_in">SetWizardMode</span>();<span class="comment">// 开启想到模式</span></span><br><span class="line">    dlg.<span class="built_in">DoModal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译运行，点击职业调查后报错如下：</p><p><img src="/.io//6-5.png"></p></li><li><p><code>Everything</code>搜索：<code>dlgdata.cpp</code>，使用Notepad++打开，转到269行：Assert断言报错【可能缺少<code>WS_GROUP</code>的属性】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 269行</span></span><br><span class="line"><span class="built_in">ASSERT</span>(::<span class="built_in">GetWindowLong</span>(hWndCtrl, GWL_STYLE) &amp; WS_GROUP);</span><br></pre></td></tr></table></figure><ul><li>查看 <code>IDD_PROP_01</code> 中的第一个Radio，其属性中的Group确实是False。</li><li>修改第一个Radio的Group属性为True，则三个Radio会合并为一个；同时需要将 <code>PROP_01.h</code> 和 <code>PROP_01.cpp</code> 中的 <code>BOOL m_lang[3]</code> 修改为 <code>int m_lang</code>，初始化值为<code>-1</code>，即谁也不选。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROP_01.cpp 中</span></span><br><span class="line">PROP_01::<span class="built_in">PROP_01</span>()</span><br><span class="line">    : <span class="built_in">CPropertyPage</span>(IDD_PROP_01)</span><br><span class="line">     ,<span class="built_in">m_lang</span>(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//memset(m_lang, 0, sizeof(m_lang));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PROP_01::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPropertyPage::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">    <span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_CPP, m_lang);</span><br><span class="line">    <span class="comment">//DDX_Radio(pDX, IDC_RADIO_JAVA, m_lang[1]);</span></span><br><span class="line">    <span class="comment">//DDX_Radio(pDX, IDC_RADIO_PYTHON, m_lang[2]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决报错，运行正常，但存在诸多细节需要完善：</p><ul><li>无用的底部按钮：帮助。</li><li>需要添加或修改的按钮：完成、上一步、下一步。</li><li>最后的输出结果等。</li></ul></li></ol><br><h4 id="6-7-3-向导的创建和使用"><a href="#6-7-3-向导的创建和使用" class="headerlink" title="6.7.3 向导的创建和使用"></a>6.7.3 向导的创建和使用</h4><blockquote><p>本节的核心任务就是重写子属性页。</p></blockquote><blockquote><p>Wizard：向导。</p></blockquote><ol><li><p>重写第一个属性页【类试图下点击<code>PROP_01</code>，在右侧属性页中选择重写】，重写 <code>OnSetActive</code> 函数：</p><ul><li>同样，第二个属性页<code>PROP_02</code>只需要两个按钮：下一页、返回，隐藏帮助按钮；</li><li>第三个属性页<code>PROP_03</code>只需要两个按钮：下一页、返回，隐藏帮助按钮。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROP_01.cpp 中</span></span><br><span class="line"><span class="function">BOOL <span class="title">PROP_01::OnSetActive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="comment">// 获取该类的父类CWnd，转为CPropertySheet类，然后设置第一页的向导按钮</span></span><br><span class="line">    ((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">SetWizardButtons</span>(PSWIZB_NEXT);</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnSetActive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PROP_02.cpp 中</span></span><br><span class="line"><span class="function">BOOL <span class="title">PROP_02::OnSetActive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    ((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">SetWizardButtons</span>(PSWIZB_NEXT | PSWIZB_BACK);</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnSetActive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PROP_03.cpp 中</span></span><br><span class="line"><span class="function">BOOL <span class="title">PROP_03::OnSetActive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    ((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">SetWizardButtons</span>(PSWIZB_BACK | PSWIZB_FINISH);</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnSetActive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为<code>PROP_O1</code>属性页中的List Box添加变量，类别为值，变量名为 <code>m_company</code>，public访问，变量类型CString。</p></li><li><p>点击下一步时，需要对本页的数据进行校验，即为前两个属性页重写 <code>OnWizardNext()</code> 函数，为最后一个属性页重写 <code>OnWizardFinish()</code> 函数。</p><ul><li>注意：获取控件值前，一定要 <code>UpdateData()</code>！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROP_01.cpp 中</span></span><br><span class="line"><span class="function">LRESULT <span class="title">PROP_01::OnWizardNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="comment">// 数据校验</span></span><br><span class="line">    <span class="built_in">UpdateData</span>();</span><br><span class="line">    <span class="comment">//TRACE(&quot;m_lang:%d\r\n&quot;, m_lang);// 0 1 2</span></span><br><span class="line">    <span class="keyword">if</span> (m_lang == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择开发语言！&quot;</span>), _T(<span class="string">&quot;开发语言未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_company.<span class="built_in">GetLength</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择企业！&quot;</span>), _T(<span class="string">&quot;企业未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnWizardNext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PROP_02.cpp 中</span></span><br><span class="line"><span class="function">LRESULT <span class="title">PROP_02::OnWizardNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="built_in">UpdateData</span>();</span><br><span class="line">    <span class="type">bool</span> hasChosen = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_skill[i] == TRUE) &#123;</span><br><span class="line">            hasChosen = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasChosen) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择工作技能！&quot;</span>), _T(<span class="string">&quot;工作技能未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnWizardNext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PROP_03.cpp 中</span></span><br><span class="line"><span class="function">BOOL <span class="title">PROP_03::OnWizardFinish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="built_in">UpdateData</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_money.<span class="built_in">GetLength</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择薪资范围！&quot;</span>), _T(<span class="string">&quot;薪资范围未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnWizardFinish</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>至此，完成对三个属性页的整合。</p></li></ol><br><h4 id="6-7-4-属性表单的返回值处理"><a href="#6-7-4-属性表单的返回值处理" class="headerlink" title="6.7.4 属性表单的返回值处理"></a>6.7.4 属性表单的返回值处理</h4><p>在<code>6.7.1</code>节中，我们在<code>MFCAppDialog.cpp</code> 中创建了本项目按钮的消息处理函数 <code>OnBnClickedBtnQuery</code> ，在其中我们创建了一个模态对话框。</p><p>如果该对话框最后是由点击【完成按钮】结束的，则需要对返回值做相应处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCAppDlg::OnBnClickedBtnQuery</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="function">CMyPropSheet <span class="title">dlg</span><span class="params">(_T(<span class="string">&quot;职业调查&quot;</span>), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 正常的PropertySheet是Tab页的格式，此处使用向导模式：</span></span><br><span class="line">    dlg.<span class="built_in">SetWizardMode</span>();<span class="comment">// 开启想到模式</span></span><br><span class="line">    <span class="comment">//dlg.DoModal();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否由点击完成结束的对话框</span></span><br><span class="line">    <span class="keyword">if</span> (ID_WIZFINISH == dlg.<span class="built_in">DoModal</span>()) &#123;</span><br><span class="line">        CString strMsg = _T(<span class="string">&quot;您的选择是：&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (dlg.m_prop<span class="number">1.</span>m_lang) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            strMsg += _T(<span class="string">&quot;开发语言：C++&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            strMsg += _T(<span class="string">&quot;开发语言：JAVA&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            strMsg += _T(<span class="string">&quot;开发语言：Python&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        strMsg += _T(<span class="string">&quot;您的公司是：&quot;</span> + dlg.m_prop<span class="number">1.</span>m_company);</span><br><span class="line">        strMsg += _T(<span class="string">&quot;您的工作技能有：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CString strSkill[<span class="number">4</span>] = &#123; _T(<span class="string">&quot;网络编程&quot;</span>),_T(<span class="string">&quot;MFC&quot;</span>), _T(<span class="string">&quot;操作系统&quot;</span>), _T(<span class="string">&quot;数据结构&quot;</span>) &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dlg.m_prop<span class="number">2.</span>m_skill[i])</span><br><span class="line">                strMsg += strSkill[i] + _T(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strMsg += _T(<span class="string">&quot;您的期望薪资是：&quot;</span> + dlg.m_prop<span class="number">3.</span>m_money);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MessageBox</span>(strMsg,_T(<span class="string">&quot;最终信息&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-7-5-项目小结"><a href="#6-7-5-项目小结" class="headerlink" title="6.7.5 项目小结"></a>6.7.5 项目小结</h4><ul><li>由一个按钮触发本对话框项目，即属性表单PropertSheet。</li><li>属性表单在创建时会不断加入属性页，即PropertyPage。</li><li>完成属性页向导的操作后，将数据返回给属性表单，再返回给按钮的消息处理函数。</li></ul><p>这样的设计保持触发按钮所在类，与属性表单类的独立性，关系清晰，单项依赖。</p><br><p>🔺需要注意的小技巧：</p><ul><li>改变控件大小时遇到不能继续变大的情况，可能是因为原对话框的虚线框的大小限制，需要先拉大虚线框范围。</li><li>在UI编辑页面，点击控件，可以在最下方的状态栏看到控件大小。</li><li>在UI编辑页面，<code>Ctrl + D</code> 显示Tab焦点获取顺序。</li><li><code>DoDataExchange</code>函数的作用：为控件绑定变量和控件。</li><li><code>Resource.h</code> 中定义了资源的ID，及其对应的int值。自增规律是找到最大的数，然后自增。</li><li>在UI编辑页面，属性工具栏中的最上方，可以切换需要修改属性的控件【此功能用于空间摆放很密集或被遮挡的情况】。</li><li>在UI编辑页面</li></ul><br><h2 id="七-常用控件"><a href="#七-常用控件" class="headerlink" title="七 常用控件"></a>七 常用控件</h2><p>控件交互一般分为两步走：</p><ol><li><p>获得控件：在6.4节中提到过，主要有以下两种。</p><ul><li><p>通过<code>GetDlgItem(控件ID)</code>获取对应控件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CListBox* list = (CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST1);</span><br><span class="line">CComboBox* combox = (CComboBox*)<span class="built_in">GetDlgItem</span>(IDC_COMBO1);</span><br></pre></td></tr></table></figure></li><li><p>为控件添加变量：绑定控件和变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：使用UpdateData(TRUE|FALSE)同步</span></span><br><span class="line"><span class="comment">//默认为True，将控件内容同步到变量</span></span><br><span class="line"><span class="comment">//FALSE，将变量同步回控件</span></span><br><span class="line"><span class="built_in">UpdateData</span>(TRUE|FALSE);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>响应事件，如点击按钮事件。</p></li></ol><br><h3 id="7-1-标准按钮-复选框-单选框"><a href="#7-1-标准按钮-复选框-单选框" class="headerlink" title="7.1 标准按钮/复选框/单选框"></a>7.1 标准按钮/复选框/单选框</h3><p>本节项目的目标：选择选项，然后点击按钮输出结果。</p><p><img src="/.io//7-1.png" alt="img"></p><p>🔺标准开局：在 <code>MFCApp</code> 的主界面，加入一个按钮，点击后跳转本项目的对话框。</p><ol><li><p>在 <code>IDD_MFCAPP_DIALOG</code> 中创建按钮，修改ID为 <code>IDC_BTN_BTN</code>，修改Caption为：单选|复选|标准Button，最后双击添加消息处理函数 <code>OnBnClickedBtnBtn()</code>。</p></li><li><p>新增视图 <code>IDD_DLG_BTN</code>，右键创建类，类名为<code>CExampleBtn</code>，基类类型为<code>CDialog</code>。</p></li><li><p>打开模态对话框：在按钮消息处理函数中初始化并DoModal。</p></li><li><p>在 <code>IDD_DLG_BTN</code> 中，添加控件：</p><ol><li>添加两个Group Box，Caption命名为：性别、爱好。</li><li>右侧添加一个按钮Button，Caption为结果，ID为<code>IDC_BTN_RESULT</code>。</li><li>性别的Group Box中添加两个Radio Button，Caption分别为：男、女，ID为<code>IDC_RAD_MAN/WOMAN</code>，进行对齐。</li><li>爱好的Group Box中添加三个Check Box，Caption分别为：足球、篮球、瑜伽，ID为<code>IDC_CK_FB/BB/YOGA</code>，进行对齐。</li><li>注意：修改第一个单选按钮的组属性Group为：True。</li></ol></li><li><p>为控件添加变量：</p><ol><li><p>只需要为第一个单选按钮添加变量：类型为值，名称为<code>m_sex</code>，变量类型int，注释为性别。修改该变量的初始化为<code>-1</code>。</p></li><li><p>为第一个复选框加添变量：类型为值，名称为<code>m_fav</code>，变量类型为BOOL，注释为爱好。</p></li><li><p>修改<code>m_fav</code>为长度为3的数组，并对初始化做相应修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CExampleBtn.cpp: 实现文件</span></span><br><span class="line">CExampleBtn::<span class="built_in">CExampleBtn</span>(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">    : <span class="built_in">CDialog</span>(IDD_DLG_BTN, pParent)</span><br><span class="line">    , <span class="built_in">m_sex</span>(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//, m_fav(FALSE)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(m_fav, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_fav));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleBtn::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">    <span class="built_in">DDX_Radio</span>(pDX, IDC_RAD_MAN, m_sex);</span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CK_FB, m_fav[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CK_BB, m_fav[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">DDX_Check</span>(pDX, IDC_CK_YOGA, m_fav[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>为按钮【结果】双击添加点击事件处理函数：<code>OnBnClickedBtnResult</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CExampleBtn.cpp 中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleBtn::OnBnClickedBtnResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UpdateData</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_sex == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择您的性别！&quot;</span>), _T(<span class="string">&quot;性别未选择&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 常见错误：两个常量字符串不可以相加</span></span><br><span class="line">    <span class="comment">//CString strMsg = _T(&quot;您的性别是：&quot;) + ((m_sex == 0) ? _T(&quot;男&quot;) : _T(&quot;女&quot;));</span></span><br><span class="line">    CString strMsg = <span class="built_in">CString</span>(_T(<span class="string">&quot;您的性别是：&quot;</span>)) + ((m_sex == <span class="number">0</span>) ? _T(<span class="string">&quot;男&quot;</span>) : _T(<span class="string">&quot;女&quot;</span>)) + _T(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CString strFav = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//方案一：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PLAN1</span></span><br><span class="line">    CString favList[<span class="number">3</span>] = &#123; _T(<span class="string">&quot;足球&quot;</span>),_T(<span class="string">&quot;篮球&quot;</span>) ,_T(<span class="string">&quot;瑜伽&quot;</span>) &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_fav[i]) &#123;</span><br><span class="line">            strFav += favList[i] + _T(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PLAN1</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方案二：打开解决方案资源管理器，打开 Resource.h,找到 IDC_CK_FB</span></span><br><span class="line">    <span class="comment">// 可以发现这几个ID都是连续的</span></span><br><span class="line">    <span class="comment">// #define IDC_CK_FB                       1020</span></span><br><span class="line">    <span class="comment">// #define IDC_CK_BB                       1021</span></span><br><span class="line">    <span class="comment">// #define IDC_CK_YOGA                     1022</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PLAN2</span></span><br><span class="line">    UINT nID = IDC_CK_FB;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_fav[i]) &#123;</span><br><span class="line">            CString strName;</span><br><span class="line">            <span class="built_in">GetDlgItemText</span>(nID + i, strName);</span><br><span class="line">            strFav += strName + _T(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PLAN2</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (strFav.<span class="built_in">GetLength</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        strMsg += _T(<span class="string">&quot;您的爱好有：&quot;</span>) + strFav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        strMsg += _T(<span class="string">&quot;您没有任何爱好！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MessageBox</span>(strMsg, _T(<span class="string">&quot;结果展示&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>至此完成本节主要内容。其他内容比如：添加一个测试按钮，ID为 <code>IDC_BTN_TEST</code>，设置为禁用状态；添加另一个按钮，名为【启用/禁用测试】，ID为<code>IDC_BTN_OPEN</code>，为其添加鼠标点击时的处理函数，使得点击时启用测试按钮。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleBtn::OnBnClickedBtnOpen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CWnd* pCButton = <span class="built_in">GetDlgItem</span>(IDC_BTN_TEST);</span><br><span class="line">    <span class="keyword">if</span> (pCButton-&gt;<span class="built_in">IsWindowEnabled</span>() == FALSE) &#123;</span><br><span class="line">        pCButton-&gt;<span class="built_in">EnableWindow</span>(TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pCButton-&gt;<span class="built_in">EnableWindow</span>(FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>🔺特别注意：</p><ul><li>不能在Group属性为False的控件上绑定变量，即只能在第一个单选按钮上添加变量。</li><li>关于禁用Enable等一系列属性，都可以在其父类【如CWnd】中找到相应的方法。</li></ul><br><h3 id="7-2-文本编辑框-列表选择框"><a href="#7-2-文本编辑框-列表选择框" class="headerlink" title="7.2 文本编辑框/列表选择框"></a>7.2 文本编辑框/列表选择框</h3><h4 id="7-2-1-EditControl"><a href="#7-2-1-EditControl" class="headerlink" title="7.2.1 EditControl"></a>7.2.1 EditControl</h4><blockquote><p>本节内容关于 <code>EditControl</code> 的使用。</p></blockquote><p>该控件除了一些通用属性【见6.3节】，还拥有一些特殊的属性，比如：</p><ul><li>行为：<ul><li>接受文件Accept File：需要实现文件拖拽的消息响应函数。</li><li>禁用Disable：不需要用户操作，仅显示文本，不可激活。</li><li>多行MultiLine：是否多行显示。</li><li>只读ReadOnly：可激活，但编辑行为无效。</li><li>Visible：隐藏状态下控件几乎不捕获消息。</li></ul></li><li>外观：<ul><li>边框Border：外框实心细线。</li><li>水平/垂直滚动条Horizontal/Vertical Scroll。</li><li>滚动条位置Left ScrollBar：滚动条出现在左侧还是右侧。</li><li>限制大小写LowerCase/UpperCase。</li><li>限制只能输入数字Number。</li></ul></li></ul><br><p>🔺标准开局：在 <code>MFCApp</code> 的主界面，加入一个按钮，点击后跳转本项目的对话框。</p><ol><li><p>在 <code>IDD_MFCAPP_DIALOG</code> 中创建按钮，修改ID为 <code>IDC_BTN_OTHER</code>，修改Caption为：其他常用控件，最后双击添加消息处理函数 <code>OnBnClickedBtnOther()</code>。</p></li><li><p>新增视图 <code>IDD_DLG_OTHER</code>，右键创建类，类名为<code>CExampleOther</code>，基类类型为<code>CDialog</code>。</p></li><li><p>打开模态对话框：在按钮消息处理函数中初始化并DoModal。</p></li><li><p>在 <code>IDD_DLG_OTHER</code> 中，添加控件：</p><ul><li>添加编辑框EditControl，修改ID为 <code>IDC_EDIT_TEXT</code>，添加变量为值类型的<code>m_strText</code>。</li></ul></li><li><p>为<code>CExampleOther</code>类重写 <code>OnInitDialog</code> 函数：实现编辑框的多行输入。</p><ul><li>设置行为中的【想要返回Want Return，即需要关注回车键，而不是默认触发Button OK】为True、多行Multiline为True，外观下的垂直滚动为True</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="built_in">SetDlgItemText</span>(IDC_EDIT_TEXT, _T(<span class="string">&quot;aaaaaaaaa\nbbbbbbb\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为编辑框右键添加事件处理程序【类列表中选择该类<code>CExampleOther</code>，消息类型可选很多事件处理】：此处演示<code>EN_CHANGE</code>，当文本发生改变时修改为大小字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnEnChangeEditText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  如果该控件是 RICHEDIT 控件，它将不</span></span><br><span class="line">    <span class="comment">// 发送此通知，除非重写 CDialog::OnInitDialog()</span></span><br><span class="line">    <span class="comment">// 函数并调用 CRichEditCtrl().SetEventMask()，</span></span><br><span class="line">    <span class="comment">// 同时将 ENM_CHANGE 标志“或”运算到掩码中。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加控件通知处理程序代码</span></span><br><span class="line">    <span class="built_in">UpdateData</span>();</span><br><span class="line">    m_strText = m_strText.<span class="built_in">MakeUpper</span>();</span><br><span class="line">    <span class="built_in">UpdateData</span>(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一些编辑框的文本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得文本框控件 </span></span><br><span class="line">CEdit* edit = (CEdit*)<span class="built_in">GetDlgItem</span>(IDC_EDIT_TEXT);</span><br><span class="line"><span class="comment">// 获取文本</span></span><br><span class="line">edit-&gt;<span class="built_in">GetWindowText</span>(text);</span><br><span class="line"><span class="comment">// 设置文本</span></span><br><span class="line">edit-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本发生改变</span></span><br><span class="line"><span class="built_in">ON_EN_CHANGE</span>(IDC_EDIT_TEXT, &amp;CMFCCommonItemDlg::OnEnChangeEditText)</span><br></pre></td></tr></table></figure></li></ol><br><h4 id="7-2-2-ListBox"><a href="#7-2-2-ListBox" class="headerlink" title="7.2.2 ListBox"></a>7.2.2 ListBox</h4><blockquote><p>本节内容关于 <code>ListBox</code> 的使用。</p></blockquote><p>该控件除了一些通用属性【见6.3节】，还拥有一些特殊的属性，比如：</p><ul><li>行为：<ul><li>只包含字符串Has String：有无其他子项，默认False。</li><li>多列MultiColumn：允许多列，需要与Has String配合使用。</li><li>无数据No data：不包含数据，空的List Box。</li><li>所有者绘制Owner Draw：自定义美化或绘制List Box，需要重写函数。</li><li>选择Selection：单选还是多选，或者不允许选择None，或者可扩展Extend，默认单选Single。</li><li>排序Sort：自动排序，默认False。因为排序规则实现不统一，故一般不开。</li><li>使用Tab键Use Tabstops：在控件内部使用Tab切换。</li><li>想要按键输入Want Key Input：如按F跳到F开头的可选项。</li></ul></li></ul><p>🔺标准开局：基于上一节的中的文本编辑对话框，在 <code>IDD_DLG_OTHER</code> 的视图中直接添加ListBox控件。</p><ol><li><p>修改控件ID为<code>IDC_LIST_COMPANY</code>，选择Selection为Multiple。</p></li><li><p>右键控件添加变量，类别为控件，变量名为<code>m_company</code>，变量类型默认CListBox。</p></li><li><p>在本UI上添加一个按钮，Caption为ListBox测试，ID为<code>IDC_BTN_LISTBOX</code>，并为该按钮添加点击事件处理函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnBnClickedBtnListbox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    CString strText;</span><br><span class="line">    <span class="type">int</span> total = m_company.<span class="built_in">GetSelCount</span>(); <span class="comment">// 获取选中项数量</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(_T(<span class="string">&quot;未选择任何公司！&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        strText += _T(<span class="string">&quot;你选择了&quot;</span>);</span><br><span class="line">        <span class="comment">//strText += _itow(total, NULL, 10);</span></span><br><span class="line">        TCHAR buf[<span class="number">32</span>] = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        _itow_s(total, buf, <span class="number">32</span>, <span class="number">10</span>);<span class="comment">//返回值为err num，结果存在buf</span></span><br><span class="line"></span><br><span class="line">        strText += buf;</span><br><span class="line">        strText += _T(<span class="string">&quot;个公司选项\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>* index = <span class="keyword">new</span> <span class="type">int</span>[total];</span><br><span class="line">        m_company.<span class="built_in">GetSelItems</span>(total, index);<span class="comment">//获取选中项编号数组</span></span><br><span class="line">        CString strTmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_company.<span class="built_in">GetText</span>(index[i], strTmp);</span><br><span class="line">            strText += strTmp + _T(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] index;</span><br><span class="line">        <span class="built_in">MessageBox</span>(strText);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是单选</span></span><br><span class="line">        m_company.<span class="built_in">GetText</span>(m_company.<span class="built_in">GetCurSel</span>(), strTmp);<span class="comment">//GetCurSel返回最后选中的项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>CExampleOther</code> 类的 <code>OnInitDialog</code> 函数中添加一些选项数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="built_in">SetDlgItemText</span>(IDC_EDIT_TEXT, _T(<span class="string">&quot;aaaaaaaaa\nbbbbbbb\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;京东&quot;</span>));</span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;拼多多&quot;</span>));</span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;比亚迪&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/.io//7-2.png"></p><blockquote><p>📋如6.4节所述，除了本节中使用变量的形式访问ListBox，还可以使用GetDlgItem直接访问控件，如下所示。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到ListBox控件</span></span><br><span class="line">CListBox* list = (CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST1);</span><br><span class="line"><span class="comment">// 添加项</span></span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;上海&quot;</span>));</span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;深圳&quot;</span>));</span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;北京&quot;</span>));</span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;长沙&quot;</span>));</span><br><span class="line"><span class="comment">// 设置当前选择项 </span></span><br><span class="line">list-&gt;<span class="built_in">SetCurSel</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前选择项编号</span></span><br><span class="line"><span class="type">int</span> n = list-&gt;<span class="built_in">GetCurSel</span>();</span><br><span class="line"><span class="comment">// 获取当前选择项文本</span></span><br><span class="line">list-&gt;<span class="built_in">GetText</span>(n, text);</span><br></pre></td></tr></table></figure><br><h3 id="7-3-组合框ComboBox"><a href="#7-3-组合框ComboBox" class="headerlink" title="7.3 组合框ComboBox"></a>7.3 组合框ComboBox</h3><p>Combobox与ListBox操作基本一致，只是界面显示小有区别。具体来说，区别如下：</p><ul><li>Combobox是下拉列表，默认不展开，只有下拉的时候才能看所有选项。</li><li>Combobox只可以单选，不可以多选。</li></ul><p><img src="/.io//7-3.png" alt="下拉列表"></p><p>下面首先介绍一些特殊的属性：</p><ul><li>行为：<ul><li>Auto：用户在行尾键入字符时，自动将文本滚动到左侧。</li><li>Data：可以填充数据【如：<code>A;B;C;</code>】【旧版本中对 <code>Type=Simple</code> 的情况不生效】。</li></ul></li><li>外观：<ul><li>OEM Convert：输入的文本会被转为OEM字符集。该字符集一般用不到，对中文支持不友好，故一般False。</li><li>Type：三个值可选。其中值为【下拉列表Droplist】时，Combo只可选，不可编辑；Dropdown可选可编辑。</li></ul></li></ul><p>🔺标准开局：与ListBox小结一致，直接在 <code>IDD_DLG_OTHER</code> 的视图中添加ComboBox控件。</p><ol><li><p>此处添加两个Combobox控件【Type分别为Simple和Dropdown】，修改控件ID为<code>IDC_COMBO_SIMPLE</code> 和 <code>IDC_COMBO_DROPDOWN</code>。【可为属性Data添加数据：<code>A;B;C;D;</code>】</p></li><li><p>右键控件添加变量，类别为控件，变量名为<code>m_simple</code>和<code>m_droplist</code>，变量类型默认CComboBox。</p></li><li><p>在本UI上添加一个按钮，Caption为Combo测试，ID为<code>IDC_BTN_TEST_DROPLIST</code>，并为该按钮添加点击事件处理函数。【未知错误：Simple的Combobox打不开下拉菜单】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnBnClickedBtnTestDroplist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// combo type = simple</span></span><br><span class="line">    <span class="type">int</span> cur = m_simple.<span class="built_in">GetCurSel</span>();</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：未选中任何列！\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：已选中选中第%d列！\n&quot;</span>, __FILE__, __LINE__, cur + <span class="number">1</span>);</span><br><span class="line">        CString strTmp;</span><br><span class="line">        m_simple.<span class="built_in">GetLBText</span>(cur, strTmp);</span><br><span class="line">        <span class="built_in">MessageBox</span>(strTmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combo type = droplist</span></span><br><span class="line">    cur = m_droplist.<span class="built_in">GetCurSel</span>();</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：未选中任何列！\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：已选中选中第%d列！\n&quot;</span>, __FILE__, __LINE__, cur + <span class="number">1</span>);</span><br><span class="line">        CString strTmp;</span><br><span class="line">        m_droplist.<span class="built_in">GetLBText</span>(cur, strTmp);</span><br><span class="line">        <span class="built_in">MessageBox</span>(strTmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combo type = dropdown</span></span><br><span class="line">    cur = m_dropdown.<span class="built_in">GetCurSel</span>();</span><br><span class="line">    <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：字符数量为%d！\n&quot;</span>, __FILE__, __LINE__, m_dropdown.<span class="built_in">GetWindowTextLength</span>());<span class="comment">//获取编辑框中的字符数量</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_dropdown.<span class="built_in">GetWindowTextLength</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//m_dropdown.GetEditSel();//获取组合框的编辑控件中当前所选内容的起始和结束字符位置。</span></span><br><span class="line">            <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：未选中任何列！\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            CString strTmp;</span><br><span class="line">            m_dropdown.<span class="built_in">GetWindowText</span>(strTmp);<span class="comment">//使用Windows API获取combo编辑框的内容</span></span><br><span class="line">            <span class="built_in">MessageBox</span>(strTmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d)：已选中选中第%d列！\n&quot;</span>, __FILE__, __LINE__, cur + <span class="number">1</span>);</span><br><span class="line">        CString strTmp;</span><br><span class="line">        m_dropdown.<span class="built_in">GetLBText</span>(cur, strTmp);<span class="comment">//获取选择项的字符串</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(strTmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要在代码中添加选项，与ListBox一致，均为<code>AddString</code>函数。</p></li></ol><p><img src="/.io//7-4.png"></p><blockquote><p>📋如6.4节所述，除了本节中使用变量的形式访问Combobox，还可以使用GetDlgItem直接访问控件，如下所示。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取下拉列表控件</span></span><br><span class="line">CComboBox* list = (CComboBox*)<span class="built_in">GetDlgItem</span>(IDC_COMBO1);</span><br><span class="line"><span class="comment">// 添加选择项</span></span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;上海&quot;</span>));</span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;深圳&quot;</span>));</span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;北京&quot;</span>));</span><br><span class="line">list-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;长沙&quot;</span>));</span><br><span class="line"><span class="comment">// 设置当前选择项</span></span><br><span class="line">list-&gt;<span class="built_in">SetCurSel</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 获取当前选择项</span></span><br><span class="line"><span class="type">int</span> n = list-&gt;<span class="built_in">GetCurSel</span>();</span><br><span class="line"><span class="comment">// 获取当前选择项文本</span></span><br><span class="line">list-&gt;<span class="built_in">GetLBText</span>(n, text);</span><br></pre></td></tr></table></figure><br><h3 id="7-4-Progress"><a href="#7-4-Progress" class="headerlink" title="7.4 Progress"></a>7.4 Progress</h3><blockquote><p>注意：Progress进度条需要与定时器联合使用【写在定时器的回调函数中】，也就是说该控件需要代码配合才能生效。</p></blockquote><p>注意Progress的特殊属性【外观】：</p><ul><li><p>垂直Vertical：是否为垂直进度条。</p></li><li><p>选取框Marquee：当未知进度的情况下，可以设置该属性为True，且在<code>OnInitDialog</code> 函数中做如下的初始化，可以修改为不断滑动的块的形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_progress.<span class="built_in">SetMarquee</span>(TRUE, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="/.io//7-5.png"></p></li></ul><br><p>🔺标准开局：与上一节一致，直接在 <code>IDD_DLG_OTHER</code> 的视图中添加Progress Control控件。</p><ol><li><p>修改ID为<code>IDC_PROGRESS</code>，添加变量<code>m_progress</code>【只能选类别为控件】</p></li><li><p>在 <code>CExampleOther</code> 类的 <code>OnInitDialog</code> 函数中初始化该控件的数据：</p><ul><li>设置进度条范围：允许<code>-32768~32767</code>，但一般从0开始。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="built_in">SetDlgItemText</span>(IDC_EDIT_TEXT, _T(<span class="string">&quot;aaaaaaaaa\nbbbbbbb\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;京东&quot;</span>));</span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;拼多多&quot;</span>));</span><br><span class="line">    m_company.<span class="built_in">AddString</span>(_T(<span class="string">&quot;比亚迪&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面为之前的小节内容</span></span><br><span class="line">    m_progress.<span class="built_in">SetRange</span>(<span class="number">0</span>,<span class="number">10000</span>);<span class="comment">//16bit</span></span><br><span class="line">    <span class="comment">//m_progress.SetRange32(0,10000);//32bit</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在本UI上添加一个按钮，Caption为改变进度，ID为<code>IDC_BTN_PROGRESS</code>，并为该按钮添加点击事件处理函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnBnClickedBtnProgress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仅简单演示</span></span><br><span class="line">    <span class="type">int</span> pos =m_progress.<span class="built_in">GetPos</span>();</span><br><span class="line">    m_progress.<span class="built_in">SetPos</span>(pos + <span class="number">500</span>);<span class="comment">// 差不多点击20次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上一步仅是简单演示，而实际应用中与定时器结合。</p><ol><li><p>在<code>CExampleOther.h</code>头文件新增一个变量表示进度值：<code>int m_progress_pos;</code></p></li><li><p>在 <code>OnInitDialog</code> 函数中初始化<code>m_progress_pos</code>为0。</p></li><li><p>新建一个按钮，Caption为【使用定时器演示进度条】，ID为<code>IDC_BTN_PROGRESS_TIMER</code>，在该按钮的点击响应函数中开几个定时器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnBnClickedBtnProgressTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 开启一个定时器</span></span><br><span class="line">    <span class="comment">// 参数：一个事件ID【需要与回调函数中一致】、ms数、回调函数指针【默认进入本对话框的OnTimer处理函数】</span></span><br><span class="line">    <span class="comment">// 注意：MFC的定时器精度不要小于30ms，MFC的定时器精度很糟糕（MFC消息机制导致的）</span></span><br><span class="line">    <span class="built_in">SetTimer</span>(<span class="number">99</span>, <span class="number">500</span>, <span class="literal">NULL</span>);<span class="comment">//该定时器每半秒用m_progress_pos更新一次进度条</span></span><br><span class="line">    <span class="comment">//SetTimer(77, 1000, NULL);//该定时器每10ms打印日志，验证MFC定时器不能超过30ms</span></span><br><span class="line">    <span class="built_in">SetTimer</span>(<span class="number">88</span>, <span class="number">100</span>, <span class="literal">NULL</span>);<span class="comment">//该定时器每100ms触发，修改 m_progress_pos</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类视图点击CExample类，右侧属性工具栏选择添加消息，添加<code>WM_TIMER</code>消息，默认将<code>OnTimer</code>作为定时器的回调函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nIDEvent == <span class="number">99</span>) &#123;</span><br><span class="line">        <span class="comment">// 进度条定时刷新</span></span><br><span class="line">        m_progress.<span class="built_in">SetPos</span>(m_progress_pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打印太多会炸，故仅打印30次</span></span><br><span class="line"><span class="comment">    static int count = 0;</span></span><br><span class="line"><span class="comment">    if (nIDEvent == 77) &#123;</span></span><br><span class="line"><span class="comment">        // GetTickCount() 开机之后不断增大的ms值</span></span><br><span class="line"><span class="comment">        TRACE(&quot;%s(%d):%s %d\n&quot;, __FILE__, __LINE__, __FUNCTION__, GetTickCount());</span></span><br><span class="line"><span class="comment">        if (count++ &gt; 3)	KillTimer(77);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (nIDEvent == <span class="number">88</span>) &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">GetTickCount</span>());</span><br><span class="line">        <span class="type">int</span> low, upper;</span><br><span class="line">        m_progress.<span class="built_in">GetRange</span>(low, upper);</span><br><span class="line">        <span class="keyword">if</span> (m_progress_pos &gt;= upper) &#123;</span><br><span class="line">            <span class="built_in">KillTimer</span>(<span class="number">88</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m_progress_pos += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CDialog::<span class="built_in">OnTimer</span>(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中，77号定时器每10ms打印日志，验证MFC定时器所设定的间隔<code>Elapse</code>不能超过30ms。</p><p>① 实验中打印的毫秒值，有相差16ms或15ms等，其来自于1000ms÷15=66.67ms，即屏幕刷新率60HZ左右。</p><p>② 当修改77号定时器间隔为100ms时，日志打印间隔基本等于110ms，误差减小。</p><p>③ 当修改77号定时器间隔为1000ms时，日志打印间隔等于1000ms，无误差。</p><p>实验证明，间隔不要太小，精度不高。</p></blockquote></li></ol></li><li><p>其他例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取进度条</span></span><br><span class="line">CProgressCtrl* prog = (CProgressCtrl*)<span class="built_in">GetDlgItem</span>(IDC_PROGRESS1);</span><br><span class="line"><span class="comment">// 设置进度条范围</span></span><br><span class="line">prog-&gt;<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义定时器</span></span><br><span class="line"><span class="built_in">SetTimer</span>(TIMER_RPOG, <span class="number">100</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器超时响应函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cdialog2Dlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="type">int</span> num, low, high;</span><br><span class="line">   CProgressCtrl* prog;</span><br><span class="line">   <span class="keyword">switch</span> (nIDEvent)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">case</span> TIMER_RPOG:</span><br><span class="line">     <span class="comment">// 得到进度条</span></span><br><span class="line">     prog = (CProgressCtrl*)<span class="built_in">GetDlgItem</span>(IDC_PROGRESS1);</span><br><span class="line">     <span class="comment">// 获取进度</span></span><br><span class="line">     num = prog-&gt;<span class="built_in">GetPos</span>();</span><br><span class="line">     <span class="comment">// 更新进度</span></span><br><span class="line">     prog-&gt;<span class="built_in">SetPos</span>(++num);</span><br><span class="line">     <span class="comment">// 获取进度条上下限</span></span><br><span class="line">     prog-&gt;<span class="built_in">GetRange</span>(low, high);</span><br><span class="line">     <span class="keyword">if</span> (num &gt;= high)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">// 进度条归零</span></span><br><span class="line">       prog-&gt;<span class="built_in">SetPos</span>(low);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   CDialogEx::<span class="built_in">OnTimer</span>(nIDEvent);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><br><blockquote><p>值得注意的是：如果使用多线程直接修改Progress绑定的变量，可能会发生冲突；但使用多线程修改成员变量时，是不会产生冲突的。故建议使用public成员变量的方式保存进度条的值，留给其他线程访问。</p></blockquote><br><h3 id="7-5-Picture"><a href="#7-5-Picture" class="headerlink" title="7.5 Picture"></a>7.5 Picture</h3><p><code>Picture Control</code> 用于加载<code>bitmap</code>图像。</p><blockquote><p>该控件的默认ID为<code>IDC_STATIC</code>，与静态文本控件 <code>Static Text</code> 继承自同一个类CStatic。也就是该父类既可以显示文本，也可以显示图片。</p></blockquote><p>🔺标准开局：与上一节一致，直接在 <code>IDD_DLG_OTHER</code> 的视图中添加<code>Picture Control</code>控件。</p><ol><li><p>创建Picture Control，选择Type为<code>icon</code>【按照需要选择，后续代码中加载icon】，修改ID为<code>IDC_PIC</code>。为控件添加变量，变量名为<code>m_picture</code>。</p></li><li><p>修改该对话框【注意是对话框，对应CExample类，而不是控件。否则，需要重载该控件类】的属性【Accept File】为True，并添加 <code>WM_DROPFILES</code> 消息处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnDropFiles</span><span class="params">(HDROP hDropInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取拖入文件的数量</span></span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">DragQueryFile</span>(hDropInfo, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 若支持单个文件，此处可做限制处理。下面实现支持多个文件拖入的较难情况：</span></span><br><span class="line">    TCHAR sPath[MAX_PATH];<span class="comment">// 宽字节</span></span><br><span class="line">    <span class="type">char</span> mbsPath[MAX_PATH * <span class="number">2</span>];<span class="comment">// 多字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sPath, <span class="number">0</span>, <span class="built_in">sizeof</span>(sPath));</span><br><span class="line">        <span class="built_in">memset</span>(mbsPath, <span class="number">0</span>, <span class="built_in">sizeof</span>(mbsPath));</span><br><span class="line">        <span class="comment">// 获取文件的路径</span></span><br><span class="line">        <span class="built_in">DragQueryFile</span>(hDropInfo, i, sPath, MAX_PATH);</span><br><span class="line">        <span class="comment">// 获取的sPath不能直接使用，需要转为对应的多字节字符序列</span></span><br><span class="line">        <span class="comment">// wcstombs将宽字符序列转换为对应的多字节字符序列</span></span><br><span class="line">        <span class="comment">//wcstombs(mbsPath, sPath, MAX_PATH);//std::wcstombs?</span></span><br><span class="line">        <span class="type">size_t</span> total;</span><br><span class="line">        <span class="built_in">wcstombs_s</span>(&amp;total,mbsPath, sPath, MAX_PATH);</span><br><span class="line">        <span class="comment">// TRACE 只能打印多字节，不能打印宽字节，故需要上面的转换</span></span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, mbsPath);</span><br><span class="line">        <span class="comment">//D:\AboutChase\Art of Programming-2024\MFC\MFCApp\MFCApp\CExampleOther.cpp(246) : atlTraceGeneral - D:\AboutChase\Art of Programming-2024\MFC\MFCApp\MFCApp\CExampleOther.cpp(246):CExampleOther::OnDropFiles D:\AboutChase\Art of Programming-2024\MFC\MFCApp\MFCApp\res\MFCApp.ico</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CString</span>(sPath).<span class="built_in">Find</span>(_T(<span class="string">&quot;.ico&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 参数:</span></span><br><span class="line">            <span class="comment">// 1包含要加载的图像的 DLL 或可执行文件 (.exe) 的模块的句柄</span></span><br><span class="line">            <span class="comment">// 2要加载的图像。</span></span><br><span class="line">            <span class="comment">// 3要加载的图像的类型。</span></span><br><span class="line">            <span class="comment">// 4图标或光标的宽度（以像素为单位）</span></span><br><span class="line">            <span class="comment">// 5图标或光标的高度（以像素为单位）</span></span><br><span class="line">            <span class="comment">// 6选项</span></span><br><span class="line">            <span class="comment">//	LR_LOADFROMFILE(图标、光标或位图文件指定的文件) 加载独立图像</span></span><br><span class="line">            <span class="comment">//  LR_DEFAULTSIZE 与（0,0）配合使用，显示默认大小</span></span><br><span class="line">            HANDLE hIcon = <span class="built_in">LoadImage</span>(<span class="built_in">AfxGetInstanceHandle</span>(), sPath, IMAGE_ICON, <span class="number">0</span>, <span class="number">0</span>, LR_LOADFROMFILE | LR_DEFAULTSIZE);</span><br><span class="line">            m_picture.<span class="built_in">SetIcon</span>((HICON)hIcon);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDialog::<span class="built_in">OnDropFiles</span>(hDropInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//7-6.png"></p></li></ol><br><h3 id="7-6-List"><a href="#7-6-List" class="headerlink" title="7.6 List"></a>7.6 List</h3><p><code>List Control</code> 区别与 <code>List Box</code>，用于加载<code>bitmap</code>图像。</p><p>该控件的特殊属性：</p><ul><li>外观<ul><li>视图View：可选Icon、Small Icon、List、Report【后两个常用】</li><li>单选Single Selection：只允许单选【开启时按住Ctrl多选】。</li><li>编辑标签Edit Label：是否可以编辑给定的标签项，需要重写相应函数。</li><li>始终显示选定内容Always Show Selection：失去焦点时，继续显示灰色底纹【默认False，建议True】。</li></ul></li><li>行为<ul><li>排序Sort：不建议使用。</li><li>自动排序：不建议使用</li></ul></li></ul><p>🔺标准开局：与上一节一致，直接在 <code>IDD_DLG_OTHER</code> 的视图中添加<code>List Control</code>控件。</p><ol><li><p>创建List Control，View选择为<code>Report</code>，修改ID为<code>IDC_LIST_CTRL</code>。为控件添加变量【只允许控件类型变量】，变量名为<code>m_list</code>。</p></li><li><p>在 <code>CExampleOther</code> 类的 <code>OnInitDialog</code> 函数中初始化List：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="comment">// ..............</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List init</span></span><br><span class="line">    <span class="comment">//int InsertColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);</span></span><br><span class="line">    <span class="comment">//int InsertColumn(_In_ int nCol, _In_z_ LPCTSTR lpszColumnHeading,	_In_ int nFormat = LVCFMT_LEFT, _In_ int nWidth = -1, _In_ int nSubItem = -1);</span></span><br><span class="line">    <span class="comment">// 第一个重载只有两个参数，没有指定对齐方式和宽度，会导致四个块挤在一起</span></span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">0</span>, _T(<span class="string">&quot;序号&quot;</span>), LVCFMT_LEFT, <span class="number">45</span>);</span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">1</span>, _T(<span class="string">&quot;IP&quot;</span>), LVCFMT_LEFT, <span class="number">110</span>);</span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">2</span>, _T(<span class="string">&quot;ID&quot;</span>), LVCFMT_LEFT, <span class="number">80</span>);</span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">3</span>, _T(<span class="string">&quot;CHECK&quot;</span>), LVCFMT_LEFT, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置背景颜色</span></span><br><span class="line">    m_list.<span class="built_in">SetBkColor</span>(<span class="built_in">RGB</span>(<span class="number">128</span>, <span class="number">255</span>, <span class="number">64</span>));</span><br><span class="line">    <span class="comment">// 为List添加扩展风格</span></span><br><span class="line">    DWORD extStyle = m_list.<span class="built_in">GetExtendedStyle</span>();<span class="comment">//获取扩展风格</span></span><br><span class="line">    extStyle |= LVS_EX_GRIDLINES;<span class="comment">// 增加网格线</span></span><br><span class="line">    extStyle |= LVS_EX_FULLROWSELECT;<span class="comment">// 选中时选中整行</span></span><br><span class="line">    m_list.<span class="built_in">SetExtendedStyle</span>(extStyle);</span><br><span class="line">    <span class="comment">// 为List添加数据:[参数]索引位、值</span></span><br><span class="line">    m_list.<span class="built_in">InsertItem</span>(<span class="number">0</span>, <span class="built_in">CString</span>(<span class="string">&quot;0&quot;</span>));<span class="comment">// 设置第0行第一个位置，即序号</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">1</span>, _T(<span class="string">&quot;192.168.100.100&quot;</span>));<span class="comment">// IP</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">2</span>, _T(<span class="string">&quot;211798211&quot;</span>));<span class="comment">// ID</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">3</span>, _T(<span class="string">&quot;999&quot;</span>));<span class="comment">// CHECK</span></span><br><span class="line">    <span class="comment">// 再添加一条数据</span></span><br><span class="line">    m_list.<span class="built_in">InsertItem</span>(<span class="number">1</span>, <span class="built_in">CString</span>(<span class="string">&quot;1&quot;</span>));<span class="comment">// 设置第1行第一个位置，即序号</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">1</span>, <span class="number">1</span>, _T(<span class="string">&quot;192.168.0.1&quot;</span>));<span class="comment">// IP</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">1</span>, <span class="number">2</span>, _T(<span class="string">&quot;311798333&quot;</span>));<span class="comment">// ID</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">1</span>, <span class="number">3</span>, _T(<span class="string">&quot;888&quot;</span>));<span class="comment">// CHECK</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//7-7.png"></p></li><li><p>新增一个按钮，ID为 <code>IDC_BTN_LIST_TEST</code>，Caption为【List测试】，并为按钮添加点击处理函数，由于获取List中的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnBnClickedBtnListTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取行数</span></span><br><span class="line">    <span class="type">int</span> lineCount = m_list.<span class="built_in">GetItemCount</span>();</span><br><span class="line">    <span class="comment">// 获取列头</span></span><br><span class="line">    CHeaderCtrl* pHeader = m_list.<span class="built_in">GetHeaderCtrl</span>();</span><br><span class="line">    <span class="comment">// 获取列数</span></span><br><span class="line">    <span class="type">int</span> columnCount = pHeader-&gt;<span class="built_in">GetItemCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">char</span> text[<span class="number">256</span>];</span><br><span class="line">    <span class="type">size_t</span> total;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lineCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columnCount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            CString tmp = m_list.<span class="built_in">GetItemText</span>(i, j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TRACE 只能打印多字节，不能打印宽字节，故需要下面的转换</span></span><br><span class="line">            <span class="built_in">memset</span>(text, <span class="number">0</span>, <span class="built_in">sizeof</span>(text));</span><br><span class="line">            <span class="built_in">wcstombs_s</span>(&amp;total, text, <span class="built_in">sizeof</span>(text), tmp, tmp.<span class="built_in">GetLength</span>());</span><br><span class="line">            <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D:\AboutChase\Art of Programming-2024\MFC\MFCApp\MFCApp\CExampleOther.cpp(329) : atlTraceGeneral - D:\AboutChase\Art of Programming-2024\MFC\MFCApp\MFCApp\CExampleOther.cpp(329):CExampleOther::OnBnClickedBtnListTest 0</span></span><br><span class="line">    <span class="comment">//.....192.168.100.100</span></span><br><span class="line">    <span class="comment">//.....211798211</span></span><br><span class="line">    <span class="comment">//.....999</span></span><br><span class="line">    <span class="comment">//.....1</span></span><br><span class="line">    <span class="comment">//.....192.168.0.1</span></span><br><span class="line">    <span class="comment">//.....311798333</span></span><br><span class="line">    <span class="comment">//.....888</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在第2步中的初始化函数中，做以下修改：</p><ul><li>继续追加扩展风格【Checked复选框：<code>LVS_EX_CHECKBOXES</code>】，并修改列顺序和数据添加顺序。</li><li>另外，也对测试按钮的处理函数做修改，使用 <code>m_list.GetCheck(i)</code> 获取复选框状态。</li><li>修改List的文本背景颜色：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">//==============仅修改顺序和宽度==================</span></span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">0</span>, _T(<span class="string">&quot;CHECK&quot;</span>), LVCFMT_LEFT, <span class="number">65</span>);</span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">1</span>, _T(<span class="string">&quot;序号&quot;</span>), LVCFMT_LEFT, <span class="number">45</span>);</span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">2</span>, _T(<span class="string">&quot;IP&quot;</span>), LVCFMT_LEFT, <span class="number">110</span>);</span><br><span class="line">    m_list.<span class="built_in">InsertColumn</span>(<span class="number">3</span>, _T(<span class="string">&quot;ID&quot;</span>), LVCFMT_LEFT, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置背景颜色</span></span><br><span class="line">    m_list.<span class="built_in">SetBkColor</span>(<span class="built_in">RGB</span>(<span class="number">128</span>, <span class="number">255</span>, <span class="number">64</span>));</span><br><span class="line">    <span class="comment">// ===============设置文本背景颜色===================</span></span><br><span class="line">    m_list.<span class="built_in">SetTextBkColor</span>(<span class="built_in">RGB</span>(<span class="number">128</span>, <span class="number">255</span>, <span class="number">64</span>));</span><br><span class="line">    <span class="comment">// 为List添加扩展风格</span></span><br><span class="line">    DWORD extStyle = m_list.<span class="built_in">GetExtendedStyle</span>();<span class="comment">//获取扩展风格</span></span><br><span class="line">    extStyle |= LVS_EX_GRIDLINES;<span class="comment">// 增加网格线</span></span><br><span class="line">    extStyle |= LVS_EX_FULLROWSELECT;<span class="comment">// 选中时选中整行</span></span><br><span class="line">    extStyle |= LVS_EX_CHECKBOXES;<span class="comment">// checked-------------仅新增一个风格</span></span><br><span class="line">    m_list.<span class="built_in">SetExtendedStyle</span>(extStyle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 为List添加数据:[参数]索引位、值</span></span><br><span class="line">    m_list.<span class="built_in">InsertItem</span>(<span class="number">0</span>, <span class="built_in">CString</span>(<span class="string">&quot;FALSE&quot;</span>));<span class="comment">// 设置第0行第一个位置，即check</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">1</span>, _T(<span class="string">&quot;1&quot;</span>));<span class="comment">// 序号</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">2</span>, _T(<span class="string">&quot;192.168.100.100&quot;</span>));<span class="comment">// IP</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">3</span>, _T(<span class="string">&quot;211798211&quot;</span>));<span class="comment">// ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再添加一条数据</span></span><br><span class="line">    m_list.<span class="built_in">InsertItem</span>(<span class="number">1</span>, <span class="built_in">CString</span>(<span class="string">&quot;TRUE&quot;</span>));<span class="comment">// 设置第0行第一个位置，即check</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">1</span>, <span class="number">1</span>, _T(<span class="string">&quot;2&quot;</span>));<span class="comment">// 序号</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">1</span>, <span class="number">2</span>, _T(<span class="string">&quot;192.168.0.1&quot;</span>));<span class="comment">// IP</span></span><br><span class="line">    m_list.<span class="built_in">SetItemText</span>(<span class="number">1</span>, <span class="number">3</span>, _T(<span class="string">&quot;311798333&quot;</span>));<span class="comment">// ID</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnBnClickedBtnListTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取行数</span></span><br><span class="line">    <span class="type">int</span> lineCount = m_list.<span class="built_in">GetItemCount</span>();</span><br><span class="line">    <span class="comment">// 获取列头</span></span><br><span class="line">    CHeaderCtrl* pHeader = m_list.<span class="built_in">GetHeaderCtrl</span>();</span><br><span class="line">    <span class="comment">// 获取列数</span></span><br><span class="line">    <span class="type">int</span> columnCount = pHeader-&gt;<span class="built_in">GetItemCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">char</span> text[<span class="number">256</span>];</span><br><span class="line">    <span class="type">size_t</span> total;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lineCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// =====================获取复选框状态 ==========================</span></span><br><span class="line">        <span class="keyword">if</span> (m_list.<span class="built_in">GetCheck</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;选中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;未选中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columnCount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            CString tmp = m_list.<span class="built_in">GetItemText</span>(i, j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TRACE 只能打印多字节，不能打印宽字节，故需要下面的转换</span></span><br><span class="line">            <span class="built_in">memset</span>(text, <span class="number">0</span>, <span class="built_in">sizeof</span>(text));</span><br><span class="line">            <span class="built_in">wcstombs_s</span>(&amp;total, text, <span class="built_in">sizeof</span>(text), tmp, tmp.<span class="built_in">GetLength</span>());</span><br><span class="line">            <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//7-8.png"></p></li></ol><br><h3 id="7-7-Tree"><a href="#7-7-Tree" class="headerlink" title="7.7 Tree"></a>7.7 Tree</h3><p><code>Tree Control</code> 为树形控件，该控件的特殊属性如下：</p><ul><li>外观<ul><li>视图View：可选Icon、Small Icon、List、Report【后两个常用】</li><li>单选Single Selection：只允许单选【开启时按住Ctrl多选】。</li><li>编辑标签Edit Label：是否可以编辑给定的标签项，需要重写相应函数。</li><li>始终显示选定内容Always Show Selection：失去焦点时，继续显示灰色底纹【默认False，建议True】。</li></ul></li><li>行为<ul><li>排序Sort：不建议使用。</li><li>自动排序：不建议使用</li></ul></li></ul><p>🔺标准开局：与上一节一致，直接在 <code>IDD_DLG_OTHER</code> 的视图中添加<code>Tree Control</code>控件。</p><ol><li><p>创建Tree Control，修改ID为<code>IDC_TREE</code>。为控件添加变量【只允许控件类型变量】，变量名为<code>m_tree</code>。</p></li><li><p>在 <code>CExampleOther</code> 类的 <code>OnInitDialog</code> 函数中初始化Tree：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tree</span></span><br><span class="line">    HTREEITEM hRoot = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;root&quot;</span>));<span class="comment">//插入一个根节点，返回根节点</span></span><br><span class="line">    HTREEITEM hLeaf1 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf1&quot;</span>), hRoot);<span class="comment">// 指定父节点</span></span><br><span class="line">    HTREEITEM hLeaf2 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf2&quot;</span>), hRoot);</span><br><span class="line"></span><br><span class="line">    m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), hLeaf1);</span><br><span class="line">    m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), hLeaf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时显示的树无修饰，如下图上。</p></blockquote><p><img src="/.io//7-9.png"></p></li><li><p>下面考虑修饰树图，做以下工作来导入位图资源。</p><ol><li>将本项目在文件管理器中打开，找到res文件夹，在其中右键创建bmp位图文件，使用画图打开。</li><li>点击文件，打开映像属性【Ctrl + E】，修改图像大小为32x32，画一个五角星，并填充背景；再修改图像大小为64x32，再画一个图标，并填充颜色；再修改图像大小96x32，再画一个图标，并填充颜。至此制作了三个图标，且三个图标合并在一张位图中【🌸如上图下】。</li><li>下面将该位图导入项目：资源视图下右键<code>MFCApp.rc</code>，选择添加资源，然后选择位图Bitmap，点击导入，选择刚刚制作的位图，导入即可【▲此处可能出现无法加载的问题，亲测用画图再次打开，另存为再导入】，最后修改该位图资源ID为<code>IDB_TREE</code>。</li></ol></li><li><p>在 <code>CExampleOther.h</code> 中引入public的成员变量：<code>CImageList m_icons;</code> 【该类能够处理这种将多个图标合并在一张图中的图标形式】。</p></li><li><p>在 <code>CExampleOther</code> 类的 <code>OnInitDialog</code> 函数中初始化 <code>m_icons</code>，并将图标设置进Tree：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CExampleOther::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDialog::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">    <span class="built_in">SetDlgItemText</span>(IDC_EDIT_TEXT, _T(<span class="string">&quot;aaaaaaaaa\nbbbbbbb\n&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define NO_ICON</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_ICON</span></span><br><span class="line">    <span class="comment">// Tree ：无图标版本</span></span><br><span class="line">    HTREEITEM hRoot = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;root&quot;</span>));<span class="comment">//插入一个根节点，返回根节点</span></span><br><span class="line">    HTREEITEM hLeaf1 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf1&quot;</span>), hRoot);<span class="comment">// 指定父节点</span></span><br><span class="line">    HTREEITEM hLeaf2 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf2&quot;</span>), hRoot);</span><br><span class="line"></span><br><span class="line">    m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), hLeaf1);</span><br><span class="line">    m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), hLeaf2);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// NO_ICON</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_ICON</span></span><br><span class="line">    <span class="comment">// Tree ：有图标版本</span></span><br><span class="line">    <span class="comment">// 加载Tree的图标</span></span><br><span class="line">    m_icons.<span class="built_in">Create</span>(IDB_TREE, <span class="number">32</span>, <span class="number">3</span>, <span class="number">0</span>);<span class="comment">// 资源、宽度、个数、mask</span></span><br><span class="line">    m_tree.<span class="built_in">SetImageList</span>(&amp;m_icons, TVSIL_NORMAL);<span class="comment">// 大图标的格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// InsertItem重载版本的参数：文字、未选择时的图标、选中时的图标</span></span><br><span class="line">    HTREEITEM hRoot = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;root&quot;</span>), <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//插入一个根节点，返回根节点</span></span><br><span class="line">    HTREEITEM hLeaf1 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf1&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hRoot);<span class="comment">// 指定父节点</span></span><br><span class="line">    HTREEITEM hLeaf2 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf2&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hRoot);</span><br><span class="line"></span><br><span class="line">    m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub1&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hLeaf1);</span><br><span class="line">    m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub2&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hLeaf2);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !NO_ICON</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//7-10.png"></p></li><li><p>为树节点添加事件处理程序：双击事件 <code>NM_DBLCLK</code></p><ol><li><p>右键Tree控件选择添加事件处理程序，类选择<code>CExampleOther</code>，消息类型选择<code>NM_DBLCLK</code>，点击确定。</p></li><li><p>编辑处理函数：双击节点时，打印节点文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CExampleOther::OnNMDblclkTree</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    UINT count = m_tree.<span class="built_in">GetSelectedCount</span>();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        HTREEITEM hSelect = m_tree.<span class="built_in">GetSelectedItem</span>();</span><br><span class="line">        CString strText = m_tree.<span class="built_in">GetItemText</span>(hSelect);</span><br><span class="line">        <span class="comment">// 转化为多字节以便Trace</span></span><br><span class="line">        <span class="type">char</span> sText[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(sText, <span class="number">0</span>, <span class="built_in">sizeof</span>(sText));</span><br><span class="line">        <span class="type">size_t</span> total;</span><br><span class="line">        <span class="built_in">wcstombs_s</span>(&amp;total, sText,<span class="built_in">sizeof</span>(sText), strText, strText.<span class="built_in">GetLength</span>());</span><br><span class="line">        <span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, sText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    *pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>至此，简单的控件到此结束。</p></li></ol><br><h3 id="7-8-小结"><a href="#7-8-小结" class="headerlink" title="7.8 小结"></a>7.8 小结</h3><p>需要再次注意的点：</p><ul><li>TRACE不支持宽字节字符集【如<code>WCHAR</code>】，只支持多字符集【如<code>&quot;&quot;</code>、<code>char[]</code>】，故需要<code>wcstombs_s</code>函数来转换字符集。</li></ul><br><br><h2 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11 网络编程"></a>11 网络编程</h2><h3 id="11-1-网络编程基本概念"><a href="#11-1-网络编程基本概念" class="headerlink" title="11.1 网络编程基本概念"></a>11.1 网络编程基本概念</h3><h4 id="11-1-1-socket概念"><a href="#11-1-1-socket概念" class="headerlink" title="11.1.1 socket概念"></a>11.1.1 socket概念</h4><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image063.jpg" alt="img"></p><h4 id="11-1-2-什么是C-S模式"><a href="#11-1-2-什么是C-S模式" class="headerlink" title="11.1.2 什么是C/S模式"></a>11.1.2 什么是C/S模式</h4><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image065.jpg" alt="img"></p><h4 id="11-1-3-什么是面向连接和面向消息"><a href="#11-1-3-什么是面向连接和面向消息" class="headerlink" title="11.1.3 什么是面向连接和面向消息"></a>11.1.3 什么是面向连接和面向消息</h4><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image067.jpg" alt="img"></p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image069.gif" alt="img"> <img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image071.gif" alt="img"></p><h4 id="11-1-4-IP地址和端口"><a href="#11-1-4-IP地址和端口" class="headerlink" title="11.1.4 IP地址和端口"></a>11.1.4 IP地址和端口</h4><p>Win +R</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image073.jpg" alt="img"></p><h3 id="11-2-网络套接字编程"><a href="#11-2-网络套接字编程" class="headerlink" title="11.2 网络套接字编程"></a>11.2 网络套接字编程</h3><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image075.jpg" alt="TCP与UDP比较"></p><h4 id="11-2-1-TCP套接字"><a href="#11-2-1-TCP套接字" class="headerlink" title="11.2.1 TCP套接字"></a>11.2.1 TCP套接字</h4><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image077.gif" alt="tcp_socket"></p><p>• 服务端</p><p>📋#include &lt;WinSock2.h&gt;<br>#include<iostream></iostream></p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>int main()<br>{<br>// 加载套接字库<br>WORD wVersionRequested;<br>WSADATA wsaData;<br>int err;</p><p>wVersionRequested = MAKEWORD(1,1);<br>// 初始化套接字库<br>err = WSAStartup(wVersionRequested, &amp;wsaData);<br>if (err != 0)<br>{<br>return err;<br>}</p><p>if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)<br>{<br>WSACleanup();<br>return -1;<br>}<br>// 新建套接字<br>SOCKET sockSrv = socket(AF_INET, SOCK_STREAM, 0);</p><p>SOCKADDR_IN addrSrv;<br>addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<br>addrSrv.sin_family = AF_INET;<br>addrSrv.sin_port = htons(6000);</p><p>// 绑定套接字到本地IP地址，端口号6000<br>bind(sockSrv, (SOCKADDR*)&amp; addrSrv, sizeof(SOCKADDR));</p><p>// 开始监听<br>listen(sockSrv, 5);</p><p>SOCKADDR_IN addrCli;<br>int len = sizeof(SOCKADDR);</p><p>while (true)<br>{<br>// 接收客户连接<br>SOCKET sockConn = accept(sockSrv, (SOCKADDR*)&amp; addrCli, &amp;len);<br>char sendBuf[100];<br>sprintf_s(sendBuf, 100, “Welcome %s to bingo!”, inet_ntoa(addrCli.sin_addr));<br>//发送数据<br>send(sockConn, sendBuf, strlen(sendBuf) + 1, 0);<br>char recvBuf[100];<br>//接收数据<br>recv(sockConn, recvBuf, 100, 0);<br>//打印接收的数据<br>std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;<br>closesocket(sockConn);<br>}</p><p>closesocket(sockSrv);<br>WSACleanup();</p><p>return 0;<br>}</p><p>#include &lt;WinSock2.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>int main()</p><p>{</p><p><em>printf</em>(“Server\n”);</p><p>//1 初始化网络库</p><p>// 加载套接字库</p><p><em>WORD</em> wVersionRequested;</p><p><em>WSADATA</em> wsaData;</p><p>int err;</p><p>wVersionRequested = <em>MAKEWORD</em>(2, 2);</p><p>// 1、初始化套接字库</p><p>err = <em>WSAStartup</em>(wVersionRequested, &amp;wsaData);</p><p>if (err != 0)</p><p>{</p><p>​ <em>printf</em>(“WSAStartup errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return err;</p><p>}</p><p>if (<em>LOBYTE</em>(wsaData.<em>wVersion</em>) != 2 || <em>HIBYTE</em>(wsaData.<em>wVersion</em>) != 2)</p><p>{</p><p>​ <em>printf</em>(“LOBYTE errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ <em>WSACleanup</em>();</p><p>​ return -1;</p><p>}</p><p>// 2 安装电话机</p><p>// 新建套接字</p><p><em>SOCKET</em> sockSrv = <em>socket</em>(<em>AF_INET</em>, <em>SOCK_STREAM</em>, 0);</p><p>if (<em>INVALID_SOCKET</em> == sockSrv)</p><p>{</p><p>​ <em>printf</em>(“socket errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>//给变量配置电话号码 IP 任何 端口6000</p><p><em>SOCKADDR_IN</em> addrSrv;</p><p>addrSrv.<em>sin_addr</em>.<em>S_un</em>.<em>S_addr</em> = <em>htonl</em>(<em>INADDR_ANY</em>);</p><p>addrSrv.<em>sin_family</em> = <em>AF_INET</em>;</p><p>addrSrv.<em>sin_port</em> = <em>htons</em>(6000);</p><p>// 3 分配电话号码</p><p>// 绑定套接字到本地IP地址，端口号6000</p><p>if (<em>SOCKET_ERROR</em> == <em>bind</em>(sockSrv, (*SOCKADDR**)&amp;addrSrv, sizeof(<em>SOCKADDR</em>)))</p><p>{</p><p>​ <em>printf</em>(“bind errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 4、监听 listen</p><p>if (<em>SOCKET_ERROR</em> == <em>listen</em>(sockSrv, 5))</p><p>{</p><p>​ <em>printf</em>(“listen errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 5、拿起话筒，准备通话</p><p><em>SOCKADDR_IN</em> addrCli;</p><p>int len = sizeof(<em>SOCKADDR</em>);</p><p>while (<em>TRUE</em>)</p><p>{</p><p>​ //6、分配一台分机去服务</p><p>​ <em>SOCKET</em> sockConn = <em>accept</em>(sockSrv, (*SOCKADDR**)&amp;addrCli, &amp;len);</p><p>​ char sendBuf[100] = { 0 };</p><p>​ <em>sprintf_s</em>(sendBuf, 100, “Welcome %s to bingo!”, <em>inet_ntoa</em>(addrCli.<em>sin_addr</em>));</p><p>​ //发送数据</p><p>​ int iLen = <em>send</em>(sockConn, sendBuf, <em>strlen</em>(sendBuf) + 1, 0);</p><p>​ if (iLen &lt; 0)</p><p>​ {</p><p>​ <em>printf</em>(“send errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>​ }</p><p>​ char recvBuf[100] = {0};</p><p>​ //接收数据</p><p>​ iLen = <em>recv</em>(sockConn, recvBuf, 100, 0);</p><p>​ if (iLen &lt; 0)</p><p>​ {</p><p>​ <em>printf</em>(“recv errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>​ }</p><p>​ //打印接收的数据</p><p>​ <em>printf</em>(“recvBuf = %s\n”, recvBuf);</p><p>​ <em>closesocket</em>(sockConn);</p><p>}</p><p>//7 关闭总机</p><p><em>closesocket</em>(sockSrv);</p><p><em>WSACleanup</em>();</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><p>• 客户端</p><p>📋#include &lt;WinSock2.h&gt;<br>#include<iostream></iostream></p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>int main()<br>{<br>char sendBuf[] = “hello,world”;<br>WORD wVersion;<br>WSADATA wsaData;<br>int err;</p><p>wVersion = MAKEWORD(1, 1);<br>err = WSAStartup(wVersion, &amp;wsaData);<br>if (err != 0)<br>{<br>return err;<br>}<br>if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)<br>{<br>WSACleanup();<br>return -1;<br>}</p><p>// 创建套接字<br>SOCKET sockCli = socket(AF_INET, SOCK_STREAM, 0);</p><p>SOCKADDR_IN addrSrv;<br>addrSrv.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);<br>addrSrv.sin_family = AF_INET;<br>addrSrv.sin_port = htons(6000);</p><p>//向服务器发起连接请求<br>connect(sockCli, (SOCKADDR*)&amp; addrSrv, sizeof(SOCKADDR));</p><p>// 接收数据<br>char recvBuf[100];<br>recv(sockCli, recvBuf, 100, 0);<br>std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;</p><p>// 发送数据<br>send(sockCli, sendBuf, strlen(sendBuf) + 1, 0);</p><p>// 关闭套接字<br>closesocket(sockCli);<br>WSACleanup();</p><p>// 暂停<br>system(“pause”);<br>return 0;<br>}</p><p>#include &lt;WinSock2.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>int main()</p><p>{</p><p><em>printf</em>(“Client\n”);</p><p>char sendBuf[] = “hello,world”;</p><p>//1 初始化网络库</p><p>// 加载套接字库</p><p><em>WORD</em> wVersionRequested;</p><p><em>WSADATA</em> wsaData;</p><p>int err;</p><p>wVersionRequested = <em>MAKEWORD</em>(2, 2);</p><p>// 1、初始化套接字库</p><p>err = <em>WSAStartup</em>(wVersionRequested, &amp;wsaData);</p><p>if (err != 0)</p><p>{</p><p>​ <em>printf</em>(“WSAStartup errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return err;</p><p>}</p><p>if (<em>LOBYTE</em>(wsaData.<em>wVersion</em>) != 2 || <em>HIBYTE</em>(wsaData.<em>wVersion</em>) != 2)</p><p>{</p><p>​ <em>printf</em>(“LOBYTE errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ <em>WSACleanup</em>();</p><p>​ return -1;</p><p>}</p><p>// 2 安装电话机</p><p>// 新建套接字</p><p><em>SOCKET</em> sockCli = <em>socket</em>(<em>AF_INET</em>, <em>SOCK_STREAM</em>, 0);</p><p>if (<em>INVALID_SOCKET</em> == sockCli)</p><p>{</p><p>​ <em>printf</em>(“socket errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p><em>SOCKADDR_IN</em> addrSrv;</p><p>addrSrv.<em>sin_addr</em>.<em>S_un</em>.<em>S_addr</em> = <em>inet_addr</em>(“192.168.8.253”);</p><p>addrSrv.<em>sin_family</em> = <em>AF_INET</em>;</p><p>addrSrv.<em>sin_port</em> = <em>htons</em>(6000);</p><p>// 3 连接服务器</p><p>if (<em>SOCKET_ERROR</em> == <em>connect</em>(sockCli, (*SOCKADDR**)&amp;addrSrv, sizeof(<em>SOCKADDR</em>)))</p><p>{</p><p>​ <em>printf</em>(“connect errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 4 接收和发送数据</p><p>char recvBuf[100] = {0};</p><p>int iLen = <em>recv</em>(sockCli, recvBuf, 100, 0);</p><p>if (iLen &lt; 0)</p><p>{</p><p>​ <em>printf</em>(“recv errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p><em>printf</em>(“Client recvBuf = %s\n”, recvBuf);</p><p>// 发送数据</p><p>iLen = <em>send</em>(sockCli, sendBuf, <em>strlen</em>(sendBuf) + 1, 0);</p><p>if (iLen &lt; 0)</p><p>{</p><p>​ <em>printf</em>(“send errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 关闭套接字</p><p><em>closesocket</em>(sockCli);</p><p><em>WSACleanup</em>();</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><h4 id="11-2-2-UDP套接字"><a href="#11-2-2-UDP套接字" class="headerlink" title="11.2.2 UDP套接字"></a>11.2.2 UDP套接字</h4><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image079.jpg" alt="udp_socket"> <img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif" alt="tcp_socket"></p><p>• 服务端</p><p>📋#include &lt;WinSock2.h&gt;<br>#include<iostream></iostream></p><p>#pragma comment(lib, “ws2_32.lib”)<br>int main()<br>{<br>// 初始化套接字库<br>WORD wVersion;<br>WSADATA wsaData;<br>int err;</p><p>wVersion = MAKEWORD(1, 1);<br>err = WSAStartup(wVersion, &amp;wsaData);<br>if (err != 0)<br>{<br>return err;<br>}</p><p>if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)<br>{<br>WSACleanup();<br>return -1;<br>}</p><p>// 创建套接字<br>SOCKET sockSrv = socket(AF_INET, SOCK_DGRAM, 0);</p><p>SOCKADDR_IN addrSrv;<br>addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<br>addrSrv.sin_family = AF_INET;<br>addrSrv.sin_port = htons(6001);</p><p>// 绑定套接字<br>bind(sockSrv, (SOCKADDR*)&amp;addrSrv, sizeof(SOCKADDR));</p><p>// 等待并接收数据<br>SOCKADDR_IN addrCli;<br>int len = sizeof(SOCKADDR_IN);</p><p>char recvBuf[100];<br>char sendBuf[100];<br>while (true)<br>{<br>recvfrom(sockSrv, recvBuf, 100, 0, (SOCKADDR*)&amp;addrCli, &amp;len);<br>std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;</p><pre><code> sprintf_s(sendBuf, 100, &quot;Ack %s&quot;, recvBuf);
 sendto(sockSrv, sendBuf, strlen(sendBuf) + 1, 0, (SOCKADDR*)&amp;addrCli, len);
</code></pre><p>}</p><p>closesocket(sockSrv);<br>WSACleanup();</p><p>system(“pause”);<br>return 0;<br>}</p><p>• 客户端</p><p>📋#include &lt;WinSock2.h&gt;<br>#include<iostream></iostream></p><p>#pragma comment(lib, “ws2_32.lib”)<br>int main()<br>{<br>// 加载套接字库</p><p>WORD wVersion;<br>WSADATA wsaData;<br>int err;<br>wVersion = MAKEWORD(1, 1);<br>err = WSAStartup(wVersion, &amp;wsaData);<br>if (err != 0)<br>{<br>return err;<br>}<br>if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)<br>{<br>WSACleanup();<br>return -1;<br>}</p><p>// 创建套接字<br>SOCKET sockCli = socket(AF_INET, SOCK_DGRAM, 0);<br>SOCKADDR_IN addrSrv;<br>addrSrv.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);<br>addrSrv.sin_port = htons(6001);<br>addrSrv.sin_family = AF_INET;</p><p>int len = sizeof(SOCKADDR);<br>char sendBuf[] = “hello”;<br>char recvBuf[100];</p><p>//发送数据<br>sendto(sockCli, sendBuf, strlen(sendBuf) + 1, 0, (SOCKADDR*)&amp; addrSrv, len);</p><p>recvfrom(sockCli, recvBuf, 100, 0, (SOCKADDR*)&amp; addrSrv, &amp;len);</p><p>std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;</p><p>closesocket(sockCli);</p><p>system(“pause”);<br>return 0;<br>}</p><table><thead><tr><th></th><th><strong>UDP</strong></th><th><strong>TCP</strong></th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>适用场景</td><td>适用于实时应用（IP电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h2 id="12-MFC网络编程进阶"><a href="#12-MFC网络编程进阶" class="headerlink" title="12 MFC网络编程进阶"></a>12 MFC网络编程进阶</h2><h3 id="12-1-listen的具体含义"><a href="#12-1-listen的具体含义" class="headerlink" title="12.1 listen的具体含义"></a>12.1 listen的具体含义</h3><p>监听 5表示同时监听的最大客户数<br>include &lt;WinSock2.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>int main()</p><p>{</p><p><em>printf</em>(“Server\n”);</p><p>//1 初始化网络库</p><p>// 加载套接字库</p><p><em>WORD</em> wVersionRequested;</p><p><em>WSADATA</em> wsaData;</p><p>int err;</p><p>wVersionRequested = <em>MAKEWORD</em>(2, 2);</p><p>// 1、初始化套接字库</p><p>err = <em>WSAStartup</em>(wVersionRequested, &amp;wsaData);</p><p>if (err != 0)</p><p>{</p><p>​ <em>printf</em>(“WSAStartup errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return err;</p><p>}</p><p>if (<em>LOBYTE</em>(wsaData.<em>wVersion</em>) != 2 || <em>HIBYTE</em>(wsaData.<em>wVersion</em>) != 2)</p><p>{</p><p>​ <em>printf</em>(“LOBYTE errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ <em>WSACleanup</em>();</p><p>​ return -1;</p><p>}</p><p>// 2 安装电话机</p><p>// 新建套接字</p><p><em>SOCKET</em> sockSrv = <em>socket</em>(<em>AF_INET</em>, <em>SOCK_STREAM</em>, 0);</p><p>if (<em>INVALID_SOCKET</em> == sockSrv)</p><p>{</p><p>​ <em>printf</em>(“socket errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>//给变量配置电话号码 IP 任何 端口6000</p><p><em>SOCKADDR_IN</em> addrSrv;</p><p>addrSrv.<em>sin_addr</em>.<em>S_un</em>.<em>S_addr</em> = <em>htonl</em>(<em>INADDR_ANY</em>);</p><p>addrSrv.<em>sin_family</em> = <em>AF_INET</em>;</p><p>addrSrv.<em>sin_port</em> = <em>htons</em>(6000);</p><p>// 3 分配电话号码</p><p>// 绑定套接字到本地IP地址，端口号6000</p><p>if (<em>SOCKET_ERROR</em> == <em>bind</em>(sockSrv, (*SOCKADDR**)&amp;addrSrv, sizeof(<em>SOCKADDR</em>)))</p><p>{</p><p>​ <em>printf</em>(“bind errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 4、监听 listen 最大的监听数目 ，执行到listen，单尚未执行到accept</p><p>if (<em>SOCKET_ERROR</em> == <em>listen</em>(sockSrv, 5))</p><p>{</p><p>​ <em>printf</em>(“listen errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p><em>Sleep</em>(20000);</p><p>// 5、拿起话筒，准备通话</p><p><em>SOCKADDR_IN</em> addrCli;</p><p>int len = sizeof(<em>SOCKADDR</em>);</p><p><em>printf</em>(“20 s\n”);</p><p>while (<em>TRUE</em>)</p><p>{</p><p>​ //6、分配一台分机去服务</p><p>​ <em>SOCKET</em> sockConn = <em>accept</em>(sockSrv, (*SOCKADDR**)&amp;addrCli, &amp;len);</p><p>​ char sendBuf[100] = { 0 };</p><p>​ <em>sprintf_s</em>(sendBuf, 100, “Welcome %s to bingo!”, <em>inet_ntoa</em>(addrCli.<em>sin_addr</em>));</p><p>​ //发送数据</p><p>​ int iLen = <em>send</em>(sockConn, sendBuf, <em>strlen</em>(sendBuf) + 1, 0);</p><p>​ if (iLen &lt; 0)</p><p>​ {</p><p>​ <em>printf</em>(“send errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>​ }</p><p>​ char recvBuf[100] = {0};</p><p>​ //接收数据</p><p>​ iLen = <em>recv</em>(sockConn, recvBuf, 100, 0);</p><p>​ if (iLen &lt; 0)</p><p>​ {</p><p>​ <em>printf</em>(“recv errorNum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>​ }</p><p>​ //打印接收的数据</p><p>​ <em>printf</em>(“recvBuf = %s\n”, recvBuf);</p><p>​ <em>closesocket</em>(sockConn);</p><p>}</p><p>//7 关闭总机</p><p><em>closesocket</em>(sockSrv);</p><p><em>WSACleanup</em>();</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><h3 id="12-2-一种更优雅的recv和send：超大数据的传输"><a href="#12-2-一种更优雅的recv和send：超大数据的传输" class="headerlink" title="12.2 一种更优雅的recv和send：超大数据的传输"></a>12.2 一种更优雅的recv和send：超大数据的传输</h3><p>int MySocketRecv0(int sock, char* buf, int dateSize)</p><p>{</p><p>//循环接收</p><p>int numsRecvSoFar = 0;</p><p>int numsRemainingToRecv = dateSize;</p><p><em>printf</em>(“enter MySocketRecv0\n”);</p><p>while (1)</p><p>{</p><p>​ int bytesRead = <em>recv</em>(sock, &amp;buf[numsRecvSoFar], numsRemainingToRecv, 0);</p><p>​ <em>printf</em>(“###bytesRead = %d,numsRecvSoFar = %d, numsRemainingToRecv = %d\n”,</p><p>​ bytesRead, numsRecvSoFar, numsRemainingToRecv);</p><p>​ if (bytesRead == numsRemainingToRecv)</p><p>​ {</p><p>​ return 0;</p><p>​ }</p><p>​ else if (bytesRead &gt; 0)</p><p>​ {</p><p>​ numsRecvSoFar += bytesRead;</p><p>​ numsRemainingToRecv -= bytesRead;</p><p>​ continue;</p><p>​ }</p><p>​ else if ((bytesRead &lt; 0) &amp;&amp; (<em>errno</em> == <em>EAGAIN</em>))</p><p>​ {</p><p>​ continue;</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ return -1;</p><p>​ }</p><p>}</p><p>}</p><p>int MySocketSend0(int socketNum, unsigned char* data, unsigned dataSize)</p><p>{</p><p>unsigned numBytesSentSoFar = 0;</p><p>unsigned numBytesRemainingToSend = dataSize;</p><p>while(1)</p><p>{</p><p>​ int bytesSend = send(socketNum, (char const*)(&amp;data[numBytesSentSoFar]), numBytesRemainingToSend, 0/<em>flags</em>/);</p><p>​ if(bytesSend == numBytesRemainingToSend)</p><p>​ {</p><p>​ return 0;</p><p>​ }</p><p>​ else if(bytesSend &gt; 0)</p><p>​ {</p><p>​ numBytesSentSoFar += bytesSend;</p><p>​ numBytesRemainingToSend -= bytesSend;</p><p>​ continue;</p><p>​ }</p><p>​ else if((bytesSend &lt; 0)&amp;&amp;(errno == 11))</p><p>​ {</p><p>​ continue;</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ return -1;</p><p>​ }</p><p>}</p><p>}</p><p>服务器代码：</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#include &lt;string.h&gt;</p><p>#include &lt;unistd.h&gt;</p><p>#include &lt;arpa/inet.h&gt;</p><p>#include &lt;sys/socket.h&gt;</p><p>#define BUF_SIZE 1024*1024</p><p>void error_handling(char *message);</p><p>int main(int argc, char *argv[])</p><p>{</p><p>​ int serv_sock, clnt_sock;</p><p>​ char message[BUF_SIZE];</p><p>​ int str_len, i;</p><p>​</p><p>​ struct sockaddr_in serv_adr;</p><p>​ struct sockaddr_in clnt_adr;</p><p>​ socklen_t clnt_adr_sz;</p><p>​</p><p>​ if(argc!=2) {</p><p>​ printf(“Usage : %s<port>\n”, argv[0]);</port></p><p>​ exit(1);</p><p>​ }</p><p>​ //安装电话机</p><p>​ serv_sock=socket(PF_INET, SOCK_STREAM, 0);</p><p>​ if(serv_sock==-1)</p><p>​ error_handling(“socket() error”);</p><p>​</p><p>​ memset(&amp;serv_adr, 0, sizeof(serv_adr));</p><p>​ serv_adr.sin_family=AF_INET;</p><p>​ serv_adr.sin_addr.s_addr=htonl(INADDR_ANY);</p><p>​ serv_adr.sin_port=htons(atoi(argv[1]));</p><p>​ printf(“bingdu fuwuqi \n”);</p><p>​ //分配电话号</p><p>​ if(bind(serv_sock, (struct sockaddr*)&amp;serv_adr, sizeof(serv_adr))==-1)</p><p>​ error_handling(“bind() error”);</p><p>​ //开始监听</p><p>​ if(listen(serv_sock, 5)==-1)</p><p>​ error_handling(“listen() error”);</p><p>​</p><p>​ clnt_adr_sz=sizeof(clnt_adr);</p><p>​ for(i=0; i&lt;1000; i++)</p><p>​ {</p><p>​ clnt_sock=accept(serv_sock, (struct sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</p><p>​ if(clnt_sock==-1)</p><p>​ error_handling(“accept() error”);</p><p>​ else</p><p>​ printf(“Connected client %d \n”, i+1);</p><p>​</p><p>​ while((str_len=read(clnt_sock, message, BUF_SIZE))!=0)</p><p>​ {</p><p>​ write(clnt_sock, message, str_len);</p><p>​ printf(“str_len = %d\n”,str_len);</p><p>​ }</p><p>​ close(clnt_sock);</p><p>​ }</p><p>​ close(serv_sock);</p><p>​ return 0;</p><p>}</p><p>void error_handling(char *message)</p><p>{</p><p>​ fputs(message, stderr);</p><p>​ fputc(‘\n’, stderr);</p><p>​ exit(1);</p><p>}</p><p>客户端：</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#include &lt;winsock2.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;time.h&gt;</p><p>#include<string></string></p><p>#pragma comment(lib,”ws2_32.lib”)</p><p>void ErrorHandling(char* message);</p><p>#define MAX_ARRAYSIZE (1024<em>1024</em>10)</p><p>char message[MAX_ARRAYSIZE];</p><p>int MySocketRecv0(int sock, char* buf, int dateSize)</p><p>{</p><p>//循环接收</p><p>int numsRecvSoFar = 0;</p><p>int numsRemainingToRecv = dateSize;</p><p><em>printf</em>(“enter MySocketRecv0\n”);</p><p>while (1)</p><p>{</p><p>​ int bytesRead = <em>recv</em>(sock, &amp;buf[numsRecvSoFar], numsRemainingToRecv, 0);</p><p>​ <em>printf</em>(“###bytesRead = %d,numsRecvSoFar = %d, numsRemainingToRecv = %d\n”,</p><p>​ bytesRead, numsRecvSoFar, numsRemainingToRecv);</p><p>​ if (bytesRead == numsRemainingToRecv)</p><p>​ {</p><p>​ return 0;</p><p>​ }</p><p>​ else if (bytesRead &gt; 0)</p><p>​ {</p><p>​ numsRecvSoFar += bytesRead;</p><p>​ numsRemainingToRecv -= bytesRead;</p><p>​ continue;</p><p>​ }</p><p>​ else if ((bytesRead &lt; 0) &amp;&amp; (<em>errno</em> == <em>EAGAIN</em>))</p><p>​ {</p><p>​ continue;</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ return -1;</p><p>​ }</p><p>}</p><p>}</p><p>int getCurrentTimeStr(char* strtime)</p><p>{</p><p>// 基于当前系统的当前日期/时间</p><p><em>time_t</em> now = <em>time</em>(<em>NULL</em>);</p><p>*tm** ltm = <em>localtime</em>(&amp;now);</p><p><em>sprintf</em>(strtime, “%2d:%2d:%2d “, ltm-&gt;<em>tm_hour</em>, ltm-&gt;<em>tm_min</em>, ltm-&gt;<em>tm_sec</em>);</p><p>return 0;</p><p>}</p><p>void initArray(char c)</p><p>{</p><p>int i = 0;</p><p>for (i = 0;i &lt; MAX_ARRAYSIZE; i++)</p><p>{</p><p>​ message[i] = c;</p><p>}</p><p>}</p><p>int ClientConnect()</p><p>{</p><p><em>WSADATA</em> wsaData;</p><p><em>SOCKET</em> hSocket;</p><p><em>SOCKADDR_IN</em> servAddr;</p><p>int strLen;</p><p>char ch[64] = { 0 };</p><p>initArray(‘c’);</p><p><em>printf</em>(“client \n”);</p><p>if (<em>WSAStartup</em>(<em>MAKEWORD</em>(2, 2), &amp;wsaData) != 0)</p><p>​ ErrorHandling(“WSAStartup() error!”);</p><p>hSocket = <em>socket</em>(<em>PF_INET</em>, <em>SOCK_STREAM</em>, 0);//AF_ISO</p><p>if (hSocket == <em>INVALID_SOCKET</em>)</p><p>​ ErrorHandling(“socket() error”);</p><p>getCurrentTimeStr(ch);</p><p><em>printf</em>(“begin connect %s\n”, ch);</p><p><em>memset</em>(&amp;servAddr, 0, sizeof(servAddr));</p><p>servAddr.<em>sin_family</em> = <em>AF_INET</em>;</p><p>servAddr.<em>sin_addr</em>.<em>s_addr</em> = <em>inet_addr</em>(“111.231.75.168”);//“111.231.75.168”</p><p>servAddr.<em>sin_port</em> = <em>htons</em>(9527); //</p><p>if (<em>connect</em>(hSocket, (*SOCKADDR**)&amp;servAddr, sizeof(servAddr)) == <em>SOCKET_ERROR</em>)</p><p>{</p><p>​ ErrorHandling(“connect() error!”);</p><p>}</p><p>getCurrentTimeStr(ch);</p><p><em>printf</em>(“after connect %s\n”, ch);</p><p>strLen = <em>send</em>(hSocket, message, sizeof(message) - 1, 0);</p><p><em>printf</em>(“after send %d\n”, strLen);</p><p>int ret = MySocketRecv0(hSocket, message, sizeof(message) - 1);</p><p><em>printf</em>(“Message from server: ,ret = %d\n”, ret);</p><p>if (strLen == -1)</p><p>​ ErrorHandling(“read() error!”);</p><p>// strLen = recv(hSocket, message, sizeof(message) - 1, 0);</p><p>// printf(“Message from server: ,strLen = %d\n”, strLen);</p><p>getCurrentTimeStr(ch);</p><p><em>printf</em>(“after recv %s\n”, ch);</p><p>//printf(“Message from server: %s ,strLen = %d\n”, message ,strLen);</p><p>//printf(“Message from server: ,strLen = %d\n”, strLen);</p><p><em>closesocket</em>(hSocket);</p><p><em>WSACleanup</em>();</p><p>// system(“pause”);</p><p>return 0;</p><p>}</p><p>//basic</p><p>#if 0</p><p>int main()</p><p>{</p><p>// 1、初始化网络库</p><p><em>WSADATA</em> wsaData;</p><p>if (<em>WSAStartup</em>(<em>MAKEWORD</em>(2, 2), &amp;wsaData) != 0)</p><p>​ ErrorHandling(“WSAStartup() error!”);</p><p><em>SOCKET</em> hSocket;</p><p><em>SOCKADDR_IN</em> servAddr;</p><p>char message[30] = “Bingo,Fuck me”;</p><p>int strLen;</p><p><em>printf</em>(“client\n”);</p><p>//2 安装一部电话机</p><p>hSocket = <em>socket</em>(<em>PF_INET</em>, <em>SOCK_STREAM</em>, 0);</p><p>if (hSocket == <em>INVALID_SOCKET</em>)</p><p>​ ErrorHandling(“socket() error”);</p><p><em>memset</em>(&amp;servAddr, 0, sizeof(servAddr));</p><p>servAddr.<em>sin_family</em> = <em>AF_INET</em>;</p><p>servAddr.<em>sin_addr</em>.<em>s_addr</em> = <em>inet_addr</em>(“111.231.75.168”);//192.168.0.112</p><p>servAddr.<em>sin_port</em> = <em>htons</em>(9527);</p><p>// 3、连接服务器</p><p>if (<em>connect</em>(hSocket, (*SOCKADDR**)&amp;servAddr, sizeof(servAddr)) == <em>SOCKET_ERROR</em>)</p><p>​ ErrorHandling(“connect() error!”);</p><p>strLen = <em>send</em>(hSocket, message, sizeof(message) - 1, 0);</p><p>if (strLen == -1)</p><p>​ ErrorHandling(“read() error!”);</p><p>strLen = <em>recv</em>(hSocket, message, sizeof(message) - 1, 0);</p><p>if (strLen == -1)</p><p>​ ErrorHandling(“read() error!”);</p><p><em>printf</em>(“Message from server: %s \n”, message);</p><p><em>closesocket</em>(hSocket);</p><p><em>WSACleanup</em>();</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><p>#endif</p><p>#if 1</p><p>//tcp</p><p>int main()</p><p>{</p><p>ClientConnect();</p><p><em>system</em>(“pause”);</p><p>}</p><p>#endif</p><p>void ErrorHandling(char* message)</p><p>{</p><p><em>fputs</em>(message, <em>stderr</em>);</p><p><em>fputc</em>(‘\n’, <em>stderr</em>);</p><p>char ch[64];</p><p>getCurrentTimeStr(ch);</p><p><em>printf</em>(“error num = %d, error timt %s\n”, ::<em>GetLastError</em>(), ch);</p><p><em>system</em>(“pause”);</p><p>// exit(1);</p><p>}</p><h2 id="13-网络编程实战"><a href="#13-网络编程实战" class="headerlink" title="13 网络编程实战"></a>13 网络编程实战</h2><h3 id="13-1-网络编程实战之网络文件截取（一）"><a href="#13-1-网络编程实战之网络文件截取（一）" class="headerlink" title="13.1 网络编程实战之网络文件截取（一）"></a>13.1 网络编程实战之网络文件截取（一）</h3><h3 id="13-2网络编程实战之网络文件截取—隐藏进程与修改注册表"><a href="#13-2网络编程实战之网络文件截取—隐藏进程与修改注册表" class="headerlink" title="13.2网络编程实战之网络文件截取—隐藏进程与修改注册表"></a>13.2网络编程实战之网络文件截取—隐藏进程与修改注册表</h3><h2 id="14-聊天软件项目过程"><a href="#14-聊天软件项目过程" class="headerlink" title="14 聊天软件项目过程"></a>14 聊天软件项目过程</h2><h3 id="14-1-三大工具"><a href="#14-1-三大工具" class="headerlink" title="14.1 三大工具"></a>14.1 三大工具</h3><p>回滚 备份</p><p>1 dbgview</p><p>2 beyond compare</p><p>3 VS2019自带的git功能备份到github</p><p>4 CSting与char *互转</p><p><em>USES_CONVERSION</em>;</p><p><em>CString</em> strRecvMsg = <em>A2W</em>(szRecvBuf);</p><p>5 变量的命名规范</p><p>字符串或者字符数组 sz</p><p>CString cs或者str</p><p>int i前缀</p><p>uint u</p><p>dword dw</p><p>LPCSTR</p><p>USES_CONVERSION是ATL中的一个宏定义。</p><p>用于编码转换（用的比较多的是CString向LPCWSTR转换）。</p><p>通俗的说，就是用了这个宏后，就可以用一系列的字符串转换宏非常方便。或者说，这个宏会告诉编译器，</p><p>在紧接的代码中我们要用OLE库中代码(如ansi到unicode的A2W(…))的转换宏，不加USES_CONVERSION在使用A2W会出错。</p><p>要想使用这个宏，因为它是ATL库带的，所以要加上头文件#include &lt;atlconv.h&gt;。</p><p>使用USES_CONVERSION一定要小心，它们从堆栈上分配内存，直到调用它的函数返回，</p><p>该内存不会被释放。如果在一个循环中，这个宏被反复调用几万次，将不可避免的产生stackoverflow。</p><p>在一个函数的循环体中使用A2W等字符转换宏可能会引起栈溢出</p><h3 id="14-2-C-实现socket编程-—-异步非阻塞Socket封装类-CAsyncSocket"><a href="#14-2-C-实现socket编程-—-异步非阻塞Socket封装类-CAsyncSocket" class="headerlink" title="14.2   C++实现socket编程 —- 异步非阻塞Socket封装类 CAsyncSocket"></a>14.2 C++实现socket编程 —- <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5/3441874"><em>异步</em></a>非阻塞Socket封装类 CAsyncSocket</h3><p>CAsyncSocket 最方便的socket的C++的写法</p><p>学会用MSDN去查看类 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/?query=">https://msdn.microsoft.com/zh-cn/?query=</a></p><p>1 CAsyncSocket::Create() ，使用#include &lt;afxsock.h&gt;头文件，用<em>AfxSocketInit()**初始化</em></p><p>2 <em>异步非阻塞</em></p><p>3 <em>重写 一个类 客户端和服务端</em></p><p>4 收到Socket事件之后，只是简单地<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83/9837525"><em>回调</em></a>CAsyncSocket::OnReceive()等<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0/2912832"><em>虚函数</em></a>。所以CAsyncSocket的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B4%BE%E7%94%9F%E7%B1%BB/9589520"><em>派生类</em></a>，只需要在这些虚函数里添加发送和接收的代码。</p><p>5 客户方在使用CAsyncSocket::Connect()时，往往返回一个WSAEWOULDBLOCK的错误(其它的某些<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><em>函数调用</em></a>也如此)，实际上这不应该算作一个错误，它是Socket提醒我们，由于你使用了非阻塞Socket方式，所以(连接)操作需要时间，不能瞬间建立</p><p>6 事实上，我们可以在Connect()调用之后等待CAsyncSocket::OnConnect()事件被触发，CAsyncSocket::OnConnect()是要表明Socket要么连接成功了，要么连接彻底失败了。至此，我们在CAsyncSocket::OnConnect()被调用之后就知道是否Socket连接成功了，还是失败了</p><p>7 特别注意：难点，那就是在客户方调用Connect()连接服务方，那么服务方如何Accept()，以建立连接的问题。简单的做法就是在监听的Socket收到OnAccept()时，用一个新的CAsyncSocket对象去建立连接</p><p>重写CAsyncSocket 类</p><p>8 服务端需要重写2个类？</p><p>因为服务端有两类socket，一类是服务器serversock，一类是每来一个连接的socket</p><h3 id="14-3-C-实现客户端和服务端收发消息的联调"><a href="#14-3-C-实现客户端和服务端收发消息的联调" class="headerlink" title="14.3   C++实现客户端和服务端收发消息的联调"></a>14.3 C++实现客户端和服务端收发消息的联调</h3><p>聊天软件111701客户端和服务端收发消息联调</p><p>1 connect的问题解决？？？</p><p>m_client-&gt;<em>Connect</em>(strIP, iPort) != <em>SOCKET_ERROR</em></p><p>查找这种写法才是正确的</p><p>2 如何查找错误 头文件 winerror.h MSDN</p><p>10035实际上就是无法立即完成一个非阻止性的套接字操作</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image082.jpg" alt="img"> <img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image084.jpg" alt="img"></p><h3 id="14-4-C-实现客户端和服务端整个收发功能的实现"><a href="#14-4-C-实现客户端和服务端整个收发功能的实现" class="headerlink" title="14.4   C++实现客户端和服务端整个收发功能的实现"></a>14.4 C++实现客户端和服务端整个收发功能的实现</h3><p>聊天软件111702客户端和服务端收发消息联调编码规范以及代码的简洁性</p><p>1收发数据的buf的大小的定义: 不能用魔数 宏定义</p><p>#define SEND_MAX_BUF 1024</p><p>2 重复的功能一定要封装为函数</p><p><em>CString</em> CMFCChatServerDlg::CatShowString(<em>CString</em> strInfo, <em>CString</em> strMsg)</p><p>{</p><p>//时间 + 信息（昵称）+消息</p><p><em>CString</em> strTime;</p><p><em>CTime</em> tmNow;</p><p>tmNow = <em>CTime</em>::<em>GetCurrentTime</em>();</p><p>strTime = tmNow.<em>Format</em>(“%X “);</p><p><em>CString</em> strShow;</p><p>strShow = strTime + strShow;</p><p>strShow += strInfo;</p><p>strShow += strMsg;</p><p>return strShow;</p><p>}</p><p>3 beyond compare查看代码的变化</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image086.jpg" alt="img"></p><h3 id="14-5-聊天软件配置昵称-自动回复-清除历史记录"><a href="#14-5-聊天软件配置昵称-自动回复-清除历史记录" class="headerlink" title="14.5   聊天软件配置昵称/自动回复/清除历史记录"></a>14.5 聊天软件配置昵称/自动回复/清除历史记录</h3><p>1 配置文件的读取与写入</p><p>注册表 配置ini</p><p>配置昵称的原理</p><p>A启动客户端，就应该有个读取配置文件的操作，把昵称从配置文件里面读到控件</p><p>B客户配置昵称，需要写入到配置文件</p><p>M_list的坑 ：sort的属性：自动插入</p><p>3清除历史记录</p><p>m_list.<em>ResetContent</em></p><p>3 自动回复消息</p><p>if (((*CButton**)dlg-&gt;<em>GetDlgItem</em>(IDC_AUTOSEND_RADIO))-&gt;<em>GetCheck</em>())</p><p>{</p><p>​ <em>CString</em> strAutoSendMsg;</p><p>​ dlg-&gt;<em>GetDlgItem</em>(IDC_AUTOSENDMSG_EDIT)-&gt;<em>GetWindowTextW</em>(strAutoSendMsg);</p><p>​ <em>CString</em> strName;</p><p>​ dlg-&gt;<em>GetDlgItem</em>(IDC_NAME_EDIT)-&gt;<em>GetWindowTextW</em>(strName);</p><p>​ <em>CString</em> strInfo = (<em>CString</em>)”[自动回复]” + strAutoSendMsg;</p><p>​ <em>CHAR</em> *szAutoSendBuf = <em>T2A</em>(strInfo);</p><p>​ dlg-&gt;m_client-&gt;<em>Send</em>(szAutoSendBuf, 200, 0);</p><p>​ strShow = dlg-&gt;CatShowString(strName, strInfo);</p><p>​ dlg-&gt;m_list.<em>AddString</em>(strShow);</p><p>​ dlg-&gt;m_list.<em>UpdateData</em>(<em>FALSE</em>);</p><p>}</p><h3 id="14-6-聊天软件改变字体颜色-断开连接"><a href="#14-6-聊天软件改变字体颜色-断开连接" class="headerlink" title="14.6   聊天软件改变字体颜色/断开连接"></a>14.6 聊天软件改变字体颜色/断开连接</h3><p>聊天软件11104改变字体颜色</p><p>断开连接</p><h3 id="14-6-聊天软件界面插入背景图片"><a href="#14-6-聊天软件界面插入背景图片" class="headerlink" title="14.6   聊天软件界面插入背景图片"></a>14.6 聊天软件界面插入背景图片</h3><p>聊天软件插入背景图片</p><h3 id="14-7-聊天软件打开常见的计算机应用和MFC快捷键使用"><a href="#14-7-聊天软件打开常见的计算机应用和MFC快捷键使用" class="headerlink" title="14.7   聊天软件打开常见的计算机应用和MFC快捷键使用"></a>14.7 聊天软件打开常见的计算机应用和MFC快捷键使用</h3><p>打开常见的计算机应用</p><p>MFC快捷键使用</p><h3 id="14-8-聊天软件项目总结和知识点概览"><a href="#14-8-聊天软件项目总结和知识点概览" class="headerlink" title="14.8   聊天软件项目总结和知识点概览"></a>14.8 聊天软件项目总结和知识点概览</h3><p>用xmind打开</p><h2 id="15-多线程"><a href="#15-多线程" class="headerlink" title="15 多线程"></a>15 多线程</h2><h3 id="15-1-基本概念"><a href="#15-1-基本概念" class="headerlink" title="15.1 基本概念"></a>15.1 基本概念</h3><p><strong>引入一个题目：</strong></p><p><strong><em>Bingo***</em></strong>老师*** <strong><em>提了一个需求\</em></strong> <strong><em>：打印\</em></strong></p><p><strong><em>每隔***</em></strong>3*<strong>**<em>秒叫焦老师俯卧撑\</em></strong> <strong><em>持续***</em></strong>20*<strong>**<em>次\</em></strong></p><p><strong><em>每隔***</em></strong>4*<strong>**<em>秒钟冯老师做一次甩头发\</em></strong> <strong><em>持续***</em></strong>30*<strong>**<em>次\</em></strong></p><p><strong><em>每隔***</em></strong>2*<strong><strong><em>秒钟叫*</em></strong></strong>Bingo*<strong>**<em>老师唱歌\</em></strong> <strong><em>持续***</em></strong>50*<strong>**<em>次\</em></strong></p><p>线程是在进程中产生的一个执行单元，是CPU调度和分配的最小单元，其在同一个进程中与其他线程并行运行，他们可以共享进程内的资源，比如内存、地址空间、打开的文件等等。</p><p><strong>线程</strong>是CPU调度和分派的基本单位，</p><p><strong>进程</strong>是分配资源的基本单位</p><p>进程：正在运行的程序</p><p>是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称，从操作系统核心角度来说，进程是操作系统调度除CPU时间片外进行的资源分配和保护的基本单位，它有一个独立的虚拟地址空间，用来容纳进程映像(如与进程关联的程序与数据)，并以进程为单位对各种资源实施保护，如受保护地访问处理器、文件、外部设备及其他进程(进程间通信)</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image087.gif" alt="对话气泡: 椭圆形: 那到底如何理解进程和线程呢？"></p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image089.jpg" alt="img"></p><p>计算机有很多资源组成，比如CPU、内存、磁盘、鼠标、键盘等，就像一个工厂由电力系统、作业车间、仓库、管理办公室和工人组成</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image091.gif" alt="img"></p><p>假定工厂的电力有限，一次只能供给一个或少量几个车间使用。也就是说，一部分车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务，多个CPU能够运行少量任务。</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image093.jpg" alt="img"></p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image094.jpg" alt="img"></p><p>线程就好比车间里的工人。一个进程可以包括多个线程，他们协同完成某一个任务。</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif" alt="img"></p><p>为什么使用多线程</p><p>n 避免阻塞</p><p>大家知道，单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就阻塞了，无法再去做其它的一些功能了。</p><p>n 避免CPU空转</p><p>应用程序经常会涉及到RPC，数据库访问，磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应时，CPU却不能去处理新的请求，导致这种单线程的应用程序性能很差。</p><p>n 提升效率</p><p>一个进程要独立拥有4GB的虚拟地址空间，而多个线程可以共享同一地址空间，线程的切换比进程的切换要快得多。</p><p>上下文切换</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image098.jpg" alt="img"></p><h3 id="15-2-线程创建函数"><a href="#15-2-线程创建函数" class="headerlink" title="15.2 线程创建函数"></a>15.2 线程创建函数</h3><p>CreateThread</p><p>CreateThread是一种微软在Windows API中提供了建立新的线程的函数，该函数在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E7%BA%BF%E7%A8%8B/9600138"><em>主线程</em></a>的基础上创建一个新线程。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101"><em>线程</em></a>终止运行后，线程对象仍然在系统中，必须通过CloseHandle函数来关闭该线程对象。</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HANDLE"><em>HANDLE</em></a> CreateThread(</p><p>LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD</p><p>SIZE_T dwStackSize,//initialstacksize</p><p>LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LPVOID"><em>LPVOID</em></a> lpParameter,//threadargument</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/DWORD"><em>DWORD</em></a> dwCreationFlags,//creationoption</p><p>LPDWORD lpThreadId//threadidentifier</p><p>)</p><p>· 第一个参数 lpThreadAttributes 表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。</p><p>· 第二个参数 dwStackSize 表示线程栈空间大小。传入0表示使用默认大小（1MB）。</p><p>· 第三个参数 lpStartAddress 表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。</p><p>· 第四个参数 lpParameter 是传给线程函数的参数。</p><p>· 第五个参数 dwCreationFlags 指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。</p><p>· 第六个参数 lpThreadId 将返回线程的ID号，传入NULL表示不需要返回该线程ID号</p><p>unsigned long _beginthreadex(</p><p>void *security, // 安全属性， 为NULL时表示默认安全性</p><p>unsigned stack_size, // 线程的堆栈大小， 一般默认为0</p><p>unsigned(_stdcall *start_address)(void *), // 线程函数</p><p>void *argilist, // 线程函数的参数</p><p>unsigned initflag, // 新线程的初始状态，0表示立即执行，//CREATE_SUSPENDED表示创建之后挂起</p><p>unsigned *threaddr // 用来接收线程ID</p><p>);</p><p>返回值 : // 成功返回新线程句柄， 失败返回0</p><p>__stdcall表示</p><p>1.参数从右向左压入堆栈</p><p>2.函数被调用者修改堆栈</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p><em>DWORD</em> <em>WINAPI</em> ThreadFun(<em>LPVOID</em> p)</p><p>{</p><p>int iMym = <em>((int</em>)p);</p><p><em>printf</em>(“我是子线程，PID = %d,iMym = %d\n”, <em>GetCurrentThreadId</em>(), iMym);</p><p>return 0;</p><p>}</p><p>int main()</p><p>{</p><p><em>printf</em>(“main begin\n”);</p><p><em>HANDLE</em> hThread;</p><p><em>DWORD</em> dwThreadID;</p><p>int m = 100;</p><p>hThread = <em>CreateThread</em>(<em>NULL</em>, 0, ThreadFun, &amp;m, 0, &amp;dwThreadID);</p><p><em>printf</em>(“我是主线程，PID = %d\n”, <em>GetCurrentThreadId</em>());</p><p><em>CloseHandle</em>(hThread);</p><p><em>Sleep</em>(2000);</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><h3 id="15-3-简单多线程示例"><a href="#15-3-简单多线程示例" class="headerlink" title="15.3 简单多线程示例"></a>15.3 简单多线程示例</h3><p>1 理解内核对象</p><p>​ 1 定义:</p><p>内核对象通过API来创建，每个内核对象是一个数据结构，它对应一块内存，由操作系统内核分配，并且只能由操作系统内核访问。在此数据结构中少数成员如安全描述符和使用计数是所有对象都有的，但其他大多数成员都是不同类型的对象特有的。内核对象的数据结构只能由操作系统提供的API访问，应用程序在内存中不能访问。调用创建内核对象的函数后，该函数会返回一个句柄，它标识了所创建的对象。它可以由进程的任何线程使用。</p><p>CreateProcess</p><p>CreateThread</p><p>CreateFile</p><p>event</p><p>Job</p><p>Mutex</p><p>​ 常见的内核对象 : 进程、线程、文件，存取符号对象、事件对象、文件对象、作业对象、互斥对象、管道对象、等待计时器对象，邮件槽对象，信号对象</p><p>​ 内核对象：为了管理线程/文件等资源而由操作系统创建的数据块。</p><p>​ 其创建的所有者肯定是操作系统。</p><p>​</p><p>​</p><p>第一阶段:主线程和子线程的结束时间</p><p>main函数返回后，整个进程终止，同时终止其包含的所有线程。。。</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>unsigned WINAPI ThreadFunc(void *arg);</p><p>int main(int argc, char *argv[])</p><p>{</p><p>HANDLE hThread;</p><p>unsigned threadID;</p><p>int param=5;</p><p>hThread=(HANDLE)_beginthreadex(NULL, 0, ThreadFunc, (void*)&amp;param, 0, &amp;threadID);</p><p>if(hThread==0)</p><p>{</p><p>​ puts(“_beginthreadex() error”);</p><p>​ return -1;</p><p>}</p><p>Sleep(3000);</p><p>puts(“end of main”);</p><p>return 0;</p><p>}</p><p>unsigned WINAPI ThreadFunc(void *arg)</p><p>{</p><p>int i;</p><p>int cnt=<em>((int</em>)arg);</p><p>for(i=0; i&lt;cnt; i++)</p><p>{</p><p>​ Sleep(1000); puts(“running thread”);</p><p>}</p><p>return 0;</p><p>}</p><p>第二阶段</p><p>WaitForSingleObject</p><p>来等待一个内核对象变为已通知状态</p><p><em>WaitForSingleObject</em>(</p><p><em><em>In</em></em> <em>HANDLE</em> hHandle, //指明一个内核对象的句柄</p><p><em><em>In</em></em> <em>DWORD</em> dwMilliseconds //等待时间</p><p>);</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>unsigned int __stdcall ThreadFun(<em>LPVOID</em> p)</p><p>{</p><p>int cnt = <em>((int</em>)p);</p><p>for (int i = 0; i &lt; cnt; i++)</p><p>{</p><p>​ <em>Sleep</em>(1000);</p><p>​ <em>puts</em>(“running thread”);</p><p>}</p><p>return 0;</p><p>}</p><p>int main()</p><p>{</p><p><em>printf</em>(“main begin\n”);</p><p>int iParam = 5;</p><p>unsigned int dwThreadID;</p><p><em>DWORD</em> wr;</p><p><em>HANDLE</em> hThread = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, ThreadFun,</p><p>​ (void*)&amp;iParam, 0, &amp;dwThreadID);</p><p>if (hThread == <em>NULL</em>)</p><p>{</p><p>​ <em>puts</em>(“_beginthreadex() error”);</p><p>​ return -1;</p><p>}</p><p>//</p><p><em>printf</em>(“WaitForSingleObject begin\n”);</p><p>if ((wr = <em>WaitForSingleObject</em>(hThread, <em>INFINITE</em>)) == <em>WAIT_FAILED</em>)</p><p>{</p><p>​ <em>puts</em>(“thread wait error”);</p><p>​ return -1;</p><p>}</p><p><em>printf</em>(“WaitForSingleObject end\n”);</p><p><em>printf</em>(“main end\n”);</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><p>第三阶段:</p><p>起两个线程，一个加+1，一个减1</p><p><em>WaitForMultipleObjects</em></p><p><em>WaitForMultipleObjects</em>(</p><p><em><em>In</em></em> <em>DWORD</em> nCount, // 要监测的句柄的组的句柄的个数</p><p><em>_In_reads_</em>(nCount) <em>CONST</em> *HANDLE** lpHandles, //要监测的句柄的组</p><p><em><em>In</em></em> <em>BOOL</em> bWaitAll, // TRUE 等待所有的内核对象发出信号， FALSE 任意一个内核对象发出信号</p><p><em><em>In</em></em> <em>DWORD</em> dwMilliseconds //等待时间</p><p>);</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>#define NUM_THREAD 50</p><p>unsigned WINAPI threadInc(void * arg);</p><p>unsigned WINAPI threadDes(void * arg);</p><p>long long num=0;</p><p>int main(int argc, char *argv[])</p><p>{</p><p>HANDLE tHandles[NUM_THREAD];</p><p>int i;</p><p>printf(“sizeof long long: %d \n”, sizeof(long long));</p><p>for(i=0; i&lt;NUM_THREAD; i++)</p><p>{</p><p>​ if(i%2)</p><p>​ tHandles[i]=(HANDLE)_beginthreadex(NULL, 0, threadInc, NULL, 0, NULL);</p><p>​ else</p><p>​ tHandles[i]=(HANDLE)_beginthreadex(NULL, 0, threadDes, NULL, 0, NULL);</p><p>}</p><p>WaitForMultipleObjects(NUM_THREAD, tHandles, TRUE, INFINITE);</p><p>printf(“result: %lld \n”, num);</p><p>return 0;</p><p>}</p><p>unsigned WINAPI threadInc(void * arg)</p><p>{</p><p>int i;</p><p>for(i=0; i&lt;500000; i++)</p><p>​ num+=1;</p><p>return 0;</p><p>}</p><p>unsigned WINAPI threadDes(void * arg)</p><p>{</p><p>int i;</p><p>for(i=0; i&lt;500000; i++)</p><p>​ num-=1;</p><p>return 0;</p><p>}</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image100.jpg" alt="img"></p><h3 id="15-4-线程同步—互斥对象"><a href="#15-4-线程同步—互斥对象" class="headerlink" title="15.4 线程同步—互斥对象"></a>15.4 线程同步—互斥对象</h3><p>互斥对象(mutex)属于内核对象，它能够确保线程拥有对单个资源的互斥访问权。</p><p>互斥对象包含一个使用数量，一个线程ID和一个计数器。其中线程ID用于标识系统中的哪个线程当前拥有互斥对象，计数器用于指明该线程拥有互斥对象的次数。</p><p>创建互斥对象：调用函数CreateMutex。调用成功，该函数返回所创建的互斥对象的句柄。</p><p>请求互斥对象所有权：调用函数WaitForSingleObject函数。线程必须主动请求共享对象的所有权才能获得所有权。</p><p>释放指定互斥对象的所有权：调用ReleaseMutex函数。线程访问共享资源结束后，线程要主动释放对互斥对象的所有权，使该对象处于已通知状态。</p><p>CreateMutex</p><p><em>HANDLE</em></p><p><em>WINAPI</em></p><p><em>CreateMutexW</em>(</p><p><em>_In_opt_</em> <em>LPSECURITY_ATTRIBUTES</em> lpMutexAttributes, //指向安全属性</p><p><em><em>In</em></em> <em>BOOL</em> bInitialOwner, //初始化互斥对象的所有者 TRUE 立即拥有互斥体</p><p><em>_In_opt_</em> <em>LPCWSTR</em> lpName //指向互斥对象名的指针 L“Bingo”</p><p>);</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>#define NUM_THREAD 50</p><p>unsigned WINAPI threadInc(void * arg);</p><p>unsigned WINAPI threadDes(void * arg);</p><p>long long num=0;</p><p>HANDLE hMutex;</p><p>int main(int argc, char *argv[])</p><p>{</p><p>​ HANDLE tHandles[NUM_THREAD];</p><p>​ int i;</p><p>​ hMutex=CreateMutex(NULL, FALSE, NULL);</p><p>​ for(i=0; i&lt;NUM_THREAD; i++)</p><p>​ {</p><p>​ if(i%2)</p><p>​ tHandles[i]=(HANDLE)_beginthreadex(NULL, 0, threadInc, NULL, 0, NULL);</p><p>​ else</p><p>​ tHandles[i]=(HANDLE)_beginthreadex(NULL, 0, threadDes, NULL, 0, NULL);</p><p>​ }</p><p>​ WaitForMultipleObjects(NUM_THREAD, tHandles, TRUE, INFINITE);</p><p>​ CloseHandle(hMutex);</p><p>​ printf(“result: %lld \n”, num);</p><p>​ return 0;</p><p>}</p><p>unsigned WINAPI threadInc(void * arg)</p><p>{</p><p>​ int i;</p><p>​ WaitForSingleObject(hMutex, INFINITE);</p><p>​ for(i=0; i&lt;500000; i++)</p><p>​ num+=1;</p><p>​ ReleaseMutex(hMutex);</p><p>​ return 0;</p><p>}</p><p>unsigned WINAPI threadDes(void * arg)</p><p>{</p><p>​ int i;</p><p>​ WaitForSingleObject(hMutex, INFINITE);</p><p>​ for(i=0; i&lt;500000; i++)</p><p>​ num-=1;</p><p>​ ReleaseMutex(hMutex);</p><p>​ return 0;</p><p>}</p><h3 id="15-5-多线程实现qq群聊的服务端和客户端"><a href="#15-5-多线程实现qq群聊的服务端和客户端" class="headerlink" title="15.5 多线程实现qq群聊的服务端和客户端"></a>15.5 多线程实现qq群聊的服务端和客户端</h3><p>服务端</p><p>//多线程+socket编程的一个联合使用</p><p>//用互斥体进行线程同步 socket编程 临界区 全局变量</p><p>#include &lt;WinSock2.h&gt;</p><p>#include<iostream></iostream></p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>#define MAX_CLNT 256</p><p>#define MAX_BUF_SIZE 256</p><p><em>SOCKET</em> clntSocks[MAX_CLNT]; //所有的连接的客户端socket</p><p><em>HANDLE</em> hMutex;</p><p>int clntCnt = 0; //当前连接的数目</p><p>// 服务端的设计：</p><p>// 1 每来一个连接，服务端起一个线程（安排一个工人）维护</p><p>// 2 将收到的消息转发给所有的客户端</p><p>// 3 某个连接断开，需要处理断开的连接</p><p>//发送给所有的客户端</p><p>void SendMsg(char *szMsg, int iLen)</p><p>{</p><p>int i = 0;</p><p><em>WaitForSingleObject</em>(hMutex, <em>INFINITE</em>);</p><p>for (i = 0; i &lt; clntCnt; i++)</p><p>{</p><p>​ <em>send</em>(clntSocks[i], szMsg, iLen, 0);</p><p>}</p><p><em>ReleaseMutex</em>(hMutex);</p><p>}</p><p>//处理客户端连接的函数</p><p>unsigned <em>WINAPI</em> HandleCln(void* arg)</p><p>{</p><p>//1 接收传递过来的参数</p><p><em>SOCKET</em> hClntSock = <em>((<em>SOCKET</em></em>)arg);</p><p>int iLen = 0, i;</p><p>char szMsg[MAX_BUF_SIZE] = { 0 };</p><p>//2 进行数据的收发 循环接收</p><p>//接收到客户端的数据</p><p>// while ((iLen = recv(hClntSock, szMsg, sizeof(szMsg),0)) != 0)</p><p>// { //收到的数据立马发给所有的客户端</p><p>// SendMsg(szMsg, iLen);</p><p>// }</p><p>while (1)</p><p>{</p><p>​ iLen = <em>recv</em>(hClntSock, szMsg, sizeof(szMsg), 0);</p><p>​ if (iLen != -1)</p><p>​ {</p><p>​ //收到的数据立马发给所有的客户端</p><p>​ SendMsg(szMsg, iLen);</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ break;</p><p>​ }</p><p>}</p><p><em>printf</em>(“此时连接数目为 %d\n”, clntCnt);</p><p>//3 某个连接断开，需要处理断开的连接 遍历</p><p><em>WaitForSingleObject</em>(hMutex, <em>INFINITE</em>);</p><p>for (i = 0; i&lt;clntCnt; i++)</p><p>{</p><p>​ if (hClntSock == clntSocks[i])</p><p>​ {</p><p>​ //移位</p><p>​ while (i++ &lt; clntCnt)</p><p>​ {</p><p>​ clntSocks[i] = clntSocks[i+1];</p><p>​ }</p><p>​ break;</p><p>​ }</p><p>}</p><p>clntCnt–; //当前连接数的一个自减</p><p><em>printf</em>(“断开此时连接数目 %d”, clntCnt);</p><p><em>ReleaseMutex</em>(hMutex);</p><p><em>closesocket</em>(hClntSock);</p><p>return 0;</p><p>}</p><p>int main()</p><p>{</p><p>// 加载套接字库</p><p><em>WORD</em> wVersionRequested;</p><p><em>WSADATA</em> wsaData;</p><p>int err;</p><p><em>HANDLE</em> hThread;</p><p>wVersionRequested = <em>MAKEWORD</em>(1, 1);</p><p>// 初始化套接字库</p><p>err = <em>WSAStartup</em>(wVersionRequested, &amp;wsaData);</p><p>if (err != 0)</p><p>{</p><p>​ return err;</p><p>}</p><p>if (<em>LOBYTE</em>(wsaData.<em>wVersion</em>) != 1 || <em>HIBYTE</em>(wsaData.<em>wVersion</em>) != 1)</p><p>{</p><p>​ <em>WSACleanup</em>();</p><p>​ return -1;</p><p>}</p><p>//创建一个互斥对象</p><p>hMutex = <em>CreateMutex</em>(<em>NULL</em>, <em>FALSE</em>, <em>NULL</em>);</p><p>// 新建套接字</p><p><em>SOCKET</em> sockSrv = <em>socket</em>(<em>AF_INET</em>, <em>SOCK_STREAM</em>, 0);</p><p><em>SOCKADDR_IN</em> addrSrv;</p><p>addrSrv.<em>sin_addr</em>.<em>S_un</em>.<em>S_addr</em> = <em>htonl</em>(<em>INADDR_ANY</em>);</p><p>addrSrv.<em>sin_family</em> = <em>AF_INET</em>;</p><p>addrSrv.<em>sin_port</em> = <em>htons</em>(9190);</p><p>// 绑定套接字到本地IP地址，端口号9190</p><p>if (<em>bind</em>(sockSrv, (*SOCKADDR**)&amp;addrSrv, sizeof(<em>SOCKADDR</em>)) == <em>SOCKET_ERROR</em>)</p><p>{</p><p>​ <em>printf</em>(“bind ERRORnum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 开始监听</p><p>if(<em>listen</em>(sockSrv, 5) == <em>SOCKET_ERROR</em>)</p><p>{</p><p>​ <em>printf</em>(“listen ERRORnum = %d\n”, <em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p><em>printf</em>(“start listen\n”);</p><p><em>SOCKADDR_IN</em> addrCli;</p><p>int len = sizeof(<em>SOCKADDR</em>);</p><p>while (1)</p><p>{</p><p>​ // 接收客户连接 sockConn此时来的客户端连接</p><p>​ <em>SOCKET</em> sockConn = <em>accept</em>(sockSrv, (*SOCKADDR**)&amp;addrCli, &amp;len);</p><p>​ //每来一个连接，服务端起一个线程（安排一个工人）维护客户端的连接</p><p>​ //每来一个连接，全局数组应该加一个成员，最大连接数加1</p><p>​ <em>WaitForSingleObject</em>(hMutex, <em>INFINITE</em>);</p><p>​ clntSocks[clntCnt++] = sockConn;</p><p>​ <em>ReleaseMutex</em>(hMutex);</p><p>​ hThread = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, HandleCln,</p><p>​ (void*)&amp;sockConn, 0, <em>NULL</em>);</p><p>​ <em>printf</em>(“Connect client IP: %s \n”, <em>inet_ntoa</em>(addrCli.<em>sin_addr</em>));</p><p>​ <em>printf</em>(“Connect client num: %d \n”, clntCnt);</p><p>}</p><p><em>closesocket</em>(sockSrv);</p><p><em>WSACleanup</em>();</p><p>return 0;</p><p>}</p><p>客户端</p><p>// 1 接收服务端的消息 安排一个工人 起一个线程接收消息</p><p>// 2 发送消息给服务端 安排一个工人 起一个线程发送消息</p><p>// 3 退出机制</p><p>#include &lt;WinSock2.h&gt;</p><p>#include<iostream></iostream></p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>#pragma comment(lib, “ws2_32.lib”)</p><p>#define NAME_SIZE 32</p><p>#define BUF_SIZE 256</p><p>char szName[NAME_SIZE] = “[DEFAULT]”;</p><p>char szMsg[BUF_SIZE];</p><p>//发送消息给服务端</p><p>unsigned <em>WINAPI</em> SendMsg(void* arg)</p><p>{</p><p>//1 接收传递过来的参数</p><p><em>SOCKET</em> hClntSock = <em>((<em>SOCKET</em></em>)arg);</p><p>char szNameMsg[NAME_SIZE + BUF_SIZE]; //又有名字，又有消息</p><p>//循环接收来自于控制台的消息</p><p>while (1)</p><p>{</p><p>​ <em>fgets</em>(szMsg, BUF_SIZE, <em>stdin</em>); //阻塞在这一句</p><p>​ //退出机制 当收到q或Q 退出</p><p>​ if (!<em>strcmp</em>(szMsg, “Q\n”) || !<em>strcmp</em>(szMsg, “q\n”))</p><p>​ {</p><p>​ <em>closesocket</em>(hClntSock);</p><p>​ <em>exit</em>(0);</p><p>​ }</p><p>​ <em>sprintf</em>(szNameMsg, “%s %s”,szName, szMsg);//字符串拼接</p><p>​ <em>send</em>(hClntSock, szNameMsg, <em>strlen</em>(szNameMsg), 0);//发送</p><p>}</p><p>return 0;</p><p>}</p><p>//接收服务端的消息</p><p>unsigned <em>WINAPI</em> RecvMsg(void* arg)</p><p>{</p><p>//1 接收传递过来的参数</p><p><em>SOCKET</em> hClntSock = <em>((<em>SOCKET</em></em>)arg);</p><p>char szNameMsg[NAME_SIZE + BUF_SIZE]; //又有名字，又有消息</p><p>int iLen = 0;</p><p>while (1)</p><p>{</p><p>​ //recv阻塞</p><p>​ iLen = <em>recv</em>(hClntSock, szNameMsg, NAME_SIZE + BUF_SIZE - 1, 0);</p><p>​ //服务端断开</p><p>​ if (iLen == -1)</p><p>​ {</p><p>​ return -1;</p><p>​ }</p><p>​ // szNameMsg的0到iLen -1 都是收到的数据 iLen个</p><p>​ szNameMsg[iLen] = 0;</p><p>​ //接收到的数据输出到控制台</p><p>​ <em>fputs</em>(szNameMsg, <em>stdout</em>);</p><p>}</p><p>return 0;</p><p>}</p><p>// 带参数的main函数，用命令行启动 在当前目录按下shift + 鼠标右键 cmd</p><p>int main(int argc, char *argv[])</p><p>{</p><p>// 加载套接字库</p><p><em>WORD</em> wVersionRequested;</p><p><em>WSADATA</em> wsaData;</p><p>int err;</p><p><em>SOCKET</em> hSock;</p><p><em>SOCKADDR_IN</em> servAdr;</p><p><em>HANDLE</em> hSendThread, hRecvThread;</p><p>wVersionRequested = <em>MAKEWORD</em>(1, 1);</p><p>// 初始化套接字库</p><p>err = <em>WSAStartup</em>(wVersionRequested, &amp;wsaData);</p><p>if (err != 0)</p><p>{</p><p>​ return err;</p><p>}</p><p>if (<em>LOBYTE</em>(wsaData.<em>wVersion</em>) != 1 || <em>HIBYTE</em>(wsaData.<em>wVersion</em>) != 1)</p><p>{</p><p>​ <em>WSACleanup</em>();</p><p>​ return -1;</p><p>}</p><p><em>sprintf</em>(szName, “[%s]”, argv[1]);</p><p>//1 建立socket</p><p>hSock = <em>socket</em>(<em>PF_INET</em>, <em>SOCK_STREAM</em>, 0);</p><p>// 2 配置端口和地址</p><p><em>memset</em>(&amp;servAdr, 0, sizeof(servAdr));</p><p>servAdr.<em>sin_addr</em>.<em>S_un</em>.<em>S_addr</em> = <em>inet_addr</em>(“127.0.0.1”);</p><p>servAdr.<em>sin_family</em> = <em>AF_INET</em>;</p><p>servAdr.<em>sin_port</em> = <em>htons</em>(9190);</p><p>// 3 连接服务器</p><p>if (<em>connect</em>(hSock, (*SOCKADDR**)&amp;servAdr, sizeof(servAdr)) == <em>SOCKET_ERROR</em>)</p><p>{</p><p>​ <em>printf</em>(“connect error error code = %d\n”,<em>GetLastError</em>());</p><p>​ return -1;</p><p>}</p><p>// 4 发送服务端的消息 安排一个工人 起一个线程发送消息</p><p>hSendThread = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, SendMsg,</p><p>​ (void*)&amp;hSock, 0, <em>NULL</em>);</p><p>// 5 接收消息给服务端 安排一个工人 起一个线程接收消息</p><p>hRecvThread = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, RecvMsg,</p><p>​ (void*)&amp;hSock, 0, <em>NULL</em>);</p><p>//等待内核对象的信号发生变化</p><p><em>WaitForSingleObject</em>(hSendThread, <em>INFINITE</em>);</p><p><em>WaitForSingleObject</em>(hRecvThread, <em>INFINITE</em>);</p><p>// 6 关闭套接字</p><p><em>closesocket</em>(hSock);</p><p><em>WSACleanup</em>();</p><p>return 0;</p><p>}</p><h3 id="15-6线程同步之事件对象"><a href="#15-6线程同步之事件对象" class="headerlink" title="15.6线程同步之事件对象"></a>15.6线程同步之事件对象</h3><p>事件对象也属于内核对象，它包含以下三个成员：</p><p>​ ● 使用计数；</p><p>​ ● 用于指明该事件是一个自动重置的事件还是一个人工重置的事件的布尔值；</p><p>​ ● 用于指明该事件处于已通知状态还是未通知状态的布尔值。</p><p>​ 事件对象有两种类型：人工重置的事件对象和自动重置的事件对象。这两种事件对象的区别在于当人工重置的事件对象得到通知时，等待该事件对象的所有线程均变为可调度线程；而当一个自动重置的事件对象得到通知时，等待该事件对象的线程中只有一个线程变为可调度线程。</p><p>\1. 创建事件对象</p><p>​ 调用CreateEvent函数创建或打开一个命名的或匿名的事件对象。</p><p>\2. 设置事件对象状态</p><p>​ 调用SetEvent函数把指定的事件对象设置为有信号状态。</p><p>\3. 重置事件对象状态</p><p>​ 调用ResetEvent函数把指定的事件对象设置为无信号状态。</p><p>\4. 请求事件对象</p><p>线程通过调用WaitForSingleObject函数请求事件对象。</p><p>​ 创建事件对象的函数原型如下：</p><p>HANDLE CreateEvent( 　　</p><p>LPSECURITY_ATTRIBUTES lpEventAttributes, // 安全属性 　　<br>BOOL bManualReset, 　　// 复位方式　　TRUE 必须用ResetEvent手动复原 FALSE 自动还原为无信号状态</p><p>BOOL bInitialState, 　 // 初始状态 　　TRUE 初始状态为有信号状态 FALSE 无信号状态</p><p>LPCTSTR lpName 　　　　//对象名称 　NULL 无名的事件对象　</p><p>);</p><p>#if 1</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>#define STR_LEN 100</p><p>unsigned <em>WINAPI</em> NumberOfA(void* arg);</p><p>unsigned <em>WINAPI</em> NumberOfOthers(void* arg);</p><p>static char str[STR_LEN];</p><p>static <em>HANDLE</em> hEvent;</p><p>int main(int argc, char* argv[])</p><p>{</p><p><em>HANDLE</em> hThread1, hThread2;</p><p><em>fputs</em>(“Input string: “, <em>stdout</em>);</p><p><em>fgets</em>(str, STR_LEN, <em>stdin</em>);</p><p>//NUll 默认的安全符 手动 FALSE 初始状态为无信号状态</p><p>hEvent = <em>CreateEvent</em>(<em>NULL</em>, <em>TRUE</em>, <em>FALSE</em>, <em>NULL</em>);</p><p>hThread1 = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, NumberOfA, <em>NULL</em>, 0, <em>NULL</em>);</p><p>hThread2 = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, NumberOfOthers, <em>NULL</em>, 0, <em>NULL</em>);</p><p><em>WaitForSingleObject</em>(hThread1, <em>INFINITE</em>);</p><p><em>WaitForSingleObject</em>(hThread2, <em>INFINITE</em>);</p><p>//直到2个线程执行完之后，再把事件设置为无信号状态</p><p><em>ResetEvent</em>(hEvent);</p><p><em>CloseHandle</em>(hEvent);</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><p>unsigned <em>WINAPI</em> NumberOfA(void* arg)</p><p>{</p><p>int i, cnt = 0;</p><p>//再没有执行fputs(“Input string: “, stdout);</p><p>//fgets(str, STR_LEN, stdin);SetEvent(hEvent);之前，卡在</p><p>//WaitForSingleObject</p><p><em>WaitForSingleObject</em>(hEvent, <em>INFINITE</em>);</p><p>for (i = 0; str[i] != 0; i++)</p><p>{</p><p>​ if (str[i] == ‘A’)</p><p>​ cnt++;</p><p>}</p><p><em>printf</em>(“Num of A: %d \n”, cnt);</p><p>return 0;</p><p>}</p><p>unsigned <em>WINAPI</em> NumberOfOthers(void* arg)</p><p>{</p><p>int i, cnt = 0;</p><p>//再没有执行fputs(“Input string: “, stdout);</p><p>//fgets(str, STR_LEN, stdin);SetEvent(hEvent);之前，卡在</p><p>//WaitForSingleObject</p><p>// WaitForSingleObject(hEvent, INFINITE);</p><p>for (i = 0; str[i] != 0; i++)</p><p>{</p><p>​ if (str[i] != ‘A’)</p><p>​ cnt++;</p><p>}</p><p><em>printf</em>(“Num of others: %d \n”, cnt - 1);</p><p>//把事件对象设置为有信号状态</p><p><em>SetEvent</em>(hEvent);</p><p>return 0;</p><p>}</p><p>#endif</p><p>// 火车站卖票 A工人 B工人</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>int iTickets = 100;</p><p><em>HANDLE</em> g_hEvent;</p><p><em>DWORD</em> <em>WINAPI</em> SellTicketA(void* lpParam)</p><p>{</p><p>while (1)</p><p>{</p><p>​ <em>WaitForSingleObject</em>(g_hEvent, <em>INFINITE</em>);</p><p>​ if (iTickets &gt; 0)</p><p>​ {</p><p>​ <em>Sleep</em>(1);</p><p>​ iTickets–;</p><p>​ <em>printf</em>(“A remain %d\n”, iTickets);</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ break;</p><p>​ }</p><p>​ <em>SetEvent</em>(g_hEvent);</p><p>}</p><p>return 0;</p><p>}</p><p><em>DWORD</em> <em>WINAPI</em> SellTicketB(void* lpParam)</p><p>{</p><p>while (1)</p><p>{</p><p>​ <em>WaitForSingleObject</em>(g_hEvent, <em>INFINITE</em>);</p><p>​ if (iTickets &gt; 0)</p><p>​ {</p><p>​ <em>Sleep</em>(1);</p><p>​ iTickets–;</p><p>​ <em>printf</em>(“B remain %d\n”, iTickets);</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ break;</p><p>​ }</p><p>​ <em>SetEvent</em>(g_hEvent);</p><p>}</p><p>return 0;//0 内核对象被销毁</p><p>}</p><p>int main()</p><p>{</p><p><em>HANDLE</em> hThreadA, hThreadB;</p><p>hThreadA = <em>CreateThread</em>(<em>NULL</em>, 0 ,SellTicketA, <em>NULL</em>, 0, 0);// 2</p><p>hThreadB = <em>CreateThread</em>(<em>NULL</em>, 0, SellTicketB, <em>NULL</em>, 0, 0);</p><p><em>CloseHandle</em>(hThreadA); //1</p><p><em>CloseHandle</em>(hThreadB);</p><p>g_hEvent = <em>CreateEvent</em>(<em>NULL</em>, <em>FALSE</em>, <em>FALSE</em>, <em>NULL</em>);</p><p><em>SetEvent</em>(g_hEvent);</p><p><em>Sleep</em>(4000);</p><p><em>CloseHandle</em>(g_hEvent);</p><p><em>system</em>(“pause”);</p><p>return 0;</p><h3 id="15-7深入理解windows内核对象与句柄"><a href="#15-7深入理解windows内核对象与句柄" class="headerlink" title="15.7深入理解windows内核对象与句柄"></a>15.7深入理解windows内核对象与句柄</h3><p>\1. 内核对象</p><p>Windows中每个内核对象都只是一个内存块，它由操作系统内核分配，并只能由操作系统内核进行访问，应用程序不能在内存中定位这些数据结构并直接更改其内容。这个内存块是一个数据结构，其成员维护着与对象相关的信息。少数成员（安全描述符和使用计数）是所有内核对象都有的，但大多数成员都是不同类型对象特有的。</p><p>CreateFile</p><p>如：file文件对象、event事件对象、process进程、thread线程、iocompletationport完成端口（windows服务器）、mailslot邮槽、mutex互斥量和 registry注册表 等</p><p>\2. 内核对象的使用计数与生命期</p><p>内核对象的所有者是操作系统内核，而非进程。换言之也就是说当进程退出，内核对象不一定会销毁。操作系统内核通过内核对象的使用计数，知道当前有多少个进程正在使用一个特定的内核对象。初次创建内核对象，使用计数为1。当另一个进程获得该内核对象的访问权之后，使用计数加1。如果内核对象的使用计数递减为0，操作系统内核就会销毁该内核对象。也就是说内核对象在当前进程中创建，但是当前进程退出时，内核对象有可能被另外一个进程访问。这时，进程退出只会减少当前进程对引用的所有内核对象的使用计数，而不会减少其他进程对内核对象的使用计数（即使该内核对象由当前进程创建）。那么内核对象的使用计数未递减为0，操作系统内核不会销毁该内核对象。示例如下：</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image101.gif" alt="åæ ¸å¯¹è±¡ä¸è¿ç¨"></p><p>(1)进程1退出，2不退出时。内核对象A,B的引用计数减为0，被操作系统内核销毁，而进程1只减少自身对C,D的引用计数，不会影响进程2对C,D的引用计数，此时C,D引用计数不为0，不会被销毁。<br>(2)进程2退出，1不退出时。进程2减少自身对C,D的引用计数，不会影响进程1，故A,B,C,D都不会被销毁<br>(3)进程1，2均退出时，只要ABCD不被别的进程使用，内核对象A,B,C,D的引用计数均递减为0，被内核销毁<br>(4)进程1和2均为退出时，内核对象A,B,C,D的引用计数只要有一个递减为0，那么递减为0的内核对象便被内核销毁</p><p>\3. 操作内核对象</p><p>Windows提供了一组函数进行操作内核对象。成功调用一个创建内核对象的函数后，会返回一个句柄，它表示了所创建的内核对象，可由进程中的任何线程使用。在32位进程中，句柄是一个32位值，在64位进程中句柄是一个64位值。我们可以使用唯一标识内核对象的句柄，调用内核操作函数对内核对象进行操作。</p><p>\4. 内核对象与其他类型的对象</p><p>Windows进程中除了内核对象还有其他类型的对象，比如窗口，菜单，字体等，这些属于用户对象和GDI对象。要区分内核对象与非内核对象，最简单的方式就是查看创建这个对象的函数，几乎所有创建内核对象的函数都有一个允许我们指定安全属性的参数。</p><p>注意：</p><p>1 一个对象是不是内核对象，通常可以看创建此对象API的参数中是否需要：PSECURITY_ATTRIBUTES 类型的参数。</p><p>2 内核对象只是一个内存块，这块内存位于操作系统内核的地址空间，内存块中存放一个数据结构（此数据结构的成员有如：安全描述符、使用计数等）。</p><p>3 每个进程中有一个句柄表（handle table），这个句柄表仅供内核对象使用，如下图：</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image103.jpg" alt="img"></p><p>4 调用</p><p>hThread = CreateThread(… , &amp;threadId);</p><p>当调用了CreateThread CreateFile 等创建内核对象的函数后，</p><p>就是相当于操作系统多了一个内存块，这个内存块就是内核对象</p><p>也是此时内核对象被创建，其数据结构中的引用计数初始为1（这样理解：只要内核对象被创建，其引用计数被初始化为1），这里实则发生两件事：创建了一个内核对象和创建线程的函数打开（访问）了此对象，所以内核对象的引用计数加1，这时引用计数就为2了。</p><p>调用API CreateThread的时候，不仅仅是创建了一个内核对象，引用计数+1，还打开了内核对象+1，所以引用计数变为2</p><p>当调用CloseHandle(hThread); 时发生这样的事情：系统通过hThread计算出此句柄在句柄表中的索引，然后把那一项处理后标注为空闲可用的项，内核对象的引用计数减1即此时此内核对象的引用计数为1，之后这个线程句柄与创建时产生的内核对象已经没有任何关系了。不能通过hThread句柄去访问内核对象了</p><p>只有当内核对象的引用计数为0时，内核对象才会被销毁，而此时它的引用计数为1，那它什么时候会被销毁？</p><p>当此线程结束的时候，它的引用计数再减1即为0，内核对象被销毁。此时又有一个新问题产生：我们已经关闭了线程句柄，也就是这个线程句柄已经和内核对象没有瓜葛了，那么那个内核对象是怎么又可以和此线程联系起来了呢？ 其实是创建线程时产生的那个线程ID，代码如下：</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;WinBase.h&gt;</p><p><em>DWORD</em> <em>WINAPI</em> ThreadProc(<em>LPVOID</em> lpParameter)</p><p>{</p><p><em>printf</em>(“I am comming…”);</p><p>while (1) {}</p><p>return 0;</p><p>}</p><p>int main()</p><p>{</p><p><em>HANDLE</em> hThread;</p><p><em>HANDLE</em> headle2;</p><p><em>DWORD</em> threadId;</p><p>hThread = <em>CreateThread</em>(<em>NULL</em>, 0, ThreadProc, <em>NULL</em>, 0, &amp;threadId);</p><p>// CloseHandle(hThread); // 关闭了线程句柄</p><p>headle2 = <em>OpenThread</em>(<em>THREAD_QUERY_INFORMATION</em>, <em>FALSE</em>, threadId);</p><p>headle2 = <em>OpenThread</em>(<em>THREAD_QUERY_INFORMATION</em>, <em>FALSE</em>, threadId);</p><p>headle2 = <em>OpenThread</em>(<em>THREAD_QUERY_INFORMATION</em>, <em>FALSE</em>, threadId);</p><p>return 0;</p><p>}</p><h3 id="15-8线程同步之信号量"><a href="#15-8线程同步之信号量" class="headerlink" title="15.8线程同步之信号量"></a>15.8线程同步之信号量</h3><p>内核对象的状态：</p><p>触发状态(有信号状态)，表示有可用资源。</p><p>未触发状态（无信号状态），表示没有可用资源</p><p>工作原理</p><p>​ 以一个停车场是运作为例。假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，看门人限制了可以活动的线程。假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，但是得保证最多停两辆车。对于Semaphore而言，就如同一个看门人，限制了可活动的线程数。</p><p>信号量的组成</p><p>　　①计数器：该内核对象被使用的次数</p><p>　　②<strong>最大资源数量</strong>：标识信号量可以控制的最大资源数量（带符号的32位）</p><p>　　③<strong>当前资源数量</strong>：标识当前可用资源的数量（带符号的32位）。即表示<strong>当前开放资源的个数</strong>（注意<strong>不是剩下资源的个数</strong>），<strong>只有开放的资源才能被线程所申请</strong>。但这些开放的资源不一定被线程占用完。比如，当前开放5个资源，而只有3个线程申请，则还有2个资源可被申请，但如果这时总共是7个线程要使用信号量，显然开放的资源5个是不够的。这时还可以再开放2个，直到达到最大资源数量。</p><p>信号量的规则如下：</p><p>（1）如果当前资源计数大于0，那么信号量处于触发状态(有信号状态)，表示有可用资源。</p><p>（2）如果当前资源计数等于0，那么信号量属于未触发状态（无信号状态），表示没有可用资源。</p><p>（3）系统绝对不会让当前资源计数变为负数</p><p>（4）当前资源计数绝对不会大于最大资源计数</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image104.jpg" alt="img"></p><p>信号量与互斥量不同的地方是，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源。</p><p>创建信号量</p><p><em>HANDLE</em></p><p><em>WINAPI</em></p><p><em>CreateSemaphoreW</em>(</p><p><em>_In_opt_</em> <em>LPSECURITY_ATTRIBUTES</em> lpSemaphoreAttributes, // Null 安全属性</p><p><em><em>In</em></em> <em>LONG</em> lInitialCount, //初始化时，共有多少个资源是可以用的。 0：未触发状//态（无信号状态），表示没有可用资源</p><p><em><em>In</em></em> <em>LONG</em> lMaximumCount, //能够处理的最大的资源数量 3</p><p><em>_In_opt_</em> <em>LPCWSTR</em> lpName //NULL 信号量的名称</p><p>);</p><p><em>增加信号量</em></p><p><em>WINAPI</em></p><p><em>ReleaseSemaphore</em>(</p><p><em><em>In</em></em> <em>HANDLE</em> hSemaphore, //信号量的句柄</p><p><em><em>In</em></em> <em>LONG</em> lReleaseCount, //将lReleaseCount值加到信号量的当前资源计数上面 0-&gt; 1</p><p><em>_Out_opt_</em> <em>LPLONG</em> lpPreviousCount //当前资源计数的原始值</p><p>);</p><p>关闭句柄</p><p><em>CloseHandle</em>(</p><p><em><em>In</em></em> <em><em>Post_ptr_invalid</em></em> <em>HANDLE</em> hObject</p><p>);</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>unsigned <em>WINAPI</em> Read(void* arg);</p><p>unsigned <em>WINAPI</em> Accu(void* arg);</p><p>static <em>HANDLE</em> semOne;</p><p>static <em>HANDLE</em> semTwo;</p><p>static int num;</p><p>int main(int argc, char* argv[])</p><p>{</p><p><em>HANDLE</em> hThread1, hThread2;</p><p>semOne = <em>CreateSemaphore</em>(<em>NULL</em>, 0, 1, <em>NULL</em>);</p><p>//semOne 没有可用资源 只能表示0或者1的二进制信号量 无信号</p><p>semTwo = <em>CreateSemaphore</em>(<em>NULL</em>, 1, 1, <em>NULL</em>);</p><p>//semTwo 有可用资源，有信号状态 有信号</p><p>hThread1 = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, Read, <em>NULL</em>, 0, <em>NULL</em>);</p><p>hThread2 = (<em>HANDLE</em>)<em>_beginthreadex</em>(<em>NULL</em>, 0, Accu, <em>NULL</em>, 0, <em>NULL</em>);</p><p><em>WaitForSingleObject</em>(hThread1, <em>INFINITE</em>);</p><p><em>WaitForSingleObject</em>(hThread2, <em>INFINITE</em>);</p><p><em>CloseHandle</em>(semOne);</p><p><em>CloseHandle</em>(semTwo);</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><p>unsigned <em>WINAPI</em> Read(void* arg)</p><p>{</p><p>int i;</p><p>for (i = 0; i &lt; 5; i++)</p><p>{</p><p>​ <em>fputs</em>(“Input num: “, <em>stdout</em>); // 1 5 11</p><p>​ <em>printf</em>(“begin read\n”); // 3 6 12</p><p>​ //等待内核对象semTwo的信号，如果有信号，继续执行；如果没有信号，等待</p><p>​ <em>WaitForSingleObject</em>(semTwo, <em>INFINITE</em>);</p><p>​ <em>printf</em>(“beginning read\n”); //4 10 16</p><p>​ <em>scanf</em>(“%d”, &amp;num);</p><p>​ <em>ReleaseSemaphore</em>(semOne, 1, <em>NULL</em>);</p><p>}</p><p>return 0;</p><p>}</p><p>unsigned <em>WINAPI</em> Accu(void* arg)</p><p>{</p><p>int sum = 0, i;</p><p>for (i = 0; i &lt; 5; i++)</p><p>{</p><p>​ <em>printf</em>(“begin Accu\n”); //2 9 15</p><p>​ //等待内核对象semOne的信号，如果有信号，继续执行；如果没有信号，等待</p><p>​ <em>WaitForSingleObject</em>(semOne, <em>INFINITE</em>);</p><p>​ <em>printf</em>(“beginning Accu\n”); //7 13</p><p>​ sum += num;</p><p>​ <em>printf</em>(“sum = %d \n”, sum); // 8 14</p><p>​ <em>ReleaseSemaphore</em>(semTwo, 1, <em>NULL</em>);</p><p>}</p><p><em>printf</em>(“Result: %d \n”, sum);</p><p>return 0;</p><p>}</p><h3 id="15-9线程同步之关键代码段"><a href="#15-9线程同步之关键代码段" class="headerlink" title="15.9线程同步之关键代码段"></a>15.9线程同步之关键代码段</h3><p>关键代码段，也称为临界区，工作在用户方式下。它是指一个小代码段，在代码能够执行前，它必须独占对某些资源的访问权。通常把多线程中访问同一种资源的那部分代码当做关键代码段。</p><p>\1. 初始化关键代码段</p><p>​ 调用InitializeCriticalSection函数初始化一个关键代码段。</p><p>InitializeCriticalSection(</p><p><em><em>Out</em></em> <em>LPCRITICAL_SECTION</em> lpCriticalSection</p><p>);</p><p>​ 该函数只有一个指向CRITICAL_SECTION结构体的指针。在调用InitializeCriticalSection函数之前，首先需要构造一个CRITICAL_SCTION结构体类型的对象，然后将该对象的地址传递给InitializeCriticalSection函数。</p><p>2进入关键代码段</p><p><em>VOID</em></p><p><em>WINAPI</em></p><p><em>EnterCriticalSection</em>(</p><p><em><em>Inout</em></em> <em>LPCRITICAL_SECTION</em> lpCriticalSection</p><p>);</p><p>​ 调用EnterCriticalSection函数，以获得指定的临界区对象的所有权，该函数等待指定的临界区对象的所有权，如果该所有权赋予了调用线程，则该函数就返回；否则该函数会一直等待，从而导致线程等待。</p><p>\3. 退出关键代码段</p><p><em>VOID</em></p><p><em>WINAPI</em></p><p><em>LeaveCriticalSection</em>(</p><p><em><em>Inout</em></em> <em>LPCRITICAL_SECTION</em> lpCriticalSection);</p><p>​ 线程使用完临界区所保护的资源之后，需要调用LeaveCriticalSection函数，释放指定的临界区对象的所有权。之后，其他想要获得该临界区对象所有权的线程就可以获得该所有权，从而进入关键代码段，访问保护的资源。</p><p>\4. 删除临界区</p><p><em>WINBASEAPI</em></p><p><em>VOID</em></p><p><em>WINAPI</em></p><p><em>DeleteCriticalSection</em>(</p><p><em><em>Inout</em></em> <em>LPCRITICAL_SECTION</em> lpCriticalSection</p><p>);</p><p>​ 当临界区不再需要时，可以调用DeleteCriticalSection函数释放该对象，该函数将释放一个没有被任何线程所拥有的临界区对象的所有资源。</p><p><em>BOOL</em> COneIPCChannel::InitIPCChannel(<em>CWnd</em> * pVideoWnd)</p><p>{</p><p>m_pVideoBuffer = new CVideoRecieveBuffer;</p><p>m_pVideoWnd = pVideoWnd;</p><p>m_bPlaying = <em>FALSE</em>;</p><p>m_isTFPlay=<em>FALSE</em>;</p><p><em>InitializeCriticalSection</em>(&amp;m_cs);</p><p>m_hWaitEvent = <em>CreateEvent</em>(NULL,<em>FALSE</em>,<em>FALSE</em>,NULL);</p><p>return <em>TRUE</em>;</p><p>}</p><p><em>BOOL</em> COneIPCChannel::InitIPCChannelREMOTE(<em>CWnd</em> * pVideoWnd,int *Session)</p><p>{</p><p>m_Session=Session;</p><p>m_pVideoWnd = pVideoWnd;</p><p>m_bPlaying = <em>FALSE</em>;</p><p>m_isTFPlay = <em>FALSE</em>;</p><p>m_pVideoBuffer = new CVideoRecieveBuffer;</p><p><em>InitializeCriticalSection</em>(&amp;m_cs);</p><p>m_hWaitEvent = <em>CreateEvent</em>(NULL,<em>FALSE</em>,<em>FALSE</em>,NULL);</p><p>return <em>TRUE</em>;</p><p>}</p><p>卖票系统</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>int iTickets = 5000;</p><p><em>CRITICAL_SECTION</em> g_cs;</p><p>// A窗口 B窗口</p><p><em>DWORD</em> <em>WINAPI</em> SellTicketA(void* lpParam)</p><p>{</p><p>while (1)</p><p>{</p><p>​ <em>EnterCriticalSection</em>(&amp;g_cs);//进入临界区</p><p>​ if (iTickets &gt; 0)</p><p>​ {</p><p>​ <em>Sleep</em>(1);</p><p>​ iTickets–;</p><p>​ <em>printf</em>(“A remain %d\n”, iTickets);</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_cs);//离开临界区</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_cs);//离开临界区</p><p>​ break;</p><p>​ }</p><p>}</p><p>return 0;</p><p>}</p><p><em>DWORD</em> <em>WINAPI</em> SellTicketB(void* lpParam)</p><p>{</p><p>while (1)</p><p>{</p><p>​ <em>EnterCriticalSection</em>(&amp;g_cs);//进入临界区</p><p>​ if (iTickets &gt; 0)</p><p>​ {</p><p>​ <em>Sleep</em>(1);</p><p>​ iTickets–;</p><p>​ <em>printf</em>(“B remain %d\n”, iTickets);</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_cs);//离开临界区</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_cs);//离开临界区</p><p>​ break;</p><p>​ }</p><p>}</p><p>return 0;</p><p>}</p><p>int main()</p><p>{</p><p><em>HANDLE</em> hThreadA, hThreadB;</p><p>hThreadA = <em>CreateThread</em>(<em>NULL</em>, 0, SellTicketA, <em>NULL</em>, 0, <em>NULL</em>); //2</p><p>hThreadB = <em>CreateThread</em>(<em>NULL</em>, 0, SellTicketB, <em>NULL</em>, 0, <em>NULL</em>); //2</p><p><em>CloseHandle</em>(hThreadA); //1</p><p><em>CloseHandle</em>(hThreadB); //1</p><p><em>InitializeCriticalSection</em>(&amp;g_cs); //初始化关键代码段</p><p><em>Sleep</em>(40000);</p><p><em>DeleteCriticalSection</em>(&amp;g_cs);//删除临界区</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><h3 id="15-10线程死锁"><a href="#15-10线程死锁" class="headerlink" title="15.10线程死锁"></a>15.10线程死锁</h3><p>死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;process.h&gt;</p><p>int iTickets = 5000;</p><p><em>CRITICAL_SECTION</em> g_csA;</p><p><em>CRITICAL_SECTION</em> g_csB;</p><p>// A窗口 B窗口</p><p><em>DWORD</em> <em>WINAPI</em> SellTicketA(void* lpParam)</p><p>{</p><p>while (1)</p><p>{</p><p>​ <em>EnterCriticalSection</em>(&amp;g_csA);//进入临界区A</p><p>​ <em>Sleep</em>(1);</p><p>​ <em>EnterCriticalSection</em>(&amp;g_csB);//进入临界区B</p><p>​ if (iTickets &gt; 0)</p><p>​ {</p><p>​ <em>Sleep</em>(1);</p><p>​ iTickets–;</p><p>​ <em>printf</em>(“A remain %d\n”, iTickets);</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csB);//离开临界区B</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csA);//离开临界区A</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csB);//离开临界区B</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csA);//离开临界区A</p><p>​ break;</p><p>​ }</p><p>}</p><p>return 0;</p><p>}</p><p><em>DWORD</em> <em>WINAPI</em> SellTicketB(void* lpParam)</p><p>{</p><p>while (1)</p><p>{</p><p>​ <em>EnterCriticalSection</em>(&amp;g_csB);//进入临界区B</p><p>​ <em>Sleep</em>(1);</p><p>​ <em>EnterCriticalSection</em>(&amp;g_csA);//进入临界区A</p><p>​ if (iTickets &gt; 0)</p><p>​ {</p><p>​ <em>Sleep</em>(1);</p><p>​ iTickets–;</p><p>​ <em>printf</em>(“B remain %d\n”, iTickets);</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csA);//离开临界区A</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csB);//离开临界区B</p><p>​ }</p><p>​ else</p><p>​ {</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csA);//离开临界区A</p><p>​ <em>LeaveCriticalSection</em>(&amp;g_csB);//离开临界区B</p><p>​ break;</p><p>​ }</p><p>}</p><p>return 0;</p><p>}</p><p>int main()</p><p>{</p><p><em>HANDLE</em> hThreadA, hThreadB;</p><p>hThreadA = <em>CreateThread</em>(<em>NULL</em>, 0, SellTicketA, <em>NULL</em>, 0, <em>NULL</em>); //2</p><p>hThreadB = <em>CreateThread</em>(<em>NULL</em>, 0, SellTicketB, <em>NULL</em>, 0, <em>NULL</em>); //2</p><p><em>CloseHandle</em>(hThreadA); //1</p><p><em>CloseHandle</em>(hThreadB); //1</p><p><em>InitializeCriticalSection</em>(&amp;g_csA); //初始化关键代码段A</p><p><em>InitializeCriticalSection</em>(&amp;g_csB); //初始化关键代码段B</p><p><em>Sleep</em>(40000);</p><p><em>DeleteCriticalSection</em>(&amp;g_csA);//删除临界区</p><p><em>DeleteCriticalSection</em>(&amp;g_csB);//删除临界区</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><h3 id="15-11各种线程同步的比较总结"><a href="#15-11各种线程同步的比较总结" class="headerlink" title="15.11各种线程同步的比较总结"></a>15.11各种线程同步的比较总结</h3><p>windows线程同步的方式主要有四种：互斥对象Mutex、事件对象event和关键代码段criticalSection。 信号量</p><p>​ 对于上面介绍的三种线程同步的方式，它们之间的区别如下所述：</p><p>​ ● 互斥对象和事件以及信号量都属于内核对象，利用内核对象进行线程同步时，速度较慢，但利用互斥对象和事件对象这样的内核对象，可以在多个进程中的各个线程间进行同步。</p><p>​ ● 关键代码段工作在用户方式下，同步速度较快，但在使用关键代码段时，很容易进入死锁状态，因为在等待进入关键代码段时无法设定超时值。</p><p>用户级别的：关键代码段，只能本进程中</p><p>内核级别的：互斥量/事件/信号量，可以跨进程</p><p>​ 通常，在编写多线程程序并需要实现线程同步时，首选关键代码段，由于它的使用比较简单，如果是在MFC程序中使用的话，可以在类的构造函数Init中调用InitializeCriticalSection函数，在该类的析构函数中调用DeleteCriticalSection函数，在所需保护的代码前面调用EnterCriticalSection函数，在访问完所需保护的资源后，调用LeaveCriticalSection函数。可见，关键代码段在使用上是非常方便的，但有几点需要注意：</p><p>A 在程序中调用了EnterCriticalSection后，要相应的调用LeaveCriticalSection函数，否则其他等待该临界区对象所有权的线程将无法执行。</p><p>B 如果访问关键代码段时，使用了多个临界区对象，就要注意防止线程死锁的发生。另外，如果需要在多个进程间的各个线程间实现同步的话，可以使用互斥对象和事件对象或者信号量。</p><table><thead><tr><th>比较</th><th>互斥量 Mutex</th><th>事件对象 Event</th><th>信号量对象 Semaphore</th><th>关键代码段（临界区）CriticalSection</th></tr></thead><tbody><tr><td>是否为内核对象</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>速度</td><td>较慢</td><td>较慢</td><td>较慢</td><td>快</td></tr><tr><td>多个进程种的线程同步</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>发生死锁</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>组成</td><td>一个线程ID：用来标识哪个线程当前拥有该互斥量；一个计数器：用于指明该线程拥有互斥对象的次数</td><td>一个使用计数；一个布尔值：用来标识该事件是自动重置还是人工重置；一个布尔值：表示用于指明该事件处于已通知状态（有信号）还是未通知状态（无信号）</td><td>一个使用计数； 最大资源数量； 标识当前可用资源的数量</td><td>一个小代码段； 在代码能够执行钱，它必须独占对某些资源的访问权</td></tr><tr><td>相关函数</td><td>CreateMutex WaitForSingleObjects 被保护的内容 ReleaseMutex</td><td>CreateEvent ResetEvent WaitForSingleObject 保护内容 SetEvent</td><td><em>CreateSemaphore</em> <em>WaitForSingleObject</em> <em>被保护的内容</em> <em>ReleaseSemaphore</em></td><td>InitializeCriticalSection <em>EnterCriticalSection</em> <em>被保护的内容</em> <em>LeaveCriticalSection</em> <em>DeleteCriticalSection</em></td></tr><tr><td>注意事项</td><td>谁拥有互斥对象谁释放；如果多次在同一个线程请求同一个互斥量，那么需要多次调用releaseMutex</td><td>为了实现线程间的同步，不应该使用人工重置，应该把第二个参数设置为false，设置为自动重置</td><td>它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目</td><td>防死锁：使用多个临界区对象g_csA g_csB。</td></tr><tr><td>类比</td><td>一把钥匙</td><td>一把钥匙</td><td>停车场与保安</td><td>电话亭</td></tr></tbody></table><p>什么是线程安全？</p><p>假如你的代码在多线程执行和单线程执行永远是完全一样的结果，那么你的代码是线程安全的。</p><p>陈硕《muduo》</p><p>　</p><h2 id="16-进程"><a href="#16-进程" class="headerlink" title="16 进程"></a>16 进程</h2><h3 id="16-1-基本概念-进程和子进程"><a href="#16-1-基本概念-进程和子进程" class="headerlink" title="16.1 基本概念-进程和子进程"></a>16.1 基本概念-进程和子进程</h3><p>程序,进程：正在运行的程序</p><p>A: 程序是计算机指令的集合,它以文件的形式存储在磁盘上,而进程通常被定义为一个正在运行的程序的实例,是一个程序在其自身的地址空间中的一次执行活动.一个程序可以对应多个进程.</p><p>进程是资源申请,高度和独立运行的单位,因此,它使用系统中的运行资源,而程序不能申请系统资源,不能被系统高度也不能作为独立运行的单位,因此它不占系统运行资源.</p><p>进程组成:</p><p>&lt;1&gt; 操作系统用来管理进行的内核对象</p><p>​ 内核对象也是系统用来存放关于进程的统计信息的地方.内核对象是操作系统内部分配的一个内存块,该内存块是一种数据结构,其成员负责维护该对象的各种信息.</p><p>&lt;2&gt; 地址空间</p><p>​ 它包含所有可执行模块或DLL模块的代码和数据.另外,它也包含动态内存分配的空间,例如线程的栈和堆分配空间</p><p>B: 进程从来不执行任何东西,它只是纯种的容器,若要使进行完成某项操作,它必须拥有一个在它的环境中运行的纯种,此线程负责执行包含在进程的地址空间的中的代码.也就是,真正完成代码执行的是线程,而进程只是纯种的容器,或者说是线程的执行环境.</p><p>子进程：还是一个进程</p><p>子进程指的是由另一进程（对应称之为父进程）所创建的进程。</p><p>单任务的同步机制。线程，子进程。</p><p>需要保护地址空间。</p><p>子进程的线程既可以在父进程终止之后执行我们的代码；也可以在父进程运行的过程中执行代码。</p><h3 id="16-2-如何创建一个进程"><a href="#16-2-如何创建一个进程" class="headerlink" title="16.2 如何创建一个进程"></a>16.2 如何创建一个进程</h3><p>进程的命令行：</p><p>按下 win + R</p><p><em>CreateProcess**函数</em></p><p><em>CreateProcessW</em>(</p><p><em>_In_opt_</em> <em>LPCWSTR</em> lpApplicationName,// 该字符串可以指定要执行的模块的完整路径和文件名</p><p><em>_Inout_opt_</em> <em>LPWSTR</em> lpCommandLine, //命令行</p><p><em>_In_opt_</em> <em>LPSECURITY_ATTRIBUTES</em> lpProcessAttributes,</p><p>//该 结构确定子进程是否可以继承返回到新进程对象的句柄。如果//<em>lpProcessAttributes</em>为<strong>NULL</strong>，则不能继承该句柄</p><p><em>_In_opt_</em> <em>LPSECURITY_ATTRIBUTES</em> lpThreadAttributes,</p><p>//该 结构确定子进程是否可以继承返回到新线程对象的句柄。如果//<em>lpThreadAttributes</em>为NULL，则不能继承该句柄</p><p><em><em>In</em></em> <em>BOOL</em> bInheritHandles,</p><p>//如果此参数为TRUE，则新进程将继承调用进程中的每个可继承句柄。如果参//数为FALSE，则不会继承句柄。请注意，继承的句柄与原始句柄具有相同的值和//访问权限</p><p><em><em>In</em></em> <em>DWORD</em> dwCreationFlags,// 控制优先级类别和流程创建的标志 <em>CREATE_NEW_CONSOLE</em></p><p><em>_In_opt_</em> <em>LPVOID</em> lpEnvironment,// 指向新进程的环境块的指针。如果此参数为//<strong>NULL</strong>，则新进程将使用调用进程的环境</p><p>//</p><p><em>_In_opt_</em> <em>LPCWSTR</em> lpCurrentDirectory,// 进程当前目录的完整路径</p><p><em><em>In</em></em> <em>LPSTARTUPINFOW</em> lpStartupInfo, //设置扩展属性</p><p><em><em>Out</em></em> <em>LPPROCESS_INFORMATION</em> lpProcessInformation // 该 结构接收有关新进程的标识//信息</p><p>);</p><p>查windows文档</p><p>推荐一个软件</p><p>在线：</p><p>微软的帮助文档网址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/"><em>https://docs.microsoft.com/en-us/</em></a></p><p>Shift + 鼠标右键</p><p>//创建一个用谷歌浏览器打开百度</p><p>#include &lt;windows.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;tchar.h&gt;</p><p>void RunExe()</p><p>{</p><p><em>STARTUPINFO</em> strStartupInfo;</p><p><em>memset</em>(&amp;strStartupInfo, 0, sizeof(strStartupInfo));</p><p>strStartupInfo.<em>cb</em> = sizeof(strStartupInfo);</p><p><em>PROCESS_INFORMATION</em> szProcessInformation;</p><p><em>memset</em>(&amp;szProcessInformation, 0, sizeof(szProcessInformation));</p><p><em>TCHAR</em> szCommandLine[] =<em>_T</em>(“&quot;D:\Program Files (x86)\ChromeCore\ChromeCore.exe&quot; <a target="_blank" rel="noopener" href="http://www.baidu.com/&quot;">http://www.baidu.com/&quot;</a>);</p><p>int iRet = <em>CreateProcess</em>(</p><p>​ <em>NULL</em>,</p><p>​ szCommandLine,</p><p>​ <em>NULL</em>,</p><p>​ <em>NULL</em>,</p><p>​ false,</p><p>​ <em>CREATE_NEW_CONSOLE</em>,</p><p>​ <em>NULL</em>,</p><p>​ <em>NULL</em>,</p><p>​ &amp;strStartupInfo,</p><p>​ &amp;szProcessInformation</p><p>​ );</p><p>if (iRet)</p><p>{</p><p>​ //创建成功</p><p>​ <em>printf_s</em>(“Create Success iRet = %d\n”, iRet);</p><p>​ <em>WaitForSingleObject</em>(szProcessInformation.<em>hProcess</em>, 3000);</p><p>​ <em>CloseHandle</em>(szProcessInformation.<em>hProcess</em>);</p><p>​ <em>CloseHandle</em>(szProcessInformation.<em>hThread</em>);</p><p>​ szProcessInformation.<em>dwProcessId</em> = 0;</p><p>​ szProcessInformation.<em>dwThreadId</em> = 0;</p><p>​ szProcessInformation.<em>hThread</em> = <em>NULL</em>;</p><p>​ szProcessInformation.<em>hProcess</em> = <em>NULL</em>;</p><p>}</p><p>else</p><p>{</p><p>​ <em>printf_s</em>(“Create Success iRet = %d\n”, iRet);</p><p>​ <em>printf_s</em>(“errorcode = %d\n”, <em>GetLastError</em>());</p><p>}</p><p>}</p><p>int main()</p><p>{</p><p><em>printf</em>(“This is Bingo\n”);</p><p>RunExe();</p><p><em>system</em>(“pause”);</p><p>return 0;</p><p>}</p><h3 id="16-3-进程间通信方式汇总"><a href="#16-3-进程间通信方式汇总" class="headerlink" title="16.3 进程间通信方式汇总"></a>16.3 进程间通信方式汇总</h3><p>1 socket编程 IP和端口</p><p>2 剪切板 剪切板的内核对象</p><p>3 邮槽 邮槽的内核对象</p><p>4 匿名管道（无名管道）</p><p>5 命名管道</p><p>6 Copy_data findwindows wm_copydata 很多书籍都没有 消息</p><p>Sendmessage</p><h3 id="16-4-进程间通信方式之剪切板"><a href="#16-4-进程间通信方式之剪切板" class="headerlink" title="16.4 进程间通信方式之剪切板"></a>16.4 进程间通信方式之剪切板</h3><p>系统维护管理的一块内存区域。</p><p>void CClipboardDlg::OnBnClickedSendBtn()</p><p>{</p><p>// 1 打开剪切板</p><p>if (<em>OpenClipboard</em>())</p><p>{</p><p>​ //2 清空剪切板</p><p>​ <em>EmptyClipboard</em>();</p><p>​ char* szSendBuf;</p><p>​ //3 获取编辑框的内容</p><p>​ <em>CStringW</em> strSendW;</p><p>​ <em>GetDlgItemText</em>(IDC_EDIT_SEND, strSendW);</p><p>​ <em>CStringA</em> strSend = (<em>CStringA</em>)strSendW;</p><p>​</p><p>​ //4 分配一个内存对象，内存对象的句柄就是hClip</p><p>​ <em>HANDLE</em> hClip = <em>GlobalAlloc</em>(<em>GMEM_MOVEABLE</em>, strSend.<em>GetLength</em>() + 1);</p><p>​ //5 将剪切板句柄加锁</p><p>​ szSendBuf = (char*)<em>GlobalLock</em>(hClip);</p><p>​ <em>strcpy</em>(szSendBuf, strSend);</p><p>​ <em>TRACE</em>(“szSendBuf = %s”, szSendBuf);</p><p>​ <em>GlobalUnlock</em>(hClip);</p><p>​ //6 将数据放入剪切板</p><p>​ <em>SetClipboardData</em>(<em>CF_TEXT</em>, hClip);</p><p>​ //关闭剪切板</p><p>​ <em>CloseClipboard</em>();</p><p>}</p><p>}</p><p>void CClipboardDlg::OnBnClickedRecvBtn()</p><p>{</p><p>if (<em>OpenClipboard</em>())</p><p>{</p><p>​ //确认剪切板是否可用</p><p>​ if (<em>IsClipboardFormatAvailable</em>(<em>CF_TEXT</em>))</p><p>​ {</p><p>​ <em>HANDLE</em> hClip;</p><p>​ char* pBuf;</p><p>​ //向剪切板要数据</p><p>​ hClip = <em>GetClipboardData</em>(<em>CF_TEXT</em>);</p><p>​ pBuf = (char*)<em>GlobalLock</em>(hClip);</p><p>​ <em>USES_CONVERSION</em>;</p><p>​ <em>LPCWSTR</em> strBuf = <em>A2W</em>(pBuf);</p><p>​ <em>GlobalUnlock</em>(hClip);</p><p>​ <em>SetDlgItemText</em>(IDC_EDIT_RECV, strBuf);</p><p>​ }</p><p>​ <em>CloseClipboard</em>();</p><p>}</p><p>}</p><h3 id="16-5-进程间通信方式之邮槽"><a href="#16-5-进程间通信方式之邮槽" class="headerlink" title="16.5 进程间通信方式之邮槽"></a>16.5 进程间通信方式之邮槽</h3><p>邮槽 邮槽的内核对象</p><p>使用邮槽通信的进程分为服务端和客户端。邮槽由服务端创建，在创建时需要指定邮槽名，创建后服务端得到邮槽的句柄。在邮槽创建后，客户端可以通过邮槽名打开邮槽，在获得句柄后可以向邮槽写入消息。<br>邮槽通信是单向的，只有服务端才能从邮槽中读取消息，客户端只能写入消息。消息是先入先出的。客户端先写入的消息在服务端先被读取。<br>通过邮槽通信的数据可以是任意格式的，但是一条消息不能大于424字节。<br>邮槽除了在本机内进行进程间通信外，在主机间也可以通信。但是在主机间进行邮槽通信，数据通过网络传播时使用的是数据报协议(UDP)，所以是一种不可靠的通信。通过网络进行邮槽通信时，客户端必须知道服务端的主机名或域名。</p><p>CreateMailslot</p><p>服务端</p><p>void CChildView::OnSlot()</p><p>{</p><p>// “\\.\mailslot\Mymailslot \.\mailslot\Mymailslot</p><p>// 1 创建一个邮槽</p><p><em>LPCTSTR</em> szSlotName = <em>TEXT</em>(“\\.\mailslot\Mymailslot”);</p><p><em>HANDLE</em> hSlot = <em>CreateMailslot</em>(szSlotName,</p><p>​ 0, // no maximum message size</p><p>​ <em>MAILSLOT_WAIT_FOREVER</em>, // no time-out for operations</p><p>​ <em>NULL</em>); // default security</p><p>if (hSlot == <em>INVALID_HANDLE_VALUE</em>)</p><p>{</p><p>​ <em>TRACE</em>(“CreateMailslot failed with %d\n”, <em>GetLastError</em>());</p><p>​ return ;</p><p>}</p><p>// 2 读取数据</p><p>char szBuf[100] = { 0 };</p><p><em>DWORD</em> dwRead;</p><p><em>TRACE</em>(“Begin ReadFile”);</p><p>if (!<em>ReadFile</em>(hSlot, szBuf, 100, &amp;dwRead, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“读取数据失败”));</p><p>​ <em>CloseHandle</em>(hSlot);</p><p>​ return;</p><p>}</p><p><em>TRACE</em>(“End ReadFile”);</p><p><em>MessageBox</em>((<em>CStringW</em>)szBuf);</p><p><em>CloseHandle</em>(hSlot);</p><p>}</p><p>客户端</p><p>void CChildView::OnSend()</p><p>{</p><p>// 创建一个文件句柄</p><p><em>LPCTSTR</em> szSlotName = <em>TEXT</em>(“\\.\mailslot\Mymailslot”);</p><p><em>HANDLE</em> hMailSlot =</p><p>​ <em>CreateFile</em>(szSlotName, <em>FILE_GENERIC_WRITE</em>,</p><p>​ <em>FILE_SHARE_READ</em>, <em>NULL</em>, <em>OPEN_EXISTING</em>, <em>FILE_ATTRIBUTE_NORMAL</em>,<em>NULL</em> );</p><p>if (hMailSlot == <em>INVALID_HANDLE_VALUE</em>)</p><p>{</p><p>​ <em>TRACE</em>(“CreateFile failed with %d\n”, <em>GetLastError</em>());</p><p>​ return;</p><p>}</p><p>//写入数据</p><p>char szBuf[] = “Bingo is handsome”;</p><p><em>DWORD</em> dwWrite;</p><p>if (!<em>WriteFile</em>(hMailSlot, szBuf, <em>strlen</em>(szBuf) + 1, &amp;dwWrite, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“写入数据失败”));</p><p>​ <em>CloseHandle</em>(hMailSlot);</p><p>​ return;</p><p>}</p><p><em>CloseHandle</em>(hMailSlot);</p><p>}</p><h3 id="16-6-进程间通信方式之匿名管道"><a href="#16-6-进程间通信方式之匿名管道" class="headerlink" title="16.6 进程间通信方式之匿名管道"></a>16.6 进程间通信方式之匿名管道</h3><p>匿名管道是一个没有命名的单向管道，本质上就是一个共享的内存区域。通常用来在父进程和子进程之间通信。只能实现本地两个进程之间的通信。不能实现网络通信。</p><p>共享内存</p><p><em>CreatePipe</em>(</p><p><em><em>Out</em></em> <em>PHANDLE</em> hReadPipe, //该变量接收管道的读取句柄</p><p><em><em>Out</em></em> <em>PHANDLE</em> hWritePipe,// 该变量接收管道的写句柄</p><p><em>_In_opt_</em> <em>LPSECURITY_ATTRIBUTES</em> lpPipeAttributes,//NULL</p><p><em><em>In</em></em> <em>DWORD</em> nSize //管道缓冲区的大小 0 :默认缓冲区大小</p><p>);</p><p>是否能被子进程继承</p><p>父进程</p><p>void CChildView::OnPipeCreate()</p><p>{</p><p>// TODO: 在此添加命令处理程序代码</p><p>//创建匿名管道</p><p><em>SECURITY_ATTRIBUTES</em> sa;</p><p>sa.<em>bInheritHandle</em> = <em>TRUE</em>;</p><p>sa.<em>lpSecurityDescriptor</em> = <em>NULL</em>;</p><p>sa.<em>nLength</em> = sizeof(<em>SECURITY_ATTRIBUTES</em>);</p><p>if (!<em>CreatePipe</em>(&amp;hReadPipe, &amp;hWritePipe, &amp;sa, 0))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“匿名管道创建失败”));</p><p>​ return;</p><p>}</p><p>//创建子进程</p><p><em>STARTUPINFO</em> strStartupInfo; //用来指定新进程窗口如何显示</p><p><em>memset</em>(&amp;strStartupInfo, 0, sizeof(strStartupInfo));</p><p>strStartupInfo.<em>cb</em> = sizeof(strStartupInfo);</p><p>strStartupInfo.<em>dwFlags</em> = <em>STARTF_USESTDHANDLES</em>;</p><p>strStartupInfo.<em>hStdInput</em> = hReadPipe;</p><p>strStartupInfo.<em>hStdOutput</em> = hWritePipe;</p><p>strStartupInfo.<em>hStdError</em> = <em>GetStdHandle</em>(<em>STD_ERROR_HANDLE</em>);</p><p><em>PROCESS_INFORMATION</em> szProcessInformation;</p><p><em>memset</em>(&amp;szProcessInformation, 0, sizeof(szProcessInformation));</p><p>int iRet = <em>CreateProcess</em>(</p><p>​ <em>_T</em>(“MailSlotClient.exe”),</p><p>​ <em>NULL</em>,</p><p>​ <em>NULL</em>,</p><p>​ <em>NULL</em>,</p><p>​ <em>TRUE</em>,</p><p>​ 0,</p><p>​ <em>NULL</em>,</p><p>​ <em>NULL</em>,</p><p>​ &amp;strStartupInfo,</p><p>​ &amp;szProcessInformation</p><p>);</p><p>if (iRet)</p><p>{</p><p>​ //创建成功</p><p>​ <em>CloseHandle</em>(szProcessInformation.<em>hProcess</em>);</p><p>​ <em>CloseHandle</em>(szProcessInformation.<em>hThread</em>);</p><p>​ szProcessInformation.<em>dwProcessId</em> = 0;</p><p>​ szProcessInformation.<em>dwThreadId</em> = 0;</p><p>​ szProcessInformation.<em>hThread</em> = <em>NULL</em>;</p><p>​ szProcessInformation.<em>hProcess</em> = <em>NULL</em>;</p><p>​</p><p>}</p><p>else</p><p>{</p><p>​</p><p>​ <em>CloseHandle</em>(hReadPipe);</p><p>​ <em>CloseHandle</em>(hWritePipe);</p><p>​ hReadPipe = <em>NULL</em>;</p><p>​ hWritePipe = <em>NULL</em>;</p><p>​ <em>MessageBox</em>(<em>_T</em>(“创建子进程失败”));</p><p>​ return;</p><p>}</p><p>}</p><p>void CChildView::OnPipeRead()</p><p>{</p><p>char szBuf[100] = { 0 };</p><p><em>DWORD</em> dwRead;</p><p><em>TRACE</em>(“Begin ReadFile”);</p><p>if (!<em>ReadFile</em>(hReadPipe, szBuf, 100, &amp;dwRead, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“读取数据失败”));</p><p>​ return;</p><p>}</p><p><em>TRACE</em>(“End PipeReadFile”);</p><p><em>MessageBox</em>((<em>CStringW</em>)szBuf);</p><p>}</p><p>void CChildView::OnPipeWrite()</p><p>{</p><p>//写入数据</p><p>char szBuf[] = “Bingo hen shuai”;</p><p><em>DWORD</em> dwWrite;</p><p>if (!<em>WriteFile</em>(hWritePipe, szBuf, <em>strlen</em>(szBuf) + 1, &amp;dwWrite, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“写入数据失败”));</p><p>​ return;</p><p>}</p><p>}</p><p>子进程</p><p>hReadCliPipe =<em>GetStdHandle</em>(<em>STD_INPUT_HANDLE</em>);</p><p>hWriteCliPipe = <em>GetStdHandle</em>(<em>STD_OUTPUT_HANDLE</em>);</p><p>void CChildView::OnCliPipeRead()</p><p>{</p><p>char szBuf[100] = { 0 };</p><p><em>DWORD</em> dwRead;</p><p><em>TRACE</em>(“Begin ReadFile”); //查找所有引用shift + alt + F</p><p>if (!<em>ReadFile</em>(hReadCliPipe, szBuf, 100, &amp;dwRead, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“读取数据失败”));</p><p>​ return;</p><p>}</p><p><em>TRACE</em>(“End PipeReadFile”);</p><p><em>MessageBox</em>((<em>CStringW</em>)szBuf);</p><p>}</p><p>void CChildView::OnCliPipeWrite()</p><p>{</p><p>char szBuf[] = “Bingo Bingo”;</p><p><em>DWORD</em> dwWrite;</p><p>if (!<em>WriteFile</em>(hWriteCliPipe, szBuf, <em>strlen</em>(szBuf) + 1, &amp;dwWrite, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“写入数据失败”));</p><p>​ <em>CloseHandle</em>(hWriteCliPipe);</p><p>​ return;</p><p>}</p><p><em>CloseHandle</em>(hWriteCliPipe);</p><p>}</p><h3 id="16-7-进程间通信方式之命名管道"><a href="#16-7-进程间通信方式之命名管道" class="headerlink" title="16.7 进程间通信方式之命名管道"></a>16.7 进程间通信方式之命名管道</h3><p>Socket 相似 支持网络之间不同进程的通信</p><p><em>CreateN<strong>ame</strong>dPipe</em></p><p>HANDLE CreateNamedPipeA(</p><p>LPCSTR lpName, // .\pipe<i>pipename</i></p><p>DWORD dwOpenMode,</p><p>DWORD dwPipeMode,</p><p>DWORD nMaxInstances,</p><p>DWORD nOutBufferSize,</p><p>DWORD nInBufferSize,</p><p>DWORD nDefaultTimeOut,</p><p>LPSECURITY_ATTRIBUTES lpSecurityAttributes</p><p>);</p><p>等待连接</p><p>BOOL ConnectNamedPipe(</p><p>HANDLE hNamedPipe,</p><p>LPOVERLAPPED lpOverlapped</p><p>);</p><p><em>WaitNamedPipe</em>(szNamedPipeName, <em>NMPWAIT_WAIT_FOREVER</em>)</p><p>客户端</p><p>void CChildView::OnConnectNamedPipe()</p><p>{</p><p><em>LPCTSTR</em> szNamedPipeName = <em>TEXT</em>(“\\.\pipe\mypipe”);</p><p>if (0 == <em>WaitNamedPipe</em>(szNamedPipeName, <em>NMPWAIT_WAIT_FOREVER</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“当前没有可以利用的管道”));</p><p>​ return;</p><p>}</p><p>hNamedPipe =</p><p>​ <em>CreateFile</em>(szNamedPipeName, <em>GENERIC_READ</em> | <em>GENERIC_WRITE</em>,</p><p>​ 0, <em>NULL</em>, <em>OPEN_EXISTING</em>, <em>FILE_ATTRIBUTE_NORMAL</em>, <em>NULL</em>);</p><p>if (hNamedPipe == <em>INVALID_HANDLE_VALUE</em>)</p><p>{</p><p>​ <em>TRACE</em>(“CreateFile failed with %d\n”, <em>GetLastError</em>());</p><p>​ <em>MessageBox</em>(<em>_T</em>(“打开命名管道失败！”));</p><p>​ hNamedPipe = <em>NULL</em>;</p><p>​ return;</p><p>}</p><p>}</p><p>void CChildView::OnReadNamedPipe()</p><p>{</p><p>char szBuf[100] = { 0 };</p><p><em>DWORD</em> dwRead;</p><p>if (!<em>ReadFile</em>(hNamedPipe, szBuf, 100, &amp;dwRead, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“读取数据失败”));</p><p>​ return;</p><p>}</p><p><em>MessageBox</em>((<em>CStringW</em>)szBuf);</p><p>}</p><p>void CChildView::OnWriteNamedPipe()</p><p>{</p><p>char szBuf[] = “NAMEDPIPE CLIENT”;</p><p><em>DWORD</em> dwWrite;</p><p>if (!<em>WriteFile</em>(hNamedPipe, szBuf, <em>strlen</em>(szBuf) + 1, &amp;dwWrite, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“写入数据失败”));</p><p>​ <em>CloseHandle</em>(hWriteCliPipe);</p><p>​ return;</p><p>}</p><p><em>CloseHandle</em>(hWriteCliPipe);</p><p>}</p><p>服务端</p><p>void CChildView::OnCreateNamedPipe()</p><p>{</p><p>//1 创建一个命名管道</p><p><em>LPCTSTR</em> szPipeName = <em>TEXT</em>(“\\.\pipe\mypipe”);</p><p>hNamedPipe = <em>CreateNamedPipe</em>(szPipeName,<em>PIPE_ACCESS_DUPLEX</em> | <em>FILE_FLAG_OVERLAPPED</em>,</p><p>​ <em>PIPE_TYPE_BYTE</em>, 1, 1024, 1024, 0, <em>NULL</em>);</p><p>if (hNamedPipe == <em>INVALID_HANDLE_VALUE</em>)</p><p>{</p><p>​ <em>TRACE</em>(“CreateNamedhPipe failed with %d\n”, <em>GetLastError</em>());</p><p>​ <em>MessageBox</em>(<em>_T</em>(“创建命名管道失败”));</p><p>​ return;</p><p>}</p><p>// 2 等待客户端的连接</p><p><em>HANDLE</em> hEvent = <em>CreateEvent</em>(<em>NULL</em>, <em>TRUE</em>, <em>FALSE</em>, <em>NULL</em>);</p><p>if (<em>NULL</em> == hEvent)</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“创建事件失败”));</p><p>​ <em>CloseHandle</em>(hNamedPipe);</p><p>​ hNamedPipe = <em>NULL</em>;</p><p>​ return;</p><p>}</p><p><em>OVERLAPPED</em> ovlap;</p><p><em>ZeroMemory</em>(&amp;ovlap, sizeof(<em>OVERLAPPED</em>));</p><p>ovlap.<em>hEvent</em> = hEvent;</p><p>//等待连接</p><p>if (!<em>ConnectNamedPipe</em>(hNamedPipe, &amp;ovlap))</p><p>{</p><p>​ if (<em>ERROR_IO_PENDING</em> != <em>GetLastError</em>())</p><p>​ {</p><p>​ <em>MessageBox</em>(<em>_T</em>(“等待客户端连接失败”));</p><p>​ <em>CloseHandle</em>(hNamedPipe);</p><p>​ <em>CloseHandle</em>(hEvent);</p><p>​ hNamedPipe = <em>NULL</em>;</p><p>​ hEvent = <em>NULL</em>;</p><p>​ return;</p><p>​ }</p><p>}</p><p>if (<em>WaitForSingleObject</em>(hEvent,<em>INFINITE</em>) == <em>WAIT_FAILED</em>)</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“等待对象失败”));</p><p>​ <em>CloseHandle</em>(hNamedPipe);</p><p>​ <em>CloseHandle</em>(hEvent);</p><p>​ hNamedPipe = <em>NULL</em>;</p><p>​ hEvent = <em>NULL</em>;</p><p>​ return;</p><p>}</p><p>}</p><p>void CChildView::OnSreadNamedPipe()</p><p>{</p><p>char szBuf[100] = { 0 };</p><p><em>DWORD</em> dwRead;</p><p>if (!<em>ReadFile</em>(hNamedPipe, szBuf, 100, &amp;dwRead, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“读取数据失败”));</p><p>​ return;</p><p>}</p><p><em>MessageBox</em>((<em>CStringW</em>)szBuf);</p><p>}</p><p>void CChildView::OnSwriteNamedpipe()</p><p>{</p><p>//写入数据</p><p>char szBuf[] = “OnNamedPipe Server”;</p><p><em>DWORD</em> dwWrite;</p><p>if (!<em>WriteFile</em>(hNamedPipe, szBuf, <em>strlen</em>(szBuf) + 1, &amp;dwWrite, <em>NULL</em>))</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“写入数据失败”));</p><p>​ return;</p><p>}</p><p>}</p><h3 id="16-8-进程间通信方式之WM-COPYDATA"><a href="#16-8-进程间通信方式之WM-COPYDATA" class="headerlink" title="16.8 进程间通信方式之WM_COPYDATA"></a>16.8 进程间通信方式之WM_COPYDATA</h3><p>WM_COPYDATA</p><p><em>wParam</em></p><p>传递数据的窗口的句柄。</p><p><em>帕拉姆</em></p><p>指向<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-copydatastruct"><strong>COPYDATASTRUCT</strong></a>结构的指针，该结构包含要传递的数据。</p><p>如果接收方应用程序处理此消息，则应返回<strong>TRUE</strong>；否则，应返回<strong>FALSE</strong>。</p><p>SPY++工具 专门用来查找窗口句柄</p><p>要给进程发数据，首先要拿到进程的窗口句柄，也就必须先拿到标题。</p><p>发送端</p><p>void CWMCOPYDATASENDDlg::OnBnClickedSend()</p><p>{</p><p>// 必须要知道标题 句柄</p><p><em>CString</em> strWindowTitle = <em>_T</em>(“MFCRecv”);</p><p><em>CString</em> strDataToSend = <em>_T</em>(“Hello ,this is Bingo WM_COPYDATA”);</p><p>//句柄</p><p><em>HWND</em> hRecvWnd = ::<em>FindWindow</em>(<em>NULL</em>, strWindowTitle.<em>GetBuffer</em>(0));</p><p>if (hRecvWnd != <em>NULL</em> &amp;&amp; ::<em>IsWindow</em>(hRecvWnd))</p><p>{</p><p>​ //数据的封装</p><p>​ <em>COPYDATASTRUCT</em> cpd;</p><p>​ cpd.<em>dwData</em> = 0;</p><p>​ cpd.<em>cbData</em> = strDataToSend.<em>GetLength</em>() * sizeof(<em>TCHAR</em>);</p><p>​ cpd.<em>lpData</em> = (<em>PVOID</em>)strDataToSend.<em>GetBuffer</em>(0);</p><p>​ ::<em>SendMessage</em>(hRecvWnd, <em>WM_COPYDATA</em>, (<em>WPARAM</em>)(<em>AfxGetApp</em>()-&gt;<em>m_pMainWnd</em>),(<em>LPARAM</em>)&amp;cpd);</p><p>}</p><p>strDataToSend.<em>ReleaseBuffer</em>();</p><p>}</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image106.jpg" alt="img"></p><p>接收端</p><p><em>BOOL</em> CWMCOPYDATADlg::OnCopyData(<em>CWnd** pWnd, <em>COPYDATASTRUCT</em></em> pCopyDataStruct)</p><p>{</p><p>//消息响应函数</p><p>//解析数据</p><p><em>LPCTSTR</em> szText = (<em>LPCTSTR</em>)(pCopyDataStruct-&gt;<em>lpData</em>);</p><p><em>DWORD</em> dwLength = (<em>DWORD</em>)pCopyDataStruct-&gt;<em>cbData</em>;</p><p><em>TCHAR</em> szRecvText[1024] = { 0 };</p><p><em>memcpy</em>(szRecvText, szText, dwLength);</p><p><em>MessageBox</em>(szRecvText, <em>_T</em>(“Bingo”), <em>MB_OK</em>);</p><p>return <em>CDialogEx</em>::<em>OnCopyData</em>(pWnd, pCopyDataStruct);</p><p>}</p><h3 id="16-9-进程间通信方式的比较"><a href="#16-9-进程间通信方式的比较" class="headerlink" title="16.9 进程间通信方式的比较"></a>16.9 进程间通信方式的比较</h3><p>剪贴板比较简单。剪切板和匿名管道只能实现同一机器的两个进程通信，而不能实现网络进程之间的通信。</p><p>邮槽是基于广播的，可以一对多发送。但只能一个发送，一个接收，要想同时发送接收，须写两次代码。邮槽的缺点传输的数据量很小 424字节以下。</p><p>命名管道和邮槽可以进行网络通信。命名管道只能是点对点的单一通信。</p><p>WM_COPY_DATA 封装数据和解析数据。非常方便。如果数据量大，建议用命名管道。</p><h2 id="17-动态链接库"><a href="#17-动态链接库" class="headerlink" title="17 动态链接库"></a>17 动态链接库</h2><h3 id="17-1-动态链接库的概述"><a href="#17-1-动态链接库的概述" class="headerlink" title="17.1 动态链接库的概述"></a>17.1 动态链接库的概述</h3><p>DLL就是整个windows操作系统的基础。动态链接库不能直接运行，也不能接收消息。他们是一些独立的文件。</p><p>Windows API中的所有函数都包含在DLL中。</p><p>其中有三个最重要的DLL</p><p>Kernel32.dll,它包含用于管理内存、进程和线程的各个函数；CreateThread</p><p>User32.dll，它包含用于执行用户界面任务（如窗口的创建和消息的传送）的各个函数；</p><p>GDI32.dll，它包含用于画图和显示文本的各个函数。</p><p>Windbg</p><p>静态库和动态库</p><p>静态库：函数和数据被编译进一个二进制文件（通常扩展名为.LIB）。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件（.EXE文件）；</p><p>在使用动态库的时候，往往提供两个文件：一个因入库和一个DLL。因入库包含被DLL导出的函数和变量的符号名，DLL包含实际的函数和数据。在编译链接可执行文件时，只需要链接引入库，DLL中的函数代码和数据并不复制到可执行文件中，在运行时候，再去加载DLL，访问DLL中导出的函数。</p><p>使用动态链接库的好处</p><p>1 增强产品的功能。（更换界面的DLL）换皮肤</p><p>2 提供二次开发的平台。（SDK 基础版本）</p><p>3 简化项目管理 （串行开发，以多个DLL的方式实现）</p><p>4 可以节省磁盘空间和内存。</p><p>5 有助于资源的共享。（对话框模板，字符串，图标）</p><p>6 有助于实现应用程序的本地化。（多语言版本）</p><p>7 可以采用多种编程语言来编写。</p><p>VB delphi写界面，然后调用MFC编写 的DLL来完成业务开发</p><h3 id="17-2-DLL的创建和使用"><a href="#17-2-DLL的创建和使用" class="headerlink" title="17.2 DLL的创建和使用"></a>17.2 DLL的创建和使用</h3><p>1 隐式链接</p><p>Lib，导入</p><p>2 显示加载</p><p>DumpBin命令</p><p>建立DLL文件代码如下:</p><p>_declspec(dllexport) int Add(int x,int y)</p><p>{</p><p>return x+y;</p><p>}</p><p>_declspec(dllexport) int Subtract(int x,int y)</p><p>{</p><p>return x-y;</p><p>}</p><p>//必须带_declspec(dllexport)文件,以生成*.lib文件</p><p>如果要查找*dll中包含信息，可在命令行下进入Debug所在目录，输入以下命令</p><p>dumpbin -exports dll.dll</p><p>有些时候由于某种安装原因，dumpbin被认为是无效命令，接下来在</p><p>C:\Program Files\Microsoft Visual Studio\VC14\Bin\下找到VCVARS32.bat并在命令行运行，之后就能执行dumpbin命令了。</p><p>名字改编 === 名字粉碎</p><p>在exe运行的时候，系统将为exe分配一个4GB的地址空间，然后加载模块会分析该应用程序的输入信息，从中找到该程序将要访问的动态链接库信息。然后在用户机器上搜索这些动态链接库。</p><p>新建MFC程序，新建两个按钮，代码如下：</p><p>void CDllTestDlg::OnBtnAdd()</p><p>{</p><p>// TODO: Add your control notification handler code here</p><p>CString str;</p><p>str.Format(“4+3=&amp;d”,Add(4,3));</p><p>MessageBox(str);</p><p>}</p><p>void CDllTestDlg::OnBtnSubtract()</p><p>{</p><p>// TODO: Add your control notification handler code here</p><p>CString str;</p><p>str.Format(“4-3=%d”,Subtract(4,3));</p><p>MessageBox(str);</p><p>}</p><p>为使编译器认识Add，Subtract，必须在之前使用两个声明：</p><p>extern int Add(int x,int y);</p><p>extern int Subtract(int x,int y);</p><p>可以使用标示符表示这两个函数是从动态链接库的.lib文件引用的，以生成效率更高的代码</p><p>_declspec(dllimport) int Add(int x,int y);</p><p>_declspec(dllimport) int Subtract(int x,int y);</p><p>这两段代码我们也可以在DLL中新建一个头文件放进去，并在MFC程序中添加头文件</p><p>如#include “..\Dll\Dll.h”</p><p>从原先Dll文件下Debug目录中复制*.lib到MFC程序文件夹下，并添加库函数</p><p>在project—&gt;setting—&gt;link—&gt;Object/Library Modules写下所复制的文件名</p><p>如果要查看DllTest.exe文件信息，使用命令行dumpbin -imports dlltest.exe</p><h3 id="17-3-DLL的导入和导出以及条件编译"><a href="#17-3-DLL的导入和导出以及条件编译" class="headerlink" title="17.3 DLL的导入和导出以及条件编译"></a>17.3 DLL的导入和导出以及条件编译</h3><p>与使用extern关键字这种方式对比，使用_declspec(dllimport)</p><p>的标识符，他将告诉编译器是从动态链接库引入的。。</p><p>_declspec(dllexport) 是在类、函数以及数据的声明的时候使用。把dll里面的相关代码暴露出来给其他应用程序使用。提供给别的应用程序使用。表示提供者。供dll内部使用</p><p>_declspec(dllimport)是在外部程序需要使用DLL内相关内容使用的标识符。是把dll中的相关代码插入到应用程序中去。表示使用者。不是dll内部使用。</p><p>DLL实现之后，交给客户程序。Dumpbin。</p><p>DLL的实现者和使用者不是同一个人。</p><p>方案：dll + 头文件的方式</p><p>头文件：建议使用条件指令编译。使得程序的可读性增强，灵活性增强。</p><h3 id="17-4-从DLL中导出C-类"><a href="#17-4-从DLL中导出C-类" class="headerlink" title="17.4 从DLL中导出C++类"></a>17.4 从DLL中导出C++类</h3><p>动态链接库导出整个类和仅导出该类的某些成员函数在实现方式的区别：</p><p>如果在声明类时，指定了导出标志，那么该类中所有的函数都被导出；</p><p>否则只有那些声明时指定了的导出标志的类成员函数才被导出。</p><p>DLL1.CPP</p><p>void Point::output(int x, int y)</p><p>{</p><p>//返回调用者进程当前使用的窗口</p><p><em>HWND</em> hWnd = <em>GetForegroundWindow</em>();</p><p>//获取DC</p><p><em>HDC</em> hdc = <em>GetDC</em>(hWnd);</p><p>char buf[32] = {0};</p><p><em>sprintf_s</em>(buf, “x = %d, y = %d”, x, y);</p><p>//输出坐标</p><p><em>TextOutA</em>(hdc, 0, 0, buf, <em>strlen</em>(buf));</p><p>//释放DC</p><p><em>ReleaseDC</em>(hWnd, hdc);</p><p>}</p><p>void Point::test()</p><p>{</p><p>int x = 1, y = 2;</p><p>//返回调用者进程当前使用的窗口</p><p><em>HWND</em> hWnd = <em>GetForegroundWindow</em>();</p><p>//获取DC</p><p><em>HDC</em> hdc = <em>GetDC</em>(hWnd);</p><p>char buf[32] = { 0 };</p><p><em>sprintf_s</em>(buf, “x = %d, y = %d”, x, y);</p><p>//输出坐标</p><p><em>TextOutA</em>(hdc, 50, 50, buf, <em>strlen</em>(buf));</p><p>//释放DC</p><p><em>ReleaseDC</em>(hWnd, hdc);</p><p>}</p><p>DLL1.h</p><p>// class DLL1_API Point</p><p>// {</p><p>// public:</p><p>// void output(int x, int y);</p><p>// };</p><p>class DLL1_API Point</p><p>{</p><p>public:</p><p>void output(int x, int y);</p><p>void test();</p><p>};</p><h3 id="17-5-解决名字改编的问题"><a href="#17-5-解决名字改编的问题" class="headerlink" title="17.5 解决名字改编的问题"></a>17.5 解决名字改编的问题</h3><p>用C++写了一个DLL，如果眼红C语言编写客户端</p><p>我们希望dll在编译时，导出函数的名称不要发生改编。</p><p>extern “C”</p><p>因为C++导出或导入动态链接库会发生名字的改编，如果不想发生名字改编，我们可以使用如下代码：</p><p>#define DLL_API extern “c” _declspec(dllexport)</p><p>编译器就不会进行名字改编，一个用C语言编写的客户端程序可以调用C++的Dll。其缺点就是不能导出一个类的成员函数，只能用于导出全局函数这种情况。</p><p>_stdcall 标准的调用约定 C/C++ MFC</p><p>Delphi pascal的从左至右的压栈方式</p><p>C/C++的DLL给delphi使用</p><p>接下来新建一个动态链接库文件，文件名为Dll2，cpp文件代码为：</p><p>#include “pch.h”</p><p>int _stdcall add(int x, int y)</p><p>{</p><p>return x + y;</p><p>}</p><p>int _stdcall(int x, int y)</p><p>{</p><p>return x - y;</p><p>}</p><p>为了最终解决问题，我们可以新建一个模块文件Dll.def，以使得其他语言编制的程序也能使用我们的动态链接库。</p><p>添加代码</p><p>LIBRARY BingoDll2</p><p>EXPORTS //即使调用_stdcall约定，也不会发生改编，而只会调用这里显示的Add //字符串</p><p>Subtract</p><p>EXPORTS 语句引入了一个由一个或多个 definitions（导出的函数或数据）组成的节。每个定义必须在单独一行上。EXPORTS 关键字可以在第一个定义所在的同一行上或在前一行上。.def 文件可以包含一个或多个 EXPORTS 语句。</p><p>当DLL中导出函数采用的是标准调用约定时，访问该dll的客户端程序也应该采用该约定类型来访问相应的导出函数。</p><p>导出 definitions 的语法为：</p><p>entryname[=internalname] [@ordinal [NONAME]] [PRIVATE] [DATA]</p><p>entryname 是要导出的函数名或变量名。这是必选项。如果导出的名称与 DLL 中的名称不同，则通过 internalname 指定 DLL 中导出的名称。例如，如果 DLL 导出函数 func1()，要将它用作 func2()，则应指定：</p><p>EXPORTS</p><p>func2=func1</p><p>@ordinal 允许指定是序号而不是函数名将进入 DLL 的导出表。这有助于最小化 DLL 的大小。.LIB 文件将包含序号与函数之间的映射，这使您得以像通常在使用 DLL 的项目中那样使用函数名。</p><p>可选的 NONAME 关键字允许只按序号导出，并减小结果 DLL 中导出表的大小。但是，如果要在 DLL 上使用 GetProcAddress，则必须知道序号，因为名称将无效。</p><p>可选的 DATA 关键字指定导出的是数据，而不是代码。例如，可以导出数据变量，如下所示：</p><p>EXPORTS</p><p>i DATA</p><h3 id="17-6-显示（动态）加载方式加载DLL"><a href="#17-6-显示（动态）加载方式加载DLL" class="headerlink" title="17.6 显示（动态）加载方式加载DLL"></a>17.6 显示（动态）加载方式加载DLL</h3><p>LoadLibrary函数 动态加载库</p><p>//1 动态加载dll</p><p><em>HINSTANCE</em> hInst = <em>LoadLibraryA</em>(“BingoDll2.dll”);</p><p>//2 声明要加载的函数 定义函数指针类型</p><p>typedef int (_stdcall *ADDPROC)(int <em>a</em>, int <em>b</em>);</p><p>//3 从DLL获取函数的地址 A 通过导出函数的实际函数名 B通过序号访问DLL的导出函数</p><p>ADDPROC Add = (ADDPROC)<em>GetProcAddress</em>(hInst, “add”);</p><p>//ADDPROC Add = (ADDPROC)GetProcAddress(hInst, “?Add@@YAHHH@Z”);</p><p>//ADDPROC Add = (ADDPROC)GetProcAddress(hInst, MAKEINTRESOURCEA(1));</p><p>if (!Add)</p><p>{</p><p>​ <em>MessageBox</em>(<em>_T</em>(“获取函数地址失败”));</p><p>​ <em>TRACE</em>(“GetProcAddress errorcode = %d”, <em>GetLastError</em>);</p><p>​ return;</p><p>}</p><p>// 4 调用函数</p><p><em>CString</em> str;</p><p>str.<em>Format</em>(L”4+3 = %d”, Add(4, 3));</p><p><em>MessageBox</em>(str);</p><p><em>FreeLibrary</em>(hInst);</p><p>因为调用LoadLibrary时动态加载动态链接库，所以不需要头文件和.lib文件</p><p>如果我们在动态链接库中使用标准调用约定_stdcall，而在可执行程序中使用动态加载DLL，会发生名字重编，如果知道DLL中函数的序号，这时可以使用宏MAKEINTRESOURCE把序号转变成名字，如：</p><p>ADDPROC Add=(ADDPROC)GetProcAddress(hInst,MAKEINTRESOURCE（1）)；</p><h3 id="17-7-DLLMain函数"><a href="#17-7-DLLMain函数" class="headerlink" title="17.7 DLLMain函数"></a>17.7 DLLMain函数</h3><p>DllMain</p><p>//对可执行模块，入口函数winmain dll dllmain</p><p>//HMODULE hModule 表示动态链接可以的模块句柄，</p><p>//当Dll初次被加载的时候，句柄可以通过这个参数传递进来</p><p>//如果某些函数需要用到当前DLL模块的句柄，那么就可以为该DLL提供dllmain函数</p><p>//然后通过参数，保存在一个全局变量里面，以供其他函数使用</p><p>//</p><p><em>BOOL</em> <em>APIENTRY</em> <em>DllMain</em>( <em>HMODULE</em> hModule,</p><p>​ <em>DWORD</em> ul_reason_for_call,</p><p>​ <em>LPVOID</em> lpReserved</p><p>​ )</p><p>{</p><p>switch (ul_reason_for_call)</p><p>{</p><p>case <em>DLL_PROCESS_ATTACH</em>://进程第一次加载DLL并调用Dllmain函数</p><p>case <em>DLL_THREAD_ATTACH</em>://当前进程正创建一个新线程</p><p>case <em>DLL_THREAD_DETACH</em>://线程结束</p><p>case <em>DLL_PROCESS_DETACH</em>://进程结束</p><p>​ break;</p><p>}</p><p>return <em>TRUE</em>;</p><p>}</p><p>Def文件 dll导出函数或者符号</p><p>静态库和动态库的区别</p><p>加载dll的两种方式：隐式连接和动态加载以及具体实现</p><p>Dll导出函数的名字便便问题以及解决办法 def文件</p><p>Dllmain函数的作用</p><p>Dumpbin命令和工具使用</p><h2 id="18-MFC文件和注册表的操作"><a href="#18-MFC文件和注册表的操作" class="headerlink" title="18  MFC文件和注册表的操作"></a>18 MFC文件和注册表的操作</h2><p>日志、操作配置文件、ini、注册表、音视频的文件存储。</p><p>Linux下一切皆文件</p><h3 id="18-1-C-C-操作文件"><a href="#18-1-C-C-操作文件" class="headerlink" title="18.1 C/C++操作文件"></a>18.1 C/C++操作文件</h3><h4 id="18-1-1-const-char-与-char-const"><a href="#18-1-1-const-char-与-char-const" class="headerlink" title="18.1.1  const char* 与 char *const"></a>18.1.1 const char* 与 char *const</h4><p>const char * 常量指针,表示指向的内容为常量。指针可以指向其他变量，但是内容不能变了。</p><p>char *const == const char *</p><p>char szName[6] = “Bingo”;</p><p>const char * pName = szName;</p><p>*pName = ‘b’; 错误</p><p>char szName[6] = “Bingo”;</p><p>char * const pName = szName;</p><p>char *p;</p><p>pName = p; 错误</p><p>*pName = ‘b’; 正确</p><p>表示pName是指针常量；表示地址是常量。不能再变了。但是内容可以改变</p><h4 id="18-1-2-C语言操作文件"><a href="#18-1-2-C语言操作文件" class="headerlink" title="18.1.2  C语言操作文件"></a>18.1.2 C语言操作文件</h4><p><em>fopen</em>(</p><p>​ <em>_In_z_</em> char const* _FileName,</p><p>​ <em>_In_z_</em> char const* _Mode</p><p>​ );</p><p><em>errno_t</em> __cdecl <em>fopen_s</em>(</p><p>​ <em><em>Outptr_result_maybenull</em></em> <em>FILE**</em> _Stream,</p><p>​ <em>_In_z_</em> char const* _FileName,</p><p>​ <em>_In_z_</em> char const* _Mode</p><p>​ );</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image108.jpg" alt="img"></p><p><em>size_t</em> __cdecl <em>fwrite</em>(</p><p>​ <em><em>In_reads_bytes</em></em>(_ElementSize * _ElementCount) void const* _Buffer,</p><p>​ <em><em>In</em></em> <em>size_t</em> _ElementSize,</p><p>​ <em><em>In</em></em> <em>size_t</em> _ElementCount,</p><p>​ <em><em>Inout</em></em> *FILE** _Stream</p><p>​ );</p><p>宽字节而言 wchar a[20] = “Bingo”;</p><p>ANSI char a[20] = “Bingo”;</p><p><em>fseek</em>(</p><p>​ <em><em>Inout</em></em> *FILE** _Stream, //指向FILE结构体指针</p><p>​ <em><em>In</em></em> long _Offset, //偏移量</p><p>​ <em><em>In</em></em> int _Origin//指定文件指针的起始位置 //SEEK_CUR 当前位置</p><p>//SEEK_END 文件结尾位置 SEEK_SET 文件开始位置</p><p>​ );</p><p><em>Ftell</em> <em>返回文件指针的当前位置</em></p><h4 id="18-1-3-C-操作文件"><a href="#18-1-3-C-操作文件" class="headerlink" title="18.1.3  C++操作文件"></a>18.1.3 C++操作文件</h4><p><em>Ofstream**类</em></p><p>(const char* _Filename, <em>ios_base</em>::<em>openmode</em> _Mode = <em>ios_base</em>::<em>out</em>,</p><p>​ int _Prot = <em>ios_base</em>::<em>_Default_open_prot</em>)</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image110.jpg" alt="img"></p><p>nPort</p><p><img src="file:///C:/Users/Stell/AppData/Local/Temp/msohtmlclip1/01/clip_image112.jpg" alt="img"></p><p><em>读文件</em></p><p><em>ifstream</em> ifs(“2.txt”);</p><p>char pBuf[100] = { 0 };</p><p>ifs.<em>read</em>(pBuf, 100);</p><p>ifs.<em>close</em>();</p><p><em>USES_CONVERSION</em>;</p><p><em>CString</em> strBuf = <em>A2W</em>(pBuf);</p><p><em>MessageBox</em>(strBuf);</p><p><em>写文件</em></p><p>ofstream ofs(“2.txt”);//第一个参数表示文件名，2 打开的方式，</p><p>ofs.write(“BingoC++”, strlen(“BingoC++”));</p><p>ofs.close();</p><h3 id="18-2-Win32-API-MFC操作文件"><a href="#18-2-Win32-API-MFC操作文件" class="headerlink" title="18.2 Win32 API/MFC操作文件"></a>18.2 Win32 API/MFC操作文件</h3><h4 id="18-2-1-Win32-API操作文件"><a href="#18-2-1-Win32-API操作文件" class="headerlink" title="18.2.1  Win32 API操作文件"></a>18.2.1 Win32 API操作文件</h4><p>CreateFile</p><p>文件 管道 油槽 通信资源 磁盘设备 控制台 目录</p><p>CreateFileW(</p><p>​ <em><em>In</em></em> <em>LPCWSTR</em> <em>lpFileName</em>,//创建或打开的对象的名称</p><p>​ <em><em>In</em></em> <em>DWORD</em> dwDesiredAccess,//访问方式 读，读-写 写 查询 0 GENERIC_READ GENERIC_WRITE</p><p>​ <em><em>In</em></em> <em>DWORD</em> <em>dwShareMode</em>,//共享方式 0</p><p>​ <em>_In_opt_</em> <em>LPSECURITY_ATTRIBUTES</em> <em>lpSecurityAttributes</em>,//NULL 不能被子进程继承</p><p>​ <em><em>In</em></em> <em>DWORD</em> dwCreationDisposition,//如何创建文件 CREATE_NEW CREATE_ALWAYS</p><p>​ <em><em>In</em></em> <em>DWORD</em> dwFlagsAndAttributes,//设置文件的属性和标志</p><p>​ <em>_In_opt_</em> <em>HANDLE</em> <em>hTemplateFile</em>//NULL</p><p>);</p><p><em>BOOL</em> <em>WriteFile</em>(</p><p>​ <em>HANDLE</em> hFile,</p><p>​ <em>LPCVOID</em> lpBuffer,</p><p>​ <em>DWORD</em> nNumberOfBytesToWrite,//要写入的字节数</p><p>​ <em>LPDWORD</em> lpNumberOfBytesWritten, //用来接收实际写入到文件的字节数</p><p>​ <em>LPOVERLAPPED</em> <em>lpOverlapped</em></p><p>);</p><p>//windows API的写文件</p><p><em>HANDLE</em> hFile;</p><p>hFile = <em>CreateFile</em>(<em>_T</em>(“3.txt”), <em>GENERIC_WRITE</em>, 0, <em>NULL</em>,</p><p>​ <em>CREATE_NEW</em>, <em>FILE_ATTRIBUTE_NORMAL</em>, <em>NULL</em>);</p><p>if (hFile == <em>INVALID_HANDLE_VALUE</em>)</p><p>{</p><p>​ <em>TRACE</em>(“INVALID_HANDLE_VALUE,ERRORCODE = %d”,<em>GetLastError</em>());</p><p>​ return;</p><p>}</p><p><em>DWORD</em> dwWrites;</p><p><em>WriteFile</em>(hFile, “BingoWin32API”, <em>strlen</em>(“BingoWin32API”), &amp;dwWrites, <em>NULL</em>);</p><p><em>TRACE</em>(“##dwWrites = %d”, dwWrites);</p><p><em>CloseHandle</em>(hFile);</p><p>//windows API的读文件</p><p><em>HANDLE</em> hFile;</p><p>hFile = <em>CreateFile</em>(<em>_T</em>(“3.txt”), <em>GENERIC_READ</em>, 0, <em>NULL</em>,</p><p><em>OPEN_EXISTING</em>, <em>FILE_ATTRIBUTE_NORMAL</em>, <em>NULL</em>);</p><p>char pBuf[100] = {0};</p><p><em>DWORD</em> dwReads;</p><p><em>ReadFile</em>(hFile, pBuf, 100, &amp;dwReads, <em>NULL</em>);</p><p><em>TRACE</em>(“##dwReads = %d”, dwReads);</p><p><em>CloseHandle</em>(hFile);</p><h4 id="18-2-2-MFC操作文件"><a href="#18-2-2-MFC操作文件" class="headerlink" title="18.2.2  MFC操作文件"></a>18.2.2 MFC操作文件</h4><p>//MFC的读文件</p><p><em>CFile</em> file(L”4.txt”, <em>CFile</em>::<em>modeRead</em> );</p><p>char* pBuf;</p><p><em>DWORD</em> dwFileLen = file.<em>GetLength</em>();</p><p>pBuf = new char[dwFileLen + 1];</p><p>pBuf[dwFileLen] = 0;</p><p>file.<em>Read</em>(pBuf, dwFileLen);</p><p>file.<em>Close</em>();</p><p><em>USES_CONVERSION</em>;</p><p><em>CString</em> strBuf = <em>A2W</em>(pBuf);</p><p><em>MessageBox</em>(strBuf);</p><p>//MFC的写文件</p><p><em>CFile</em> file(L”4.txt”,<em>CFile</em>::<em>modeCreate</em> | <em>CFile</em>::<em>modeWrite</em>);</p><p>file.<em>Write</em>(“BingoMFC”, <em>strlen</em>(“BingoMFC”));</p><p>file.<em>Close</em>();</p><p><em>CFileDialog -&gt; CCommonDialog -&gt; CDialog-&gt; CWnd -&gt; CCmdTarget -&gt; CObject</em></p><p><em>CFileDialog</em>(<em>BOOL</em> bOpenFileDialog, // TRUE 构建一个打开的对话框 FALSE 构建一个保存对话框</p><p>​ <em>LPCTSTR</em> lpszDefExt = <em>NULL</em>, //指定默认的文件扩展名 NULL</p><p>​ <em>LPCTSTR</em> <em>lpszFileName</em> = <em>NULL</em>, //初始文件名 NULL 默认没有初始文件名</p><p>​ <em>DWORD</em> <em>dwFlags</em> = <em>OFN_HIDEREADONLY</em> | <em>OFN_OVERWRITEPROMPT</em>,</p><p>​ <em>LPCTSTR</em> lpszFilter = <em>NULL</em>, //用来指定一个或一组文件的过滤器</p><p>​ <em>CWnd</em> * pParentWnd = <em>NULL</em>,//用来指定文件对话框的父窗口或者拥有窗口</p><p>​ <em>DWORD</em> <em>dwSize</em> = 0, //大小</p><p>​ <em>BOOL</em> bVistaStyle = <em>TRUE</em>);//可见或者不可见</p><p>读：</p><p>// CFile file(L”4.txt”, CFile::modeRead );</p><p>// char* pBuf;</p><p>// DWORD dwFileLen = file.GetLength();</p><p>// pBuf = new char[dwFileLen + 1];</p><p>// pBuf[dwFileLen] = 0;</p><p>// file.Read(pBuf, dwFileLen);</p><p>// file.Close();</p><p>// USES_CONVERSION;</p><p>// CString strBuf = A2W(pBuf);</p><p>// MessageBox(strBuf);</p><p><em>CFileDialog</em> fileDlg(<em>TRUE</em>);</p><p>fileDlg.<em>m_ofn</em>.<em>lpstrTitle</em> = L”Bingo”;</p><p>fileDlg.<em>m_ofn</em>.<em>lpstrFilter</em> = <em>_T</em>(“Text Files(<em>.txt)\0</em>.txt\0All Files(<em>.</em>)\0*.*\0\0”);</p><p>if (<em>IDOK</em> == fileDlg.<em>DoModal</em>())</p><p>{</p><p>​ <em>CFile</em> file(fileDlg.<em>GetFileName</em>(), <em>CFile</em>::<em>modeRead</em>);</p><p>​ char* pBuf;</p><p>​ <em>DWORD</em> dwFileLen = file.<em>GetLength</em>();</p><p>​ pBuf = new char[dwFileLen + 1];</p><p>​ pBuf[dwFileLen] = 0;</p><p>​ file.<em>Read</em>(pBuf, dwFileLen);</p><p>​ file.<em>Close</em>();</p><p>​ <em>USES_CONVERSION</em>;</p><p>​ <em>CString</em> strBuf = <em>A2W</em>(pBuf);</p><p>​ <em>MessageBox</em>(strBuf);</p><p>}</p><p>写：</p><p><em>CFileDialog</em> fileDlg(<em>FALSE</em>);</p><p>fileDlg.<em>m_ofn</em>.<em>lpstrTitle</em> = L”Bingo”;</p><p>fileDlg.<em>m_ofn</em>.<em>lpstrFilter</em> = <em>_T</em>(“Text Files(<em>.txt)\0</em>.txt\0All Files(<em>.</em>)\0*.*\0\0”);</p><p>fileDlg.<em>m_ofn</em>.<em>lpstrDefExt</em> = L”txt”;</p><p>if (<em>IDOK</em> == fileDlg.<em>DoModal</em>())</p><p>{</p><p>​ <em>CFile</em> file(fileDlg.<em>GetFileName</em>(),<em>CFile</em>::<em>modeCreate</em> | <em>CFile</em>::<em>modeWrite</em>);</p><p>​ <em>USES_CONVERSION</em>;</p><p>​ char* szBuf = <em>T2A</em>(fileDlg.<em>GetFileName</em>());</p><p>​ <em>TRACE</em>(“###fileDlg.GetFileName() = %s”, szBuf);</p><p>​ file.<em>Write</em>(“BingoMFC111”, <em>strlen</em>(“BingoMFC111”));</p><p>​ file.<em>Close</em>();</p><p>}</p><h3 id="18-3-配置文件的访问与读写"><a href="#18-3-配置文件的访问与读写" class="headerlink" title="18.3 配置文件的访问与读写"></a>18.3 配置文件的访问与读写</h3><p>void CMyMFCFileView::OnWriteConfig()</p><p>{</p><p>// [metadata]</p><p>// title = 搜狗双拼</p><p>//</p><p>// [声母]</p><p>// ch = I</p><p>// sh = U</p><p>// zh = V</p><p>// empty = O</p><p>//获取当前路径</p><p><em>WCHAR</em> strPath[<em>MAX_PATH</em>] = {0};</p><p><em>GetCurrentDirectoryW</em>(<em>MAX_PATH</em>, strPath);</p><p><em>TRACE</em>(“##strPath = %ls”, strPath);</p><p>// 当前路径 D:\Users\82835\source\repos\MyMFCFile\ + Test.ini</p><p><em>CString</em> strFilePath;</p><p>strFilePath.<em>Format</em>(L”%ls//Test.ini”, strPath);</p><p><em>WritePrivateProfileStringW</em>(L”metadata”, L”title”, L”搜狗双拼”, strFilePath);</p><p><em>WritePrivateProfileStringW</em>(L”声母”, L”ch”, L”I”, strFilePath);</p><p><em>WritePrivateProfileStringW</em>(L”声母”, L”sh”, L”U”, strFilePath);</p><p>}</p><p>void CMyMFCFileView::OnReadConfig()</p><p>{</p><p>//获取当前路径</p><p><em>WCHAR</em> strPath[<em>MAX_PATH</em>] = { 0 };</p><p><em>WCHAR</em> strTitle[<em>MAX_PATH</em>] = { 0 };</p><p><em>WCHAR</em> strCh[<em>MAX_PATH</em>] = { 0 };</p><p><em>WCHAR</em> strSh[<em>MAX_PATH</em>] = { 0 };</p><p><em>GetCurrentDirectoryW</em>(<em>MAX_PATH</em>, strPath);</p><p><em>TRACE</em>(“##strPath = %ls”, strPath);</p><p>// 当前路径 D:\Users\82835\source\repos\MyMFCFile\ + Test.ini</p><p><em>CString</em> strFilePath;</p><p>strFilePath.<em>Format</em>(L”%ls//Test.ini”, strPath);</p><p><em>DWORD</em> dwNum1 = <em>GetPrivateProfileStringW</em>(L”metadata”, L”title”,<em>NULL</em>,</p><p>strTitle, <em>MAX_PATH</em>, strFilePath);</p><p><em>DWORD</em> dwNum2 = <em>GetPrivateProfileStringW</em>(L”声母”, L”ch”, <em>NULL</em>,</p><p>strCh, <em>MAX_PATH</em>, strFilePath);</p><p><em>DWORD</em> dwNum3 = <em>GetPrivateProfileStringW</em>(L”声母”, L”sh”, <em>NULL</em>,</p><p>strSh, <em>MAX_PATH</em>, strFilePath);</p><p><em>TRACE</em>(“####dwNum1 = %d, dwNum2 = %d, dwNum3 = %d”, dwNum1, dwNum2, dwNum3);</p><p><em>USES_CONVERSION</em>;</p><p>char* szTitle = <em>W2A</em>(strTitle);</p><p>char* szCh= <em>W2A</em>(strCh);</p><p>char* szSh = <em>W2A</em>(strSh);</p><p><em>TRACE</em>(“####strTitle = %s, strCh = %s, strSh = %s”, szTitle, szCh, szSh);</p><p>}</p><h3 id="18-4-注册表编程"><a href="#18-4-注册表编程" class="headerlink" title="18.4 注册表编程"></a>18.4 注册表编程</h3><h4 id="18-4-1-注册表API"><a href="#18-4-1-注册表API" class="headerlink" title="18.4.1  注册表API"></a>18.4.1 注册表API</h4><p>注册表 存储在二进制文件里面，win32 API提供了大量的函数操作注册表</p><p>注册表：Win+ R组合键 ：regedit</p><p>RegCreateKey 创建指定的注册表项</p><p><em>RegCreateKeyW</em>(</p><p>​ <em><em>In</em></em> <em>HKEY</em> <em>hKey</em>, //打开的当前项的句柄 实际上就是那几个分支</p><p>​ <em>_In_opt_</em> <em>LPCWSTR</em> lpSubKey,//打开或者创建的表项的名称</p><p>​ <em><em>Out</em></em> <em>PHKEY</em> phkResult //用来接收创建或者打开表项句柄 regclosekey</p><p>​ );</p><p>​ <em>RegOpenKeyW</em>(</p><p>​ <em><em>In</em></em> <em>HKEY</em> <em>hKey</em>, //打开的当前项的句柄 实际上就是那几个分支</p><p>​ <em>_In_opt_</em> <em>LPCWSTR</em> lpSubKey,</p><p>​ <em><em>Out</em></em> <em>PHKEY</em> phkResult</p><p>​ );</p><p>​ //写入注册表</p><p>​ <em>RegSetValueW</em>(</p><p>​ <em><em>In</em></em> <em>HKEY</em> <em>hKey</em>, //打开的当前项的句柄 实际上就是那几个分支</p><p>​ <em>_In_opt_</em> <em>LPCWSTR</em> lpSubKey, //打开或者创建的表项的名称</p><p>​ <em><em>In</em></em> <em>DWORD</em> <em>dwType</em>, //指示被存储信息的类型 REG_SZ类型</p><p>​ <em>_In_reads_bytes_opt_</em>(<em>cbData</em>) <em>LPCWSTR</em> <em>lpData</em>,//要存放到注册表里面的数据</p><p>​ <em><em>In</em></em> <em>DWORD</em> <em>cbData</em> //要存放的字符串数据的大小、长度</p><p>​ );</p><p>​ <em>RegSetValueExW</em>(</p><p>​ <em><em>In</em></em> <em>HKEY</em> <em>hKey</em>, //打开的当前项的句柄 实际上就是那几个分支</p><p>​ <em>_In_opt_</em> <em>LPCWSTR</em> lpValueName,//指向一个字符串的指针，包含了将要设置值的名称</p><p>​ <em><em>Reserved</em></em> <em>DWORD</em> <em>Reserved</em>,// 保留参数 0</p><p>​ <em><em>In</em></em> <em>DWORD</em> <em>dwType</em>,//REG_BINARY</p><p>​ <em>_In_reads_bytes_opt_</em>(<em>cbData</em>) <em>CONST</em> <em>BYTE</em> * <em>lpData</em>,</p><p>​ <em><em>In</em></em> <em>DWORD</em> <em>cbData</em></p><p>​ );</p><p><em>RegQueryValueW</em>(</p><p>​ <em><em>In</em></em> <em>HKEY</em> <em>hKey</em>,</p><p>​ <em>_In_opt_</em> <em>LPCWSTR</em> lpSubKey,</p><p>​ <em><em>Out_writes_bytes_to_opt</em></em>(<em>lpcbData, *lpcbData) *__out_data_source</em>(REGISTRY) <em>LPWSTR</em> <em>lpData</em>,</p><p>​ <em>_Inout_opt_</em> <em>PLONG</em> lpcbData</p><p>);</p><h4 id="18-4-2注册表读写"><a href="#18-4-2注册表读写" class="headerlink" title="18.4.2注册表读写"></a>18.4.2注册表读写</h4><p>写注册表</p><p><em>HKEY</em> hKey;</p><p><em>DWORD</em> dwAge = 39;</p><p>//创建注册表项 VS2019自带的调试器管理员权限运行 自己的生成是以用户的权限运行</p><p>int ret = ::<em>RegCreateKeyW</em>(<em>HKEY_LOCAL_MACHINE</em>, L”SOFTWARE\Rock\admin”, &amp;hKey);</p><p>if (ret != <em>ERROR_SUCCESS</em>)</p><p>{</p><p>​ <em>TRACE</em>(“##RegCreateKeyW Failed ,ErrorCode = %d,ret = %d”,<em>GetLastError</em>(), ret);</p><p>​ <em>MessageBox</em>(L”创建注册表失败”);</p><p>​ return;</p><p>}</p><p>//写注册表</p><p>ret = ::<em>RegSetValueEx</em>(hKey, L”age”, 0, <em>REG_DWORD</em>, (<em>CONST</em> *BYTE**) &amp; dwAge, 4);</p><p>if (ret != <em>ERROR_SUCCESS</em>)</p><p>{</p><p>​ <em>TRACE</em>(“##RegSetValueEx Failed ,ErrorCode = %d,ret = %d”, <em>GetLastError</em>(),ret);</p><p>​ <em>MessageBox</em>(L”写注册表失败”);</p><p>​ return;</p><p>}</p><p>::<em>RegCloseKey</em>(hKey);</p><p>读注册表</p><p><em>HKEY</em> hKey;</p><p><em>DWORD</em> dwAge;</p><p>//创建注册表项 VS2019自带的调试器管理员权限运行 自己的生成是以用户的权限运行</p><p>int ret = ::<em>RegOpenKeyW</em>(<em>HKEY_LOCAL_MACHINE</em>, L”SOFTWARE\Rock\admin”, &amp;hKey);</p><p>if (ret != <em>ERROR_SUCCESS</em>)</p><p>{</p><p>​ <em>TRACE</em>(“##RegOpenKeyW Failed ,ErrorCode = %d,ret = %d”, <em>GetLastError</em>(), ret);</p><p>​ <em>MessageBox</em>(L”打开注册表失败”);</p><p>​ return;</p><p>}</p><p>//写注册表</p><p><em>DWORD</em> dwType;</p><p><em>DWORD</em> dwValue;</p><p>ret = ::<em>RegQueryValueEx</em>(hKey, L”age”, 0, &amp;dwType, (<em>LPBYTE</em>) &amp; dwAge, &amp;dwValue);</p><p>if (ret != <em>ERROR_SUCCESS</em>)</p><p>{</p><p>​ <em>TRACE</em>(“##RegQueryValueEx Failed ,ErrorCode = %d,ret = %d”, <em>GetLastError</em>(), ret);</p><p>​ <em>MessageBox</em>(L”读注册表失败”);</p><p>​ return;</p><p>}</p><p><em>TRACE</em>(“###dwType = %d,dwValue = %d ,dwAge = %d”, dwType, dwValue, dwAge);</p><p>::<em>RegCloseKey</em>(hKey);</p><h3 id="18-5-文件操作的企业级应用"><a href="#18-5-文件操作的企业级应用" class="headerlink" title="18.5 文件操作的企业级应用"></a>18.5 文件操作的企业级应用</h3><p>1 调试日志 debugview 文件日志：警告日志 错误日志 5星</p><p>2 视频存储 4星</p><p>3文件传输 CFile 与socket结合使用 4星</p><p>4 C语言和MFC的文件操作用途广泛；win32 API少用 ifstream ofstream 3星</p><p>5 配置文件 windows 5星</p><p>6 注册表的操作 病毒 逆向 操作注册表 5星</p><p>总结：const char *和char *const</p><p>C/C++/WIN32 API/MFC对文件的操作</p><p>配置文件的操作</p><p>注册表 ：权限</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Moustache 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Moustache</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://hammerzer.github.io/2024/08/28/mfc-start/" title="MFC快速入门">https://hammerzer.github.io/2024/08/28/mfc-start/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%A1%86%E6%9E%B6/" rel="tag"><i class="fa fa-tag"></i> 操作系统与框架</a> <a href="/tags/MFC/" rel="tag"><i class="fa fa-tag"></i> MFC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2024/08/20/CPP-QA/" rel="prev" title="CPP-QA"><i class="fa fa-chevron-left"></i> CPP-QA</a></div><div class="post-nav-item"><a href="/2024/10/13/LeetCode101-Open-brush/" rel="next" title="LeetCode101开刷">LeetCode101开刷 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CONTENT-OUTLINE"><span class="nav-number">1.</span> <span class="nav-text">CONTENT OUTLINE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%87-%E7%9B%AE%E5%BD%95"><span class="nav-number">2.</span> <span class="nav-text">〇 目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-MFC%E5%88%9D%E8%AF%86"><span class="nav-number">3.</span> <span class="nav-text">一 MFC初识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MFC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.</span> <span class="nav-text">1.1 MFC是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AD%A6%E4%B9%A0MFC%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">3.2.</span> <span class="nav-text">1.2 学习MFC的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-MFC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91"><span class="nav-number">3.3.</span> <span class="nav-text">1.3 MFC开发环境搭建和就业方向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-MFC%E7%9A%84%E5%89%8D%E8%BA%AB%EF%BC%9AWin32"><span class="nav-number">3.4.</span> <span class="nav-text">1.4 MFC的前身：Win32</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">3.5.</span> <span class="nav-text">1.5 重要概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-API%E4%B8%8ESDK"><span class="nav-number">3.5.1.</span> <span class="nav-text">1.5.1 API与SDK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%A5%E6%9F%84-%E7%AA%97%E5%8F%A3%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.5.2.</span> <span class="nav-text">1.5.2 窗口与句柄&#x2F;窗口类对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.5.3.</span> <span class="nav-text">1.5.3 消息循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.4.</span> <span class="nav-text">1.5.4 回调函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-number">3.6.</span> <span class="nav-text">1.7 变量命名约定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-MFC%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">二 MFC程序开发流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="nav-number">4.1.</span> <span class="nav-text">2.1 项目创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-MFC%E4%B8%8Ewin32%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text">2.2 MFC与win32开发方式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">2.3 MFC消息映射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E4%BD%93%E4%BC%9AMFC%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">2.4 体会MFC程序的运行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E6%96%AD%E7%82%B9%E9%80%90%E8%BF%87%E7%A8%8B%E6%89%A7%E8%A1%8CMain%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.1.</span> <span class="nav-text">2.4.1 断点逐过程执行Main函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E7%BB%93%E5%90%88%E7%BB%98%E5%9B%BE%E8%BF%87%E7%A8%8B%E5%86%8D%E8%B0%88%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">4.4.2.</span> <span class="nav-text">2.4.2 结合绘图过程再谈消息映射机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E7%AE%80%E5%8D%95%E7%BB%98%E5%9B%BE%E4%B8%8E%E6%96%87%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">三 简单绘图与文本编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%BC%95%E5%85%A5"><span class="nav-number">5.1.</span> <span class="nav-text">3.1 项目创建与引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%94%BB%E7%BA%BF"><span class="nav-number">5.2.</span> <span class="nav-text">3.2 画线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%94%BB%E7%AC%94"><span class="nav-number">5.3.</span> <span class="nav-text">3.3 画笔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E7%94%BB%E5%88%B7%E3%80%90%E5%A1%AB%E5%85%85%E3%80%91"><span class="nav-number">5.4.</span> <span class="nav-text">3.4 画刷【填充】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E6%96%87%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="nav-number">5.5.</span> <span class="nav-text">3.5 文本编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%B0%8F%E7%BB%93"><span class="nav-number">5.6.</span> <span class="nav-text">3.6 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E8%8F%9C%E5%8D%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="nav-number">6.</span> <span class="nav-text">四 菜单与工具栏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.</span> <span class="nav-text">4.1 基本菜单操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">4.2 添加事件处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%8F%9C%E5%8D%95%E5%91%BD%E4%BB%A4%E8%B7%AF%E7%94%B1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">6.3.</span> <span class="nav-text">4.3 菜单命令路由及其优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">6.4.</span> <span class="nav-text">4.4 工具栏基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-MFC%E6%80%BB%E4%BD%93%E7%90%86%E8%A7%A3"><span class="nav-number">7.</span> <span class="nav-text">五 MFC总体理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-MFC%E7%B1%BB%E8%A7%86%E5%9B%BE%E5%92%8CMFC%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">5.1 MFC类视图和MFC所有的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-MFC%E6%A1%86%E6%9E%B6%E7%90%86%E8%AE%BA"><span class="nav-number">7.2.</span> <span class="nav-text">5.2 MFC框架理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E5%85%B3%E9%94%AE%E7%B1%BB"><span class="nav-number">7.2.1.</span> <span class="nav-text">5.2.1 关键类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%85%B3%E9%94%AE%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.2.2.</span> <span class="nav-text">5.2.2 关键类之间的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-MFC%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB"><span class="nav-number">7.3.</span> <span class="nav-text">5.3 MFC消息分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">8.</span> <span class="nav-text">六 对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">8.1.</span> <span class="nav-text">6.1 对话框基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%98%BE%E7%A4%BA"><span class="nav-number">8.2.</span> <span class="nav-text">6.2 对话框的创建和显示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E6%A8%A1%E6%80%81%E5%92%8C%E9%9D%9E%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">8.2.1.</span> <span class="nav-text">6.2.1 模态和非模态对话框</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%8C%89%E9%92%AE"><span class="nav-number">8.3.</span> <span class="nav-text">6.3 动态创建按钮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%8E%A7%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">8.4.</span> <span class="nav-text">6.4 控件的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-Get-SetWindowText"><span class="nav-number">8.4.1.</span> <span class="nav-text">6.4.1 Get&#x2F;SetWindowText</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-Get-SetDlgItemText"><span class="nav-number">8.4.2.</span> <span class="nav-text">6.4.2 Get&#x2F;SetDlgItemText</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-Get-SetDlgItemInt"><span class="nav-number">8.4.3.</span> <span class="nav-text">6.4.3 Get&#x2F;SetDlgItemInt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-%E6%8E%A7%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E8%81%94"><span class="nav-number">8.4.4.</span> <span class="nav-text">6.4.4 控件与数据变量相关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-5-%E6%8E%A7%E4%BB%B6%E4%B8%8E%E6%8E%A7%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E8%81%94"><span class="nav-number">8.4.5.</span> <span class="nav-text">6.4.5 控件与控件变量相关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-6-SendMessage%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.6.</span> <span class="nav-text">6.4.6 SendMessage通用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E5%AF%B9%E8%AF%9D%E6%A1%86%E4%BC%B8%E7%BC%A9%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.5.</span> <span class="nav-text">6.5 对话框伸缩功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E5%AF%B9%E8%AF%9D%E6%A1%86%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%80%83%E8%B7%91%E6%8C%89%E9%92%AE"><span class="nav-number">8.6.</span> <span class="nav-text">6.6 对话框项目：逃跑按钮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%81%8C%E4%B8%9A%E8%B0%83%E6%9F%A5"><span class="nav-number">8.7.</span> <span class="nav-text">6.7 项目：职业调查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-%E5%88%9B%E5%BB%BA%E4%B8%89%E4%B8%AA%E5%B1%9E%E6%80%A7%E9%A1%B5"><span class="nav-number">8.7.1.</span> <span class="nav-text">6.7.1 创建三个属性页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7%E8%A1%A8%E5%8D%95"><span class="nav-number">8.7.2.</span> <span class="nav-text">6.7.2 创建属性表单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-3-%E5%90%91%E5%AF%BC%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">8.7.3.</span> <span class="nav-text">6.7.3 向导的创建和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-4-%E5%B1%9E%E6%80%A7%E8%A1%A8%E5%8D%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86"><span class="nav-number">8.7.4.</span> <span class="nav-text">6.7.4 属性表单的返回值处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-5-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93"><span class="nav-number">8.7.5.</span> <span class="nav-text">6.7.5 项目小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6"><span class="nav-number">9.</span> <span class="nav-text">七 常用控件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%A0%87%E5%87%86%E6%8C%89%E9%92%AE-%E5%A4%8D%E9%80%89%E6%A1%86-%E5%8D%95%E9%80%89%E6%A1%86"><span class="nav-number">9.1.</span> <span class="nav-text">7.1 标准按钮&#x2F;复选框&#x2F;单选框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E6%A1%86-%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E6%A1%86"><span class="nav-number">9.2.</span> <span class="nav-text">7.2 文本编辑框&#x2F;列表选择框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-EditControl"><span class="nav-number">9.2.1.</span> <span class="nav-text">7.2.1 EditControl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-ListBox"><span class="nav-number">9.2.2.</span> <span class="nav-text">7.2.2 ListBox</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E7%BB%84%E5%90%88%E6%A1%86ComboBox"><span class="nav-number">9.3.</span> <span class="nav-text">7.3 组合框ComboBox</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-Progress"><span class="nav-number">9.4.</span> <span class="nav-text">7.4 Progress</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-Picture"><span class="nav-number">9.5.</span> <span class="nav-text">7.5 Picture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-List"><span class="nav-number">9.6.</span> <span class="nav-text">7.6 List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-Tree"><span class="nav-number">9.7.</span> <span class="nav-text">7.7 Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-%E5%B0%8F%E7%BB%93"><span class="nav-number">9.8.</span> <span class="nav-text">7.8 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">11 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">10.1.</span> <span class="nav-text">11.1 网络编程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-1-socket%E6%A6%82%E5%BF%B5"><span class="nav-number">10.1.1.</span> <span class="nav-text">11.1.1 socket概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-2-%E4%BB%80%E4%B9%88%E6%98%AFC-S%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.1.2.</span> <span class="nav-text">11.1.2 什么是C&#x2F;S模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-3-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%9D%A2%E5%90%91%E6%B6%88%E6%81%AF"><span class="nav-number">10.1.3.</span> <span class="nav-text">11.1.3 什么是面向连接和面向消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-4-IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="nav-number">10.1.4.</span> <span class="nav-text">11.1.4 IP地址和端口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">10.2.</span> <span class="nav-text">11.2 网络套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-1-TCP%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">10.2.1.</span> <span class="nav-text">11.2.1 TCP套接字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-2-UDP%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">10.2.2.</span> <span class="nav-text">11.2.2 UDP套接字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-MFC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6"><span class="nav-number">11.</span> <span class="nav-text">12 MFC网络编程进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-listen%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89"><span class="nav-number">11.1.</span> <span class="nav-text">12.1 listen的具体含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-%E4%B8%80%E7%A7%8D%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84recv%E5%92%8Csend%EF%BC%9A%E8%B6%85%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93"><span class="nav-number">11.2.</span> <span class="nav-text">12.2 一种更优雅的recv和send：超大数据的传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98"><span class="nav-number">12.</span> <span class="nav-text">13 网络编程实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E6%88%AA%E5%8F%96%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-number">12.1.</span> <span class="nav-text">13.1 网络编程实战之网络文件截取（一）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E6%88%AA%E5%8F%96%E2%80%94%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="nav-number">12.2.</span> <span class="nav-text">13.2网络编程实战之网络文件截取—隐藏进程与修改注册表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">14 聊天软件项目过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-%E4%B8%89%E5%A4%A7%E5%B7%A5%E5%85%B7"><span class="nav-number">13.1.</span> <span class="nav-text">14.1 三大工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-C-%E5%AE%9E%E7%8E%B0socket%E7%BC%96%E7%A8%8B-%E2%80%94-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9ESocket%E5%B0%81%E8%A3%85%E7%B1%BB-CAsyncSocket"><span class="nav-number">13.2.</span> <span class="nav-text">14.2 C++实现socket编程 —- 异步非阻塞Socket封装类 CAsyncSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-C-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E8%81%94%E8%B0%83"><span class="nav-number">13.3.</span> <span class="nav-text">14.3 C++实现客户端和服务端收发消息的联调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-C-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B4%E4%B8%AA%E6%94%B6%E5%8F%91%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">13.4.</span> <span class="nav-text">14.4 C++实现客户端和服务端整个收发功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%98%B5%E7%A7%B0-%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D-%E6%B8%85%E9%99%A4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">13.5.</span> <span class="nav-text">14.5 聊天软件配置昵称&#x2F;自动回复&#x2F;清除历史记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E6%94%B9%E5%8F%98%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">13.6.</span> <span class="nav-text">14.6 聊天软件改变字体颜色&#x2F;断开连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E7%95%8C%E9%9D%A2%E6%8F%92%E5%85%A5%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87"><span class="nav-number">13.7.</span> <span class="nav-text">14.6 聊天软件界面插入背景图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-7-%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E6%89%93%E5%BC%80%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E5%92%8CMFC%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8"><span class="nav-number">13.8.</span> <span class="nav-text">14.7 聊天软件打开常见的计算机应用和MFC快捷键使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-8-%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88"><span class="nav-number">13.9.</span> <span class="nav-text">14.8 聊天软件项目总结和知识点概览</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">14.</span> <span class="nav-text">15 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">14.1.</span> <span class="nav-text">15.1 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number">14.2.</span> <span class="nav-text">15.2 线程创建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-%E7%AE%80%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.3.</span> <span class="nav-text">15.3 简单多线程示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E2%80%94%E4%BA%92%E6%96%A5%E5%AF%B9%E8%B1%A1"><span class="nav-number">14.4.</span> <span class="nav-text">15.4 线程同步—互斥对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0qq%E7%BE%A4%E8%81%8A%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">14.5.</span> <span class="nav-text">15.5 多线程实现qq群聊的服务端和客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">14.6.</span> <span class="nav-text">15.6线程同步之事件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-7%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3windows%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8F%A5%E6%9F%84"><span class="nav-number">14.7.</span> <span class="nav-text">15.7深入理解windows内核对象与句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-8%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">14.8.</span> <span class="nav-text">15.8线程同步之信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-9%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="nav-number">14.9.</span> <span class="nav-text">15.9线程同步之关键代码段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-10%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">14.10.</span> <span class="nav-text">15.10线程死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-11%E5%90%84%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93"><span class="nav-number">14.11.</span> <span class="nav-text">15.11各种线程同步的比较总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E8%BF%9B%E7%A8%8B"><span class="nav-number">15.</span> <span class="nav-text">16 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">15.1.</span> <span class="nav-text">16.1 基本概念-进程和子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-number">15.2.</span> <span class="nav-text">16.2 如何创建一个进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB"><span class="nav-number">15.3.</span> <span class="nav-text">16.3 进程间通信方式汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%89%AA%E5%88%87%E6%9D%BF"><span class="nav-number">15.4.</span> <span class="nav-text">16.4 进程间通信方式之剪切板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E9%82%AE%E6%A7%BD"><span class="nav-number">15.5.</span> <span class="nav-text">16.5 进程间通信方式之邮槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">15.6.</span> <span class="nav-text">16.6 进程间通信方式之匿名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">15.7.</span> <span class="nav-text">16.7 进程间通信方式之命名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8BWM-COPYDATA"><span class="nav-number">15.8.</span> <span class="nav-text">16.8 进程间通信方式之WM_COPYDATA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-9-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">15.9.</span> <span class="nav-text">16.9 进程间通信方式的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="nav-number">16.</span> <span class="nav-text">17 动态链接库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">16.1.</span> <span class="nav-text">17.1 动态链接库的概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-DLL%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">16.2.</span> <span class="nav-text">17.2 DLL的创建和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-3-DLL%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E4%BB%A5%E5%8F%8A%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-number">16.3.</span> <span class="nav-text">17.3 DLL的导入和导出以及条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-4-%E4%BB%8EDLL%E4%B8%AD%E5%AF%BC%E5%87%BAC-%E7%B1%BB"><span class="nav-number">16.4.</span> <span class="nav-text">17.4 从DLL中导出C++类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-5-%E8%A7%A3%E5%86%B3%E5%90%8D%E5%AD%97%E6%94%B9%E7%BC%96%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">16.5.</span> <span class="nav-text">17.5 解决名字改编的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-6-%E6%98%BE%E7%A4%BA%EF%BC%88%E5%8A%A8%E6%80%81%EF%BC%89%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%8A%A0%E8%BD%BDDLL"><span class="nav-number">16.6.</span> <span class="nav-text">17.6 显示（动态）加载方式加载DLL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-7-DLLMain%E5%87%BD%E6%95%B0"><span class="nav-number">16.7.</span> <span class="nav-text">17.7 DLLMain函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-MFC%E6%96%87%E4%BB%B6%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">17.</span> <span class="nav-text">18 MFC文件和注册表的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-1-C-C-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">17.1.</span> <span class="nav-text">18.1 C&#x2F;C++操作文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-1-const-char-%E4%B8%8E-char-const"><span class="nav-number">17.1.1.</span> <span class="nav-text">18.1.1 const char* 与 char *const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-2-C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">17.1.2.</span> <span class="nav-text">18.1.2 C语言操作文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-3-C-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">17.1.3.</span> <span class="nav-text">18.1.3 C++操作文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-Win32-API-MFC%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">17.2.</span> <span class="nav-text">18.2 Win32 API&#x2F;MFC操作文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-1-Win32-API%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">17.2.1.</span> <span class="nav-text">18.2.1 Win32 API操作文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-2-MFC%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">17.2.2.</span> <span class="nav-text">18.2.2 MFC操作文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E8%AF%BB%E5%86%99"><span class="nav-number">17.3.</span> <span class="nav-text">18.3 配置文件的访问与读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BC%96%E7%A8%8B"><span class="nav-number">17.4.</span> <span class="nav-text">18.4 注册表编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-4-1-%E6%B3%A8%E5%86%8C%E8%A1%A8API"><span class="nav-number">17.4.1.</span> <span class="nav-text">18.4.1 注册表API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-4-2%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%AF%BB%E5%86%99"><span class="nav-number">17.4.2.</span> <span class="nav-text">18.4.2注册表读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="nav-number">17.5.</span> <span class="nav-text">18.5 文件操作的企业级应用</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Moustache" src="/images/180-180.png"><p class="site-author-name" itemprop="name">Moustache</p><div class="site-description" itemprop="description">我是小胡子</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">78</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/hammerzer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hammerzer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:stellar_lzu@163.com" title="E-Mail → mailto:stellar_lzu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Chase</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">1.9m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">29:01</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script size="300" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JRehDoQ6pHXV1zKg09AMNLFt-gzGzoHsz',
      appKey     : 'cRAt4W15KiQdrIuHlQrRrtIl',
      placeholder: "Just go go",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>