<!DOCTYPE html><html lang="zh-CN"><head><script src="https://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/180-180.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/32-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/16-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hammerzer.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="CONTENT OUTLINE ​    Linux       〇、目录 Ubuntu问题 Linux 简介 Linux 开发入门 开发环境搭建 创建Linux控制台项目 Linux标准库函数 网络编程基础 linux系统编程：进程 linux系统编程：线程 I&#x2F;O复用   动态库项目【Linux快速入门2】"><meta property="og:type" content="article"><meta property="og:title" content="Linux快速入门"><meta property="og:url" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/index.html"><meta property="og:site_name" content="Moustache&#39;s Blog"><meta property="og:description" content="CONTENT OUTLINE ​    Linux       〇、目录 Ubuntu问题 Linux 简介 Linux 开发入门 开发环境搭建 创建Linux控制台项目 Linux标准库函数 网络编程基础 linux系统编程：进程 linux系统编程：线程 I&#x2F;O复用   动态库项目【Linux快速入门2】"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pics4.baidu.com/feed/50da81cb39dbb6fd03aa2d6446669517962b3754.jpeg@f_auto?token=984c08decaf6a3a501d7ec6da0347bbb"><meta property="og:image" content="https://pics2.baidu.com/feed/342ac65c10385343903cd857dc518e71cb8088a2.jpeg@f_auto?token=7f0591f4b506bda1a605757c5f1db56c"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/2-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/2-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/3-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/3-2.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-2.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-3.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-4.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-5.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-6.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-7.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-8.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-9.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-10.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-11.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-12.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-13.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-14.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-15.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-16.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-17.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-18.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-19.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-20.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-21.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-22.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/4-23.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/5-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/5-2.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/5-3.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/6-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/6-2.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/6-3.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/7-1.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/7-2.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/7-3.png"><meta property="og:image" content="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/7-4.png"><meta property="article:published_time" content="2024-04-13T05:00:49.000Z"><meta property="article:modified_time" content="2025-03-20T16:07:32.567Z"><meta property="article:author" content="Moustache"><meta property="article:tag" content="操作系统与框架"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pics4.baidu.com/feed/50da81cb39dbb6fd03aa2d6446669517962b3754.jpeg@f_auto?token=984c08decaf6a3a501d7ec6da0347bbb"><link rel="canonical" href="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Linux快速入门 | Moustache's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Moustache's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Moustache's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">小胡子的私人空间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">36</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">79</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/180-180.png"><meta itemprop="name" content="Moustache"><meta itemprop="description" content="我是小胡子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Moustache's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Linux快速入门</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-04-13 13:00:49" itemprop="dateCreated datePublished" datetime="2024-04-13T13:00:49+08:00">2024-04-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-03-21 00:07:32" itemprop="dateModified" datetime="2025-03-21T00:07:32+08:00">2025-03-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a> </span></span><span id="/2024/04/13/Linux-Quick-Start/" class="post-meta-item leancloud_visitors" data-flag-title="Linux快速入门" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> <span>℃</span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2024/04/13/Linux-Quick-Start/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2024/04/13/Linux-Quick-Start/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>181k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2:45</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote><p>​ <span style="background:#ff0">Linux</span></p></blockquote><hr style="border:0;height:1px;background:#333;background-image:linear-gradient(to right,#ccc,#333,#ccc)"><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><h2 id="〇、目录"><a href="#〇、目录" class="headerlink" title="〇、目录"></a>〇、目录</h2><ul><li><code>Ubuntu</code>问题</li><li><code>Linux</code> 简介</li><li><code>Linux</code> 开发入门<ul><li>开发环境搭建</li><li>创建Linux控制台项目</li><li>Linux标准库函数</li><li>网络编程基础</li><li>linux系统编程：进程</li><li>linux系统编程：线程</li><li>I/O复用</li></ul></li><li>动态库项目【Linux快速入门2】</li></ul><span id="more"></span><br><h2 id="一-Ubuntu问题"><a href="#一-Ubuntu问题" class="headerlink" title="一  Ubuntu问题"></a>一 <code>Ubuntu</code>问题</h2><h3 id="1-安装虚拟机"><a href="#1-安装虚拟机" class="headerlink" title="1 安装虚拟机"></a>1 安装虚拟机</h3><h4 id="1-1-安装步骤"><a href="#1-1-安装步骤" class="headerlink" title="1.1 安装步骤"></a>1.1 安装步骤</h4><blockquote><p>安装虚拟机：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">参考原文</a> 虚拟机下载VM16【公众号：软件科技汇】</p></blockquote><ul><li><p>下载<code>VMware Workstation Pro 16</code></p></li><li><p>虚拟机<code>ubuntu</code>镜像，我这里下载的是<code>Ubuntu 18.04</code><a target="_blank" rel="noopener" href="https://ubuntu.com/download/desktop">下载地址</a></p></li><li><p>在<code>VMware</code>中创建虚拟机【详细步骤见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">参考原文</a> | <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34028816/article/details/141558433">简易安装</a>】</p></li></ul><blockquote><p><code>Ubuntu.vmdk</code>文件：虚拟机磁盘文件</p></blockquote><br><h4 id="1-2-关于VMware的一些问题"><a href="#1-2-关于VMware的一些问题" class="headerlink" title="1.2 关于VMware的一些问题"></a>1.2 关于VMware的一些问题</h4><h5 id="1-2-1-解决虚拟启动问题【关于BIOS设置】"><a href="#1-2-1-解决虚拟启动问题【关于BIOS设置】" class="headerlink" title="1.2.1 解决虚拟启动问题【关于BIOS设置】"></a>1.2.1 解决虚拟启动问题【关于BIOS设置】</h5><p>一般在<code>Advanced、Security、BIOS Features、Configuration</code>下面，找到<code>Intel Virtualization Technology</code>按回车键选择Enabled，表示开启。</p><p>进入<code>BIOS</code>之后选择某个选项按<code>Enter</code>是进入，按<code>Esc</code>是返回，按<code>F10</code>或<code>F4</code>保存。</p><blockquote><p>联想拯救者怎么进入<code>bios</code>？</p><p>1、联想拯救者在开机或重启状态下，在开机等待界面，连续按快捷键<code>F2</code>（或是<code>Fn+F2</code>）即可进入<code>bios</code>。</p><p>2、<code>nova</code>孔是联想拯救者快捷进入bios的方式之一，而且不仅是联想拯救者系列，联想旗下多个系列的产品都设置有该功能。用户在笔记本侧边找到<code>nova</code>孔，用针或牙签刺入，即可调出快捷菜单。选择<code>bios</code>进入即可【右侧<code>USB</code>孔旁】</p></blockquote><br><h5 id="1-2-2-解决虚拟启动问题【关于BIOS设置已完成】"><a href="#1-2-2-解决虚拟启动问题【关于BIOS设置已完成】" class="headerlink" title="1.2.2 解决虚拟启动问题【关于BIOS设置已完成】"></a>1.2.2 解决虚拟启动问题【关于BIOS设置已完成】</h5><p>如果打开BOIS中的设置之后，依然报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此平台不支持虚拟化的 Intel VT-x/EPT。 不使用虚拟化的 Intel VT-x/EPT,是否继续</span><br></pre></td></tr></table></figure><p>可以参考<a target="_blank" rel="noopener" href="https://huaweicloud.csdn.net/63560df1d3efff3090b590d1.html">此处</a></p><br><h5 id="1-2-3-相关组合键"><a href="#1-2-3-相关组合键" class="headerlink" title="1.2.3 相关组合键"></a>1.2.3 相关组合键</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt +Enter 虚拟机全屏</span><br></pre></td></tr></table></figure><br><h5 id="1-2-4-新版本的VM无法完成安装VM-Tool的解决办法"><a href="#1-2-4-新版本的VM无法完成安装VM-Tool的解决办法" class="headerlink" title="1.2.4 新版本的VM无法完成安装VM-Tool的解决办法"></a>1.2.4 新版本的VM无法完成安装VM-Tool的解决办法</h5><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/junjun6022/article/details/140083298">参考此处</a></p></blockquote><p>在<code>VMware Workstation 17 pro</code>版本(个人版)的虚拟机中安装完<code>Ubuntu 22.04</code>版本后，发现VMware Tools安装选项为灰色无法安装。</p><blockquote><p>在版本 10.3.10(VMware Tools) 中停止提供适用于 Linux 虚拟机的 VMware Tar 工具的功能，因此 Workstation Player 中包含的 tar 工具 (linux.iso) 是 10.3.10，且不会进行更新。由于此更改， 安装/更新/重新安装 VMware Tools 菜单不可用于以下 Linux 虚拟机。</p></blockquote><p>① 解决方案一（不可行）：</p><p>关闭客户机后，启动客户机，“安装VMware Tools”选项在启动过程中是可以点击的。此时虚拟机底部会提示登录系统后，在任务栏会发现多出一个磁盘图标，表示VMware Tools挂载成功了。</p><p>② 解决方案二：</p><ol><li>关闭客户机，打开“虚拟机”-&gt;“设置”，在“硬件”-&gt;“<code>CD/DVD(SATA)</code>”中选择“使用ISO映像文件”。</li><li>加载<code>linux.iso</code>文件 （<code>linux.iso</code>文件在VMware Workstation的安装目录，也可根据VM的提示直接下载）。</li><li>设置好后关闭设置，启动客户机，登录系统后，在任务栏会加载VMware Tools的磁盘图标。</li></ol><br><h3 id="2-关于Ubuntu遇到的问题"><a href="#2-关于Ubuntu遇到的问题" class="headerlink" title="2 关于Ubuntu遇到的问题"></a>2 关于Ubuntu遇到的问题</h3><h4 id="2-1-屏幕显示大小调整"><a href="#2-1-屏幕显示大小调整" class="headerlink" title="2.1 屏幕显示大小调整"></a>2.1 屏幕显示大小调整</h4><blockquote><p>屏幕显示大小调整： 设置→<code>Devices</code>→<code>Displays</code>→<code>Resolution</code></p></blockquote><br><h4 id="2-2-初始su密码错误"><a href="#2-2-初始su密码错误" class="headerlink" title="2.2 初始su密码错误"></a>2.2 初始su密码错误</h4><blockquote><p><a target="_blank" rel="noopener" href="https://www.yii666.com/article/605608.html?action=onAll">原文</a>解决</p></blockquote><p><code>Ubuntu</code>刚安装后，在终端中运行<code>su</code>命令要求输入密码，出现密码错误。</p><p>原因：<code>root</code>没有默认密码，需要手动设定。以安装<code>ubuntu</code>时输入的用户名登陆，该用户在<code>admin</code>组中，有权限给<code>root</code>设定密码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd [root] 或者 sudo passwd</span><br><span class="line"><span class="comment">#Enter后输入原始密码，新密码和确认密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出root</span></span><br><span class="line"><span class="keyword">exit</span>  |  Ctrl+D</span><br></pre></td></tr></table></figure><br><h4 id="2-3-Ubuntu上修改主机名"><a href="#2-3-Ubuntu上修改主机名" class="headerlink" title="2.3 Ubuntu上修改主机名"></a>2.3 Ubuntu上修改主机名</h4><blockquote><p><a target="_blank" rel="noopener" href="https://www.python100.com/html/75774.html">原文</a></p></blockquote><ul><li><p>方法一：修改文件【需要先获取root权限】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gedit /etc/hostname</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gedit /etc/hosts</span></span><br></pre></td></tr></table></figure></li><li><p>方法二：hostname文件的修改可使用命令完成【需要先获取root权限】</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hostnamectl</span> <span class="built_in">set-hostname</span> <span class="string">new-hostname</span></span><br></pre></td></tr></table></figure></li></ul><br><h4 id="2-4-Ubuntu安装一直卡黑屏"><a href="#2-4-Ubuntu安装一直卡黑屏" class="headerlink" title="2.4 Ubuntu安装一直卡黑屏"></a>2.4 Ubuntu安装一直卡黑屏</h4><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42081389/article/details/104072902">解决原文</a></p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Please <span class="built_in">remove</span> the installation medium then reboot</span><br><span class="line"><span class="comment">#Ubuntu 18.04 一直卡在黑屏</span></span><br><span class="line"><span class="comment">#解决：编辑虚拟机设置 → CD/DVD...关闭启动时连接</span></span><br><span class="line"><span class="comment">#注意：首次安装需打开以上设置</span></span><br></pre></td></tr></table></figure><h4 id="2-5-修改最佳apt下载服务器"><a href="#2-5-修改最佳apt下载服务器" class="headerlink" title="2.5 修改最佳apt下载服务器"></a>2.5 修改最佳<code>apt</code>下载服务器</h4><blockquote><p>可参考<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/c1a3101eee72e79f646deb3d.html">此</a></p></blockquote><ul><li><code>Ubuntu18.04</code>：打开<code>Software and Update</code>（左下角All Software），直接<code>stop</code>其自动检查，就会出现设置</li></ul><br><h4 id="2-6-错误：无法得到锁"><a href="#2-6-错误：无法得到锁" class="headerlink" title="2.6 错误：无法得到锁"></a>2.6 错误：无法得到锁</h4><p><strong>问题：</strong>新搭建的<code>Ubuntu</code>虚拟机，执行apt安装命令是报错<code>could not get lock /var/lib/dpkg/lock-frontend</code></p><p><strong>问题原因：</strong>存在另外一个进程在使用这个目录：<code>/var/lib/dpkg/lock-frontend</code>，【比如，正在更新软件<code>Cache</code>】。所以先确定是否还有其他人在使用软件管理程序或者在使用<code>apt</code>进行软件的安装，如果没有的话，可以直接删除/重命名被锁定的文件。</p><p><strong>解决：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/dpkg/lock-frontend</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure><br><h4 id="2-7-Ubuntu打开终端时自动退出base环境"><a href="#2-7-Ubuntu打开终端时自动退出base环境" class="headerlink" title="2.7 Ubuntu打开终端时自动退出base环境"></a>2.7 Ubuntu打开终端时自动退出base环境</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda<span class="built_in"> config </span>--<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure><br><h4 id="2-8-解压提取VMware-Tool时报错"><a href="#2-8-解压提取VMware-Tool时报错" class="headerlink" title="2.8 解压提取VMware-Tool时报错"></a>2.8 解压提取VMware-Tool时报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not enough free space to extract VMwareTools</span><br></pre></td></tr></table></figure><p>原因：不能在安装的文件夹中解压。</p><p>解决办法：将<code>VMwareTools-10.3.2-9925305.tar.gz</code><strong>复制到另一个文件夹中再提取</strong>即可。</p><blockquote><p>或者，尝试双击打开 <code>.gz</code> 文件，再点击 <code>Extract</code> 提取。</p></blockquote><br><h4 id="2-9-虚拟机内容到Windows"><a href="#2-9-虚拟机内容到Windows" class="headerlink" title="2.9 虚拟机内容到Windows"></a>2.9 虚拟机内容到Windows</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#路径【共享文件】</span></span><br><span class="line">/mnt/hgfs/VM-share/...</span><br><span class="line"><span class="comment">#对应的windows路径</span></span><br><span class="line">D:\Software\VMwareUbuntu\VM-share</span><br></pre></td></tr></table></figure><ol><li><p>在VMware设置共享文件夹：右键单击对应虚拟机——&gt;选项——&gt;共享文件夹——&gt;启用</p></li><li><p>虚拟机中找到 <code>/mnt/hgfs</code> 目录：<code>Other Locations</code> -&gt; <code>Computer</code> -&gt; <code>mnt</code> -&gt; <code>hgfs</code></p><blockquote><p>如果没有hgfs文件夹，就用下列命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/hgfs</span><br></pre></td></tr></table></figure></blockquote></li><li><p>将 <code>/mnt/hgfs</code> 目录的写权限授予所有用户：<code>sudo chmod a+w /mnt/hgfs</code></p></li><li><p>将 VMware 主机上的共享文件系统挂载到虚拟机中的 <code>/mnt/hgfs</code> 目录下：<code>vmhgfs-fuse .host:/ /mnt/hgfs/</code></p></li></ol><br><h4 id="2-10-安装软件包时无法找到源"><a href="#2-10-安装软件包时无法找到源" class="headerlink" title="2.10 安装软件包时无法找到源"></a>2.10 安装软件包时无法找到源</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Package</span> <span class="title">gcc </span><span class="keyword">is</span> <span class="keyword">not</span> available, but <span class="keyword">is</span> referred to by another <span class="keyword">package</span>.</span><br><span class="line">This may mean that the <span class="keyword">package</span> <span class="title"></span><span class="keyword">is</span> missing, has been obsoleted, <span class="keyword">or</span></span><br><span class="line"><span class="keyword">is</span> only available from another source</span><br></pre></td></tr></table></figure><p><strong>解决：</strong>按 2.5 设置最佳源后，在root模式下，执行 <code>apt update</code> 解决。</p><br><h4 id="2-11-Ubuntu启动卡住"><a href="#2-11-Ubuntu启动卡住" class="headerlink" title="2.11 Ubuntu启动卡住"></a>2.11 Ubuntu启动卡住</h4><p>重启后卡在<code>Started GNOME Display Manager</code>不动，记录解决办法。参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43990097/article/details/137649700">此处</a>。</p><p>Ubuntu突然出现了一个问题：每次开机不到5分钟，随便点击一下浏览器或者其他的地方就会卡住，但是鼠标可以移动，就是无法点击，而且等待一段时间后会出现黑屏然后提示。此问题同理，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/guoyihaoguoyihao/article/details/104494025">此处</a>。</p><p>其实本来就是为了学习而安装，暂未找到解决方案【目前重新安装，且分区自动分配】。</p><br><h4 id="2-12-Ubuntu版本问题"><a href="#2-12-Ubuntu版本问题" class="headerlink" title="2.12 Ubuntu版本问题"></a>2.12 Ubuntu版本问题</h4><blockquote><p>注意：<code>Ubuntu-18.04.1-desktop-amd64.iso</code> 有问题，替换为 <code>18.04.6</code> 可以解决很多问题。</p></blockquote><br><h4 id="2-13-Ubuntu获取ip"><a href="#2-13-Ubuntu获取ip" class="headerlink" title="2.13 Ubuntu获取ip"></a>2.13 Ubuntu获取ip</h4><p>① 使用 <code>ifconfig</code> 命令：<code>ifconfig</code> 是一个老牌的网络配置工具，它能显示网络接口的详细信息，包括 IP 地址。可以通过以下命令获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 ifconfig</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install net-tools</span><br></pre></td></tr></table></figure><p>② 使用 <code>ip</code> 命令：<code>ip</code> 命令是 <code>ifconfig</code> 的现代替代品，提供了更多功能。可以通过以下命令查看 IP 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>③ 网络配置：Ubuntu 系统中，<code>/etc/network/interfaces</code> 文件用于配置网络接口。可以在此文件中配置静态 IP 地址。</p><p>例如，配置 eth0 接口使用静态 IP 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.100</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">dns-nameservers 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure><br><h3 id="3-Ubuntu-分区号Sda的解释"><a href="#3-Ubuntu-分区号Sda的解释" class="headerlink" title="3 Ubuntu 分区号Sda的解释"></a>3 Ubuntu 分区号Sda的解释</h3><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Ftworld21/article/details/15707417?locationNum=8">参考原文</a></p></blockquote><p><strong>主分区</strong>：一块物理硬盘上可以被独立使用的一部分，一个硬盘最多可以有<strong>4个主分区</strong></p><p><strong>扩展分区</strong>：为了突破一个物理硬盘只能有4个分区的限制，引入了扩展分区。扩展分区和主分区的地位相当，但是扩展分区本身不能被直接使用，然而可以被继续划分成多个逻辑分区。</p><p><strong>逻辑分区</strong>：逻辑分区可以有任意多个，但是不能独立存在，多个连续的逻辑分区可做为一个扩展分区。一个硬盘只能有一个扩展分区。</p><p><strong>总结</strong>：也就是说，在一个物理硬盘上主分区和扩展分区加在一起<strong>最多仍然只有4个</strong>。但是扩展分区可以继续被划分成逻辑分区，而对多数用户而言，其实主分区和逻辑分区在使用上是没什么区别的。这样就达到了一快硬盘几乎可以有无限个分区的目的。</p><p><strong><code>LINUX</code>下分区实例分析：</strong></p><p>现在电脑上有一个<code>SCSI</code>硬盘，这时查看设备<code>ls /dev</code>，会发现有一个<code>sda</code>，如果是<code>IDE</code>硬盘，就是<code>hda</code>。</p><ul><li><p>分区方案一：4个主分区【这时候能看到：<code>sda,sda1,sda2,sda3,dsa4</code>】</p></li><li><p>分区方案二：一个主分区然后一个逻辑分区【这时候能看到：<code>sda,sda1,sda2,sda5</code>】</p><p>这里<code>sda</code>是物理硬盘，<code>sda1</code>是主分区，<code>sda2</code>是扩展分区，<code>sda5</code>是逻辑分区（正是因为必须保留4个数字给主分区和扩展分区使用，所以逻辑分区的数字必须从5开始）。</p></li><li><p>分区方案三：一个逻辑分区<br>这里能看到：sda，sda1，sda5<br>见到这些数字不要害怕，这样一解释就很容易理解了。如果有多块物理硬盘就会出现sdb，sdc</p></li></ul><br><h3 id="4-Ubuntu快捷键"><a href="#4-Ubuntu快捷键" class="headerlink" title="4 Ubuntu快捷键"></a>4 Ubuntu快捷键</h3><h4 id="4-1-操作系统快捷键和命令"><a href="#4-1-操作系统快捷键和命令" class="headerlink" title="4.1 操作系统快捷键和命令"></a>4.1 操作系统快捷键和命令</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Ctrl</span> + Alt + T 快速打开终端</span><br><span class="line"><span class="symbol">Ctrl</span> + Shift + W 关闭终端</span><br><span class="line"><span class="symbol">Ctrl</span> + L 快速清除终端屏幕</span><br><span class="line"></span><br><span class="line"><span class="symbol">Alt</span> + Tab 切换程序</span><br><span class="line"><span class="symbol">Alt</span> + Tab + Shift 逆向切换程序</span><br><span class="line"><span class="symbol">Alt</span> +<span class="built_in">F4</span> 关闭窗口</span><br><span class="line"></span><br><span class="line"><span class="symbol">Alt</span> + <span class="built_in">F2</span> 打开命令窗口，可输入命令启动应用程序，如gedit（文本编辑器）    </span><br><span class="line"><span class="symbol">Ctrl</span> + Alt + <span class="built_in">F7</span> 切换到命令行界面</span><br><span class="line"><span class="symbol">Ctrl</span> + Alt + <span class="built_in">F2</span> 切换到图形界面</span><br><span class="line"></span><br><span class="line"><span class="symbol">Ctrl</span> + Shift +C/V 终端的复制粘贴</span><br></pre></td></tr></table></figure><br><h4 id="4-2-Vim-命令和快捷键"><a href="#4-2-Vim-命令和快捷键" class="headerlink" title="4.2 Vim 命令和快捷键"></a>4.2 <code>Vim</code> 命令和快捷键</h4><ul><li><code>vim</code>或命令行下：鼠标左键选中即为复制， 按下中键（鼠标滚轮）即为粘贴</li></ul><h5 id="4-2-1-Vim-的三种模式"><a href="#4-2-1-Vim-的三种模式" class="headerlink" title="4.2.1 Vim 的三种模式"></a>4.2.1 Vim 的三种模式</h5><p>Vim 有三种主要模式，每种模式下有不同的功能：</p><ol><li><p>普通模式（Normal Mode）:</p><ul><li>默认模式，用于导航和操作文本。</li><li>按 <code>Esc</code> 键从其他模式返回普通模式。</li></ul></li><li><p>插入模式（Insert Mode）:</p><ul><li><p>用于输入和编辑文本。</p></li><li><p>从普通模式按 <code>i</code>、<code>a</code>、<code>o</code> 等键进入插入模式。</p></li></ul></li><li><p>命令模式（Command Mode）:</p><ul><li><p>用于执行保存、退出等命令。</p></li><li><p>从普通模式按 <code>:</code> 进入命令模式。</p></li></ul></li></ol><h5 id="4-2-2-Vim-的基本操作"><a href="#4-2-2-Vim-的基本操作" class="headerlink" title="4.2.2 Vim 的基本操作"></a>4.2.2 Vim 的基本操作</h5><p><strong>1 启动和退出 Vim</strong></p><p>启动 Vim:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file.txt</span><br></pre></td></tr></table></figure><ul><li><p>退出 Vim:</p></li><li><p>普通模式下按 <code>:q</code> 退出。</p></li><li><p>如果有未保存的更改，按 <code>:q!</code> 强制退出。</p></li><li><p>保存并退出：<code>:wq</code> 或 <code>:x</code>。</p></li></ul><p><strong>2 光标移动</strong></p><ul><li><p><strong>字符移动</strong>:</p></li><li><p><code>h</code>：左移。</p></li><li><p><code>j</code>：下移。</p></li><li><p><code>k</code>：上移。</p></li><li><p><code>l</code>：右移。</p></li><li><p><strong>单词移动</strong>:</p></li><li><p><code>w</code>：移动到下一个单词的开头。</p></li><li><p><code>b</code>：移动到上一个单词的开头。</p></li><li><p><strong>行移动</strong>:</p></li><li><p><code>0</code>：移动到行首。</p></li><li><p><code>$</code>：移动到行尾。</p></li><li><p><code>gg</code>：移动到文件开头。</p></li><li><p><code>G</code>：移动到文件末尾。</p></li><li><p><code>:n</code>：跳转到第 <code>n</code> 行（如 <code>:10</code> 跳转到第 10 行）。</p></li></ul><p><strong>3 文本编辑</strong></p><ul><li><p><strong>插入文本</strong>:</p></li><li><p><code>i</code>：在光标前插入。</p></li><li><p><code>a</code>：在光标后插入。</p></li><li><p><code>o</code>：在当前行下方插入新行。</p></li><li><p><code>O</code>：在当前行上方插入新行。</p></li><li><p><strong>删除文本</strong>:</p></li><li><p><code>x</code>：删除光标处的字符。</p></li><li><p><code>dd</code>：删除当前行。</p></li><li><p><code>dw</code>：删除从光标到下一个单词开头的文本。</p></li><li><p><strong>复制和粘贴</strong>:</p></li><li><p><code>yy</code>：复制当前行。</p></li><li><p><code>p</code>：粘贴到光标后。</p></li><li><p><code>P</code>：粘贴到光标前。</p></li><li><p><strong>撤销和重做</strong>:</p></li><li><p><code>u</code>：撤销上一次操作。</p></li><li><p><code>Ctrl + r</code>：重做。</p></li></ul><p><strong>4 搜索和替换</strong></p><ul><li><p><strong>搜索</strong>:</p></li><li><p><code>/pattern</code>：向下搜索 <code>pattern</code>。</p></li><li><p><code>?pattern</code>：向上搜索 <code>pattern</code>。</p></li><li><p>按 <code>n</code> 跳转到下一个匹配，<code>N</code> 跳转到上一个匹配。</p></li><li><p><strong>替换</strong>:</p></li><li><p><code>:s/old/new</code>：替换当前行的第一个匹配。</p></li><li><p><code>:s/old/new/g</code>：替换当前行的所有匹配。</p></li><li><p><code>:%s/old/new/g</code>：替换整个文件中的所有匹配。</p></li></ul><p><strong>5 保存和退出</strong></p><ul><li><code>:w</code>：保存文件。</li><li><code>:q</code>：退出 Vim。</li><li><code>:wq</code> 或 <code>:x</code>：保存并退出。</li><li><code>:q!</code>：强制退出，不保存更改。</li></ul><h5 id="4-2-3-Vim-的高级功能"><a href="#4-2-3-Vim-的高级功能" class="headerlink" title="4.2.3 Vim 的高级功能"></a>4.2.3 Vim 的高级功能</h5><p><strong>1 多窗口操作</strong></p><ul><li><p><strong>分割窗口</strong>:</p></li><li><p><code>:sp</code>：水平分割窗口。</p></li><li><p><code>:vsp</code>：垂直分割窗口。</p></li><li><p><strong>切换窗口</strong>:</p></li><li><p><code>Ctrl + w + h/j/k/l</code>：切换到左/下/上/右窗口。</p></li><li><p><strong>关闭窗口</strong>:</p></li><li><p><code>:q</code>：关闭当前窗口。</p></li></ul><p><strong>2 宏录制</strong></p><ul><li><p><strong>录制宏</strong>:</p></li><li><p><code>q</code> + 字母（如 <code>a</code>）：开始录制宏。</p></li><li><p>执行操作。</p></li><li><p><code>q</code>：停止录制。</p></li><li><p><strong>执行宏</strong>:</p></li><li><p><code>@</code> + 字母（如 <code>a</code>）：执行录制的宏。</p></li></ul><p><strong>3 插件管理</strong></p><ul><li>使用插件管理器（如 <code>vim-plug</code>）安装和管理插件。</li></ul><p>示例：</p><p><img src="https://pics4.baidu.com/feed/50da81cb39dbb6fd03aa2d6446669517962b3754.jpeg@f_auto?token=984c08decaf6a3a501d7ec6da0347bbb" alt="img"></p><ul><li>安装插件：<code>:PlugInstall</code></li></ul><h5 id="4-2-4-Vim-的实际应用场景"><a href="#4-2-4-Vim-的实际应用场景" class="headerlink" title="4.2.4 Vim 的实际应用场景"></a>4.2.4 Vim 的实际应用场景</h5><p><strong>1 编辑配置文件</strong></p><ul><li>使用 Vim 编辑系统配置文件（如 <code>/etc/nginx/nginx.conf</code>）。</li></ul><p>示例：</p><p><img src="https://pics2.baidu.com/feed/342ac65c10385343903cd857dc518e71cb8088a2.jpeg@f_auto?token=7f0591f4b506bda1a605757c5f1db56c" alt="img"></p><p><strong>2 编写代码</strong></p><ul><li>使用 Vim 编写代码，结合插件（如 <code>YouCompleteMe</code>）实现代码补全。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim main.py</span><br></pre></td></tr></table></figure><p><strong>3 日志分析</strong></p><ul><li>使用 Vim 查看和分析日志文件。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure><p><strong>4 批量文本处理</strong></p><ul><li>使用 Vim 的搜索替换功能批量修改文本。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/old/new/g</span><br></pre></td></tr></table></figure><h5 id="4-2-5-Vim-使用示例"><a href="#4-2-5-Vim-使用示例" class="headerlink" title="4.2.5 Vim 使用示例"></a>4.2.5 Vim 使用示例</h5><p><strong>示例 1: 编辑文件并保存</strong></p><p>打开文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file.txt</span><br></pre></td></tr></table></figure><ol><li>进入插入模式并编辑内容：</li></ol><ul><li>按 <code>i</code> 进入插入模式。</li><li>输入文本。</li></ul><ol><li>保存并退出：</li></ol><ul><li>按 <code>Esc</code> 返回普通模式。</li><li>输入 <code>:wq</code> 保存并退出。</li></ul><p><strong>示例 2: 搜索和替换</strong></p><p>打开文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file.txt</span><br></pre></td></tr></table></figure><ol><li>搜索 <code>hello</code>：</li></ol><ul><li>按 <code>/</code>，输入 <code>hello</code>，按 <code>Enter</code>。</li><li>按 <code>n</code> 跳转到下一个匹配。</li></ul><ol><li>替换 <code>hello</code> 为 <code>world</code>：</li></ol><ul><li>输入 <code>:%s/hello/world/g</code>，按 <code>Enter</code>。</li></ul><p><strong>示例 3: 多窗口操作</strong></p><p>打开文件并水平分割窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file.txt:sp file2.txt</span><br></pre></td></tr></table></figure><ol><li>切换窗口：</li></ol><ul><li>按 <code>Ctrl + w + j</code> 切换到下方窗口。</li></ul><ol><li>关闭窗口：</li></ol><ul><li>输入 <code>:q</code> 关闭当前窗口。</li></ul><br><h3 id="5-通用终端命令"><a href="#5-通用终端命令" class="headerlink" title="5 通用终端命令"></a>5 通用终端命令</h3><blockquote><p><code>Ubuntu</code>为<code>Linux</code>内核的，故<code>Linux</code>命令均可用于<code>Ubuntu</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">chase@chaseVM:~S   ----- <span class="comment">#用户名@计算机名:绝对路径$</span></span><br><span class="line"></span><br><span class="line">su ----- 获取root权限【<span class="built_in">exit</span>推出 | Ctrl+D退出】</span><br><span class="line"><span class="built_in">sudo</span> xxx ----- 以root权限执行</span><br><span class="line"></span><br><span class="line">dpkg -s &lt;软件包名&gt; ----- 验证某个软件包是否已经安装【dpkg -s vim】</span><br><span class="line">apt list --installed ----- 列出apt已安装的程序及依赖</span><br><span class="line">apt list --installed | grep program_name ----- 使用grep进行过滤</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 使用模糊搜索 *匹配任意模糊位，？代表一个模糊位</span></span><br><span class="line"><span class="built_in">pwd</span>:打印工作目录</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示经过筛选后的进程</span></span><br><span class="line">ps -Al|grep Linux </span><br><span class="line"><span class="built_in">kill</span> -9 [进程号] <span class="comment">#结束进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看磁盘使用情况【人类可读的格式显示，如KB、MB、GB等】</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><br><h2 id="二-Linux简介"><a href="#二-Linux简介" class="headerlink" title="二 Linux简介"></a>二 Linux简介</h2><h3 id="1-系统介绍"><a href="#1-系统介绍" class="headerlink" title="1 系统介绍"></a>1 系统介绍</h3><ul><li>开源的发行版本</li><li>Linux系统族谱</li></ul><p><strong>知名Linux系统：</strong> Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等</p><p><strong>为什么要学习Linux？</strong></p><ul><li>Linux系统在服务器市场的占有率（2016年）</li></ul><p>世界上500个最快的超级计算机90％以上运行Linux发行版或变种，包括最快的前10名超级计算机运行的都是基于Linux内核的操作系统。Linux也广泛应用在嵌入式系统上，如手机（Mobile Phone）、平板电脑（Tablet）、路由器（Router）、电视（TV）和电子游戏机等。在移动设备上广泛使用的Android操作系统就是创建在Linux内核之上。</p><br><p><strong>Linux的优点：</strong></p><ul><li>开源免费、可自行修改，对其他开源软件兼容性良好</li><li>多用户访问友好、权限管理方便快捷</li><li>内存管理优秀，可以长期连续运行，系统占用内存低</li><li>工具功能库完善，部署安装方便</li></ul><br><p><strong>Windows下Linux虚拟机的安装与启动【子系统方法】</strong>【更推荐VM虚拟机的方式】</p><p>首先开启开发人员模式【这种方式在windows上比较兼容，运行速度快，占用内存小】，然后启用子系统功能【设置-应用-程序和功能-启用或关闭windows功能】</p><p>上面的设置打开之后，打开win10的微软应用商店，再搜索Ubuntu，选择Ubuntu18.04 LTS【Long Time Support】</p><blockquote><p>LTS表示长期支持版本，不选择20.04是因为该版本太新，一些库可能支持的还不是那么好。另外可能有一些潜在的缺陷，18.04则已经运行两三年了，环境相对更加稳定，支持的库更稳定和丰富</p></blockquote><p>点击18.04后，进入详情页面；点击获取，即可下载安装该虚拟机；安装完成之后，即可在开始菜单中</p><p>看到图标，点击图标即可启动Ubuntu子系统</p><blockquote><p>出现install wrong已解决<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17576885/article/details/126707239">参考</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 1：解决不能正常启动</span><br><span class="line">wsl.exe –update：进行升级</span><br></pre></td></tr></table></figure></blockquote><br><h3 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2 基本命令"></a>2 基本命令</h3><h4 id="2-1-ls命令"><a href="#2-1-ls命令" class="headerlink" title="2.1 ls命令"></a>2.1 ls命令</h4><p>命令<code>ls</code>是<code>list</code>的缩写，其作用是列出指定位置的文件和文件夹【如果没有指定，默认是列出当前位置的文件或者文件夹】</p><p>可通过字体颜色和背景颜色区分是否未文件夹和权限，如：</p><ul><li>白色字体为文件</li><li>蓝色字体为文件夹</li><li>绿色字体为可执行</li><li>红色字体一般为压缩包</li><li>绿色背景为拥有全部权限</li><li>蓝色背景为拥有部分权限</li></ul><p>常用的参数有</p><h5 id="a：列出所有的文件或者文件夹"><a href="#a：列出所有的文件或者文件夹" class="headerlink" title="-a：列出所有的文件或者文件夹"></a>-a：列出所有的文件或者文件夹</h5><p>在Linux系统里面，以 <code>.</code> 开头的文件或者文件夹，一般会被默认视为隐藏文件。如果想要查看这些隐藏文件或者文件夹，最好使用<code>-a</code>参数</p><h5 id="l：列出详细信息"><a href="#l：列出详细信息" class="headerlink" title="-l：列出详细信息"></a>-l：列出详细信息</h5><p>默认<code>ls</code>只显示名字，并不显示详细信息。<code>-l</code>参数除了会显示名称以外，还会显示文件的权限、所属用户、分组、大小、修改日期</p><ul><li><code>d</code>开头：文件夹；<code>p</code>开头：管道</li><li>紧接着的3x3个位置为root用户权限、当前用户权限、普通其他用户权限。rwx分别为读、写、执行</li><li>结合<code>-a</code>使用：<code>ls -al</code></li><li><code>l</code>缩写自：long list format或者long</li></ul><h5 id="h：增加可读性"><a href="#h：增加可读性" class="headerlink" title="-h：增加可读性"></a>-h：增加可读性</h5><p>默认文件是按照字节为单位显示大小的。<code>-h</code>参数会使得附带K、M、G、T等大小后缀【K表示千字节、M表示兆字节、G表示1024兆、T表示1024G】</p><ul><li>虽然精准度下降了，但是更容易阅读</li><li>结合<code>-a</code>使用：<code>ls -ah</code></li><li>缩写自：human readable</li></ul><h5 id="R：递归访问"><a href="#R：递归访问" class="headerlink" title="-R：递归访问"></a>-R：递归访问</h5><p>默认是显示当前目录下的文件和文件夹。R参数后，如果当前目录下有其他文件夹，则会将该文件夹下面的文件和文件夹也显示出来</p><ul><li>R缩写自：recursion 递归</li><li><code>-r</code>: 反向排序输出</li></ul><h5 id="Q：文件名用双引号包裹"><a href="#Q：文件名用双引号包裹" class="headerlink" title="-Q：文件名用双引号包裹"></a>-Q：文件名用双引号包裹</h5><p>该参数是为了防止某些文件或者文件夹的末尾是空格字符。这样可以通过双引号，看到文件名实际的长度</p><p>【Q缩写自：quotation mark】</p><h5 id="t：按时间排序"><a href="#t：按时间排序" class="headerlink" title="-t：按时间排序"></a>-t：按时间排序</h5><p>按文件最近的一次修改时间排序【t：time】</p><br><h4 id="2-2-echo命令"><a href="#2-2-echo命令" class="headerlink" title="2.2 echo命令"></a>2.2 echo命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示字符串</span></span><br><span class="line"><span class="built_in">echo</span> hello world</span><br><span class="line"><span class="built_in">echo</span> “hello world”</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示转义字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;\\&#x27;</span> <span class="comment">#输出\\</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\\&quot;</span> <span class="comment">#输出\</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示换行/不换行【没有-e，单独\n无效】</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;换行\n&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;不换行\c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示原样字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$PATH&#x27;</span>=<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示命令结果【用于将程序直接结果导入文本文件】</span></span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">date</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&gt;将左边命令的输出，输入到右边的文件或者命令【如果右边的文件不存在，则创建一个】</span></span><br><span class="line"><span class="comment">#&gt;&gt;将左边命令的输出，追加到右边的文件【如果右边的文件不存在，则创建一个】</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;d&quot;</span> &gt; 1.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span> &gt;&gt; 1.txt <span class="comment">#【默认会换行】</span></span><br></pre></td></tr></table></figure><br><h4 id="2-3-cd命令"><a href="#2-3-cd命令" class="headerlink" title="2.3 cd命令"></a>2.3 cd命令</h4><p>cd 目标路径【change directory】路径可以是绝对路径，也可以是相对路径。除此之外，还有一些特别的符号：</p><ul><li><code>.</code>表示当前目录</li><li><code>..</code>表示上一级目录（也就是父目录）</li><li><code>~</code>表示当前用户的用户目录【在root用户和普通用户条件下，符号~是有不同含义的】【Linux磁盘不分区】<ul><li>普通用户<code>~</code>一般是<code>/home/</code>用户名文件夹</li><li>root用户对应的<code>~</code>是<code>/root</code>文件夹</li></ul></li></ul><h4 id="2-4-head命令"><a href="#2-4-head命令" class="headerlink" title="2.4 head命令"></a>2.4 head命令</h4><blockquote><p>默认显示文件前十行内容</p></blockquote><ul><li><code>-c n</code>：显示头部的指定n个字符【char】</li><li><code>-n x</code>：显示头部的指定的x行</li><li><code>-v</code>：显示文件名【配合脚本遍历输出文件内容】</li><li><code>-q</code>：不显示文件名</li></ul><h4 id="2-5-tail命令"><a href="#2-5-tail命令" class="headerlink" title="2.5 tail命令"></a>2.5 tail命令</h4><p>一些简单命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清空窗口</span></span><br><span class="line">clear</span><br></pre></td></tr></table></figure><p><code>tail</code>命令默认显示尾部十行，<code>-c -n -v -q</code>同head命令，以下是另外的一些：</p><ul><li><code>-f</code>：可以不断的更新尾部内容【在另一个窗口修改文件，会实时显示】</li></ul><br><h4 id="2-6-ps命令"><a href="#2-6-ps命令" class="headerlink" title="2.6 ps命令"></a>2.6 ps命令</h4><ul><li>所有进程都是<code>init</code>进程的子进程或者孙进程</li><li>默认显示由自己创建的进程</li><li>ps只显示ps执行瞬间进程的状态</li></ul><p>常用参数：</p><ul><li><code>-Al</code>：显示所有进程的详情和进程名称【缩写自All long format】<ul><li>tty：字符交互环境，即串口设备</li><li><code>-Al</code>关注【PRI进程优先级，越小越好；PPID父进程；UID用户ID，0为root用户】</li></ul></li><li><code>-aux</code>：显示所有进程和其启动命令【cmd带参数；STAT状态，s为sleep，R为running】</li><li><code>-au</code>：显示所有进程</li></ul><p><strong>数值项说明</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">USER    进程所属用户</span><br><span class="line">UID     进程所属用户ID</span><br><span class="line">PID     进程ID</span><br><span class="line">PPID     父进程ID</span><br><span class="line"></span><br><span class="line">C/%CPU     CPU占用率</span><br><span class="line">%MEM     内存占用率</span><br><span class="line">VSZ     虚拟内存占用大小（其中部分可能在交换文件中）</span><br><span class="line">RSS     实际内存占用大小（RAM占用的大小）</span><br><span class="line">TTY     对应的控制台设备【由哪一个控制台设备启动】开始此进程的终端</span><br><span class="line">TIME     进程执行的时间</span><br><span class="line">START    进程开始执行的世界</span><br><span class="line">COMMAND 进程启动执行的命令（带参数）</span><br><span class="line">CMD     进程启动执行的命令（不带参数）[启动的程序名称]</span><br><span class="line">S/STAT     状态 S休眠 R运行 D阻塞 Z僵尸进程 T暂停</span><br><span class="line">F       内核分配给进程的系统标记</span><br><span class="line">PRI     优先级 数值越低，优先级越高，甚至可能为负数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">STIME 进程启动时的系统时间</span><br><span class="line">NI：用来参与决定优先级</span><br><span class="line">ADDR：进程的内存地址</span><br><span class="line">SZ：所需交换空间的大致大小</span><br><span class="line">WCHAN：进程休眠的内核函数地址</span><br></pre></td></tr></table></figure><br><h4 id="2-7-cp命令"><a href="#2-7-cp命令" class="headerlink" title="2.7 cp命令"></a>2.7 cp命令</h4><p>copy复制的缩写，命令用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [参数] 源文件/文件夹 目标文件/文件夹 <span class="comment">#【默认不能复制文件夹】</span></span><br></pre></td></tr></table></figure><ul><li><code>[]</code>表示可选</li><li><code>sudo</code>命令提权</li><li><code>mkdir</code>创建文件夹</li></ul><p><strong>常用参数：</strong></p><ul><li><p><code>-a</code>：带属性复制【此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于<code>dpR</code>参数组合】【d复制时保留链接；p为带权限复制；R为递归】</p></li><li><p><code>-d</code>：复制时保留链接【这里所说的链接相当于Windows系统中的快捷方式】</p></li><li><p><code>-f</code>：强制覆盖【覆盖已经存在的目标文件而不给出提示】【Ubuntu默认是强制覆盖】</p></li><li><p><code>-i</code>：覆盖提示【与<code>-f</code>选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答<code>y</code>时目标文件将被覆盖】</p></li><li><p><code>-p</code>：带权限复制【除复制文件的内容外，还把修改时间和访问权限也复制到新文件中】</p></li><li><p><code>-r</code>：文件夹复制【若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件】</p></li><li><p><code>-l</code>：创建链接【不复制文件，只是生成链接文件【只在部分系统有效，在Ubuntu下没有效果】</p><br></li></ul><h4 id="2-8-rm命令"><a href="#2-8-rm命令" class="headerlink" title="2.8 rm命令"></a>2.8 rm命令</h4><p>命令<code>remove</code>的缩写，删除文件或文件夹【需要参数】</p><p><strong>常用参数：</strong></p><ul><li><code>-i</code>：删除确认：每个被删除的文件都需要确认</li><li><code>-f</code>：强制删除：无需确认就会删除指定的文件</li><li><code>-r</code>：目录删除：删除指定文件夹下的所有文件和子文件夹【<code>-ir</code>可组合使用】</li></ul><p>​<br></p><h4 id="2-9-chmod命令"><a href="#2-9-chmod命令" class="headerlink" title="2.9 chmod命令"></a>2.9 chmod命令</h4><h5 id="2-9-1-基本介绍"><a href="#2-9-1-基本介绍" class="headerlink" title="2.9.1 基本介绍"></a>2.9.1 基本介绍</h5><p><code>chmod</code> 命令是 Unix 和 Linux 系统中的一个用于修改文件或目录的访问权限的命令。它可以控制文件或目录的读、写、执行权限，以及文件或目录的所有者、所属组等信息。</p><p><strong>语法：</strong><code>chmod [选项] [模式] 文件或目录</code></p><p><strong>参数：</strong></p><ul><li><code>u</code>：表示所有者</li><li><code>g</code>：表示所属组</li><li><code>o</code>：表示其他用户</li><li><code>a</code>：表示所有用户</li><li><code>r</code>：表示读权限</li><li><code>w</code>：表示写权限</li><li><code>x</code>：表示执行权限</li><li><code>+</code>：表示增加权限</li><li><code>-</code>：表示减少权限</li><li><code>=</code>：表示赋予指定权限</li></ul><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者【Owner】、用户组【Group】、其它用户【Other Users】，以下几点需注意：</p><ul><li>只有文件所有者和超级用户root可以修改文件或目录的权限</li><li>可以使用绝对模式【八进制数字模式】或符号模式指定文件的权限，而使用权限则为所有使用者</li><li>符号模式与绝对模式的关系如下图</li></ul><p><img src="./2-1.png"></p><h5 id="2-9-2-符号模式"><a href="#2-9-2-符号模式" class="headerlink" title="2.9.2 符号模式"></a>2.9.2 符号模式</h5><ul><li>使用符号模式可以设置多个项目：who【用户类型】、operator【操作符】和 permission【权限】，每个项目的设置可以用逗号隔开</li><li>命令 chmod 将修改 <code>who</code> 【指定是用户类型】对文件的访问权限，用户类型由一个或者多个字母在 <code>who</code> 的位置来说明。</li></ul><p>用户类型参数：</p><table><thead><tr><th>who</th><th>用户类型</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>user</td><td>文件所有者</td></tr><tr><td>g</td><td>group</td><td>文件所有者所在组</td></tr><tr><td>o</td><td>others</td><td>所有其他用户</td></tr><tr><td>a</td><td>all</td><td>所有用户，和ugo使用一样</td></tr></tbody></table><p>操作符参数：</p><table><thead><tr><th>Operator</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>为指定的用户类型增加权限</td></tr><tr><td>-</td><td>为指定的用户类型去除权限</td></tr><tr><td>=</td><td>直接重置用户类型的所有权限</td></tr></tbody></table><p>符号模式参数：</p><table><thead><tr><th>Permission</th><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>读</td><td>设置为可读权限</td></tr><tr><td>w</td><td>写</td><td>设置为可写权限</td></tr><tr><td>x</td><td>执行权限</td><td>设置为可执行权限</td></tr><tr><td>X</td><td>特殊执行权限</td><td>只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td>s</td><td>setuid/gid</td><td>当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td>t</td><td>粘贴位</td><td>设置粘贴位【只有超级用户可以设置该位，只有文件所有者u可以使用该位】</td></tr></tbody></table><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a=rwx file     <span class="comment">#表示所有用户都可读写执行</span></span><br><span class="line"><span class="built_in">chmod</span> a+r file        <span class="comment">#表示给所有用户加上可读权限</span></span><br><span class="line"><span class="built_in">chmod</span> ugo+r file    <span class="comment">#与a+r的相同</span></span><br><span class="line"><span class="built_in">chmod</span> u+x file        <span class="comment">#表示给文件所有者加上执行权限</span></span><br></pre></td></tr></table></figure><h5 id="2-9-3-八进制语法"><a href="#2-9-3-八进制语法" class="headerlink" title="2.9.3 八进制语法"></a>2.9.3 八进制语法</h5><p><code>chmod</code> 命令可以使用八进制数来指定权限。</p><p>文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p><table><thead><tr><th>num</th><th>权限</th><th>对应符号</th><th>二进制</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td><td>111</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td><td>110</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td><td>101</td></tr><tr><td>4</td><td>只读</td><td>r–</td><td>100</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td><td>011</td></tr><tr><td>2</td><td>只写</td><td>-w-</td><td>010</td></tr><tr><td>1</td><td>只执行</td><td>–x</td><td>001</td></tr><tr><td>0</td><td>无</td><td>—</td><td>000</td></tr></tbody></table><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法为：</span></span><br><span class="line"><span class="built_in">chmod</span> abc file</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中a,b,c各为一个数字，分别表示User、Group、及Other的权限，然后rwx分别对应421，若要rwx属性则为4+2+1=7，rw-则为4+2=6等等</span></span><br><span class="line"><span class="built_in">chmod</span> 777 file     <span class="comment">#表示User、Group、及Other的权限都设为rwx</span></span><br><span class="line"><span class="built_in">chmod</span> 764 file    <span class="comment">#表示User、Group、及Other的权限分别为rwx、rw-、r--</span></span><br></pre></td></tr></table></figure><h5 id="2-9-4-接四位数字的情况"><a href="#2-9-4-接四位数字的情况" class="headerlink" title="2.9.4 接四位数字的情况"></a>2.9.4 接四位数字的情况</h5><p>有时，对于特殊需求提供一位特殊文件权限标识位。同理，正常的<code>rwx</code>，现有额外的一位八进制数，其现设为三位二进制a、b、c依序组成。</p><ul><li>a代表<code>setuid</code>位：如果该位为1，则表示设置<code>setuid</code></li><li>b代表<code>setgid</code>位：如果该位为1，则表示设置<code>setgid</code></li><li>c代表<code>sticky</code>位：如果该位为1，则表示设置<code>sticky</code></li></ul><blockquote><p>如6755，对应权限为 <code>-rwsr-sr-x</code></p></blockquote><p><code>setuid</code> 意为：设置使文件在执行阶段具有文件所有者的权限。比如<code>/usr/bin/passwd</code>，如果一般用户执行该文件，则在执行过程中，该文件可以获得root权限，从而可以更改用户的密码。</p><p><code>setgid</code> 意为：该权限只对目录有效。目录被设置该位后，任何用户在此目录下创建的文件都具有和该目录所属的组相同的组。</p><p><code>sticky bit</code> 意为：该位可以理解为防删除位【一个文件是否可以被某用户删除，主要取决于该文件所属的组是否对该用户具有写权限】</p><ul><li><p>如果没有写权限，则这个目录下的所有文件都不能被删除，同时也不能添加新的文件</p></li><li><p>如果希望用户能够添加文件但同时不能删除文件，则可以对文件使用<code>sticky bit</code>位。</p></li><li><p>设置该位后，就算用户对目录具有写权限也不能删除该文件。例如，如果在rwx=777的前提额外想要使文件拥有sticky bit与setgid，即使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> 3777 【文件】</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-9-5-权限修改示例"><a href="#2-9-5-权限修改示例" class="headerlink" title="2.9.5 权限修改示例"></a>2.9.5 权限修改示例</h5><p>问题1：使用echo命令输出内容到某个文件时，系统提示我们权限不够，无法执行这个操作。</p><p>分析：对文件进行写入操作，如果目标文件的写入权限并不属于当前用户或当前用户所在的用户组，就会出现权限不够的错误。在这种情况下，即使我们是通过sudo命令以超级用户的权限运行echo命令，也无法绕过文件的权限设置。</p><p>解决：</p><ol><li>修改文件的权限：【chmod命令修改文件的权限】例如，<code>chmod +w filename</code></li><li>切换用户：尝试切换为拥有相应权限的用户。例如，可以使用su命令切换用户，或者使用sudo命令以超级用户的权限运行echo命令</li><li>使用重定向符号：除了echo命令外，还可以使用重定向符号&gt;来输出内容到文件中。这种方式相对更加灵活，且不会受到文件权限的限制。</li></ol><br><h4 id="2-10-chown"><a href="#2-10-chown" class="headerlink" title="2.10 chown"></a>2.10 chown</h4><p>chown 命令是 Unix 和 Linux 系统中的一个用于修改文件或目录的所属用户和组的命令。它可以将文件或目录的所有权转移给其他用户或组，只有<strong>文件的所有者</strong>或<strong>超级用户</strong>才能使用这个命令进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown [选项] [所有者][:[组]] 文件或目录</span></span><br><span class="line"><span class="comment"># change owner</span></span><br><span class="line"><span class="comment"># -R：递归处理，将目录下的所有文件和子目录的所有权都修改为指定的用户和组。</span></span><br><span class="line"><span class="comment"># -f：不显示错误信息。</span></span><br><span class="line"><span class="comment"># -v：显示详细的处理信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将文件的所有权修改为指定用户：</span></span><br><span class="line"><span class="built_in">chown</span> username file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文件的所有权修改为指定用户和组：</span></span><br><span class="line"><span class="built_in">chown</span> username:group file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#将目录下的所有文件和子目录的所有权都修改为指定用户和组：</span></span><br><span class="line"><span class="built_in">chown</span> -R username:group directory</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>chown 命令默认只修改文件或目录的所有者，如果要修改组，需要使用 <code>:</code> 分隔符指定组名。</li></ul><br><h4 id="2-11-其他命令【🔺】"><a href="#2-11-其他命令【🔺】" class="headerlink" title="2.11 其他命令【🔺】"></a>2.11 其他命令【🔺】</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#【查看test.cpp内容】</span></span><br><span class="line"><span class="built_in">cat</span> test.cpp </span><br><span class="line"></span><br><span class="line"><span class="comment">#文件/文件夹改变权限【change权限，r为递归子文件和目录】</span></span><br><span class="line"><span class="comment">#6：110(提权/改组) 7：111（读写执行） 111（当前用户） 111（其他用户）</span></span><br><span class="line"><span class="built_in">chmod</span> [-r] 6777（八进制数） </span><br><span class="line"></span><br><span class="line"><span class="comment">#vim编辑器</span></span><br><span class="line"><span class="comment">#按 i 键进入插入模式，可以在当前光标位置插入文本</span></span><br><span class="line"><span class="comment">#按 Esc 键回到普通模式，可以使用各种快捷键来操作文本</span></span><br><span class="line"><span class="comment">#在普通【命令模式】：</span></span><br><span class="line"><span class="comment">####U：撤销操作</span></span><br><span class="line"><span class="comment">####Ctrl+R：恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在普通模式下，按 : 键进入【命令行模式】，可以在底部输入并执行各种 Ex 命令</span></span><br><span class="line"><span class="comment">## 输入 :w 命令，可以保存文件，但不退出 Vim</span></span><br><span class="line"><span class="comment">## 输入 :q 命令，可以退出 Vim，但如果文件有修改，会提示你保存或放弃</span></span><br><span class="line"><span class="comment">## 输入 :wq 命令，可以保存文件并退出 Vim</span></span><br><span class="line"><span class="comment">## 输入 :q! 命令，可以放弃文件的修改并退出 Vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出文件夹中的10个文件名</span></span><br><span class="line"><span class="built_in">ls</span> | <span class="built_in">head</span> -n 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找文件</span></span><br><span class="line">whereis su</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立文件链接</span></span><br><span class="line"><span class="built_in">ln</span> -s test.txt test1.txt <span class="comment">#-s:软链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看网络ip</span></span><br><span class="line">ipconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看进程间通信相关的信息</span></span><br><span class="line">ipcs -m    <span class="comment">#共享内存</span></span><br><span class="line">ipcs -s <span class="comment">#信号量</span></span><br><span class="line">ipcs -q <span class="comment">#消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看函数定义</span></span><br><span class="line">man <span class="keyword">select</span> <span class="comment">#查看select函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改最后修改日期</span></span><br><span class="line"><span class="built_in">touch</span> 文件名</span><br></pre></td></tr></table></figure><br><h3 id="3-常见错误【🔺】"><a href="#3-常见错误【🔺】" class="headerlink" title="3 常见错误【🔺】"></a>3 常见错误【🔺】</h3><h4 id="3-1-镜像源问题"><a href="#3-1-镜像源问题" class="headerlink" title="3.1 镜像源问题"></a>3.1 镜像源问题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br></pre></td></tr></table></figure><p>解决：现无法定位问题，是因为找不到源镜像导致的，只需要将/etc/apt/路径下的source.list文件内容改成对应的源镜像【<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuan2019035055/article/details/126981876">参考</a>】</p><br><h4 id="3-2-Systemd与service"><a href="#3-2-Systemd与service" class="headerlink" title="3.2 Systemd与service"></a>3.2 Systemd与service</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System has not been booted with systemd as init system (PID 1). Can<span class="string">&#x27;t operate.</span></span><br></pre></td></tr></table></figure><p>解决：目前的理解是，这是两套相互对应的命令体系【<a target="_blank" rel="noopener" href="https://blog.csdn.net/ken2232/article/details/132529761">参考</a>】</p><br><h4 id="3-3-VS中突发的未知错误"><a href="#3-3-VS中突发的未知错误" class="headerlink" title="3.3 VS中突发的未知错误"></a>3.3 VS中突发的未知错误</h4><p>问题描述：<code>VS2022</code> 远程编辑调试Linux上的代码，不知道动了哪儿，出现大量标红，且出错无意义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">错误(活动)    E0020	未定义标识符 <span class="string">&quot;clnt_sock&quot;</span>	ChatApp	</span><br><span class="line">错误(活动)    E0020	未定义标识符 <span class="string">&quot;message&quot;</span>	ChatApp	</span><br><span class="line">错误(活动)    E0077	此声明没有存储类或类型说明符	ChatApp	</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解决：此类错误一般可能是缺失了括号<code>&#123;</code>等标识符，导致的编译错误。</p><br><br><h2 id="三-Linux开发入门"><a href="#三-Linux开发入门" class="headerlink" title="三 Linux开发入门"></a>三 Linux开发入门</h2><h3 id="1-开发环境搭建"><a href="#1-开发环境搭建" class="headerlink" title="1 开发环境搭建"></a>1 开发环境搭建</h3><h4 id="1-1-gcc安装"><a href="#1-1-gcc安装" class="headerlink" title="1.1 gcc安装"></a>1.1 gcc安装</h4><ol><li>设置root密码：<code>sudo passwd root</code>【需要记住该密码，即用户名为root，密码为此】</li><li>进入root账户：<code>su</code> 【pwd、exit】</li><li>安装编译器：<code>apt-get install gcc g++</code>【gcc调用g++来编译c++】【980721/xin——】</li><li>查看当前的gcc、g++版本 【<code>gcc --version</code> | <code>g++ --version</code>】</li><li>验证一下：<code>g++ -o test main.cpp</code>【编译cpp文件】</li><li>运行：<code>./test</code>【可运行文件】</li></ol><br><h4 id="1-2-ssh服务的安装"><a href="#1-2-ssh服务的安装" class="headerlink" title="1.2 ssh服务的安装"></a>1.2 ssh服务的安装</h4><p>该服务用户后续的代码编写和远程运行、调试</p><p>步骤：</p><ol><li><p>安装服务程序：<code>sudo apt install openssh-server</code>【开源免费】</p></li><li><p>安装客户端程序：<code>sudo apt install openssh-client</code>【客户端有一个密钥生成器】</p></li><li><p>修改配置文件【<code>su etc/ssh/sshd_config</code> / <code>su etc/sshd_config</code>】【windows子系统方式位置：<code>C:\Users\Stell\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04LTS_79rhkp1fndgsc\LocalState\rootfs\etc\ssh</code>】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LoginGraceTime 2m</span><br><span class="line"><span class="comment">#可能要该</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line">UsePAM <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">X11Forwarding <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">PrintMotd no</span><br><span class="line"></span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line"></span><br><span class="line">Subsystem    sftp /usr/lib/openssh/sftp-server</span><br></pre></td></tr></table></figure></li><li><p>子Linux系统启动服务：<code>C:\Windows\System32\bash.exe -c &quot;sudo service ssh start&quot;</code></p><ul><li>Unbuntu虚拟机启动ssh服务：<code>sudo service ssh</code></li><li>在 linux 启动和查看ssh服务，且修改sshd配置后重启一次VM【<code>service ssh status</code> | <code>service ssh start</code>】</li><li>VM网络一般使用桥接模式，即本机和虚拟机ip一致；若使用NAT模式，需要使用<code>ifconfig</code>查得实际ip</li><li>此处：用户名<code>root</code>；密码<code>xin980721</code></li></ul></li></ol><blockquote><p>【如何开机自启动服务？】</p><p>建立一个bat文件，将上面这个命令写入其中，然后放入文件夹【开机启动项：<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>或者<code>C:\Users\你的用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>】</p></blockquote><br><h4 id="1-3-相关问题"><a href="#1-3-相关问题" class="headerlink" title="1.3 相关问题"></a>1.3 相关问题</h4><h5 id="1-3-1-gcc安装时出现的锁问题"><a href="#1-3-1-gcc安装时出现的锁问题" class="headerlink" title="1.3.1 gcc安装时出现的锁问题"></a>1.3.1 gcc安装时出现的锁问题</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@chase-virtual-machine:/home/chase# apt-get install gcc g++</span><br><span class="line">E: 无法获得锁 /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)</span><br><span class="line">E: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？</span><br></pre></td></tr></table></figure><p>此错误表明系统中有其他进程正在占用软件包管理器的锁（如 <code>apt</code>、<code>dpkg</code> 或自动更新服务）。常见原因包括：</p><ol><li>另一个 <code>apt</code> 或 <code>dpkg</code> 进程正在运行。</li><li>锁文件未正确释放（如进程被强制终止）。</li><li>后台自动更新服务（如 <code>unattended-upgrades</code>）正在运行。</li></ol><hr><p><strong>解决方法</strong></p><p><strong>1. 检查并终止占用进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否有正在运行的 apt/dpkg 进程</span></span><br><span class="line">ps aux | grep -E <span class="string">&#x27;apt|dpkg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发现相关进程（如 apt-get、apt），强制终止它们</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">kill</span> -9 &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><p><strong>2. 删除锁文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 apt 和 dpkg 的锁文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/apt/lists/lock</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure><p><strong>3. 清除缓存并重试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理软件包缓存</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次尝试安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc g++</span><br></pre></td></tr></table></figure><p><strong>4. 检查后台自动更新</strong></p><p>如果问题反复出现，可能是后台自动更新服务导致的。可以临时禁用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 unattended-upgrades 服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop unattended-upgrades</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用自动更新（可选）</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> unattended-upgrades</span><br></pre></td></tr></table></figure><br><h5 id="1-3-2-gcc安装时出现的没有安装候选"><a href="#1-3-2-gcc安装时出现的没有安装候选" class="headerlink" title="1.3.2 gcc安装时出现的没有安装候选"></a>1.3.2 gcc安装时出现的没有安装候选</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E：Package <span class="string">&#x27;gcc&#x27;</span> <span class="built_in">has</span> <span class="keyword">no</span> installation candidate</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：升级 apt-get，后再次尝试安装。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><br><h5 id="1-3-2-VS2022连接远程Linux服务器报错：主机名与端口不存在"><a href="#1-3-2-VS2022连接远程Linux服务器报错：主机名与端口不存在" class="headerlink" title="1.3.2  VS2022连接远程Linux服务器报错：主机名与端口不存在"></a>1.3.2 VS2022连接远程Linux服务器报错：主机名与端口不存在</h5><p>先说结论：错误原因是混淆了主机名和用户名【真nmd】。但是，之后的排查顺序需要注意积累。</p><blockquote><p>详细步骤参考此处：<a target="_blank" rel="noopener" href="https://blog.huochengrm.cn/gz/11979.html">SSH连接报错解决方案探析，SSH连接常见报错原因分析与高效解决指南</a></p></blockquote><p><strong>（1）启动 SSH 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start sshd</span><br><span class="line"><span class="comment"># 或者在某些系统上</span></span><br><span class="line"><span class="built_in">sudo</span> service sshd start</span><br></pre></td></tr></table></figure><p><strong>（2）检查 SSH 服务状态：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status sshd</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">sudo</span> service sshd status</span><br></pre></td></tr></table></figure><p><strong>（3）查看端口是否开放：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netstat tnlp | grep :22</span><br></pre></td></tr></table></figure><p>如果未开放，则重新启动 SSH 服务。</p><p><strong>（4）测试网络连通性：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>（5）开放防火墙端口：</strong></p><p>直接打开端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables I INPUT p tcp dport 22 j ACCEPT</span><br></pre></td></tr></table></figure><p>永久打开端口（CentOS 7）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> firewallcmd permanent addservice=ssh</span><br><span class="line"><span class="built_in">sudo</span> firewallcmd reload</span><br></pre></td></tr></table></figure><p>永久打开端口（CentOS 6）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/sysconfig/iptables</span><br><span class="line">添加以下行并保存</span><br><span class="line">A RHFirewall1INPUT m state state NEW m tcp p tcp dport 22 j ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> service iptables restart</span><br></pre></td></tr></table></figure><br><h3 id="2-创建Linux控制台项目"><a href="#2-创建Linux控制台项目" class="headerlink" title="2 创建Linux控制台项目"></a>2 创建Linux控制台项目</h3><ol><li>启动VS，在项目选择页面点击创建新项目</li><li>在创建新项目页面选择【C++、Linux控制台应用】【此处可能没有相应模板，可以使用VS更新来加入Linux开发相关的插件】</li><li>输入项目名称和解决方案名称，点击创建【不推荐勾选解决方案在同级目录】</li><li>连接Linux系统ssh服务【工具 | 选项 | 跨平台 | 连接管理器 | 添加连接】【用户名<code>root</code>；密码为sudo密码<code>xin980721</code>；主机名：在VM中查得ip；端口22】</li><li>生成解决方案【具体项目右键 | 属性 | 常规 | 远程生成计算机】【如果没有，可能是因为使用了错误的项目模板】，使用windows平台调试Linux程序<ul><li>修改远程服务器</li><li>修改远程根目录</li><li>平台工具集为<code>GCC for Remote Linux</code>】</li></ul></li><li>相应在Linux服务器中生成out文件【进入方法：<code>su root</code> | <code>cd ~</code>】</li></ol><p><strong>注意：</strong></p><ul><li>由于目前绝大多数的Linux系统都是64位的，故项目一般使用x64编译</li><li>32位仅限于部分嵌入式系统</li><li>程序是在Linux上运行的，windows上只是编写和调试</li></ul><br><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><h3 id="3-Linux标准库函数"><a href="#3-Linux标准库函数" class="headerlink" title="3 Linux标准库函数"></a>3 Linux标准库函数</h3><h4 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h4><blockquote><p>头文件&lt;ctype.h&gt;</p></blockquote><p>用于①正则表达式规则；②解析字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试字符是否为英文字母或数字:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalnum</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试字符是否为英文字母:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalpha</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//测试字符是否为小写英文字母:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">islower</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//测试字符是否为大写英文字母:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isupper</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试字符是否为阿拉伯数字:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isdigit</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//测试字符是否为16进制数字:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isxdigit</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试字符是否为空格字符:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isblank</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//测试字符是否为空格字符:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isspace</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试字符是否为可打印字符:【屏幕】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isgraph</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//测试字符是否为可打印字符:【纸】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isprint</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试字符是否为ASCII码的控制字符:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">iscntrl</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试字符是否为ASCII码字符:0~127【检测中文符号】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isascii</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试字符是否为标点符号或特殊符号:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ispunct</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>调用 <code>Linux API</code> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s 向你问好!\n&quot;</span>, <span class="string">&quot;Linux_consoleApplication&quot;</span>);</span><br><span class="line">    <span class="comment">//const char* str = &quot;Hello World!\n2024&quot;;</span></span><br><span class="line">    <span class="comment">//size_t len = sizeof(str);//8:错误原因是只计算了指针的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello World!\n2024 你好！&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">sizeof</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;len:&quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(str[i]))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(str[i]))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;_&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">iscntrl</span>(str[i]))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ispunct</span>(str[i]))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="3-2-数据转换函数"><a href="#3-2-数据转换函数" class="headerlink" title="3.2 数据转换函数"></a>3.2 数据转换函数</h4><blockquote><p>头文件&lt;stdlib.h&gt;【包含数据转换、随机数、字符集转换】</p><p>注意：先验证，再使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【字符串 to 浮点数】</span></span><br><span class="line"><span class="comment">//将字符串转换成整型数:【与atol的区别存在于以前的低位CPU】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成长整型数:</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成64位整数（C++11）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title">atoll</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串转换成浮点型数:</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串转换成整数【base=10为十进制】【endptr指向非法数字的开始处】</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">strtol</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr, <span class="type">int</span> base)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成无符号整数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">strtoul</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr, <span class="type">int</span> base)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成长整数（C++11）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title">strtoll</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr, <span class="type">int</span> base)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成无符号长整数（C++11）</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title">strtoull</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr, <span class="type">int</span> base)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串转换成浮点数（C++11）</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">strtof</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成双精度数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">strtod</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成长双精度数（C++11）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">strtold</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>** endptr)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//【浮点数 to 字符串】</span></span><br><span class="line"><span class="comment">//将浮点型数转换成字符串:ndigit指的是全部的有效位数；decpt输出小数点位置，即几个；sign输出正负</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">ecvt</span><span class="params">(<span class="type">double</span> value, <span class="type">int</span> ndigit, <span class="type">int</span> *decpt, <span class="type">int</span> *sign)</span></span>;</span><br><span class="line"><span class="comment">//将浮点型数转换为字符串:ndigit指的是小数点之后的有效位数【区别在于ndigit】【位数不足加0】</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fcvt</span><span class="params">(<span class="type">double</span> value, <span class="type">int</span> ndigit, <span class="type">int</span> *decpt, <span class="type">int</span> *sign)</span></span>;</span><br><span class="line"><span class="comment">//将浮点型数转换为字符串:ndigit指的是最大有效位数；bug输出【位数不足不加0】【无需二次处理】</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gcvt</span><span class="params">(<span class="type">double</span> value, <span class="type">int</span> ndigit, <span class="type">char</span> *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>【字符串 to 浮点数】示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&quot; int:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&quot; long long:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">atoi</span>(<span class="string">&quot;123456&quot;</span>) &lt;&lt; std::endl;<span class="comment">//cpu 8 16 32 64  以前i=16 l=32  现在i=32 l=64 ll=64</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">atol</span>(<span class="string">&quot;234567&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">atoll</span>(<span class="string">&quot;1234567890123&quot;</span>) &lt;&lt; std::endl;<span class="comment">//新特征，要先验证，再使用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">atof</span>(<span class="string">&quot;1.234567&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strtol</span>(<span class="string">&quot;-987654321&quot;</span>, <span class="literal">NULL</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">char</span>* pEnd;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strtoll</span>(<span class="string">&quot;-987654321000abc123456&quot;</span>, &amp;pEnd, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pEnd:&quot;</span> &lt;&lt; pEnd &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strtof</span>(<span class="string">&quot;1.2345678&quot;</span>, <span class="literal">NULL</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strtod</span>(<span class="string">&quot;1.234567890123&quot;</span>, <span class="literal">NULL</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">strtod</span>(<span class="string">&quot;1.234567890123&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf %g\r\n&quot;</span>, <span class="built_in">strtod</span>(<span class="string">&quot;1.234567890123&quot;</span>, <span class="literal">NULL</span>), d);</span><br><span class="line">    std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strtold</span>(<span class="string">&quot;1.234567890123456789&quot;</span>, <span class="literal">NULL</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%Lf\r\n&quot;</span>, <span class="built_in">strtold</span>(<span class="string">&quot;1.234567890123456789&quot;</span>, <span class="literal">NULL</span>));<span class="comment">//print只支持double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【浮点数 to 字符串】示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> decpt, sign;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ecvt</span>(<span class="number">0.123456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ecvt</span>(<span class="number">0.0123456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ecvt</span>(<span class="number">-123.456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ecvt</span>(<span class="number">100</span>, <span class="number">4</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=================================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fcvt</span>(<span class="number">0.123456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fcvt</span>(<span class="number">0.0123456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fcvt</span>(<span class="number">-123.456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fcvt</span>(<span class="number">100</span>, <span class="number">3</span>, &amp;decpt, &amp;sign) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">gcvt</span>(<span class="number">0.123456789</span>, <span class="number">10</span>, buffer) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">gcvt</span>(<span class="number">0.0123456789</span>, <span class="number">10</span>, buffer) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">gcvt</span>(<span class="number">-123.456789</span>, <span class="number">10</span>, buffer) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">gcvt</span>(<span class="number">100</span>, <span class="number">10</span>, buffer) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="3-3-格式化输入输出函数"><a href="#3-3-格式化输入输出函数" class="headerlink" title="3.3 格式化输入输出函数"></a>3.3 格式化输入输出函数</h4><blockquote><p>包含在 <code>cstdio</code></p></blockquote><h5 id="3-3-1-常用输入输出函数"><a href="#3-3-1-常用输入输出函数" class="headerlink" title="3.3.1 常用输入输出函数"></a>3.3.1 常用输入输出函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【输出】************************************</span></span><br><span class="line"><span class="comment">//v:可变参数 | s:输出到缓冲区 | n：带缓冲区大小参数更安全 | f:文件</span></span><br><span class="line"><span class="comment">//格式化输出数据：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">//格式化输出数据：【可变参数】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//格式化字符串复制：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">//更安全的格式化字符串复制：明确缓冲区大小size，超过直接丢掉，返回实际长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化字符串复制：【输出到缓冲区str】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">//更安全的格式化字符串复制:明确缓冲区大小size，超过直接丢掉，返回实际长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span> <span class="params">(<span class="type">char</span> * str, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【输入】************************************</span></span><br><span class="line"><span class="comment">//格式化字符串输入：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;<span class="comment">//返回识别到的参数个数</span></span><br><span class="line"><span class="comment">//1 空格是默认的分隔符</span></span><br><span class="line"><span class="comment">//2 部分数据格式是可以自动正确分割的,如%c%d；但是整数和小数之间，需要手动分割（使用空格）</span></span><br><span class="line"><span class="comment">//3 格式字符串里面的空格，可有可无。但是如果使用了其他分隔符，则在输入的时候，必须对应输入分隔符</span></span><br><span class="line"><span class="comment">//4 待输入变量，一定要取地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化字符串输入：【从缓冲区str输入】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化字符串输入：【可变参数】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsscanf</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * s, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【与文件相关】************************************</span></span><br><span class="line"><span class="comment">//格式化输出数据至文件：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//格式化输出数据至文件：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfprintf</span> <span class="params">( FILE * stream, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化文件字符串输入：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化文件字符串输入：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfscanf</span> <span class="params">( FILE * stream, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson17</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %u %l %lld %f %e %g\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0.00001</span>, <span class="number">0.00001</span>, <span class="number">0.00001</span>);<span class="comment">//lld长整数|e指数小数|g在f/e中选最短</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%s %d %f\n&quot;</span>, <span class="string">&quot;yidaoyun&quot;</span>, <span class="number">100</span>, <span class="number">100.12345</span>);</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%s %d %f\n&quot;</span>, <span class="string">&quot;yidaoyun&quot;</span>, <span class="number">100</span>, <span class="number">100.12345</span>);</span><br><span class="line"></span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pFile:&quot;</span>&lt;&lt;pFile &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">fprintf</span>(pFile, <span class="string">&quot;%s %d %f\n&quot;</span>, <span class="string">&quot;yidaoyun&quot;</span>, <span class="number">100</span>, <span class="number">100.12345</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(pFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdarg.h&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);<span class="comment">//相当于数组链接【改变ap值】//ap:8 48 ...</span></span><br><span class="line">    <span class="built_in">vprintf</span>(format, ap);<span class="comment">//ap:24 64 ...</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4906</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为ap每次被改变，故每次需要用va_start重新为ap定位</span></span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), format, ap);</span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buffer, format, ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession19</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">double</span> db;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">scanf</span>(<span class="string">&quot;%c%d,%f,%lf&quot;</span>, &amp;c, &amp;d, &amp;f, &amp;db);<span class="comment">//空格可加可不加，但输入时默认使用空格分割</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret=%d %c %d %f %lf\n&quot;</span>, ret, c, d, f, db);</span><br><span class="line">    <span class="comment">//%f在printf中可自动转换为double；但scanf中%f与%lf严格区分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson17</span>();</span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;%s %d %f\n&quot;</span>, <span class="string">&quot;yidaoyun&quot;</span>, <span class="number">100</span>, <span class="number">100.12345</span>);</span><br><span class="line">    <span class="built_in">lession19</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-printf函数format详解"><a href="#3-3-2-printf函数format详解" class="headerlink" title="3.3.2 printf函数format详解"></a>3.3.2 printf函数format详解</h5><table><thead><tr><th>格式字符</th><th>意义</th></tr></thead><tbody><tr><td>d</td><td>以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td>o</td><td>以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td>x X</td><td>以十六进制形式输出无符号整数(不输出前缀0x)</td></tr><tr><td>u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>f</td><td>以小数形式输出单、双精度实数</td></tr><tr><td>E e</td><td>以指数形式输出单、双精度实数</td></tr><tr><td>G g</td><td>以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td>c</td><td>输出单个字符</td></tr><tr><td>s</td><td>输出字符串</td></tr><tr><td>p</td><td>输出指针地址</td></tr><tr><td>lu</td><td>32位无符号整数</td></tr><tr><td>llu</td><td>64位无符号整数</td></tr></tbody></table><table><thead><tr><th>flags（标识）</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td></tr><tr><td>+</td><td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td>空格</td><td>如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td>#</td><td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。</td></tr><tr><td>0</td><td>在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td></tr></tbody></table><table><thead><tr><th>width（宽度）</th><th>描述</th></tr></thead><tbody><tr><td>(number)</td><td>要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td></tr><tr><td>*</td><td>宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table><p>​</p><table><thead><tr><th>.precision（精度）</th><th>描述</th></tr></thead><tbody><tr><td>.number</td><td>对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。</td></tr><tr><td>.*</td><td>精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table><table><thead><tr><th>length（长度）</th><th>描述</th></tr></thead><tbody><tr><td>h</td><td>参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td>l（小写L）</td><td>参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td>L</td><td>参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td></tr></tbody></table><p>​</p><p><strong>附加参数</strong> – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p><br><h5 id="3-3-3-scanf函数format详解"><a href="#3-3-3-scanf函数format详解" class="headerlink" title="3.3.3 scanf函数format详解"></a>3.3.3 scanf函数format详解</h5><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</td></tr><tr><td>width</td><td>这指定了在当前读取操作中读取的最大字符数。</td></tr><tr><td>modifiers</td><td>为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</td></tr><tr><td>type</td><td>一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。</td></tr></tbody></table><table><thead><tr><th>类型</th><th>合格的输入</th><th>参数的类型</th></tr></thead><tbody><tr><td>%a、%A</td><td>读入一个浮点值(仅 C99 有效)。</td><td>float *</td></tr><tr><td>%c</td><td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td><td>char *</td></tr><tr><td>%d</td><td>十进制整数：数字前面的 + 或 - 号是可选的。</td><td>int *</td></tr><tr><td>%e、%E、%f、%F、%g、%G</td><td>浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td><td>float *</td></tr><tr><td>%lf</td><td>双精度数输入</td><td>double *</td></tr><tr><td>%i</td><td>读入十进制，八进制，十六进制整数 。</td><td>int *</td></tr><tr><td>%o</td><td>八进制整数。</td><td>int *</td></tr><tr><td>%s</td><td>字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td><td>char *</td></tr><tr><td>%u</td><td>无符号的十进制整数。</td><td>unsigned int *</td></tr><tr><td>%x、%X</td><td>十六进制整数。</td><td>int *</td></tr><tr><td>%p</td><td>读入一个指针 。</td><td></td></tr><tr><td>%[]</td><td>扫描字符集合 。</td><td></td></tr><tr><td>%%</td><td>读 % 符号。</td><td></td></tr></tbody></table><p><strong>附加参数</strong> – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p><br><h4 id="3-4-权限控制函数"><a href="#3-4-权限控制函数" class="headerlink" title="3.4 权限控制函数"></a>3.4 权限控制函数</h4><h5 id="3-4-1-Linux权限说明"><a href="#3-4-1-Linux权限说明" class="headerlink" title="3.4.1 Linux权限说明"></a>3.4.1 Linux权限说明</h5><p><img src="./2-1.png"></p><ul><li>设置用户权限【S：提权和降权】【对应Owner】</li><li>设置组权限【s：修改当前的组权限】【对应Group】</li><li>仅所有者可删除权限【t】【对应Other User】</li><li>读取权限【r | 4】</li><li>写入权限【w| 2】</li><li>执行权限【x | 1】</li><li>头部标志【<code>d</code>：文件夹；<code>l</code>：链接文件；<code>-</code>：文件】</li></ul><p><img src="./3-1.png"></p><ul><li><p>文件所有者的权限：红色方框</p></li><li><p>文件所有者所在组的权限：蓝色方框</p></li><li><p>其他组的权限：橙色方框</p></li></ul><blockquote><p>在linux中，<code>s</code>指的是“强制位权限”，位于user权限组或group权限组的第三位置。s权限位是一个敏感的权限位，容易造成系统的安全问题。</p><p>如果在user权限组中设置了s位，则当文件被执行时，该文件是以文件所有者uid而不是用户uid执行程序；如果在group权限组中设置了s位，当文件被执行时，该文件是以文件所有者gid而不是用户gid执行程序。</p></blockquote><p><strong>注意：</strong></p><ul><li>root例外，其拥有全部权限</li><li>对进程也是有效的【<code>/proc</code>】，对内存也是有效的【某一个进程下的内存】</li><li>【Linux下一切<strong>都是文件</strong>，进程、内存、网络……】</li></ul><h5 id="3-4-2-Linux权限控制函数"><a href="#3-4-2-Linux权限控制函数" class="headerlink" title="3.4.2 Linux权限控制函数"></a>3.4.2 Linux权限控制函数</h5><p><strong>获取用户识别码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件：</span></span><br><span class="line">&lt;unistd.h&gt;</span><br><span class="line">&lt;sys/types.h&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//取得有效的用户识别码：【有效的用户：程序启动时所拥有的用户状态】</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//取得真实的用户识别码：【真实的用户：当下程序所拥有的用户状态】【部分程序运行时，权限会被改变】【常用**】</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如su提权【下图】</span></span></span><br><span class="line"><span class="function"><span class="comment">//而启动su的，其实是有效用户</span></span></span><br></pre></td></tr></table></figure><p><img src="./3-2.png"></p><p>其中，上面的函数返回值 <code>uid_t</code> 为整数类型</p><ul><li><code>0</code>：root 最高权限【没有<code>&lt;1000</code>】；</li><li><code>[1000~10000)</code> ：system、数据库、服务、tty、保留的用户；【Linux、Unbuntu等】</li><li><code>≥10000</code>：其他用户【如<code>Andriod</code> 每个应用会分配一个用户 ，但系统应用例外；网络用户】</li></ul><br><p><strong>获取组识别码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得有效的组识别码：【程序启动时】</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">//取得真实的组识别码：【程序运行时】</span></span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson22</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getuid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">geteuid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getgid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getegid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;setuid:&quot;</span> &lt;&lt; <span class="built_in">setuid</span>(<span class="number">0</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;setgid:&quot;</span> &lt;&lt; <span class="built_in">setgid</span>(<span class="number">0</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getuid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">geteuid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getgid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getegid</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若修改远程远程项目根目录为：/home/[用户名]/projects</span></span><br><span class="line">    <span class="comment">//运行该项目的.out文件，uid/euid/gid/egid为1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson22</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>设置识别码</strong>【以下的内容需要对应的权限】</p><table><thead><tr><th>真实用户高权限【程序运行时】</th><th>有效用户高权限【程序启动时】</th><th>可以提权</th></tr></thead><tbody><tr><td>真实用户高权限</td><td>有效用户低权限</td><td>可以提权</td></tr><tr><td>真实用户低权限</td><td>有效用户高权限</td><td>可以提权</td></tr><tr><td>真实用户低权限</td><td>有效用户低权限</td><td>不可提权</td></tr></tbody></table><ul><li>权限不足，无法产生效果【权限不足，操作失败返回<code>-1</code>；操作成功返回0】</li><li>提权需要该文件属于高级别的用户或者用户组，即有效用户有更高的权限，或者以更高权限的用户来执行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置真实的用户识别码：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//设置有效的用户识别码：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//设置真实及有效的用户识别码：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setreuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//设置有效的组识别码：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//设置真实的组识别码：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//设置真实及有效的组识别码：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setregid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid)</span></span></span><br></pre></td></tr></table></figure><br><p><strong>创建会话</strong></p><blockquote><p>【用于守护进程】在bash中执行的命令【如服务、sleep休眠等】，此类进程会随着bash解释器的关闭而直接终止。此时若使用守护进程，即可维持进程在后台运行。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 守护进程的关键调用函数【创建新会话】</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>注意：守护进程的ID至少小于1000，故用户和组要有足够的权限。如何获取权限：</p><ul><li>以高权限用户来启动</li><li>有能力提权【设置识别码】</li></ul><p><strong>创建新会话</strong>：当前进程只能是子进程才能够调用成功【失败返回<code>-1</code>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lession23</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">setsid</span>() &lt;&lt; std::endl;<span class="comment">//主进程的时候必然失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>3.6</code> 进程控制函数详解</p></blockquote><br><h4 id="3-5-I-O函数"><a href="#3-5-I-O函数" class="headerlink" title="3.5 I/O函数"></a>3.5 I/O函数</h4><p><code>I/O</code> ： <code>Input/Output</code>【输入/输出 | 写入/读取，即与文件有很大的关系】【主要用于设备读写】</p><h5 id="3-5-1-open-create函数"><a href="#3-5-1-open-create函数" class="headerlink" title="3.5.1 open/create函数"></a>3.5.1 open/create函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">&lt;sys/types.h&gt;     <span class="comment">//定义flag宏</span></span><br><span class="line">&lt;sys/stat.h&gt;    <span class="comment">//定义flag宏</span></span><br><span class="line">&lt;fcntl.h&gt;<span class="comment">//open</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//打开文件：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags**, <span class="type">mode_t</span> mode**)</span></span></span><br><span class="line"><span class="function"><span class="comment">//mode当非O_CREAT时可省略，故写成下面的形式</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path,<span class="type">int</span> flags,...)</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>flags</code>：多个标志用<code>|</code>符号连接【前三者必须三选一】【后两个可与前三组合使用】<ul><li><strong>O_RDONLY</strong>：只读打开【默认】</li><li><strong>O_WRONLY</strong>：只写打开</li><li><strong>O_RDWR</strong>：读，写打开</li><li><code>O_CREAT</code>：若文件不存在，则创建它，<strong>需要使用mode选项</strong>。来指明新文件的访问权</li><li><code>O_APPEND</code>：追加写，如果文件已经有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容【不能与只读<code>O_RDONLY</code>搭配】</li></ul></li><li><code>mode</code>：多个标志用<code>|</code>符号连接<ul><li><code>S_IRUSR S_IWUSR S_IXUSR</code>：所有者的读写执行 User</li><li><code>S_IRGRP S_IWGRP S_IXGRP</code>：所属组的读写执行 Group</li><li><code>S_IROTH S_IWOTH S_IXOTH</code>：其他用户的读写执行 Other</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个不存在的文件：【等价于flag=O_CREAT】【灵活度低】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure><br><h5 id="3-5-2-文件操作"><a href="#3-5-2-文件操作" class="headerlink" title="3.5.2 文件操作"></a>3.5.2 文件操作</h5><p>文件的最主要的操作：<strong>打开【3.5.1】、读取、写入、关闭</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从打开的文件读取文件数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">4096</span>]=<span class="string">&quot;&quot;</span>;    <span class="comment">///缓冲区</span></span><br><span class="line"><span class="built_in">read</span>(fd,buffer,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line"><span class="built_in">read</span>(fd,buffer<span class="number">+256</span>,<span class="built_in">sizeof</span>(buffer));<span class="comment">//buf可以加偏移</span></span><br><span class="line"><span class="comment">//允许把多个不同文件的数据，读入到同一个缓冲区</span></span><br><span class="line"><span class="comment">//fd可能是：硬盘文件、网络连接、内存、光驱、命令输入输出tty【只要有数据产生】</span></span><br><span class="line"><span class="comment">//buf是一个无类型指针，字符缓冲区、结构体指针</span></span><br><span class="line"><span class="comment">//    【用于文件解析，ELF文件格式】【网络数据包的解析】等等</span></span><br></pre></td></tr></table></figure><p>写入与关闭：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从打开的文件写入文件数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//fd可以是网络、串口、文件、内存、其他设备</span></span></span><br><span class="line"><span class="function"><span class="comment">//buf可以加偏移：可以同一个内存段的不同部分，保存到不同的文件中</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//关闭文件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Linux（或者其他操作系统）当中可以同时打开的文件数量，是有限的</span></span></span><br><span class="line"><span class="function"><span class="comment">//一般来讲是4096个文件（验证方法，待网络编程学习完成之后）</span></span></span><br></pre></td></tr></table></figure><br><h5 id="3-5-3-其他文件操作"><a href="#3-5-3-其他文件操作" class="headerlink" title="3.5.3 其他文件操作"></a>3.5.3 其他文件操作</h5><ul><li>输出重定向</li><li>文件重定向</li><li>文件同步</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制文件描述符：【输出重定向】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> oldfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制文件描述符到新的文件描述符中去【文件重定向】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件数据同步【写磁盘太慢，故先写入内存缓冲区】</span></span><br><span class="line"><span class="comment">//【该函数强制将缓存中的数据写入磁盘缓冲区，注意并非磁盘盘片】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsync</span><span class="params">(<span class="type">int</span> fd)</span></span>;    <span class="comment">//谨慎使用，会耗费时间，常用于数据库同步</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure><ul><li>文件读写位置修改</li><li>临时文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">&lt;sys/types.h&gt;</span><br><span class="line">&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件读写位置修改</span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//whence：</span></span><br><span class="line"><span class="comment">//***SEEK_SET  参数offset 即为新的读写位置.不能为负数</span></span><br><span class="line"><span class="comment">//***SEEK_CUR  以目前的读写位置往后增加offset个位移量【offet允许负值】</span></span><br><span class="line"><span class="comment">//***SEEK_END  将读写位置指向文件尾后再增加offset个位移量【offet允许负值】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line">&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建临时文件【肯定是有读写权限的】【】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkstemp</span><span class="params">(<span class="type">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">//要求template：前缀任意字母，后缀必须为XXXXXX</span></span><br><span class="line"><span class="comment">//创建的文件是临时的，不保证数据长期有效【close文件之前，本次运行前有效】</span></span><br></pre></td></tr></table></figure><p><strong>文件锁操作</strong></p><ul><li>防止文件被篡改导致冲突</li><li>防止程序多实例，要用到<code>LOCK_NB</code>标志来添加锁定</li><li>多个程序竞争文件控制权【消息分发、文件处理】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">&lt;sys/file.h&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//文件锁操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">flock</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> operation)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//operation：</span></span><br><span class="line"><span class="comment">//***LOCK_SH【建立共享锁定】多个进程（程序）可同时对同一个文件作共享锁定。[应用1]</span></span><br><span class="line"><span class="comment">//***LOCK_EX【建立互斥锁定】一个文件同时只有一个互斥锁定。[应用2]</span></span><br><span class="line"><span class="comment">//***LOCK_UN【解除文件锁定状态】文件被关闭的时候，自动解锁；但可能存在时差</span></span><br><span class="line"><span class="comment">//***LOCK_NB【无法建立锁定时，此操作可不被阻断，马上返回进程】通常与LOCK_SH或LOCK_EX做OR(|)组合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【NB：NonBlock，非主设备】LOCK_EX无法上锁时会一直等待直到可以上锁，带NB之后不会等待直接返回</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：文件锁只是标志，并不能阻止相应的文件操作【即关注时有用，不关注时无效】</p></blockquote><br><h5 id="3-5-4-文件控制"><a href="#3-5-4-文件控制" class="headerlink" title="3.5.4 文件控制"></a>3.5.4 文件控制</h5><blockquote><p>文件控制<code>control=cntl</code>。文件操作：打开、关闭、读取、写入、控制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">&lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件控制操作 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span></span>; ==&gt; F_GETLK[获取文件锁] F_SETLK[设置文件锁]</span><br></pre></td></tr></table></figure><p><code>cmd</code>参数说明：</p><ul><li><p><code>F_DUPFD</code>：用来查找大于或等于参数arg的最小且仍未使用的文件描述符，并且复制参数fd的文件描述符。执行成功则返回新复制的文件描述符。新描述符与fd共享同一文件表项，但是新描述符有它自己的一套文件描述符标志，其中FD_CLOEXEC文件描述符标志被清除。请参考dup2()。</p></li><li><p><code>F_GETFD</code>：取得close-on-exec标志。若此标志的<code>FD_CLOEXEC</code>位为0，代表在调用<code>exec()</code>【进程控制函数】相关函数时文件将不会关闭。【管道】</p></li><li><p><code>F_SETFD</code>：设置close-on-exec 标志。该标志以参数arg 的FD_CLOEXEC位决定。</p></li><li><p><code>F_GETFL</code>【FL=Flags】：取得文件描述符状态标志，此标志为open（）的参数flags。</p></li><li><p><code>F_SETFL</code>：设置文件描述符状态标志，参数arg为新标志，但只允许<code>O_APPEND</code>、<code>O_NONBLOCK</code>【非阻塞通信】和<code>O_ASYNC</code>【异步通信】位的改变，其他位的改变将不受影响。</p></li><li><p><code>F_GETLK</code>【LK=Lock】：取得文件锁定的状态。</p></li><li><p><code>F_SETLK</code>：设置文件锁定的状态。此时flcok 结构的l_type 值必须是F_RDLCK、F_WRLCK或F_UNLCK。如果无法建立锁定，则返回-1，错误代码为EACCES 或EAGAIN。</p></li><li><p><code>F_SETLKW</code>【wait】<code>F_SETLK</code> 作用相同，但是无法建立锁定时，此调用会一直等到锁定动作成功为止。若在等待锁定的过程中被信号中断时，会立即返回<code>-1</code>，错误代码为EINTR。</p></li></ul><br><h5 id="3-5-5-练习"><a href="#3-5-5-练习" class="headerlink" title="3.5.5 练习"></a>3.5.5 练习</h5><p>理解文件锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>        <span class="comment">//close</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>        <span class="comment">//lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span>    <span class="comment">//lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span><span class="comment">//errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">//strerror</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson30</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int fd = open(&quot;/home/xin/test.txt&quot;, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);</span></span><br><span class="line">    <span class="comment">//权限可简写为0755，不加0默认为十进制</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/home/xin/test.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0755</span>);<span class="comment">//权限是八进制的</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;<span class="comment">//文件锁其实是一个建议性的锁 </span></span><br><span class="line">        <span class="comment">//printf(&quot;write:%d\n&quot;, write(fd, &quot;hello&quot;, 5));</span></span><br><span class="line">        <span class="comment">//write(fd, &quot;Hello fileLock!&quot;, 15);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flock:%d\n&quot;</span>, <span class="built_in">flock</span>(fd, LOCK_EX));<span class="comment">//互斥锁，并打印返回值[会检查文件锁]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write:%d\n&quot;</span>, <span class="built_in">write</span>(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>));<span class="comment">//返回值为写入长度【应该写不进去】</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="built_in">flock</span>(fd, LOCK_UN);<span class="comment">//解锁</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson30</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="3-6-进程控制函数"><a href="#3-6-进程控制函数" class="headerlink" title="3.6 进程控制函数"></a>3.6 进程控制函数</h4><p><span style="background:#ff0">进程是操作系统调度的一个最小的单位；线程是xxxx </span></p><h5 id="3-6-1-执行文件"><a href="#3-6-1-执行文件" class="headerlink" title="3.6.1 执行文件"></a>3.6.1 执行文件</h5><ul><li><code>l</code>：进程执行的参数<code>arg</code>，以可变参数的形式给出的【<code>arg</code>参数以<code>NULL</code>为最后一个参数，即最后一个参数必须为空指针】</li><li><code>p</code>：进程函数会将当前的<code>PATH</code>作为一个参考环境变量【即<code>file</code>可以是相对路径】</li><li><code>e</code>：进程函数会需要用户来设置这个环境变量【env】</li><li><code>v</code>：进程函数会用参数<strong>数组</strong>来传递<code>argv</code>，数组的最后一个成员必须是<code>NULL</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//exec函数系列：不是真正创建进程，本质是替换进程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">char</span> * <span class="type">const</span> argv[ ],<span class="type">char</span> * <span class="type">const</span> envp[ ])</span></span>;<span class="comment">//内核级别调用</span></span><br></pre></td></tr></table></figure><h5 id="3-6-2-建立新进程"><a href="#3-6-2-建立新进程" class="headerlink" title="3.6.2 建立新进程"></a>3.6.2 建立新进程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//大于0的数，此时就是父进程</span></span><br><span class="line"><span class="comment">//等于0的数，此时就是子进程</span></span><br><span class="line"><span class="comment">//小于0的数，表示调用失败</span></span><br><span class="line"><span class="comment">//进程数量是有限的1~32768/32767/65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行fork后，产生两个有先后顺序分支【或者第三个分支为出错，返回值小于0】</span></span><br><span class="line"><span class="comment">//一个分支继续往后执行【父进程：返回值大于0】</span></span><br><span class="line"><span class="comment">//另一个分支创建出一个新进程并执行【返回值为0】</span></span><br><span class="line"><span class="comment">//即fork函数返回两次</span></span><br></pre></td></tr></table></figure><p>示例：</p><blockquote><p>虚拟机中对应执行文件：<code>chase@chase-virtual-machine:/home/xin/Liunx_consoleApplication/bin/x64/Debug$:./Liunx_consoleApplication.out</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pid-:&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello,here is parent!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//argv的第一个参数，一定要是命令的自身</span></span><br><span class="line">        <span class="comment">//execl直接结果相当于执行bash命令：ls -l</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">    pid - :5656</span></span><br><span class="line"><span class="comment">    hello, here is parent!5656</span></span><br><span class="line"><span class="comment">    pid - : 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson32</span>();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-3-结束进程"><a href="#3-6-3-结束进程" class="headerlink" title="3.6.3 结束进程"></a>3.6.3 结束进程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以异常方式结束进程：【异常退出：不会触发atexit或者on_exit】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//若测试的条件不成立则终止进程：【断言退出：不会触发atexit或者on_exit】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(<span class="type">int</span> expression)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常结束进程：【正常结束可以触发结束前调用函数】【推荐】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束进程执行：不会触发atexit或者on_exit</span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="comment">//************前调函数************</span></span><br><span class="line"><span class="comment">//设置程序正常结束前调用的函数：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置程序正常结束前调用的函数：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">on_exit</span><span class="params">(<span class="type">void</span> (* function)(<span class="type">int</span>,<span class="type">void</span>*),<span class="type">void</span> *arg)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson33_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__);<span class="comment">//宏：当前函数名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson33_on_exit</span><span class="params">(<span class="type">int</span> status, <span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s p=%p status=%d\n&quot;</span>, __FUNCTION__, p, status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson33</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">atexit</span>(lesson33_exit);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello,here is parent!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//abort();//不会触发atexit或者on_exit //触发异常警告</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//正常结束进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">on_exit</span>(lesson33_on_exit, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);<span class="comment">//不会触发atexit或者on_exit</span></span><br><span class="line">        _exit(<span class="number">-1</span>);<span class="comment">//不会触发atexit或者on_exit</span></span><br><span class="line">        <span class="comment">//execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);//argv的第一个参数，一定要是命令的自身</span></span><br><span class="line">        <span class="comment">//assert(0);</span></span><br><span class="line">        <span class="comment">//execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);//argv的第一个参数，一定要是命令的自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson33</span>();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-4-改变进程流程【恢复进程】"><a href="#3-6-4-改变进程流程【恢复进程】" class="headerlink" title="3.6.4 改变进程流程【恢复进程】"></a>3.6.4 改变进程流程【恢复进程】</h5><blockquote><p>x86架构下的指令寄存器是IP【eax-edx】；ARM架构下的指令寄存器是PC【R0-R16】</p><p>程序执行的中最重要的两个：CPU中的寄存器信息、内存中的堆栈信息</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//setjmp-longjmp || sigsetjmp-siglongjmp 配对使用</span></span><br><span class="line"><span class="comment">//后者的区别在于传入的sigjmp_buf,它相比jmp_buf缓存了更多信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存目前堆栈环境：【jmp_buf存储的是寄存器信息】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf environment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存目前堆栈环境：【sigjmp_buf缓存上下文，savemask为屏蔽处理】</span></span><br><span class="line"><span class="comment">//上下文：堆栈、当前寄存器、当前的状态（线程，进程）、下一条指令的位置、栈内存地址</span></span><br><span class="line"><span class="comment">//sigjmp_buf属于内核对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savemask)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到原先setjmp保存的堆栈环境：恢复环境，并将value做为setjmp的返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf environment, <span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变进程优先顺序：跳转到原先sigsetjmp保存的堆栈环境</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><blockquote><p>当程序执行时，如果发生异常错误【如段错误】，<code>setjmp</code>就会返回其他的值，此时需要longjmp来恢复寄存器和堆栈环境。</p><p>在下面的代码中，首先 <code>setjmp</code> 保存堆栈环境，返回ret必然等于0。如果执行test001，再执行test002发现出现问题，就使用 <code>longjmp</code> 恢复堆栈环境，即恢复到 <code>setjmp</code> 执行时【即指令寄存器也被修改为指向<code>setjmp</code>的下一条指令，也就说跳转程序执行进度】，并将<code>setjmp</code>的返回值ret更改【此时就能执行相应的异常处理程序】</p><p>而<code>signal</code>函数【与setjmp-longjmp搭配】，能注册错误信息的处理程序，也可以配合<code>longjmp</code>进行异常捕获和处理。【sigaction与sigsetjmp-siglongjmp搭配】</p><p>值得注意的是，这种跳转不能用于普通的程序跳转，因为会恢复寄存器，只有存在内存的内容才会保留；此类函数多用于逆向。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">jmp_buf jmpbuf;<span class="comment">//建议设置为全局，不建议为局部【jmp_bug存储寄存器信息】</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test002</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="built_in">longjmp</span>(jmpbuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test003</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">longjmp</span>(jmpbuf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test001</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="built_in">test002</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_deal</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGSEGV) &#123;</span><br><span class="line">        <span class="built_in">longjmp</span>(jmpbuf, SIGSEGV);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson34</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGSEGV, signal_deal);<span class="comment">//异常捕获【#include &lt;signal.h&gt;】</span></span><br><span class="line">    <span class="comment">//即注册一个错误信号的处理函数</span></span><br><span class="line">    <span class="comment">//struct sigaction act, actold;</span></span><br><span class="line">    <span class="comment">//act.sa_restorer//初始化 </span></span><br><span class="line">    <span class="comment">//sigaction(SIGSEGV, &amp;act, &amp;actold);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setjmp</span>(jmpbuf);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;<span class="comment">//实际上是C语言当中，处理异常的一种机制</span></span><br><span class="line">        <span class="comment">//test001();</span></span><br><span class="line">        *(<span class="type">int</span>*)(<span class="literal">NULL</span>) = <span class="number">0</span>;<span class="comment">//制造非法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;<span class="comment">//错误1的处理和恢复</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error 1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">2</span>) &#123;<span class="comment">//错误2的处理和恢复</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error 2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == SIGSEGV) &#123;<span class="comment">//错误2的处理和恢复</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error SIGSEGV\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson34</span>();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取进程信息：【多用于逆向父子调试】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得进程组识别码：</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得当前进程组识别码：</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得进程识别码：【唯一】</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得父进程的进程识别码：</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得程序进程执行优先权：【越小越牛】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpriority</span><span class="params">(<span class="type">int</span> which,<span class="type">int</span> who)</span></span>;<span class="comment">//#include &lt;sys/resource.h&gt;</span></span><br></pre></td></tr></table></figure><p>设置进程信息：【降低权限可以，但提高权限必须要足够的权限】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置进程组识别码：</span></span><br><span class="line"><span class="comment">//组识别码：父进程的所有子进程同属一个组【默认】或涉及守护进程</span></span><br><span class="line"><span class="comment">//组识别码没有大小的意义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">pid_t</span> pgid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置进程组识别码：【无参数，将组id设置为进程id】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgrp</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置程序进程执行优先权：【失败返回-1】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpriority</span><span class="params">(<span class="type">int</span> which,<span class="type">int</span> who, <span class="type">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变进程优先级：修改优先级需要权限（这个一般只有效用户的权限）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nice</span><span class="params">(<span class="type">int</span> inc)</span></span>;<span class="comment">//inc为相对值</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson35</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getpgid:&quot;</span> &lt;&lt; <span class="built_in">getpgid</span>(<span class="built_in">getpid</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getpid:&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getpgrp:&quot;</span> &lt;&lt; <span class="built_in">getpgrp</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getppid:&quot;</span> &lt;&lt; <span class="built_in">getppid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getpriority:&quot;</span> &lt;&lt; <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);<span class="comment">//可再打开一个bash，使用ps -Al来观察</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson36</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*getpgrp:&quot;</span> &lt;&lt; <span class="built_in">getpgrp</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;setpgid:&quot;</span> &lt;&lt; <span class="built_in">setpgid</span>(<span class="built_in">getpid</span>(), <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*getpgrp:&quot;</span> &lt;&lt; <span class="built_in">getpgrp</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;setpgrp(void):&quot;</span> &lt;&lt; <span class="built_in">setpgrp</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*getpgrp:&quot;</span> &lt;&lt; <span class="built_in">getpgrp</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;$getpriority:&quot;</span> &lt;&lt; <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;nice:&quot;</span> &lt;&lt; <span class="built_in">nice</span>(<span class="number">3</span>) &lt;&lt; std::endl;<span class="comment">//降低优先级</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;$getpriority:&quot;</span> &lt;&lt; <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;setpriority:&quot;</span> &lt;&lt; <span class="built_in">setpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>(), <span class="number">1</span>) &lt;&lt; std::endl;<span class="comment">//提高优先级【需要权限不一定成功】</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;$getpriority:&quot;</span> &lt;&lt; <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>()) &lt;&lt; std::endl;<span class="comment">//可在su root用户下执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson35</span>();	</span><br><span class="line">    <span class="built_in">lesson36</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-5-Wait等待"><a href="#3-6-5-Wait等待" class="headerlink" title="3.6.5 Wait等待"></a>3.6.5 Wait等待</h5><ul><li>system</li><li>wait / waitpid</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;stdlib.h&gt;</span><br><span class="line"><span class="comment">//执行shell命令：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">char</span> *command)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//等待子进程中断或结束：</span></span></span><br><span class="line"><span class="function">&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="function">&lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//等待子进程的状态【一般来讲是和fork配套使用】</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span>;</span><br><span class="line"><span class="comment">//先调用fork创建子进程，然后由父进程调用wait</span></span><br><span class="line"><span class="comment">//子进程销毁，会向父进程报告(发送SIGCHILD)【信号量】</span></span><br><span class="line"><span class="comment">//如果父进程没有接收这个报告，则子进程可能成为【僵尸进程】（会占用进程ID——pid）</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//由于wait无法区分是wait到哪一个子进程，无法区别wait后处理【不可控】</span></span><br><span class="line"><span class="comment">//等待子进程中断或结束：</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> * status,<span class="type">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">//@options:</span></span><br><span class="line"><span class="comment">//WNOHANG 非阻塞【nohang在等待过程中可执行其他操作，不阻塞子进程】</span></span><br><span class="line"><span class="comment">//WUNTRACED 被调试【under traced 用于反调试】</span></span><br><span class="line"><span class="comment">//WCONTINUED 发生了信号导致进程暂停 SIGSTOP SIGPAUSE SIGCONT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@status:【宏】【第一个表征程序如何结束；第二个为具体原因】</span></span><br><span class="line"><span class="comment">//WIFEXITED(status)</span></span><br><span class="line"><span class="comment">//WEXITSTATUS(status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WIFSIGNALED(status)</span></span><br><span class="line"><span class="comment">//WTERMSIG(status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WIFSTOPPED(status)</span></span><br><span class="line"><span class="comment">//WSTOPSIG(status)</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson37</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">system</span>(<span class="string">&quot;ls -l&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system return:%d\n&quot;</span>, ret);</span><br><span class="line">    ret = <span class="built_in">system</span>(<span class="string">&quot;mkdir test&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system return:%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;echo \&quot;%s\&quot;&gt;test/test.txt&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    ret = <span class="built_in">system</span>(buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system return:%d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实现动态构建命令，类似于批处理</span></span><br><span class="line">    <span class="built_in">lesson37</span>();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="3-7-文件和目录函数"><a href="#3-7-文件和目录函数" class="headerlink" title="3.7 文件和目录函数"></a>3.7 文件和目录函数</h4><blockquote><p>3.5节IO函数为Linux的文件模型；而此节为真正的文件和目录</p></blockquote><h5 id="3-7-1-文件指针操作"><a href="#3-7-1-文件指针操作" class="headerlink" title="3.7.1 文件指针操作"></a>3.7.1 文件指针操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件：</span></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path,<span class="type">const</span> <span class="type">char</span> * mode)</span></span>; </span><br><span class="line"><span class="comment">//不能指定权限【与open函数的区别】</span></span><br><span class="line"><span class="comment">//默认权限：rw-rw-r-- 或者 rw-r--r--</span></span><br><span class="line"><span class="comment">//*************mode:</span></span><br><span class="line"><span class="comment">//只读权限【r】 如档案</span></span><br><span class="line"><span class="comment">//只写权限【w】 如日志，只记录</span></span><br><span class="line"><span class="comment">//读写权限【r+ 或 w+】</span></span><br><span class="line"><span class="comment">//创建【+】不存在则自动创建</span></span><br><span class="line"><span class="comment">//追加【a】默认从头开始写，覆盖原文件；a为末尾追加</span></span><br><span class="line"><span class="comment">//二进制【b】</span></span><br><span class="line"><span class="comment">//文本【t】ASCⅡ码类的（默认）【b/t二选一】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件：</span></span><br><span class="line"><span class="comment">//【文件用完之后，必须要关闭】【需要判断fp是否为空NULL】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">( FILE *fp )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件：文件输出输入重定向</span></span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream )</span></span>;</span><br><span class="line"><span class="comment">//用fopen后printf，输出到标准输出，即控制台输出；而reopen后printf会自动输出到文件</span></span><br><span class="line"><span class="comment">//应用场景：将debug输出输入到文件，不影响控制台输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件描述词转为文件指针：统一open函数</span></span><br><span class="line"><span class="function">FILE * <span class="title">fdopen</span><span class="params">(<span class="type">int</span> fildes,<span class="type">const</span> <span class="type">char</span> * mode)</span></span>;</span><br><span class="line"><span class="comment">//用open函数打开的时候，得到的一个fd【file description】</span></span><br><span class="line"><span class="comment">//dfopen可以把文件描述符fd转换为文件指针FILE*</span></span><br><span class="line"><span class="comment">//应用场景：一般fopen无法用fopen打开，如串口、网络、usb【Linux：一切皆文件！！！】</span></span><br><span class="line"><span class="comment">//使用丰富的IO函数进行操作，然后用fdopen转为FILE*进行读写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回文件流所使用的文件描述词：FILE*转fd【无法修改权限，故转为fd使用fcntl修改权限】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fileno</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson38</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 读写和处理</span></span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson39</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">freopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>, stdout);<span class="comment">//stdout定义在std中</span></span><br><span class="line">    <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);<span class="comment">//三个宏：当前文件名、当前行号、函数名</span></span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实现动态构建命令，类似于批处理</span></span><br><span class="line">    <span class="comment">//lesson38();</span></span><br><span class="line">    <span class="built_in">lesson39</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-2-文件内容操作"><a href="#3-7-2-文件内容操作" class="headerlink" title="3.7.2 文件内容操作"></a>3.7.2 文件内容操作</h5><p>① 读操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件流读取数据：【柱头、盘片、扇区】</span></span><br><span class="line"><span class="comment">//【与早期操作系统读写有关，可以多次读写扇区，每次读写固定大小】</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">( <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream )</span></span>;</span><br><span class="line"><span class="comment">//目标缓冲区：buffer</span></span><br><span class="line"><span class="comment">//每次读取的字节数量：size</span></span><br><span class="line"><span class="comment">//读取多少次：count</span></span><br><span class="line"><span class="comment">//文件指针：stream</span></span><br><span class="line"><span class="comment">//返回值为读取的字节数【未读满size大小不算一次】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由文件中读取一个字符：【c=char】【成功返回内容；失败返回-1】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由文件中读取一字符串：【s=string】【n为最大长度】</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">//要求：文件必须以t模式打开，不能以二进制模式打开b【因为无法判断何时终止，二进制读取可能没有\n】</span></span><br><span class="line"><span class="comment">//实际上是读取一行【以\0或者\n为终止符或者发现了EOF = End Of File】</span></span><br><span class="line"><span class="comment">//换行符会被读入到str所指的内存里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值得注意的是：*********文件内部是有一个指针的*********</span></span><br><span class="line"><span class="comment">//该指针会记录上次读/写的位置，读写的位置是分开的，统一记录</span></span><br><span class="line"><span class="comment">//每次读写，都可以改变文件中位置的指针记录**************</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">//Linux应用需要：memset</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char buffer[65536] = &quot;&quot;;//&lt;512M  &lt;2G</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson40</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">//char buffer[4096] = &quot;&quot;;//栈上的数据 不要太大（64k==》32k以内）</span></span><br><span class="line">        <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];<span class="comment">//单次内存分配，不要超过2G  64位系统不要超过8G</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>);</span><br><span class="line">        <span class="type">size_t</span> ret = <span class="built_in">fread</span>(buffer, <span class="number">1</span>, <span class="number">1024</span>, pFile);</span><br><span class="line">        <span class="comment">//size_t ret = fread(buffer, 1024, 1, pFile);//ret = 0【//返回值为读取的字节数【未读满size大小不算一次】</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s read count %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s &lt;%s&gt;\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">        <span class="comment">//fread(buffer, 2, 1000);//用于特定文件类型的差异化读取，如音频读取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson41</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//仅读</span></span><br><span class="line">    <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;<span class="comment">//最好动态分配，但是因为1024不大，故也可以为局部变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s [%s]\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s [%d]\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//lesson40();</span></span><br><span class="line">    <span class="built_in">lesson41</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>② 写入字符与字符串：</p><blockquote><p>读一个字符后，文件内指针移动；当再写一个字符时，从上次读的下一个位置直接覆盖写</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一指定字符写入文件流中：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span> <span class="params">(<span class="type">int</span> c, File *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一指定的字符串写入文件内：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：遇到str中的\0字符时，终止写入</span></span><br><span class="line"><span class="comment">//注意：str必须是标准C语言字符串【以0或者空字符为结尾的字符串】；否则将会一致写下去导致不可知错误</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson42</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);<span class="comment">//可读写</span></span><br><span class="line">    <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">fputc</span>(<span class="string">&#x27;/&#x27;</span>, pFile);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从此时的文件内指针开始读一行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s [%s]\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), pFile));</span><br><span class="line">        <span class="comment">//再读一个字符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s [%d]\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">fputs</span>(__FUNCTION__, pFile);</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson42</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>③ 标准写入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数据写至文件流：</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">//ptr：待写入内容的地址</span></span><br><span class="line"><span class="comment">//size：写入次数</span></span><br><span class="line"><span class="comment">//nmemb：写入字节数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新缓冲区：【时间消耗是不可控的】</span></span><br><span class="line"><span class="comment">//写入Disk硬盘时并非直接写入，而是先写入内存缓冲区，达到一定量时再写入硬盘缓冲区，最后慢慢进行读写。这种策略可以实现高速读写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson43</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test1.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);<span class="comment">//+意为如果不存在则创建</span></span><br><span class="line">    <span class="keyword">if</span> (pFile) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Test</span> data = &#123;</span><br><span class="line">            <span class="number">1000</span>,<span class="string">&quot;tiger&quot;</span>,<span class="number">28</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">size_t</span> ret = <span class="built_in">fwrite</span>(&amp;data, <span class="number">1</span>, <span class="built_in">sizeof</span>(Test), pFile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">    pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test1.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);<span class="comment">//以二进制形式读，因为不再是文本，而是二进制数据</span></span><br><span class="line">    <span class="keyword">if</span> (pFile) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Test</span> read;</span><br><span class="line">        <span class="type">size_t</span> ret = <span class="built_in">fread</span>(&amp;read, <span class="number">1</span>, <span class="built_in">sizeof</span>(Test), pFile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, read.id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ret = [%s]\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, read.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, read.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson43</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="3-7-3-文件内指针操作"><a href="#3-7-3-文件内指针操作" class="headerlink" title="3.7.3 文件内指针操作"></a>3.7.3 文件内指针操作</h5><p>获取和设置文件内指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得文件流的读取位置：</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动文件流的读写位置：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> fromwhere)</span></span>;</span><br><span class="line"><span class="comment">//offset:偏移</span></span><br><span class="line"><span class="comment">//fromwhere:位置选项 [SEEK_SET | SEEK_CUR | SEEK_END]</span></span><br><span class="line"><span class="comment">//SEEK_SET 从文件的开头计算位置【offset值不可为负数】</span></span><br><span class="line"><span class="comment">//SEEK_CUR 从文件的当前位置开始计算【offset值可为负数】</span></span><br><span class="line"><span class="comment">//SEEK_END 从文件的尾部开始计算位置【offset值可为负数】</span></span><br><span class="line"><span class="comment">//注意：fseek在跳转的时候，和文件实际的大小不一定一样，可以超过实际大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//应用于64位文件读取</span></span><br><span class="line"><span class="comment">//取得文件流的读取位置：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">(FILE* stream，<span class="type">fpos_t</span>* pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动文件流的读写位置：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="comment">//通过fgetpos获取fpos_t,再修改pos.__pos值来进行跳转</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson44</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ftell = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ftell</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ftell = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ftell</span>(pFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fseeko64();</span></span><br><span class="line">        <span class="built_in">fseek</span>(pFile, <span class="number">0</span>, SEEK_SET);<span class="comment">//SEEK_CUR, SEEK_END;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">fseek</span>(pFile, <span class="number">-1</span>, SEEK_CUR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">fseek</span>(pFile, <span class="number">-66</span>, SEEK_END);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ftell = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ftell</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">fpos_t</span> pos;</span><br><span class="line">        <span class="built_in">fgetpos</span>(pFile, &amp;pos);<span class="comment">//应用于64位文件读写</span></span><br><span class="line">        <span class="comment">//fgetpos64()</span></span><br><span class="line">        pos.__pos -= <span class="number">1</span>;<span class="comment">//记录offset值</span></span><br><span class="line">        <span class="built_in">fsetpos</span>(pFile, &amp;pos);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ftell = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ftell</span>(pFile));</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson44</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-4-文件流标志"><a href="#3-7-4-文件流标志" class="headerlink" title="3.7.4 文件流标志"></a>3.7.4 文件流标志</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查文件流是否读到了文件尾：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">//feof 文件未到尾部返回为0，否则为1</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//文件读到最后一个字节，并不会触发feof</span></span><br><span class="line"><span class="comment">//必须要再读取内容，才会触发feof</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//清除文件流的错误旗标：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定文件的处理错误</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson45</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pFile = <span class="built_in">fopen</span>(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//r为只读；r+为读写</span></span><br><span class="line">    <span class="keyword">if</span> (pFile) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//加入要读很多行，就要用到判断文件结尾</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">feof</span>(pFile)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s feof = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">feof</span>(pFile));</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));<span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">            <span class="comment">//Linux下的内存清理</span></span><br><span class="line">            <span class="comment">//bzero(buffer, sizeof(buffer));</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s [%s]\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), pFile));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s feof = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">feof</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fopen为r时，写出错ferror返回1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ferror = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ferror</span>(pFile));</span><br><span class="line">        <span class="built_in">fputc</span>(<span class="string">&#x27;a&#x27;</span>, pFile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ferror = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ferror</span>(pFile));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//虽然不可以写，但仍然可以设置文件内的读指针；需要先清理错误标志</span></span><br><span class="line">        <span class="built_in">clearerr</span>(pFile);</span><br><span class="line">        <span class="built_in">fseek</span>(pFile, <span class="number">200</span>, SEEK_SET);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ferror = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ferror</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ftell = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">ftell</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s  %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fputc</span>(<span class="string">&#x27;a&#x27;</span>, pFile);</span><br><span class="line">        <span class="built_in">fseek</span>(pFile, <span class="number">-1</span>, SEEK_CUR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %c\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">fgetc</span>(pFile));</span><br><span class="line">        <span class="built_in">fclose</span>(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson45</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="3-7-5-目录操作"><a href="#3-7-5-目录操作" class="headerlink" title="3.7.5 目录操作"></a>3.7.5 目录操作</h5><ul><li>创建/删除目录</li><li>修改文件/目录所有者或权限，以及关于链接文件</li><li>目录操作函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;sys/types.h&gt; 记录宏常量</span></span><br><span class="line"><span class="comment">//&lt;sys/stat.h&gt;  文件的状态结构体和相关的宏</span></span><br><span class="line"><span class="comment">//&lt;unistd.h&gt;    标准头文件，记录一些函数的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件夹：若成功则返回0，否则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span></span>;<span class="comment">//mode同3.5.1权限mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除*空文件夹：成功返回0，错误返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除【文件 | 空的文件夹 | 链接】【效果等于rm指令】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span><span class="comment">//定义权限宏常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson46</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ret = rmdir(__FUNCTION__);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s(%d):%s ret = %d\n&quot;, __FILE__, __LINE__, __FUNCTION__, ret);</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">mkdir</span>(__FUNCTION__, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo \&quot;test\&quot; &gt; lession46/test.txt&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">rmdir</span>(__FUNCTION__);<span class="comment">//-1：无法删除文件非空文件夹[sh: 1: cannot create lession46/test.txt: Directory nonexistent]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s rmdir ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">    ret = <span class="built_in">remove</span>(<span class="string">&quot;lession46/test.txt&quot;</span>);<span class="comment">//0:成功</span></span><br><span class="line">    ret = <span class="built_in">remove</span>(__FUNCTION__);<span class="comment">//删除空文件夹成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s remove ret = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">    <span class="comment">//ret = rmdir(__FUNCTION__);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s(%d):%s rmdir ret = %d\n&quot;, __FILE__, __LINE__, __FUNCTION__, ret);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson46</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>修改文件/目录所有者或权限</strong></p><blockquote><p>下面两个接口可以用system函数进行替代</p></blockquote><p>命令：<code>chown 用户.组 目标文件或者文件夹</code></p><blockquote><p>一般而言，用户和组的代码都一样</p><p>比如 root用户它有一个专属的分组，就叫root</p><p>比如system用户，对应分组也叫system</p><p>比如feng这个用户，对应的分组也叫feng</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改文件或者目录的用户或者组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="comment">//owner和group一般呢也是一样的</span></span><br><span class="line"></span><br><span class="line">&lt;sys/stat.h&gt;</span><br><span class="line"><span class="comment">//修改文件或者目录的权限（需要对应权限）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链接（也可以删除文件）【remove也可以删除链接】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">//创建链接文件【-s：软连接，相当于快捷方式】</span></span><br><span class="line"><span class="comment">//ln -s 源文件地址 链接文件地址</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span><span class="comment">//定义权限宏常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson47</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uid_t</span> uid = <span class="built_in">getuid</span>();</span><br><span class="line">    <span class="type">gid_t</span> gid = <span class="built_in">getgid</span>();</span><br><span class="line">    ret = <span class="built_in">chown</span>(<span class="string">&quot;./test&quot;</span>, uid, gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s chown = %d uid = %d gid = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret, <span class="built_in">getuid</span>(), <span class="built_in">getgid</span>());</span><br><span class="line">    <span class="comment">//程序内提权【su】</span></span><br><span class="line">    <span class="comment">//需要 sudo chmod 6755 filename.out【权限修改为：-rwsr-sr-x】</span></span><br><span class="line">    <span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line">    ret = <span class="built_in">chown</span>(<span class="string">&quot;./test&quot;</span>, uid, gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s chown = %d uid = %d gid = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret, <span class="built_in">getuid</span>(), <span class="built_in">getgid</span>());</span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">chmod</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="number">0600</span> | S_IRGRP | S_IROTH);<span class="comment">//相当于0644</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s chmod = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">unlink</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s unlink = %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson47</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>目录操作函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;sys/types.h&gt;【包含一些宏】</span></span><br><span class="line"><span class="comment">//&lt;dirent.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开目录</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭目录</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取目录</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> * <span class="built_in">readdir</span>(DIR * dir);</span><br><span class="line"><span class="comment">//返回值pCur为dirent结构体，pCur-&gt;d_type为文件类型</span></span><br><span class="line"><span class="comment">//对于d_type：</span></span><br><span class="line"><span class="comment">//DT_UNKNOWN：未知【值为0】</span></span><br><span class="line"><span class="comment">//DT_FIFO：管道【值为1】</span></span><br><span class="line"><span class="comment">//DT_CHR：字符设备【值为2】</span></span><br><span class="line"><span class="comment">//DT_DIR：目录【值为4】</span></span><br><span class="line"><span class="comment">//DT_BLK: 块设备【值为6】</span></span><br><span class="line"><span class="comment">//DT_REG：普通文件【值为8】</span></span><br><span class="line"><span class="comment">//DT_LNK：软连接【值为10】</span></span><br><span class="line"><span class="comment">//DT_SOCK：套接字文件【值为12】</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> </span><br><span class="line">&#123; </span><br><span class="line">   <span class="type">long</span> d_ino; <span class="comment">/* inode number 索引节点号 */</span> </span><br><span class="line">   <span class="type">off_t</span> d_off; <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this d_name 文件名长 */</span> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* the type of d_name 文件类型 */</span> </span><br><span class="line">   <span class="type">char</span> d_name [NAME_MAX<span class="number">+1</span>]; <span class="comment">/* file name (null-terminated) 文件名，最长255字符 */</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dump_files</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***************************************************************\n&quot;</span>);</span><br><span class="line">    DIR* proot = <span class="built_in">opendir</span>(root);<span class="comment">//打开目录</span></span><br><span class="line">    <span class="keyword">if</span> (proot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s ~ is not exist!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent* pCur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pCur = <span class="built_in">readdir</span>(proot);</span><br><span class="line">        <span class="keyword">if</span> (pCur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pCur-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(pCur-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;d_type &amp; DT_DIR) &#123;<span class="comment">//如果为目录4</span></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">512</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;%s/%s&quot;</span>, root, pCur-&gt;d_name);<span class="comment">//缓冲形成绝对路径</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">                <span class="built_in">dump_files</span>(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pCur != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">closedir</span>(proot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson48</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dump_files</span>(<span class="string">&quot;/home/feng/projects&quot;</span>);</span><br><span class="line">    <span class="comment">//DIR* proot = opendir(&quot;/home/feng&quot;);</span></span><br><span class="line">    <span class="comment">//if (proot == NULL) &#123;</span></span><br><span class="line">    <span class="comment">//	printf(&quot;%s(%d):%s ~ is not exist!\n&quot;, __FILE__, __LINE__, __FUNCTION__);</span></span><br><span class="line">    <span class="comment">//	return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//dirent* pCur = NULL;</span></span><br><span class="line">    <span class="comment">//do &#123;</span></span><br><span class="line">    <span class="comment">//	pCur = readdir(proot);</span></span><br><span class="line">    <span class="comment">//	if (pCur != NULL) &#123;</span></span><br><span class="line">    <span class="comment">//		if (strcmp(pCur-&gt;d_name, &quot;.&quot;) == 0 || strcmp(pCur-&gt;d_name, &quot;..&quot;) == 0)</span></span><br><span class="line">    <span class="comment">//			continue;</span></span><br><span class="line">    <span class="comment">//		if (pCur-&gt;d_type &amp; DT_DIR) &#123;</span></span><br><span class="line">    <span class="comment">//			printf(&quot;%s(%d):%s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, pCur-&gt;d_name);</span></span><br><span class="line">    <span class="comment">//		&#125;</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    <span class="comment">//&#125; while (pCur != NULL);</span></span><br><span class="line">    <span class="comment">//closedir(proot);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dump_files</span>(<span class="string">&quot;/home/chase/Linux_consoleApplication&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><h3 id="4-网络编程基础"><a href="#4-网络编程基础" class="headerlink" title="4 网络编程基础"></a>4 网络编程基础</h3><h4 id="4-1-网络的基本概念"><a href="#4-1-网络的基本概念" class="headerlink" title="4.1 网络的基本概念"></a>4.1 网络的基本概念</h4><h5 id="4-1-1-网络的物理结构"><a href="#4-1-1-网络的物理结构" class="headerlink" title="4.1.1 网络的物理结构"></a>4.1.1 网络的物理结构</h5><p>数据是如何从一台机器传输到另外一台机器？</p><p><img src="./4-1.png"></p><p>中断接口→操作系统→网络数据接收接口就会有数据</p><p>【数据→系统→网卡→路由器→modem】→互联网→【modem→路由器→网卡→系统→接收程序】</p><p><strong>光纤千兆网络</strong></p><p>需要：千兆光纤线、千兆光纤转接口、工作中的转接口、光纤交换机</p><br><h5 id="4-1-2-网络中的地址-IP"><a href="#4-1-2-网络中的地址-IP" class="headerlink" title="4.1.2 网络中的地址(IP)"></a>4.1.2 网络中的地址(IP)</h5><blockquote><p>并不是所有的地址都是可以用的</p></blockquote><p>32位网络地址由四个字节构成【4 x 8，共<code>255 x 255 x 255 x 255</code> 个】</p><p><strong>注意：</strong></p><ul><li>以0开头【第一个字节】的地址，都是不可以用的</li><li>以0结尾【第四个字节】的地址，表示的是网段，而不是具体的地址</li><li>224开头到239开头的地址，是<strong>组播</strong>地址，不可用于点对点的传输【组播可以理解为<code>tcp/udp</code>上面的广播，可以极大的节约带宽】【问题：容易形成网络风暴】</li><li>240开头到255开头的地址【实验用，保留，一般不做服务器或者终端地址】</li><li><code>127.0.0.1</code>保留：回环网络的地址【本机网络：往这个地址发任何数据，都会被回发回来】</li><li><code>0.0.0.0</code>保留：一般用于服务器监听的，表示全网段监听</li><li>内网保留地址或IPv4专用地址【内网是可以访问互联网的，但需要一台服务器或路由器做网关，通过网关来连接互联网】<ul><li>Class A <code>10.0.0.0 - 10.255.255.255</code>【默认子网掩码：255.0.0.0】</li><li>Class B <code>172.16.0.0 - 172.31.255.255</code>【默认子网掩码：255.240.0.0】</li><li>Class C <code>192.168.0.0 - 192.168.255.255</code>【默认子网掩码：255.255.0.0】</li></ul></li></ul><p><img src="./4-2.png"></p><p>A类【大型网络地址】、B类【中型网络】、C类【常用】用于不同规模的网络；D类用于组播；E类保留，用于实验、私有网络</p><p><strong>注意</strong>：</p><ul><li>大型服务器大部分都是有多个地址IP的【用于全网络服务、内外网区别访问】</li></ul><br><h5 id="4-1-3-网络中的端口"><a href="#4-1-3-网络中的端口" class="headerlink" title="4.1.3 网络中的端口"></a>4.1.3 网络中的端口</h5><p><strong>公认端口</strong>（Well Known Ports）：这类端口也常称之为”常用端口”，如：</p><ul><li>443：加密https服务</li><li>22：ssh</li><li>80：实际上总是HTTP通信所使用</li><li>23：Telnet服务专用</li></ul><p>这类端口的端口号从0到1024，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象【此类端口通常不会被黑客程序利用】</p><p><strong>注册端口</strong>（Registered Ports）：端口号从1025到49151。</p><ul><li>3306：Mysql</li></ul><p>它们松散地绑定于一些服务，同时这些端口同样用于许多其他目的。另外，这些端口多数没有明确的定义服务对象，不同程序可根据实际需要自定义，如后面要介绍的远程控制软件和木马程序中都会有这些端口的定义。</p><blockquote><p>记住这些常见的程序端口在木马程序的防护和查杀上是非常有必要的，常见木马所使用的端口在后面将有详细的列表。</p></blockquote><p><strong>动态和私有端口</strong>（Dynamic and/or Private Ports）：端口号从49152到65535【不要轻易作为服务器的监听端口，除非确认服务器不会向未知IP发起请求；防火墙等会将此类端口严格管理甚至拒绝】</p><blockquote><p>理论上，不应把常用服务分配在此类端口上。</p><p>实际上，有些较为特殊的程序，特别是一些木马程序就非常喜欢用这些端口，因为这些端口常常不被引起注意，容易隐蔽。</p><p>端口并非只有服务器才会使用，客户端也一样会使用端口。</p></blockquote><br><h5 id="4-1-4-什么是协议？"><a href="#4-1-4-什么是协议？" class="headerlink" title="4.1.4 什么是协议？"></a>4.1.4 什么是协议？</h5><p>TCP协议包头说明：</p><blockquote><p>TCP/UDP 位于传输层；协议位于第七层应用层</p></blockquote><p><img src="./4-3.png"></p><p>HTTP协议的包头样例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /search/detail?ct=<span class="number">503316480</span>&amp;z=<span class="number">0</span>&amp;ipn=d</span><br><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: pic.baidu.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Cache</span>-Control: max-age=<span class="number">0</span></span><br><span class="line"><span class="attribute">Upgrade</span>-Insecure-Requests: <span class="number">1</span></span><br><span class="line"><span class="attribute">User</span>-Agent: Mozilla/<span class="number">5</span>.<span class="number">0</span> (Windows NT <span class="number">10</span>.<span class="number">0</span>; WOW64) AppleWebKit/<span class="number">537</span>.<span class="number">36</span> (KHTML, like Gecko) Chrome/<span class="number">70</span>.<span class="number">0</span>.<span class="number">3538</span>.<span class="number">25</span> Safari/<span class="number">537</span>.<span class="number">36</span> Core/<span class="number">1</span>.<span class="number">70</span>.<span class="number">3766</span>.<span class="number">400</span> QQBrowser/<span class="number">10</span>.<span class="number">6</span>.<span class="number">4163</span>.<span class="number">400</span></span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="number">0</span>.<span class="number">9</span>,image/webp,image/apng,*/*;q=<span class="number">0</span>.<span class="number">8</span></span><br><span class="line"><span class="attribute">Accept</span>-Encoding: gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept</span>-Language: zh-CN,zh;q=<span class="number">0</span>.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>SSH数据包头结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sshhead</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tlen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> plen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msgcode;</span><br><span class="line">    <span class="built_in">sshead</span>()&#123;tlen=<span class="number">6</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>协议</strong>就是一种<strong>网络式交互中数据格</strong>和<strong>交互流程</strong>的约定。通过协议，我们可以与远程的设备进行数据交互，请求或者完成对方的服务【<strong>协议就是计算机中特定任务的语言、约定</strong>】</p><br><h5 id="4-1-5-TCP协议基础"><a href="#4-1-5-TCP协议基础" class="headerlink" title="4.1.5 TCP协议基础"></a>4.1.5 TCP协议基础</h5><p>传输控制协议【TCP，Transmission Control Protocol】是一种<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流</strong>的<strong>传输层</strong>通信协议</p><blockquote><p><strong>可靠的协议</strong>：UDP协议是不可靠的协议；TCP协议是可靠的，但是牺牲了性能</p><p><strong>基于字节流</strong>：可以发1个字节，也可以发1万个字节，以字节为单位，数据是字节流；而http为文本流</p></blockquote><p>交互流程：</p><p><img src="./4-4.png"></p><p>很多时候，只有<strong>超时处理</strong>才能解决物理连接中断；而默认的超时，可能长达两个小时，这样造成很大的性能损失。</p><p>弥补：<strong>心跳包的机制</strong>，即强制询问双方是否在线。如果终止或者异常连续超过若干次【三次】，则判定物理连接错误。【也常用于提升UDP的可靠性】</p><br><h4 id="4-2-套接字"><a href="#4-2-套接字" class="headerlink" title="4.2 套接字"></a>4.2 套接字</h4><h5 id="4-2-1-什么是套接字"><a href="#4-2-1-什么是套接字" class="headerlink" title="4.2.1 什么是套接字"></a>4.2.1 什么是套接字</h5><p>网络编程就是编写程序使<strong>两台连网的计算机相互交换数据</strong>。</p><p>两台计算机之间用什么传输数据呢？首先需要物理连接，在此基础上，只需考虑如何编写<strong>数据传输软件</strong>。</p><p>但实际上这也不用愁，因为操作系统会提供名为”套接字”【socket】的部件。<strong>套接字是网络数据传输用的软件设备</strong>。【即使对网络数据传输原理不太熟悉，我们也能通过套接字完成数据传输。因此，网络编程又称为套接字编程】</p><blockquote><p>那为什么要用”套接字”这个词呢？套接字在英文里面就是“插孔/插座”的意思。</p><p>就如同我们要用电，要用到插孔，同样的，对于我们要用网络，那么就要用到socket。</p></blockquote><p><img src="./4-5.png"></p><br><h5 id="4-2-2-套接字的创建【socket函数】"><a href="#4-2-2-套接字的创建【socket函数】" class="headerlink" title="4.2.2 套接字的创建【socket函数】"></a>4.2.2 套接字的创建【socket函数】</h5><p>套接字有很多种，其中用的最多的是TCP和UDP。【考虑到我们现在能用的上的，我们先要讨论的TCP套接字】</p><p>TCP套接字可以比喻成<strong>电话机</strong>。实际上，电话机也是通过固定电话网【telephone network】完成语音数据交换的。打个比方：创建一个套接字就相当于是安装了一部电话机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linux 下的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//domain【域】套接字中使用的协议族（Protocol Family）信息</span></span><br><span class="line"><span class="comment">//type套接字数据传输类型信息</span></span><br><span class="line"><span class="comment">//protocol【协议】计算机间通信中使用的协议信息</span></span><br></pre></td></tr></table></figure><p><strong>参数一：domain 【Protocol Family】</strong></p><blockquote><p>头文件 <code>sys/socket.h</code> 中声明的协议族，下面节选5个【<code>PF</code>与<code>AF</code>有一一对应关系】【<code>Address Family</code>】</p></blockquote><table><thead><tr><th align="center">名称</th><th align="center">协议族</th><th>说明</th></tr></thead><tbody><tr><td align="center">PF_INET</td><td align="center">IPv4互联网协议族</td><td>最常用，应掌握</td></tr><tr><td align="center">PF_INET6</td><td align="center">IPv6互联网协议族</td><td></td></tr><tr><td align="center">PF_LOCAL</td><td align="center">本地通信的UNIX协议族</td><td></td></tr><tr><td align="center">PF_PACKET</td><td align="center">底层套接字的协议族</td><td>Socket直接操作IP协议</td></tr><tr><td align="center">PF_IPX</td><td align="center">IPX Novell互联网协议族</td><td></td></tr></tbody></table><p><strong>参数二：套接字类型：type</strong></p><p>套接字类型指的是套接字的<strong>数据传输方式</strong>，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。</p><blockquote><p>为什么已通过第一个参数传递了协议族信息，还要决定数据传输方式？</p><p>问题就在于，决定了协议族并不能同时决定数据传输方式。换言之，socket函数第一个参数<code>PF_INET</code>协议族中也存在多种数据传输方式。 </p></blockquote><p><span style="background:#ff0">套接字类型1∶面向连接的套接字【SOCK_STREAM】【TCP】</span></p><p>如果向socket函数的第二个参数传递<code>SOCK_STREAM</code>，将创建<strong>面向连接</strong>的套接字【可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字】</p><blockquote><p>什么是面向连接呢？数据的传输方式有三个特点：</p><ul><li>传输的过程数据不会丢失</li><li>按顺序传输</li><li>传输的过程中不存在数据边界</li></ul></blockquote><blockquote><p>数据边界是什么？</p><p>举个例子：100个糖果是分批传递的，但接收者凑齐100个后才装袋。再比如：传输数据的计算机通过3次调用write函数传递了100字节的数据，但接收数据的计算机仅通过1次read函数调用就接收了全部100个字节。</p></blockquote><p> 收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此，收到数据并不意味着马上调用read函数，只要不超过数组容量，则有可能在数据填充满缓冲后通过1次read函数调用读取全部，也有可能分成多次read函数调用进行读取。也就是说，<strong>在面向连接的套接字中，read函数和write函数的调用次数并无太大意义</strong>。所以说面向连接的套接字不存在数据边界。【更直观的举例，发了三次次两字节的数据，接受的不一定是三组两字节的数据，即没有数据边界】</p><blockquote><p>🔺经典问题：没有数据边界，会导致粘包问题，即无法区分两个包的边界。</p><p>解决：自定义包的边界标志</p></blockquote><br><p><span style="background:#ff0">套接字类型2∶面向消息的套接字【SOCK DGRAM】【UDP】</span></p><p>如果向socket函数的第二个参数传递<code>SOCK_DGRAM</code>，则将创建<strong>面向消息的套接字</strong>。面向消息的套接字可以比喻成高速移动的摩托车快递。数据（包裹）的传输方式有四个特点：</p><ul><li>强调快速传输而非传输顺序</li><li>传输的数据可能丢失也可能损毁</li><li>传输的过程中不存在数据边界</li><li>限制每次传输的数据大小</li></ul><p>面向消息的套接字：不可靠的、不按序传递的、以数据的高速传输为目的的套接字【用于音频/视频】</p><br><p><strong>参数三：protocol 计算机间通信中使用的协议信息</strong></p><p>大部分情况下可以向第三个参数传递0，当前两个参数确定之后，自动匹配一个最佳参数。</p><p>除非遇到以下这种情况∶【对协议研究较深入时】同一协议族中存在多个数据传输方式相同的协议，即数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。</p><br><h5 id="4-2-3-套接字绑定地址和端口【bind函数】"><a href="#4-2-3-套接字绑定地址和端口【bind函数】" class="headerlink" title="4.2.3 套接字绑定地址和端口【bind函数】"></a>4.2.3 套接字绑定地址和端口【bind函数】</h5><ul><li>bind函数及其参数</li><li>网络字节序与地址变换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//Linux</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//调用bind函数给套接字分配地址后，就基本完成了接电话的所有准备工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：套接字描述符 sockfd</span></span><br><span class="line"><span class="comment">//要分配地址信息（IP地址和端口号）的套接字文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数三：第二个结构体变量的长度【一般直接用sizeof(第二个参数)】</span></span><br><span class="line"><span class="comment">//第二个参数根据第三参数，来确定第二参数的解析方式</span></span><br></pre></td></tr></table></figure><p>如果把<strong>套接字</strong>比喻为电话，那么目前只安装了电话机。接着就要给电话机分配号码的方法，即使用bind函数给套接字分配 <strong>IP地址和端口号</strong>。</p><p><strong>参数二：存有地址信息的结构体变量地址值</strong>【myaddr】</p><p><span style="background:#ff0">网络地址：</span></p><ul><li><p>4字节地址族【IPv4：Internet Protocol version 4】</p></li><li><p>16字节地址族【IPv6：Internet Protocol version 6】</p></li></ul><p><img src="./4-6.png"></p><p>只需通过IP地址的第一个字节即可判断网络地址占用的字节数，因为我们根据IP地址的边界区分网络地址：</p><ul><li><p>A类地址的首字节范围∶0~127 【A类地址的首位以0开始】</p></li><li><p>B类地址的首字节范围∶128~191 【B类地址的前2位以10开始】</p></li><li><p>C类地址的首字节范围∶192~223 【C类地址的前3位以110开始】</p></li></ul><br><p><span style="background:#ff0">端口 ：</span></p><ul><li>IP用于区分计算机，端口用于在同一操作系统内为区分不同套接字而设置的，因此无法将1个端口号分配给不同套接字。</li><li>另外，端口号由<code>16位</code>构成，可分配的端口号范围是<code>0-65535</code>。但<code>0-1023</code>是知名端口，一般分配给特定应用程序。</li><li>虽然端口号不能重复，但TCP套接字和UDP套接字不会共用端口号，所以允许重复。例如：如果某TCP 套接字使用9190号端口，则其他TCP套接字就无法使用该端口号，但UDP套接字可以使用。</li></ul><p>总之，数据传输目标地址同时包含<strong>IP地址和端口号</strong>。只有这样，数据才会被传输到最终的目的应用程序【应用程序套接字】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//地址信息的表示：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> <span class="comment">//in：internet</span></span><br><span class="line">&#123;</span><br><span class="line">    sa_family;<span class="comment">//地址族（Address Family）【基本固定】</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">// //地址族（Address Family）【基本固定】</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port; <span class="comment">// 16位TCP/UDP端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">//32位IP地址，以【网络字节序】保存【应同时参考结构体in_addr，其声明为uint32t，因此只需当作32位整数型即可】</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//不使用，无特殊含义【只是为使结构体sockaddr_in的大小与sockaddr结构体保持一致而插入的成员。必需填充为0，否则无法得到想要的结果。】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    In_addr_t s_addr; <span class="comment">//32位IPv4地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>成员<code>sin_family</code> — 地址族【Address Family】：</p><p><img src="./4-7.png"></p></blockquote><br><p><strong>网络字节序与地址变换</strong></p><ul><li><p>大端序【Big Endian】：数值的高位字节存放在内存的低地址端，低位字节存放在内存的高地址端【如<code>0x1A2B3C4D</code>】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存低地址 --------------------&gt; 内存高地址</span><br><span class="line">0x1A | 0x2B | 0x3C | 0x4D</span><br><span class="line">高位字节 &lt;-------------------- 低位字节</span><br></pre></td></tr></table></figure></li><li><p>小端序【Little Endian】：高位字节存放到高位地址。</p></li></ul><p><strong>字节序转换：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过函数名掌握其功能</span></span><br><span class="line"><span class="comment">//htons中的h代表主机（host）字节序；n代表网络（network）字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;<span class="comment">//可以解释为&quot;把short型数据从网络字节序转化为主机字节序&quot;</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span>;<span class="comment">//long四字节为IP</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span>;<span class="comment">//long四字节为IP</span></span><br></pre></td></tr></table></figure><p>示例：</p><blockquote><p><code>bind</code>函数的第二参数是一个结构体指针，设计初衷是C/C++接口编程。由于C不支持函数重载，故只能用这样的形式来兼容C。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson57</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//&lt;sys/socket.h&gt; &lt;sys/types.h&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (sock != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">        addr.sin_family = AF_INET;<span class="comment">// &lt;sys / socket.h&gt;</span></span><br><span class="line">        <span class="comment">//&lt;arpa/inet.h&gt;::inet_addr:该函数将string转为网络地址，即4字节</span></span><br><span class="line">        addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.0.1&quot;</span>);</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);<span class="comment">//short的主机字节序转为网络字节序</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//报错在此</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson57</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct sockaddr_in addr;</span></span><br><span class="line"><span class="comment">//memset(&amp;addr,0,sizeof(addr);//结构体变量addr的所有成员初始化为0</span></span><br><span class="line"><span class="comment">//INADDRANY</span></span><br><span class="line"><span class="comment">//每次创建服务器端套接字都要输入IP地址会很繁琐，此时可初始化地址信息为INADDRANY。</span></span><br><span class="line"><span class="comment">//addr.sin_addr.s_addr=htonl(INADDRANY);</span></span><br></pre></td></tr></table></figure><br><h5 id="4-2-4-listen函数"><a href="#4-2-4-listen函数" class="headerlink" title="4.2.4 listen函数"></a>4.2.4 listen函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sock,<span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>sock希望进入<strong>等待连接请求状态</strong>的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字【监听套接字】</p></li><li><p><code>backlog</code>为<strong>连接请求等待队列</strong>【Queue】的长度。若为5，则队列长度为5，表示最多使5个连接请求进入队列【即一瞬间可以同时处理多少连接请求】【≤1ms】</p><p><img src="./4-8.png"></p></li></ul><p>由上图可知，作为<code>listen</code>函数的第一个参数【文件描述符套接字】的用途：</p><p>客户端连接请求本身也是从网络中接收到的一种数据，而要想接收就需要套接字。此任务就由服务器端套接字完成，它可以比作是接收连接请求的一名门卫或一扇门。</p><blockquote><p>客户端如果向服务器端询问：“请问我是否可以发起连接？”</p><p>服务器端套接字就会亲切应答∶”您好！当然可以，但系统正忙，请到等候室排号等待，准备好后会立即受理您的连接。” 同时将连接请求安排到等候室。</p></blockquote><ul><li>调用<code>listen</code>函数即可生成这种门卫【服务器端套接字】</li><li><code>listen</code>函数的第二个参数决定了等候室的大小</li><li>等候室称为连接请求等待队列。准备好服务器端套接字和连接请求等待队列后，这种可接收连接请求的状态称为<strong>等待连接请求状态</strong></li><li><code>listen</code>函数的第二个参数值与服务器端的特性有关，像频繁接收请求的Web服务器端至少应为15【另外，连接请求队列的大小始终根据实验结果而定】。</li></ul><br><h5 id="4-2-5-accept函数"><a href="#4-2-5-accept函数" class="headerlink" title="4.2.5 accept函数"></a>4.2.5 accept函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回创建的套接字文件描述符，失败时返回-1</span></span><br><span class="line"><span class="comment">//默认为阻塞状态，</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p><code>sock</code>：服务器套接字的文件描述符</p></li><li><p><code>addr</code>：保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息【因为存在伪造的可能，故仅供参考】</p></li><li><p><code>addrlen</code>：第二个参数结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填客户端地址长度。</p></li></ul><p><img src="./4-9.png"></p><blockquote><p>调用<code>listen</code>函数后，若有新的连接请求，则应按序受理。如果在与客户端的数据交换中使用门卫，那谁来守门呢？因此需要另外一个套接字，但没必要亲自创建。此时accept应运而生。</p></blockquote><p><code>accept</code> 函数受理<strong>连接请求等待队列</strong>中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于<strong>数据I/O的套接字，并返回其文件描述符</strong>。套接字是自动创建的，并自动与发起连接请求的客户端建立连接【上图展示了<code>accept</code>函数调用过程】</p><br><h4 id="4-3-TCP编程"><a href="#4-3-TCP编程" class="headerlink" title="4.3 TCP编程"></a>4.3 TCP编程</h4><h5 id="4-3-1-TCP-IP协议栈"><a href="#4-3-1-TCP-IP协议栈" class="headerlink" title="4.3.1 TCP/IP协议栈"></a>4.3.1 TCP/IP协议栈</h5><blockquote><p>为什么要理解协议栈？学习C/C++就是要懂底层的原理，否则永远都是调包侠。</p></blockquote><p>根据数据传输方式的不同，基于网络协议【TCP/IP协议】的套接字一般分为TCP套接字和UDP套接字。因为TCP套接字是面向连接的，因此又称基于流【<code>stream</code>】的套接字。</p><blockquote><p> <code>TCP</code>是<code>Transmission Control Protocol</code>【传输控制协议】的简写，意为”对数据传输过程的控制”，即可靠的连接。</p></blockquote><p><img src="./4-10.png"></p><p><strong>第一层次：数据链路层</strong></p><p>如上图所示：链路层是物理链接领域标准化的结果，也是最基本的领域。专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要上图所示的物理连接，链路层就负责这些标准。</p><p><strong>第二层次：IP层</strong></p><blockquote><p>准备好物理连接后就要传输数据。为了在复杂的网络中传输数据，首先需要考虑路径的选择。</p><p>向目标传输数据需要经过哪条路径？解决此问题就是IP层，该层使用的协议就是IP协议，解决数据包“从哪儿来-到哪儿去”的问题。</p></blockquote><p>IP是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径；但如果发生数据丢失或错误，则无法解决。换言之，IP协议是无法应对数据错误的。因此，错误处理又要下放一层。</p><p><strong>第三层次：TCP/UDP层</strong></p><p>IP层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP和UDP层以IP层提供的路径信息为基础完成实际的数据传输，故该层又称传输层（Transport）。</p><p>IP层只关注1个数据包（数据传输的基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由IP层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则有可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中有可能只收到A和C，甚至收到的C可能已损毁。</p><p>若添加TCP协议则按照下图的对话方式进行数据交换。</p><p><img src="./4-11.png"></p><p><strong>第四层次：应用层</strong></p><p>为了使程序员从这些细节中解放出来，前面三个层次中的【选择数据传输路径、数据确认过程】都被隐藏到套接字内部，并自动处理。也就是说，前面三个层次都是为了给应用层提供服务。</p><br><h5 id="4-3-2-TCP服务端"><a href="#4-3-2-TCP服务端" class="headerlink" title="4.3.2 TCP服务端"></a>4.3.2 TCP服务端</h5><p>最原始最简单的服务器模型：【收发一次数据】</p><p><img src="./4-12.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson60</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP：IPv4协议族中的流式socket|PF协议族</span></span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));<span class="comment">//清0【Linux下有zero函数清零】</span></span><br><span class="line">    seraddr.sin_family = AF_INET;<span class="comment">//地址族 本质是一致的，只是用在不同场合</span></span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);<span class="comment">//相当于填 INADDR_ANY：代表监听本机所有IP</span></span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);<span class="comment">//此时的套接字才是服务器端套接字</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    <span class="comment">//调用accept函数从队头取1个连接请求与客户端建立连接，并返回创建的套接字文件描述符</span></span><br><span class="line">    <span class="comment">//另外，调用accept函数时若等待队列为空，则accept函数不会返回，直到队列中出现新的客户端连接（阻塞）</span></span><br><span class="line">    client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;accept failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已连接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(client, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="keyword">if</span> (len != (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(message)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    <span class="built_in">close</span>(client);<span class="comment">//可以不执行的</span></span><br><span class="line">    <span class="built_in">close</span>(server);<span class="comment">//因为服务端关闭的时候，客户端会自动关闭【一般服务端不关闭】</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson60</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>会卡在<code>accept</code>函数，因为只有<code>client</code>请求之后，<code>aceept</code>才会返回；否则一直阻塞。</p></blockquote><br><h5 id="4-3-3-connect函数"><a href="#4-3-3-connect函数" class="headerlink" title="4.3.3 connect函数"></a>4.3.3 connect函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sock,<span class="keyword">struct</span> sockaddr* servaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//sock：客户端套接字文件描述符 client</span></span><br><span class="line"><span class="comment">//servaddr：保存目标服务器端地址信息的变量地址值</span></span><br><span class="line"><span class="comment">//addrlen：以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度</span></span><br><span class="line"><span class="comment">//servaddr使用addrlen进行地址识别</span></span><br></pre></td></tr></table></figure><p>思考：<strong>客户端套接字地址信息</strong>在哪儿？</p><p>实现服务器端必经过程之一就是给套接字分配IP和端口号。但客户端实现过程中并未出现套接字地址分配，而是创建套接字后立即调用conect函数。难道客户端套接字无需分配IP和端口？【答案当然不是！】</p><p>网络数据交换必须分配IP和端口。既然如此，那客户端套接字何时、何地、如何分配地址呢?</p><ul><li>何时? 调用connect函数时。</li><li>何地? 操作系统，更准确地说是在内核中。</li><li>如何? IP用计算机【主机】的IP、端口随机。</li></ul><p>客户端的IP地址和端口在调用<code>connect</code>函数时自动分配，无需调用标记的<code>bind</code>函数进行分配。这就是与服务端的不同。</p><br><h5 id="4-3-4-TCP客户端"><a href="#4-3-4-TCP客户端" class="headerlink" title="4.3.4 TCP客户端"></a>4.3.4 TCP客户端</h5><p>基于TCP服务端/客户端的函数调用关系：【须在<code>listen</code>之后、<code>close</code>之前进行<code>connect</code>】</p><p><img src="./4-13.png"></p><p>客户端代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson60</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP：IPv4协议族中的流式socket|PF协议族</span></span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));<span class="comment">//清0【Linux下有zero函数清零】</span></span><br><span class="line">    seraddr.sin_family = AF_INET;<span class="comment">//地址族 本质是一致的，只是用在不同场合</span></span><br><span class="line">    <span class="comment">//seraddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//相当于填 INADDR_ANY：代表监听本机所有IP</span></span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);<span class="comment">//此时的套接字才是服务器端套接字</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    <span class="comment">//调用accept函数从队头取1个连接请求与客户端建立连接，并返回创建的套接字文件描述符</span></span><br><span class="line">    <span class="comment">//另外，调用accept函数时若等待队列为空，则accept函数不会返回，直到队列中出现新的客户端连接（阻塞）</span></span><br><span class="line">    client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;accept failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已连接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(client, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="keyword">if</span> (len != (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(message)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    <span class="built_in">close</span>(client);<span class="comment">//可以不执行的</span></span><br><span class="line">    <span class="built_in">close</span>(server);<span class="comment">//因为服务端关闭的时候，客户端会自动关闭【一般服务端不关闭】</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson62</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//pid=0 为子进程</span></span><br><span class="line">        <span class="comment">//开启客户端</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//等待服务端先跑起来</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">            std::cout &lt;&lt; buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//pid&gt; 0 为父进程</span></span><br><span class="line">        <span class="built_in">lesson60</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为避免子进程成为僵尸进程</span></span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson62</span>();</span><br><span class="line">    <span class="comment">//lesson60();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如何同时运行服务器和客户端：【进程控制：fork函数】</p></li><li><p>可以使用TCP进行多进程间通信</p><br></li></ul><h4 id="4-4-实现迭代服务器-客户端"><a href="#4-4-实现迭代服务器-客户端" class="headerlink" title="4.4 实现迭代服务器/客户端"></a>4.4 实现迭代服务器/客户端</h4><h5 id="4-4-1-迭代服务器"><a href="#4-4-1-迭代服务器" class="headerlink" title="4.4.1 迭代服务器"></a>4.4.1 迭代服务器</h5><blockquote><p>前面的普通服务器的缺点：启动一次服务程序，只能给一个客户端服务</p></blockquote><p>迭代服务器比较原始，它的原型可以描述成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//new_fd = 服务器accept客户端的连接(new_fd = accept(listenfd, XX, XX))</span></span><br><span class="line">    <span class="comment">//逻辑处理</span></span><br><span class="line">    <span class="comment">//在这个new_fd上给客户端发送消息</span></span><br><span class="line">    <span class="comment">//关闭new_fd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，这个程序是一个一个处理各个客户端发来的连接的。比如一个客户端发来一个连接，那么只要它还没有完成自己的任务，那么它就一直会占用服务器的进程直到处理完毕后服务器关闭掉这个socket【即可以循环服务多个客户端】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;Hello. here is client\n&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(client, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        std::cout &lt;&lt; buffer;<span class="comment">//收到回复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_serve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务器端进行多次accept监听处理</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;accept failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="built_in">write</span>(client, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (len != (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(buffer)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;write failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(server);<span class="comment">//因为服务端关闭的时候，客户端会自动关闭【一般服务端不关闭】</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson63</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//pid=0 为子进程</span></span><br><span class="line">        <span class="comment">//开启客户端</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//等待服务端先跑起来</span></span><br><span class="line">        <span class="built_in">run_client</span>();</span><br><span class="line">        <span class="built_in">run_client</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//pid&gt; 0 为父进程</span></span><br><span class="line">        <span class="built_in">run_serve</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为避免子进程成为僵尸进程</span></span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson63</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) chase@chase-virtual-machine:~/Linux_consoleApplication/bin/x64/Debug$ ./Linux_consoleApplication.out </span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(63):run_serve</span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(19):run_client</span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(77):run_serve</span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(85):run_serve</span><br><span class="line">Hello. here is client</span><br><span class="line">client <span class="keyword">done</span>!</span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(19):run_client</span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(77):run_serve</span><br><span class="line">/home/chase/Linux_consoleApplication/main.cpp(85):run_serve</span><br><span class="line">Hello. here is client</span><br><span class="line">client <span class="keyword">done</span>!</span><br><span class="line"><span class="comment">#需要手动退出</span></span><br></pre></td></tr></table></figure><br><h5 id="4-4-2-回声服务器实现"><a href="#4-4-2-回声服务器实现" class="headerlink" title="4.4.2 回声服务器实现"></a>4.4.2 回声服务器实现</h5><p>回声服务器：将从客户端收到的数据原样返回给客户端，即回声。改进点如下：</p><ul><li><p><code>client</code> 客户端加入输入输出交互：fgets、fputs</p></li><li><p>服务端 <code>accept</code> 仅2次，每次<code>accept</code> 进行无限次回声服务</p></li><li><p>子进程调用服务器，父【主】进程调用客户端</p></li></ul><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//加入交互</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to Quit):&quot;</span>, stdout);<span class="comment">//符合Linux思想：一切皆文件</span></span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), stdin);<span class="comment">//从标准输入流中获取，并写入buffer，最大长度为第二参数，以回车结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断条件最好加两层括号，避免优先级问题出现意外</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(client, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;from server:&quot;</span> &lt;&lt; buffer;<span class="comment">//收到回复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_serve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="comment">//const char* message = &quot;hello world!\n&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端进行多次accept监听处理</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)<span class="comment">//accept 两个客户端</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;accept failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">//优化************************************************</span></span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer))) &gt; <span class="number">0</span>)<span class="comment">//while条件是不为0怎继续循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//直接回声至服务端</span></span><br><span class="line">            len = <span class="built_in">write</span>(client, buffer, len);<span class="comment">//注意！</span></span><br><span class="line">            <span class="keyword">if</span> (len != (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(buffer)) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;write failed! len:(&quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot;) buffer:&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">close</span>(server);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直到客户端不发消息 len&lt;=0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s (%s)\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;read abort!&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(server);<span class="comment">//因为服务端关闭的时候，客户端会自动关闭【一般服务端不关闭】</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//pid=0 为子进程</span></span><br><span class="line">        <span class="comment">//开启服务器</span></span><br><span class="line">        <span class="built_in">run_serve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//pid&gt; 0 为父进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">run_client</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson64</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：当服务器端出错，如果直接close服务器，那么主进程中的两次client循环自动终止【即第二次connect时服务器已终止】</p></blockquote><br><h5 id="4-4-3-回声服务器存在的问题"><a href="#4-4-3-回声服务器存在的问题" class="headerlink" title="4.4.3 回声服务器存在的问题"></a>4.4.3 回声服务器存在的问题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(sock, message,<span class="built_in">strlen</span>(message));</span><br><span class="line">str_len= <span class="built_in">read</span>(sock, message,BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">message[str_len]= <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Message from server:%s&quot;</span>,message);</span><br></pre></td></tr></table></figure><p>以上代码有个<strong>错误假设</strong>∶”每次调用read、write函数时都会以字符串为单位执行实际的I/O操作。”【Input输入：外部设备到内存；Output输出：内存到外部设备】</p><blockquote><p>当然，每次调用write函数都会传递1个字符串，因此这种假设在某种程度上也算合理。但是我们之前讲过：TCP不存在数据边界吗?</p></blockquote><p>上述客户端是基于TCP的。因此，多次调用write函数传递的字符串有可能一次性传递到服务器端。此时客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。还需考虑服务器端的如下情况∶</p><ul><li>字符串太长，需要分2个数据包发送！</li></ul><blockquote><p>此时，我们的回声服务器端/客户端给出的结果是正确的。但这只是运气好罢了！只是因为收发的数据小，而且运行环境为同一台计算机或相邻的两台计算机，所以没发生错误，可实际上仍存在发生错误的可能。</p></blockquote><p><strong>完美解决回声服务器存在的问题：</strong>【多次读写缓冲区】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//加入交互</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to Quit):&quot;</span>, stdout);<span class="comment">//符合Linux思想：一切皆文件</span></span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), stdin);<span class="comment">//从标准输入流中获取，并写入buffer，最大长度为第二参数，以回车结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断条件最好加两层括号，避免优先级问题出现意外</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化写*****************************************</span></span><br><span class="line">        <span class="comment">//write(client, buffer, strlen(buffer));</span></span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strlen</span>(buffer);<span class="comment">//待发送的实际长度</span></span><br><span class="line">        <span class="type">size_t</span> send_len = <span class="number">0</span>;<span class="comment">//已发送的长度</span></span><br><span class="line">        <span class="keyword">while</span> (send_len &lt; len)<span class="comment">//存在未发送的内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">write</span>(client, buffer + send_len, <span class="built_in">strlen</span>(buffer) - send_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;write failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//即每次实际发送长度ret，不一定为buffer的全部</span></span><br><span class="line">            send_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//优化读</span></span><br><span class="line">        <span class="comment">//read(client, buffer, sizeof(buffer));</span></span><br><span class="line">        <span class="type">size_t</span> read_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (read_len &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将client套接字读到buffer+read_len的位置，本次共读len - read_len个</span></span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">read</span>(client, buffer + read_len, len - read_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;read failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            read_len += ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;from server:&quot;</span> &lt;&lt; buffer;<span class="comment">//收到回复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_serve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="comment">//const char* message = &quot;hello world!\n&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端进行多次accept监听处理</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)<span class="comment">//accept 两个客户端</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;accept failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="comment">//优化************************************************</span></span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer))) &gt; <span class="number">0</span>)<span class="comment">//while条件是不为0怎继续循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//直接回声至服务端</span></span><br><span class="line">            len = <span class="built_in">write</span>(client, buffer, len);<span class="comment">//注意！</span></span><br><span class="line">            <span class="keyword">if</span> (len != (<span class="type">ssize_t</span>)<span class="built_in">strlen</span>(buffer)) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;write failed! len:(&quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot;) buffer:&quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">close</span>(server);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直到客户端不发消息 len&lt;=0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s (%s)\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;read abort!&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(server);<span class="comment">//因为服务端关闭的时候，客户端会自动关闭【一般服务端不关闭】</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson65</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//pid=0 为子进程</span></span><br><span class="line">        <span class="comment">//开启服务器</span></span><br><span class="line">        <span class="built_in">run_serve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//pid&gt; 0 为父进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">run_client</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson65</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="4-4-4-回声服务器实战：计算器的网络实现"><a href="#4-4-4-回声服务器实战：计算器的网络实现" class="headerlink" title="4.4.4 回声服务器实战：计算器的网络实现"></a>4.4.4 回声服务器实战：计算器的网络实现</h5><p><strong>需求</strong>【CS架构】：</p><ol><li>客户端连接到服务器端后，以1字节整数形式传递待算数字个数【<code>0~255</code>】【应该 <code>≥2</code>】</li><li>客户端向服务器端传递的每个整数型数据占用4字节</li><li>传递整数型数据后接着传递运算符【运算符信息占用1字节，<code>+ | - | *</code>之一，即该运算只用一种运算符】</li><li>服务器端以4字节整数型向客户端传回运算结果</li><li>客户端得到运算结果后终止与服务器端的连接</li></ol><p>客户端实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_client66</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> opnd_cnt = <span class="number">0</span>;<span class="comment">//操作数个数</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];<span class="comment">//待发送缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//int tmp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数字个数【fgets获取字符串/scanf获取字符和数字】</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Operand count:[&gt;=2]&quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opnd_cnt);</span><br><span class="line">        <span class="keyword">if</span> (opnd_cnt &lt;= <span class="number">1</span> &amp;&amp; opnd_cnt &lt; <span class="number">256</span>)<span class="comment">//用1字节传递</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;Operand error, too small!\n&quot;</span>, stdout);</span><br><span class="line">            <span class="built_in">close</span>(client);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;client Done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[<span class="number">0</span>] = (<span class="type">char</span>)opnd_cnt;<span class="comment">//服务器此处要解释为无符号数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取操作数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; opnd_cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;Input operand:&quot;</span>, stdout);</span><br><span class="line">            <span class="comment">/*scanf(&quot;%d&quot;, &amp;tmp);</span></span><br><span class="line"><span class="comment">            buffer[i + 1] = tmp;*/</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, buffer + <span class="number">1</span> + <span class="number">4</span> * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fgetc</span>(stdin);<span class="comment">//换行符结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取操作符</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input operator:&quot;</span>, stdout);</span><br><span class="line">        buffer[<span class="number">1</span> + opnd_cnt * <span class="number">4</span>] = (<span class="type">char</span>)<span class="built_in">fgetc</span>(stdin);</span><br><span class="line">        <span class="built_in">fgetc</span>(stdin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓冲分批发送</span></span><br><span class="line">        <span class="type">size_t</span> len = opnd_cnt * <span class="number">4</span> + <span class="number">2</span>;<span class="comment">//待发送的实际长度</span></span><br><span class="line">        <span class="type">size_t</span> send_len = <span class="number">0</span>;<span class="comment">//已发送的长度</span></span><br><span class="line">        <span class="keyword">while</span> (send_len &lt; len)<span class="comment">//存在未发送的内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">write</span>(client, buffer + send_len, len - send_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;(client)write failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//即每次实际发送长度ret，不一定为buffer的全部</span></span><br><span class="line">            send_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//优化读</span></span><br><span class="line">        <span class="type">size_t</span> read_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (read_len &lt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">read</span>(client, buffer + read_len, len - read_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;read failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            read_len += ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;from server:&quot;</span> &lt;&lt; *(<span class="type">int</span>*)buffer &lt;&lt; std::endl;<span class="comment">//收到运算结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculator</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">int</span> oprand[], <span class="type">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = oprand[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result += oprand[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result -= oprand[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result *= oprand[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server66</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> server, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="comment">//const char* message = &quot;hello world!\n&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端套接字</span></span><br><span class="line">    server = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="keyword">if</span> (server &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(server, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端进行多次accept监听处理</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)<span class="comment">//accept 两个客户端</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        client = <span class="built_in">accept</span>(server, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;accept failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(server);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//connected</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s (%s)\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;connected!&quot;</span>);</span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="number">0</span>;</span><br><span class="line">        len = <span class="built_in">read</span>(client, buffer, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如1字节的200[11001000]转为4字节无符号，发现首bit为1，故前面全部添加1</span></span><br><span class="line">            <span class="comment">//即1111...111[11001000],此时&amp;0xFF之后，即只保留了[11001000]200</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ((<span class="type">unsigned</span>)buffer[<span class="number">0</span>] &amp; <span class="number">0xFF</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">read</span>(client, buffer + <span class="number">1</span> + i * <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">read</span>(client, buffer + <span class="number">1</span> + ((<span class="type">unsigned</span>)buffer[<span class="number">0</span>] &amp; <span class="number">0xFF</span>) * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">            result = <span class="built_in">calculator</span>(((<span class="type">unsigned</span>)buffer[<span class="number">0</span>] &amp; <span class="number">0xFF</span>), (<span class="type">int</span>*)(buffer + <span class="number">1</span>), buffer[<span class="number">1</span> + ((<span class="type">unsigned</span>)buffer[<span class="number">0</span>] &amp; <span class="number">0xFF</span>) * <span class="number">4</span>]);</span><br><span class="line">            <span class="built_in">write</span>(client, &amp;result, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt;&quot;result:&quot; &lt;&lt; result &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">close</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(server);<span class="comment">//因为服务端关闭的时候，客户端会自动关闭【一般服务端不关闭】</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson66</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//开启服务器</span></span><br><span class="line">        <span class="built_in">server66</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="built_in">run_client66</span>();</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fork failed!&quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson66</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>fgets获取字符串</li><li>scanf获取字符和数字</li><li><code>fgetc(stdin);</code>换行符结束输入，消除换行符</li></ul><br><h4 id="4-5-TCP底层原理"><a href="#4-5-TCP底层原理" class="headerlink" title="4.5 TCP底层原理"></a>4.5 TCP底层原理</h4><h5 id="4-5-1-TCP套接字的I-O缓冲"><a href="#4-5-1-TCP套接字的I-O缓冲" class="headerlink" title="4.5.1 TCP套接字的I/O缓冲"></a>4.5.1 TCP套接字的I/O缓冲</h5><p>我们知道，TCP套接字的数据收发无边界【即并非每次发5字节，就会收5字节；服务器端即使调用1次write函数传输40字节的数据，客户端也有可能通过4次read函数调用每次读取10字节】【在上节的代码中，客户端将参数收集到buffer缓冲区后，只进行了一次写操作；而服务端分多次read读取参数，最后写一次】</p><p>但此处也有一些疑问，服务器端一次性传输了40字节，而客户端居然可以缓慢地分批接收。客户端接收10字节后，剩下的30字节在何处等候呢？是不是像飞机为等待着陆而在空中盘旋一样，剩下30字节也在网络中徘徊并等待接收呢?</p><p>实际上，write函数调用后<strong>并非立即传输数据</strong>，read函数调用后也<strong>并非马上接收数据</strong>。更准确地说，如下图所示，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输人缓冲读取数据。</p><p><img src="./4-14.png"></p><p>调用<code>write</code>函数时，数据将移到输出缓冲，在适当的时候【不管是分别传送还是一次性传送】传向对方的输入缓冲，这时对方将调用read函数从输入缓冲读取数据。这些I/O 缓冲特性可整理如下:</p><ul><li>I/O缓冲在每个TCP套接字中单独存在</li><li>I/O缓冲在创建套接字时自动生成</li><li>即使关闭套接字也会继续传递输出缓冲中遗留的数据</li><li>关闭套接字将丢失输入缓冲中的数据。</li></ul><p>那么，下面这种情况会引发什么后果?【理解了I/O缓冲后，其流程∶】</p><blockquote><p>“客户端输入缓冲为50字节，而服务器端传输了100字节。”</p><p>这的确是个问题。输入缓冲只有50字节，却收到了100字节的数据。可以提出如下解决方案∶</p><p>填满输入缓冲前迅速调用read函数读取数据，这样会腾出一部分空间，问题就解决了。其实，根本不会发生这类问题，因为TCP会控制数据流。</p></blockquote><p>TCP中有滑动窗口【<code>Sliding Window</code>】协议，用对话方式呈现如下：</p><ul><li><p>套接字A∶”你好，最多可以向我传递50字节。”</p></li><li><p>套接字B∶”OK!”</p></li><li><p>套接字A∶”我腾出了20字节的空间，最多可以收70字节。</p></li><li><p>套接字B∶”OK!”</p></li></ul><p>数据收发也是如此，因此TCP中不会因为缓冲溢出而丢失数据；但是会因为缓冲而影响传输效率。</p><br><h5 id="4-5-2-TCP的内部原理"><a href="#4-5-2-TCP的内部原理" class="headerlink" title="4.5.2 TCP的内部原理"></a>4.5.2 TCP的内部原理</h5><p>TCP通信三大步骤：</p><ol><li><p>三次握手建立连接</p></li><li><p>开始通信，进行数据交换</p></li><li><p>四次挥手断开连接</p><br></li></ol><h5 id="4-5-3-TCP三次握手"><a href="#4-5-3-TCP三次握手" class="headerlink" title="4.5.3 TCP三次握手"></a>4.5.3 TCP三次握手</h5><p>【第一次握手】套接字A∶”你好，套接字B。我这儿有数据要传给你，建立连接吧。”</p><p>【第二次握手】套接字B∶”好的，我这边已就绪。”【一般A是客户端，B是服务端】</p><p>【第三次握手】套接字A∶”谢谢你受理我的请求。”</p><p><img src="./4-15.png"></p><blockquote><p>有一种网络攻击，两次握手之后直接结束，而服务器一直等待第三地握手</p></blockquote><p><span style="background:#ff0">【①】</span>首先，请求连接的主机A向主机B传递如下信息∶</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SYN] SEQ:1000,  ACK: -</span><br></pre></td></tr></table></figure><p>该消息中<code>SEQ</code>为1000，<code>ACK</code>为空，而<code>SEQ</code>为1000的含义∶”现传递的数据包序号为1000，如果接收无误，请通知我向您传递1001号数据包。”</p><blockquote><p>这是首次请求连接时使用的消息，又称SYN。SYN是 <code>Synchronization</code> 的简写，表示收发数据前传输的同步消息。</p></blockquote><p><span style="background:#ff0">【②】</span>接下来主机B向A传递如下消息∶</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[SYN + ACK]</span> SEQ:<span class="number">2000</span>,   ACK:<span class="number">1001</span></span><br></pre></td></tr></table></figure><p>此时<code>SEQ</code>为2000，<code>ACK</code>为1001，而<code>SEQ</code>为2000的含义∶”现传递的数据包序号为2000如果接收无误，请通知我向您传递2001号数据包。”</p><p>而<code>ACK</code>1001的含义∶”刚才传输的<code>SEQ</code>为1000的数据包接收无误，现在请传递<code>SEQ</code>为1001的数据包。”</p><blockquote><p>对主机A首次传输的数据包的确认消息（ACK1001）和为主机B传输数据做准备的同步消息（SEQ2000）捆绑发送，因此，此种类型的消息又称 <code>SYN+ACK</code>。</p><p>收发数据前向数据包分配序号【<code>SEQ</code>】，并向对方通报此序号，这都是为防止数据丢失所做的准备。通过向数据包分配序号并确认，可以在数据丢失时马上查看并重传丢失的数据包。因此，TCP可以<strong>保证可靠的数据传输</strong>。</p></blockquote><p><span style="background:#ff0">【③】</span>最后观察主机A向主机B传输的消息∶</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ACK]</span> SEQ:<span class="number">1001</span>,  ACK:<span class="number">2001</span></span><br></pre></td></tr></table></figure><p>TCP连接过程中发送数据包时需分配序号。在之前的序号1000的基础上加1，也就是分配1001。此时该数据包传递如下消息∶”已正确收到传输的<code>SEQ</code>为2000的数据包，现在可以传输<code>SEQ</code>为2001的数据包。”</p><p>这样就传输了添加<code>ACK</code> 2001的<code>ACK</code>消息。至此，主机A和主机B确认了彼此均就绪。</p><br><p>通俗易懂的<strong>另类理解</strong>：</p><blockquote><p>TCP 三次握手好比在一个夜高风黑的夜晚，你一个人在小区里散步，不远处看见小区里的一位漂亮妹子迎面而来，但是因为路灯有点暗等原因不能100%确认，所以要通过招手的方式来确定对方是否认识自己：</p><ol><li>你首先向妹子招手【SYN】，妹子看到你向自己招手后，向你点了点头挤出了一个微笑【ACK】。你看到妹子微笑后确认了妹子成功辨认出了自己</li><li>但是妹子有点不好意思，向四周看了一看，有没有可能你是在看别人呢，她也需要确认一下。妹子也向你招了招手【SYN】，你看到妹子向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑【ACK】，妹子看到对方的微笑后确认了你就是在向自己打招呼【进入established状态】</li></ol></blockquote><p>总结一下，这个过程中总共有四个动作：</p><ol><li>你招手</li><li>妹子点头微笑</li><li>妹子招手</li><li>你点头微笑</li></ol><blockquote><p>这不是四次握手吗？为什么是三次？？</p><p>答案：2+3 动作是两个动作的合并</p></blockquote><ol><li><p>你招手【SYN】</p></li><li><p>妹子点头微笑并向你招手【SYN+ACK】</p></li><li><p>你点头微笑【ACK】</p><p>于是确定了你和妹纸之间可以进行拥抱，而我们就来到TCP通信的第二步了！</p></li></ol><br><h5 id="4-5-4-TCP数据传输"><a href="#4-5-4-TCP数据传输" class="headerlink" title="4.5.4 TCP数据传输"></a>4.5.4 TCP数据传输</h5><p>TCP 数据传输就是两个人隔空交流，有一定的距离，需要对方反复确认听见了自己的话。</p><p><img src="./4-16.png"></p><blockquote><p>你喊了一句话【SEQ】，妹子听见了之后要向你回复自己听见了【ACK】</p><p>如果你喊了一句，半天没听到妹子回复，你会很低落，好比谈恋爱的时候，你满腔热情，而妹子忽冷忽热，所以你锲而不舍，一次不行，就两次，两次不行就三次，这就是<strong>TCP重传</strong>。既然会重传，妹子就有可能同一句话听见了两次，这就是<strong>去重</strong>。</p></blockquote><p>重传和去重这两项工作，操作系统的网络内核模块都已经帮我们处理好了！</p><blockquote><p>完事之后，妹纸和你要依依不舍地分开了，那么就要分手了</p></blockquote><p>也就是来到了TCP通信的第三步了</p><br><h5 id="4-5-5-TCP四次挥手"><a href="#4-5-5-TCP四次挥手" class="headerlink" title="4.5.5 TCP四次挥手"></a>4.5.5 TCP四次挥手</h5><p><img src="./4-17.png"></p><blockquote><p>主动发起发要等待两次服务端的应答，此时就很有可能卡在这一步。实际情况中，局域网内的时延为30ms以内，累加之后依然是不可接受的时延。故在开发中，需要将等待任务交给一个新线程去执行【即本线程不做挥手下线任务】</p></blockquote><p>挥手过程：</p><ol><li><p>套接字A∶”我希望断开连接。”</p></li><li><p>套接字B∶”哦，是吗?请稍候。”</p></li><li><p>套接字B∶”我也准备就绪，可以断开连接。”</p></li><li><p>套接字A∶”好的，谢谢合作。”</p></li></ol><p>翻译为生活场景就是：</p><ol><li><p>我：”对不起，我妈叫我回家了，我想分开了。”</p></li><li><p>妹纸：”好的，请稍后，我给我妈打个电话，确定一下能不能回家。”</p></li><li><p>妹纸：”我确定好了，可以回家，分开吧。”</p></li><li><p>我：”好的，分开吧，分手快乐。”</p></li></ol><blockquote><p>关于TCP的各种状态，在高级课程里介绍</p></blockquote><br><h5 id="4-5-6-TCP如何保证可靠传输"><a href="#4-5-6-TCP如何保证可靠传输" class="headerlink" title="4.5.6 TCP如何保证可靠传输"></a>4.5.6 TCP如何保证可靠传输</h5><blockquote><p>待补充</p></blockquote><ul><li>三次握手四次挥手</li><li>拥塞控制</li><li>流量管理</li><li>应答机制，校验位、时序、序列号</li><li>等等</li></ul><br><h4 id="4-6-UDP编程"><a href="#4-6-UDP编程" class="headerlink" title="4.6 UDP编程"></a>4.6 UDP编程</h4><h5 id="4-6-1-UDP基本原理"><a href="#4-6-1-UDP基本原理" class="headerlink" title="4.6.1 UDP基本原理"></a>4.6.1 UDP基本原理</h5><p>在四层<code>TCP/IP</code>模型中，第二层传输层【Transport】分为<code>TCP</code>和<code>UDP</code>两种。数据交换过程可以分为：</p><ul><li>通过<code>TCP</code>套接字完成的<code>TCP</code> 方式</li><li>通过<code>UDP</code>套接字完成的<code>UDP</code> 方式【用户数据报协议，<code>User Datagram Protocol</code>】</li></ul><p>UDP套接字的特点：</p><ul><li>UDP 是<strong>无连接的</strong>，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li><li>UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，主机不需要维持复杂的连接状态表</li><li>UDP 是<strong>面向报文的</strong>，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li><li>UDP 没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP 的首部开销小，只有8个字节，比 TCP 的20个字节的首部要短</li></ul><blockquote><p>我们可以通过信件说明UDP的工作原理，这是讲解UDP时使用的传统示例，它与UDP特性完全相符。</p></blockquote><p><strong>寄信前应先在信封上填好寄信人和收信人的地址，之后贴上邮票放进邮筒即可</strong>。</p><ul><li><p>信件的特点使我们无法确认对方是否收到</p></li><li><p>另外，邮寄过程中也可能发生信件丢失的情况</p></li></ul><p>也就是说，信件是一种不可靠的传输方式。与之类似，UDP提供的同样是<strong>不可靠的数据传输服务</strong>。</p><br><p><strong>引入问题</strong>：既然如此，TCP应该是更优质的协议吧？</p><p><strong>答</strong>：如果只考虑可靠性，TCP的确比UDP好；但UDP在结构上比TCP更简洁，即性能更快。</p><ul><li>UDP不会发送类似<code>ACK</code>的应答消息，也不会像<code>SEQ</code>那样给数据包分配序号。因此，UDP的性能有时比TCP高出很多。</li><li>编程中实现UDP也比TCP简单。</li><li>另外，UDP的可靠性虽比不上TCP，但也不会像想象中那么频繁地发生数据损毁。因此，在更重视性能而非可靠性的情况下，UDP是一种很好的选择。</li></ul><p>既然如此，UDP的作用到底是什么呢?为了提供可靠的数据传输服务，TCP在不可靠的IP层进行流控制，而UDP就缺少这种流控制机制。</p><blockquote><p><strong>流控制</strong>是区分UDP和TCP的最重要的标志。但若从TCP中除去流控制，所剩内容也屈指可数。也就是说，TCP的生命在于流控制。</p></blockquote><br><p><strong>引入问题</strong>：如何将TCP与UDP的优势结合起来？</p><p>如果把<code>TCP</code>比喻为<strong>电话</strong>，把 <code>UDP</code>比喻为<strong>信件</strong>。</p><blockquote><p>但这只是形容协议工作方式，并没有包含<strong>数据交换速率</strong>。请不要误认为【电话的速度比信件快，因此TCP 的数据收发速率也比 UDP快】。</p><p>实际上正好相反。TCP的速度无法超过UDP，但在收发某些类型的数据时有可能接近 UDP。例如，每次交换的数据量越大，TCP的传输速率就越接近 UDP的传输速率。</p></blockquote><p><img src="./4-18.png"></p><p>从上图可以看出，<strong>IP</strong>的作用就是<span style="background:#ff0">让离开主机B的UDP数据包准确传递到主机A</span>。但把<code>UDP</code>包最终交给主机A的某一个UDP套接字的过程则是由UDP完成的。UDP最重要的作用就是<span style="background:#ff0">根据<strong>端口号</strong>将传到主机的数据包交付给最终的UDP套接字。</span></p><p>其实，在实际的应用场景中，UDP也具有一定的可靠性。网络传输特性导致信息丢失频发，可若要传递压缩文件【发送1万个数据包时，只要丢失1个就会产生问题】，则<span style="background:#ff0">必须使用TCP</span>，因为压缩文件只要丢失一部分就很难解压。但通过网络实时传输视频或音频时的情况有所不同。对于多媒体数据而言，丢失一部分也没有太大问题，这只会引起短暂的画面抖动，或出现细微的杂音。但因为需要提供实时服务，速度就成为非常重要的因素，此时需要考虑使用UDP【此时，可以同时使用TCP进行流量监控，比如报告丢包情况以便进行应对】。但UDP并非每次都快于TCP，TCP比UDP慢的原因通常有以下两点：</p><ul><li>收发数据前后进行的连接设置及清除过程</li><li>收发数据过程中为保证可靠性而添加的流控制</li></ul><p>总之，尤其是收发的数据量小但需要频繁连接时，UDP比TCP更高效。</p><p>另外，也可以使用UDP去模拟TCP，但可以一次握手建立连接，简化应答机制。</p><br><h5 id="4-6-2-UDP服务端"><a href="#4-6-2-UDP服务端" class="headerlink" title="4.6.2 UDP服务端"></a>4.6.2 UDP服务端</h5><p>UDP中的服务器端和客户端没有连接：</p><ul><li>UDP服务器端/客户端不像TCP那样在连接状态下交换数据，因此与TCP不同，无需经过连接过程</li><li>也就是说，不必调用TCP连接过程中调用的<code>listen</code>函数和<code>accept</code>函数</li><li>UDP中只有创建套接字的过程和数据交换过程</li></ul><p>UDP服务器端和客户端<strong>均只需一个套接字</strong>：</p><p>TCP中，套接字之间应该是一对一的关系，即若要向10个客户端提供服务，则除了守门的服务器套接字外，还需要10个服务器端套接字。但在UDP中，不管是服务器端还是客户端都只需要1个套接字。</p><blockquote><p>之前解释UDP原理时举了信件的例子，收发信件时使用的<strong>邮筒</strong>可以比喻为UDP套接字。只要附近有1个邮筒，就可以通过它向任意地址寄出信件。同样，只需1个UDP套接字就可以向任意主机传输数据。</p></blockquote><p><img src="./4-19.png"></p><blockquote><p>上图展示了1个UDP套接字与两个不同主机交换数据的过程。也就是说，只需1个UDP套接字就能和多台主机通信。【视频会议就是利用UDP的这种特性】</p></blockquote><p>需要注意的是，创建好TCP套接字后，传输数据时无需再添加地址信息【这是因为TCP套接字将保持与对方套接字的连接。换言之，TCP套接字知道目标地址信息】。</p><p>但UDP套接字不会保持连接状态【UDP套接字只有简单的邮筒功能】，因此每次传输数据都要添加目标地址信息，这相当于寄信前在信件中填写地址。以下为填写地址并传输数据时调用的UDP相关函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回传输的字节数，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock,<span class="type">void</span>*buff,<span class="type">size_t</span> nbytes,<span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//sock:用于传输数据的UDP套接字文件描述符。</span></span><br><span class="line"><span class="comment">//buff:保存待传输数据的缓冲地址值。</span></span><br><span class="line"><span class="comment">//nbytes:待传输的数据长度，以字节为单位。</span></span><br><span class="line"><span class="comment">//flags:可选项参数，若没有则传递0。</span></span><br><span class="line"><span class="comment">//to:存有目标地址信息的sockaddr结构体变量的地址值。</span></span><br><span class="line"><span class="comment">//addrlen:传递给参数to的地址值结构体变量长度。</span></span><br></pre></td></tr></table></figure><blockquote><p>上述函数与之前的TCP输出函数最大的区别在于，此函数<strong>需要向它传递目标地址信息</strong>。</p></blockquote><p>接下来介绍<strong>接收UDP数据</strong>的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回接收的字节数，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* from,  <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="comment">//sock：用于接收数据的UDP套接字文件描述符。</span></span><br><span class="line"><span class="comment">//buff：保存接收数据的缓存地址值</span></span><br><span class="line"><span class="comment">//nbytes：可接收的最大字节数，故无法超过参数buf所指的缓冲大小。</span></span><br><span class="line"><span class="comment">//flags：可选项参数，若没有则传入0。</span></span><br><span class="line"><span class="comment">//from：存有发送端地址信息的sockaddr结构体变量的地址值。</span></span><br><span class="line"><span class="comment">//addrlen：保存参数from的结构体变量长度的变量地址值。</span></span><br></pre></td></tr></table></figure><p>UDP数据的发送端并不固定，因此该函数定义为可接收发送端信息的形式，也就是将同时返回UDP数据包中的发送端信息。</p><blockquote><p>编写UDP程序时<strong>最核心的部分</strong>就在于上述两个函数，这也说明二者在UDP数据传输中的地位。</p></blockquote><blockquote><p>UDP是DDOS攻击的主要方式，一个原因是UDP无法拒收。就算屏蔽该IP，也只能UDP数据包到达接收端后，才能知道发送端IP。另一个原因是UDP包中的发送端地址可以伪造。</p></blockquote><br><h5 id="4-6-3-UDP回声服务器"><a href="#4-6-3-UDP回声服务器" class="headerlink" title="4.6.3 UDP回声服务器"></a>4.6.3 UDP回声服务器</h5><p>服务端总结为以下几步：</p><ol><li>声明变量</li><li>参数校验</li><li>创建UDP套接字</li><li>填写地址</li><li>bind</li><li>收/发消息</li><li>关闭套接字</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, stderr);<span class="comment">//标准错误流，也可以输出到stdout</span></span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lesson73_server</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//参数声明</span></span><br><span class="line">    <span class="type">int</span> ser_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">512</span>];<span class="comment">//buffer</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr, clientaddr;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在bash中执行：./LinuxConsole.out 9527</span></span><br><span class="line">        <span class="comment">//argv[1]= 9527</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ussage:%d &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">handle_error</span>(<span class="string">&quot;Argument Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    ser_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);<span class="comment">//UDP [tcp为SOCK_STREAM]</span></span><br><span class="line">    <span class="keyword">if</span> (ser_sock == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handle_error</span>(<span class="string">&quot;create UDP-Socket Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填写地址</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//0.0.0.0</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">short</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(ser_sock, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handle_error</span>(<span class="string">&quot;bind failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收发10次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="built_in">recvfrom</span>(ser_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="built_in">sendto</span>(ser_sock, message, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, clientlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(ser_sock);<span class="comment">//如果不执行，一般需要延迟30s才能再次bind！！！！！</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server close!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果不执行 <code>close(socket)</code> ，一般需要延迟30s才能再次<code>bind</code>。这就是之前实验中为什么总是出现<code>bind failed</code>的原因。</li><li><code>serv_sock=socket(PF_INET, SOCK_DGRAM, 0);</code> 创建UDP套接字，向<code>socket</code>函数第二个参数传递<code>SOCK_DGRAM</code></li><li><code>recvfrom</code> 利用分配的地址接收数据，不限制数据传输对象。</li><li><code>sendto</code>函数调用同时获取数据传输端的地址，正是利用该地址将接收的数据逆向重传。</li></ul><br><h5 id="4-6-4-UDP客户端"><a href="#4-6-4-UDP客户端" class="headerlink" title="4.6.4 UDP客户端"></a>4.6.4 UDP客户端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lesson74_client</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//变量声明</span></span><br><span class="line">    <span class="type">int</span> client_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">socklen_t</span> serv_len = <span class="built_in">sizeof</span>(serv_addr);</span><br><span class="line">    <span class="type">char</span> message[<span class="number">512</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在bash中执行：./LinuxConsole.out 9527</span></span><br><span class="line">        <span class="comment">//argv[1]= 9527</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ussage:%d &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">handle_error</span>(<span class="string">&quot;Argument Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    client_socket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);<span class="comment">//UDP,dgram:数据报</span></span><br><span class="line">    <span class="keyword">if</span> (client_socket == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handle_error</span>(<span class="string">&quot;client socked create fail!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填写地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//目标发送地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>((<span class="type">short</span>)<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input message[Q/q to Quit]:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">sendto</span>(client_socket, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, serv_len);</span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">recvfrom</span>(client_socket, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, &amp;serv_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(client_socket);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client close!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>为什么fork后，主进程开客户端，子进程开服务端？</p><ul><li>d</li><li>父进程更易于调试</li></ul></li><li><p><code>bind failed</code> 的绑定错误？</p><blockquote><p>见4.7</p></blockquote></li><li><p>客户端退出条件是<code>q\n</code>还是<code>q</code> ？【如何调试？】</p><p>在实际断点调试中，<code>message</code>为<code>q</code>，故选择后者。【添加断点，可在代码中查看变量值】</p></li><li><p>UDP在<code>sendto</code>函数中自动分配发送端接受地址和端口；如果先调用recvfrom，即当作服务器用，就必须bind。</p></li></ul><br><h5 id="4-6-5-UDP的传输特性和调用"><a href="#4-6-5-UDP的传输特性和调用" class="headerlink" title="4.6.5 UDP的传输特性和调用"></a>4.6.5 UDP的传输特性和调用</h5><p>上节讲到UDP服务器端/客户端的实现方法。但如果仔细观察UDP客户端会发现，它<span style="background:#ff0">缺少把IP和端口分配给套接字的过程。</span></p><ul><li>TCP客户端调用<code>connect</code>函数自动完成此过程，而UDP中连能承担相同功能的函数调用语句都没有【究竟在何时分配IP和端口号呢?】</li><li>UDP程序中，调用<span style="background:#ff0;font-weight:700">sendto函数传输数据前应完成对套接字的地址分配工作</span>，因此调用<code>bind</code>函数。</li></ul><blockquote><p>当然，bind函数在TCP程序中出现过，但bind函数不区分TCP和UDP，也就是说，在UDP程序中同样可以调用。</p></blockquote><ul><li>另外，如果调用<code>sendto</code>函数时发现尚未分配地址信息，则在首次调用<code>sendto</code>函数时给相应套接字自动分配IP和端口【IP用主机IP，端口号选尚未使用的任意端口号】【注册端口或动态端口】</li><li>而且此时分配的地址一直保留到程序结束【关闭套接字之前】为止，因此也可用来与其他UDP套接字进行数据交换。</li></ul><p>综上所述，调用<code>sendto</code>函数时自动分配IP和端口号，即UDP客户端中通常无需额外的地址分配过程。</p><blockquote><p>🔺上例中为什么服务器端UDP需要<code>bind</code>，而客户端不需要<code>bind</code>？</p><p>答：客户端的<code>sendto</code>函数自动填充本地地址IP和Port，同时手动添加了目标地址和端口，同时之后的<code>recvform</code>沿用之前的目标地址和端口；而服务端直接<code>recvfrom</code>，其中只有服务端套接字，其他的都是与待接受的UDP数据包有关信息，连本地IP和端口都没有，故需要手动<code>bind</code>。</p><p>【也就是说，用了<code>sendto</code>就不需要<code>bind</code>，没用<code>sendto</code>之前要使用<code>recvfrom</code>就必须<code>bind</code>】</p></blockquote><br><h4 id="4-7-套接字的多种可选项"><a href="#4-7-套接字的多种可选项" class="headerlink" title="4.7 套接字的多种可选项"></a>4.7 套接字的多种可选项</h4><h5 id="4-7-1-I-O缓冲大小"><a href="#4-7-1-I-O缓冲大小" class="headerlink" title="4.7.1 I/O缓冲大小"></a>4.7.1 I/O缓冲大小</h5><p>我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也十分重要。【默认512K的缓冲区】</p><p><img src="./4-20.png"></p><blockquote><p>用于验证套接字类型的SO_TYPE是典型的只读可选项，这一点可以通过下面这句话解释∶套接字类型只能在创建时决定，以后不能再更改。</p></blockquote><p>从上表可以看出，套接字可选项是分层的。<code>IPPROTO_IP</code>层可选项是IP协议相关事项，<code>IPPROTO_TCP</code>层可选项是<code>TCP</code>协议相关的事项，<code>SOL_SOCKET</code>层是套接字相关的通用可选项。</p><blockquote><p>确实无需全部背下来或理解，实际能够设置的可选项数量是上表的好几倍，实际开发中逐一掌握即可。</p></blockquote><br><p><strong><code>getsockopt</code> &amp; <code>setsockopt</code> 函数【Linux函数，Windows有自己的相应函数】：</strong></p><p>我们几乎可以针对上表中的所有可选项进行读取【Get】和设置【Set】【当然，有些可选项只能进行一种操作】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level,<span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="comment">//sock ：用于查看选项套接字文件描述符。</span></span><br><span class="line"><span class="comment">//level：要查看的可选项的协议层。</span></span><br><span class="line"><span class="comment">//optname ：要查看的可选项名。</span></span><br><span class="line"><span class="comment">//optval：保存查看结果的缓冲地址值。</span></span><br><span class="line"><span class="comment">//optlen：向第四个参数optval传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。</span></span><br><span class="line"><span class="comment">//【详细使用方法见4.7.4/3】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span>*optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">//sock用于更改可选项的套接字文件描述符。</span></span><br><span class="line"><span class="comment">//level要更改的可选项协议层。</span></span><br><span class="line"><span class="comment">//optname 要更改的可选项名。</span></span><br><span class="line"><span class="comment">//optval 保存要更改的选项信息的缓冲地址值。</span></span><br><span class="line"><span class="comment">//optlen 向第四个参数optval传递的可选项信息的字节数。</span></span><br></pre></td></tr></table></figure><br><h5 id="4-7-2-SO-SNDBUF-amp-SO-RCVBUF"><a href="#4-7-2-SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="4.7.2 SO_SNDBUF &amp;SO_RCVBUF"></a>4.7.2 SO_SNDBUF &amp;SO_RCVBUF</h5><p>我们知道，创建套接字将同时生成I/O缓冲。<code>SO_RCVBUF</code>是输入缓冲大小相关可选项，<code>SO_SNDBUF</code>是输出缓冲大小相关可选项。用这两个可选项既可以读取当前I/O缓冲大小，也可以进行更改。</p><p>通过下列示例读取创建套接字时默认的I/O缓冲大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">int</span> snd_buf, rcv_buf, state;</span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    len = <span class="built_in">sizeof</span>(snd_buf);</span><br><span class="line">    <span class="comment">//获取SO_SNDBUF状态</span></span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_SNDBUF, &amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sizeof</span>(rcv_buf);</span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_RCVBUF, &amp;rcv_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input buffer size: %d \n&quot;</span>, rcv_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Outupt buffer size: %d \n&quot;</span>, snd_buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    snd_buf = <span class="number">1024</span> * <span class="number">3</span>, rcv_buf = <span class="number">1024</span> * <span class="number">3</span>;</span><br><span class="line">    state = <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;rcv_buf, <span class="built_in">sizeof</span>(rcv_buf));</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;setsockopt() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, <span class="built_in">sizeof</span>(snd_buf));</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;setsockopt() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看</span></span><br><span class="line">    len = <span class="built_in">sizeof</span>(rcv_buf);</span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_SNDBUF, &amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sizeof</span>(rcv_buf);</span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_RCVBUF, &amp;rcv_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input buffer size: %d \n&quot;</span>, rcv_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Outupt buffer size: %d \n&quot;</span>, snd_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台输出：</span></span><br><span class="line"><span class="comment">//Input buffer size: 131072</span></span><br><span class="line"><span class="comment">//Outupt buffer size: 16384</span></span><br><span class="line"><span class="comment">//Input buffer size: 6144</span></span><br><span class="line"><span class="comment">//Outupt buffer size: 6144</span></span><br></pre></td></tr></table></figure><br><h5 id="4-7-3-SO-REUSEADDR"><a href="#4-7-3-SO-REUSEADDR" class="headerlink" title="4.7.3 SO_REUSEADDR"></a>4.7.3 SO_REUSEADDR</h5><p>发生地址分配错误【<code>Binding Error</code>，即<code>bind</code>函数返回<code>-1</code>】</p><p>学习<code>SO_REUSEADDR</code>可选项之前，应理解好<code>Timewait</code>状态。以下面的程序为例：</p><ul><li>开启两个终端，一个参数为1，即服务端；两一个参数为2，即客户端</li><li>建立连接，即connect成功后，由服务端使用 <code>CTRL+C</code> 主动断开连接</li><li>再次运行第一步骤，试图建立连接【显示 <code>bind failed</code>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">server78</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, client;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr,client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(addr),clientlen=<span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="keyword">if</span> (serv_sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, addrlen);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">3</span>);</span><br><span class="line">    client = <span class="built_in">accept</span>(serv_sock,(<span class="keyword">struct</span> sockaddr*) &amp; client_addr, &amp;clientlen);</span><br><span class="line">    <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client78</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//【之前的TCP客户端】</span></span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to Quit):&quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), stdin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strlen</span>(buffer);<span class="comment">//待发送的实际长度</span></span><br><span class="line">        <span class="type">size_t</span> send_len = <span class="number">0</span>;<span class="comment">//已发送的长度</span></span><br><span class="line">        <span class="keyword">while</span> (send_len &lt; len)<span class="comment">//存在未发送的内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">write</span>(client, buffer + send_len, <span class="built_in">strlen</span>(buffer) - send_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;write failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//优化读</span></span><br><span class="line">        <span class="type">size_t</span> read_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (read_len &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">read</span>(client, buffer + read_len, len - read_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;read failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            read_len += ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;from server:&quot;</span> &lt;&lt; buffer;<span class="comment">//收到回复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson78</span><span class="params">(<span class="type">char</span>* option)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//模拟启动双进程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(option, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//服务器</span></span><br><span class="line">        <span class="built_in">server78</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//客户端</span></span><br><span class="line">        <span class="built_in">client78</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson78</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的程序是一个服务器，使用TCP套接字，等待客户端连接。【正常情况下，如果客户端断开连接，则需要经过四次挥手】。但是，如果”在客户端控制台输入<code>Q</code>消息，或通过<code>CTRL+C</code>终止程序”呢？</p></blockquote><p>也就是说，【方式①】让客户端先通知服务器端终止程序：</p><ul><li>在客户端控制台输入Q消息时调用<code>close</code>函数，向服务器端发送<code>FIN</code>消息并经过四次挥手过程。</li><li>当然，输人<code>CTRL+C</code> 时也会向服务器传递<code>FIN</code>消息【强制终止程序时，由操作系统关闭文件及套接字，此过程相当于调用<code>close</code>函数，也会向服务器端传递<code>FIN</code>消息】</li></ul><p><span style="background:#f9ad56">“但看不到什么特殊现象啊?”</span>答案是肯定的，通常都是由客户端先请求断开连接，所以不会发生特别的事情。重新运行服务器端也不成问题，但按照如下方式终止程序时则不同：”【方式②】服务器端和客户端已建立连接的状态下，向服务器端控制台输入<code>CTRL+C</code>，即强制关闭服务器端。”</p><blockquote><p>这主要模拟了服务器端向客户端发送<code>FIN</code>消息的情景。<span style="background:#ff0">如果以这种方式终止程序，那服务器端重新运行时将产生问题。如果用同一端口号重新运行服务器端，将输出 <code>bind error</code> ，并且无法再次运行。</span>【但在这种情况下，再过大约3分钟即可重新运行服务器端】</p></blockquote><hr><p><span style="background:#13dddd">上述两种运行方式唯一的区别就是：谁先传输<code>FIN</code>消息，但结果却迥然不同，原因何在?</span></p><p><img src="./4-21.png"></p><p>假设上图中主机A是服务器端，因为是主机A向B发送<code>FIN</code>消息，故可以想象成服务器端在控制台输入<code>CTRL+C</code>。但问题是，套接字经过四次挥手过程后并非立即消除，而是要经过一段时间的<code>Time-wait</code>状态。当然，只有先断开连接的【先发送<code>FIN</code>消息的】主机才经过<code>Time-wait</code>状态。因此，有以下结论：</p><ul><li>若服务器端先断开连接，则无法立即重新运行。</li><li>套接字处在<code>Time-wait</code>过程时，相应端口是正在使用的状态。因此，就像之前验证过的，<code>bind</code>函数调用过程中当然会发生错误。</li><li><code>Time-wait</code> 在几秒到理论上限两小时不等，</li></ul><p>有些人会误以为 <code>Time-wait</code> 过程只存在于服务器端。但实际上，不管是服务器端还是客户端，<strong>套接字都会有 Time-wait 过程</strong>。<span style="background:#ff0">先断开连接的套接字必然会经过<code>Time-wait</code> 过程，但无需考虑客户端 Time-wait状态。因为<strong>客户端套接字的端口号是任意指定的</strong>。</span>【与服务器端不同，客户端每次运行程序时都会动态分配端口号，因此无需过多关注<code>Time-wait</code>状态】【服务端的端口肯定要固定】</p><hr><p><span style="background:#13dddd">到底为什么会有<code>Time-wait</code>状态呢?</span></p><p>如上图中，假设主机A向主机B传输<code>ACK</code>消息【SEQ5001、ACK7502】后立即消除套接字。但最后这条<code>ACK</code>消息在传递途中丢失，未能传给主机B。这时会发生什么？</p><p>主机B会认为之前自己发送的<code>FIN</code>消息【SEQ 7501、ACK 5001】未能抵达主机A，继而试图重传。但此时主机A已是完全终止的状态，因此主机B永远无法收到从主机A最后传来的<code>ACK</code>消息。相反，若主机A的套接字处在<code>Time-wait</code>状态，则会向主机B重传最后的<code>ACK</code>消息，主机B也可以正常终止。基于这些考虑，先传输<code>FIN</code>消息的主机应经过<code>Time-wait</code>过程。</p><p><code>Time-wait</code>看似重要，但并不一定讨人喜欢。考虑一下系统发生故障从而紧急停止的情况。这时需要尽快重启服务器端以提供服务，但因处于<code>Time-wait</code>状态而必须等待几分钟。因此，Time-wait并非只有优点，而且有些情况下可能引发更大问题。下图演示了四次握手时不得不延长<code>Time-wait</code>过程的情况：</p><p><img src="./4-22.png"></p><blockquote><p>如上图所示，在主机A的四次握手过程中，如果最后的数据丢失，则主机B会认为主机A未能收到自己发送的<code>FIN</code>消息，因此重传。这时，收到FIN消息的主机A将重启<code>Time-wait</code>计时器。因此，如果网络状况不理想，Time-wait状态将持续。</p></blockquote><br><p><span style="background:#13dddd">解决办法：地址再分配</span></p><p>在套接字的可选项中更改为<code>SO_REUSEADDR</code>的状态。适当调整该参数，可将<code>Time-wait</code>状态下的套接字端口号重新分配给新的套接字。<code>SO_REUSEADDR</code>的默认值为0【<code>False</code>】，这就意味着无法分配<code>Time-wait</code>状态下的套接字端口号。因此需要将这个值改成1【<code>True</code>】【再做一次，就能解决上述问题】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">server78</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_sock, client, optval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr, client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(addr), clientlen = <span class="built_in">sizeof</span>(client_addr), optvallen;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="keyword">if</span> (serv_sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//***************************************************************</span></span><br><span class="line">    <span class="comment">//socket之后进行对sockopt的修改</span></span><br><span class="line">    <span class="built_in">getsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, &amp;optvallen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SO_REUSEADDR = %d\n&quot;</span>, optval);</span><br><span class="line">    optval = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, optvallen);</span><br><span class="line">    <span class="built_in">getsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, &amp;optvallen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SO_REUSEADDR = %d\n&quot;</span>, optval);</span><br><span class="line">    <span class="comment">//***************************************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, addrlen);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    addrlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, addrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">3</span>);</span><br><span class="line">    client = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;clientlen);</span><br><span class="line">    <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client78</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//【之前的TCP客户端】</span></span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to Quit):&quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), stdin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strlen</span>(buffer);<span class="comment">//待发送的实际长度</span></span><br><span class="line">        <span class="type">size_t</span> send_len = <span class="number">0</span>;<span class="comment">//已发送的长度</span></span><br><span class="line">        <span class="keyword">while</span> (send_len &lt; len)<span class="comment">//存在未发送的内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">write</span>(client, buffer + send_len, <span class="built_in">strlen</span>(buffer) - send_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;write failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//优化读</span></span><br><span class="line">        <span class="type">size_t</span> read_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (read_len &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">read</span>(client, buffer + read_len, len - read_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;read failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            read_len += ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;from server:&quot;</span> &lt;&lt; buffer;<span class="comment">//收到回复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson78</span><span class="params">(<span class="type">char</span>* option)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//模拟启动双进程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(option, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//服务器</span></span><br><span class="line">        <span class="built_in">server78</span>();</span><br><span class="line">        <span class="built_in">server78</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//客户端</span></span><br><span class="line">        <span class="built_in">client78</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson78</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="4-7-4-TCP-NODELAY"><a href="#4-7-4-TCP-NODELAY" class="headerlink" title="4.7.4 TCP_NODELAY"></a>4.7.4 TCP_NODELAY</h5><p>什么是<strong>Nagle算法</strong>？使用该算法能够获得哪些数据通信特性?</p><p>Nagle算法是以发明人<code>John Nagle</code>的名字命名的，它用于自动连接许多的小缓冲器消息。这一过程【称为nagling】通过<strong>减少必须发送包的个数</strong>来增加网络软件系统的效率。</p><p><img src="./4-23.png"></p><blockquote><p>从上图中可以得到如下结论：”只有收到前一数据的ACK消息时，Nagle算法才发送下一数据。”</p><p>注意：输入每一个字母是有间隔的，是输入一个字符发一次，还是一起发？</p></blockquote><p>TCP套接字默认使用Nagle算法交换数据，因此最大限度地进行缓冲，直到收到ACK。上图左侧正是这种情况。为了发送字符串”Nagle”，将其传递到输出缓冲。这时头字符”N”之前没有其他数据（没有需接收的ACK），因此立即传输。之后开始等待字符”N”的ACK消息，等待过程中，剩下的”agle”填入输出缓冲。接下来，收到字符”N”的ACK消息后，将输出缓冲的”agle”装入一个数据包发送。也就是说，共需传递4个数据包以传输1个字符串。</p><p>接下来分析未使用Nagle算法时发送字符串”Nagle”的过程。假设字符”N”到”e”依序传到输出缓冲。此时的发送过程与ACK接收与否无关，因此数据到达输出缓冲后将立即被发送出去。从上图右侧可以看到，发送字符串”Nagle”时共需10个数据包。由此可知，不使用Nagle算法将对网络流量产生负面影响。即使只传输1个字节的数据，其头信息都有可能是几十个字节。因此，为了提高网络传输效率，必须使用Nagle算法。</p><blockquote><p>在程序中将字符串传给输出缓冲时并不是逐字传递的，故发送字符串”Nagle”的实际情况并非如上图所示。但如果隔一段时间再把构成字符串的字符传到输出缓冲（如果存在此类数据传递）的话，则有可能产生类似上图的情况。上图中就是隔一段时间向输出缓冲传递待发送数据的。</p></blockquote><br><p>【 <span style="background:#13dddd">缺点</span>】但Nagle算法并不是什么时候都适用。<strong>根据传输数据的特性，网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。</strong></p><blockquote><p>最典型的是传输大文件数据。将文件数据传入输出缓冲不会花太多时间，因此，即便不使用Nagle算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。</p></blockquote><p><span style="background:#ff0">一般情况下，不使用Nagle算法可以提高传输速度。但如果无条件放弃使用Nagle算法，就会增加过多的网络流量，反而会影响传输。因此，未准确判断数据特性时不应禁用Nagle算法。</span></p><blockquote><p>刚才说过的【大文件数据】应禁用Nagle算法。换言之，如果有必要，就应禁用Nagle算法。Nagle算法使用与否在网络流量上差别不大，使用Nagle算法的传输速度更慢，禁用方法非常简单。</p></blockquote><p>另外，使用Nagle算法后，会将小包合并成大包，因此也会产生<strong>粘包问题</strong>。具体表现在：【假如依次3个包，包含json数据，大小依次为60、120、3000，一般前两个包会合并】</p><ul><li>接受端需要进行协调接受方式，即要明确知道要从一个数据包中拆分为两包进行解析【增加了接收端工作量】</li><li>合并包会产生时延，导致实时性下降【如果对实时性有要求，需要禁用Nagle】</li></ul><p>从下列代码也可看出，只需将套接字可选项<code>TCP_NODELAY</code>改为1【真】即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt_val=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span>*)&amp;opt_val, <span class="built_in">sizeof</span>(opt_val));</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过TCP_NODELAY的值查看Nagle算法的设置状态。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> opt_val, <span class="type">socklen_t</span> opt_len;</span><br><span class="line">opt_len = <span class="built_in">sizeof</span>(opt_val);</span><br><span class="line"></span><br><span class="line"><span class="built_in">getsockopt</span>(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span>*)&amp;opt_val, &amp;opt_len);</span><br></pre></td></tr></table></figure><ul><li>如果正在使用<code>Nagle</code>算法，<code>optval</code>变量中会保存0</li><li>如果已禁用<code>Nagle</code>算法，则保存1</li><li>何时需要禁用，何时需要打开，需要根据实际情况考量</li></ul><blockquote><p>至此，<code>socket</code>的相关内容就告一段落，主要还是解析了内部的一些参数和原理，在实际工作中也会用到，面试的时候也会被问到，大家好好掌握。</p></blockquote><br><h4 id="4-8-Questions"><a href="#4-8-Questions" class="headerlink" title="4.8 Questions"></a>4.8 Questions</h4><ol><li>序列号SEQ是在三次握手期间确定的，而并非第一次握手确定，因为第一次握手不一定能收到。</li></ol><br><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><h3 id="5-linux系统编程：进程"><a href="#5-linux系统编程：进程" class="headerlink" title="5 linux系统编程：进程"></a>5 linux系统编程：进程</h3><blockquote><p>到目前为止，大家已对套接字编程有了一定的理解，但要想实现真正的服务器端，只凭这些内容还不够。因此，现在开始学习<strong>构建实际网络服务所需内容</strong>。</p></blockquote><h4 id="5-1-进程的概念以及应用"><a href="#5-1-进程的概念以及应用" class="headerlink" title="5.1 进程的概念以及应用"></a>5.1 进程的概念以及应用</h4><p>利用之前学习到的内容，我们可以构建<strong>按序向第一个客户端到第一百个客户端提供服务</strong>的服务器端。</p><blockquote><p>当然，第一个客户端不会抱怨服务器端，但如果每个客户端的平均服务时间为0.5秒，则第100个客户端会对服务器端产生相当大的不满。</p></blockquote><h5 id="5-1-1-服务端类型和并发服务器"><a href="#5-1-1-服务端类型和并发服务器" class="headerlink" title="5.1.1 服务端类型和并发服务器"></a>5.1.1 服务端类型和并发服务器</h5><p><strong>两种类型的服务端</strong></p><blockquote><p>如果真正为客户端着想，应提高客户端满意度平均标准。如果有下面这种类型的服务器端，应该感到满意了吧？</p></blockquote><ul><li>“第一个连接请求的受理时间为0秒，第50个连接请求的受理时间为50秒，第100个连接请求的受理时间为100秒！但只要受理，服务只需1秒钟。”【如果排在前面的请求数能用一只手数清，客户端当然会对服务器端感到满意。但只要超过这个数，客户端就会开始抱怨。】</li><li>“所有连接请求的受理时间不超过1秒，但平均服务时间为2~3秒。”【并发服务器】</li></ul><br><p><strong>并发服务器的实现方法：</strong></p><p>即使有可能延长服务时间，也有必要改进服务器端，使其同时向所有发起请求的客户端提供服务，以提高平均满意度。而且，<span style="background:#ff0">网络程序中数据通信时间比CPU运算时间占比更大。因此，向多个客户端提供服务是一种有效利用CPU的方式。</span></p><p>接下来讨论同时向多个客户端提供服务的并发服务器端。下面列出的是具有代表性的并发服务器端实现模型和方法：</p><ol><li><p>多进程服务器∶通过创建多个进程提供服务</p></li><li><p>多路复用服务器∶通过捆绑并统一管理I/O对象提供服务【与<code>I/O</code>复用有关】</p></li><li><p>多线程服务器∶通过生成与客户端等量的线程提供服务【与多线程有关】</p><br></li></ol><h5 id="5-1-2-概念"><a href="#5-1-2-概念" class="headerlink" title="5.1.2 概念"></a>5.1.2 概念</h5><p><strong>进程：</strong><span style="background:#ff0">占用内存空间的正在运行的程序。</span></p><ul><li>进程ID为全局可见，线程ID只是进程内可见，除非全局共享该线程</li><li>内存空间独立，即原则上不允许其他程序访问【除非如调试程序<code>gdb</code>】【有点线程不占空间，属于进程的一部分】</li></ul><blockquote><p>假如同学们从网上下载了《植物大战僵尸游戏》并安装到硬盘。此时的游戏并非进程，而是程序。因为游戏并未进入运行状态。</p><p>接着开始运行程序。此时游戏被加载到主内存并进入运行状态，这时才可称为进程。如果同时运行多个植物大战僵尸游戏程序，则会生成相应数量的进程，也会占用相应进程数的内存空间。</p></blockquote><blockquote><p>再举个例子。进行文档相关操作，这时应打开文档编辑软件。如果工作的同时还想听音乐，应打开酷狗播放器。另外，为了与朋友聊天，再打开微信软件。此时共创建3个进程。</p><p>从操作系统的角度看， <span style="background:#13dddd">进程是程序流的基本单位</span>。若创建多个进程，则操作系统将同时运行。</p></blockquote><p>有时，一个程序运行过程中也会产生多个进程。接下来要创建的<strong>多进程服务器</strong>就是其中的代表。编写服务器端前，先了解一下通过程序创建进程的方法【<code>5.1.3</code>】。</p><br><p><strong>CPU核的个数与进程数</strong></p><p>拥有2个运算设备的CPU称作双核CPU，拥有4个运算器的CPU 称作4核CPU。也就是说，1个CPU中可能包含多个运算设备【核心】。</p><p>核的个数与可同时运行的进程数相同；但若进程数超过核数，进程将<span style="background:#13dddd">分时</span>使用CPU 资源【但因为CPU 运转速度极快，我们会感到所有进程同时运行。当然，核数越多，这种感觉越明显】。</p><br><p><strong>进程ID：</strong></p><p>无论进程是如何创建的，所有进程都会从操作系统分配到ID。</p><ul><li>此<code>ID</code>称为<strong>进程ID</strong>，其值为<code>＞2</code>的<strong>整数</strong>【取值范围：<code>0~32767</code>或<code>65535</code>】</li><li><code>ID=1</code>要分配给操作系统启动后的首个进程【<code>init</code>进程 | 用于协助操作系统】，因此用户进程无法得到<code>ID</code>值1。</li><li>进程ID不连续，因为中间可能会产生各种子进程和线程，可能其中的某些已经死亡；当最后一个进程号32767用完之后，会从头开始找空进程号</li></ul><p>通过<code>ps au</code>指令可以查看当前运行的所有进程。特别需要注意的是，该命令同时可以列出<code>PID</code>【进程ID】。通过指定a和u参数列出了所有进程详细信息。</p><br><h5 id="5-1-3-通过fork-函数创建进程"><a href="#5-1-3-通过fork-函数创建进程" class="headerlink" title="5.1.3 通过fork 函数创建进程"></a>5.1.3 通过fork 函数创建进程</h5><p>创建进程的方法很多，此处只介绍用于创建多进程服务器端的<code>fork</code>函数【fork函数实际上是通过<code>clone</code>函数发挥作用】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回进程 ID，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>fork函数将创建调用的进程副本【也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用fork函数的进程】</p></li><li><p>另外，两个进程都将执行fork函数调用后的语句【准确地说是在fork函数返回后】。但因为通过同一个进程、复制相同的内存空间，之后的程序流<strong>要根据fork函数的返回值加以区分</strong>。即利用fork函数的如下特点区分程序执行流程：</p><ul><li>父进程∶fork函数返回子进程<code>ID&gt;0</code>。</li><li>子进程∶fork函数返回<code>0</code></li></ul></li><li><p>虽然复制了相同的内存空间，如堆、栈等，但之后子进程不可以互相访问父进程的内存空间【但子进程有父进程的副本，故？】</p></li></ul><blockquote><p>此处”父进程”（Parent Process）指原进程，即调用fork函数的主体，而”子进程”（Child Process）是通过父进程调用fork函数复制出的进程。接下来讲解调用fork函数后的程序运行流程，如下图所示。</p></blockquote><p><img src="./5-1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gval=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> lval=<span class="number">20</span>;</span><br><span class="line">    gval++, lval+=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程。父进程的pid中存有子进程的ID，子进程的pid是0</span></span><br><span class="line">    pid=fork();         </span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">// if Child Process</span></span><br><span class="line">        gval+=<span class="number">2</span>, lval+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// if Parent Process</span></span><br><span class="line">        gval-=<span class="number">2</span>, lval-=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Proc: [%d, %d] \n&quot;</span>, gval, lval); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Proc: [%d, %d] \n&quot;</span>, gval, lval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从运行结果可以看出，调用fork函数后，父子进程拥有完全独立的内存结构。</p></blockquote><br><h4 id="5-2-进程和僵尸进程"><a href="#5-2-进程和僵尸进程" class="headerlink" title="5.2 进程和僵尸进程"></a>5.2 进程和僵尸进程</h4><p>文件操作中，关闭文件和打开文件同等重要。同样，进程销毁和进程创建同等重要。如果未认真对待进程销毁，它们将变成僵尸进程困扰大家。</p><p>进程完成工作后【执行完main函数中的程序后】应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源【进程号和内存】。这种状态下的进程称作<strong>僵尸进程</strong>【执行结束后等待父进程的下一步指示】，这也是给系统带来负担的原因之一。</p><p><strong>产生僵尸进程的原因：</strong></p><p>首先利用如下两个示例，展示调用<code>fork</code>函数产生子进程的终止方式：</p><ul><li>传递参数并调用exit函数。</li><li>main函数中执行retun语句并返回值。</li></ul><p><span style="background:#13dddd">向<code>exit</code>函数传递的参数值和<code>main</code>函数的returm语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。</span>处在这种状态下的进程就是<strong>僵尸进程</strong>。也就是说，将子进程变成僵尸进程的，正是操作系统。</p><p>既然如此，此僵尸进程何时被销毁呢？<strong>当操作系统向创建子进程的父进程，传递子进程的<code>exit</code>参数值或<code>return</code>语句的返回值后，才会销毁僵尸进程。</strong>【合理性：对某些异常结束的子进程，父进程还可以获取子进程的相关状态，以便于解决相应的问题】【但同时，操作系统不会主动传递这些参数】</p><p>如何向父进程传递这些值呢？操作系统不会主动把这些值传递给父进程，只有父进程主动发起请求【函数调用】时，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态【也就是说，父母要负责收回自己生的孩子】。下面我们来创建一个僵尸进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">//exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson82</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Process ID: %d \n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//获取子进程状态【即上文提到的：父进程主动获取子进程的状态】</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process ID: %d \n&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//不能return,因为没有返回值void</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//20s内，子进程为僵尸进程</span></span><br><span class="line">    <span class="built_in">lesson82</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看进程状态：在父进程sleep期间，子进程变成僵尸进程【倒数第四行的Z】【O表示正在运行；S代表正在休眠；R代表运行态；Z代表僵死态；T代表停止】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 S     0   5751   1222  0  80   0 - 26947 -      ?        00:00:00 sshd</span><br><span class="line">4 S     0   5753   1222  0  80   0 - 26980 -      ?        00:00:00 sshd</span><br><span class="line">4 S     0   5754      1  0  80   0 - 19219 -      ?        00:00:00 systemd</span><br><span class="line">5 S     0   5756   5754  0  80   0 - 64799 -      ?        00:00:00 (sd-pam)</span><br><span class="line">4 S     0   5857   5753  0  80   0 -  3267 -      ?        00:00:00 sftp-server</span><br><span class="line">1 I     0   6088      2  0  80   0 -     0 -      ?        00:00:00 kworker/4:1-</span><br><span class="line">1 I     0   6442      2  0  80   0 -     0 -      ?        00:00:00 kworker/u256</span><br><span class="line">0 S  1000   6544   2293  0  80   0 -  1096 hrtime pts/0    00:00:00 Linux_consol</span><br><span class="line">1 Z  1000   6545   6544  0  80   0 -     0 -      pts/0    00:00:00 Li &lt;defunct&gt;</span><br><span class="line">0 S  1000   6557   2284  0  80   0 -  6118 <span class="built_in">wait</span>   pts/1    00:00:00 bash</span><br><span class="line">1 I     0   6575      2  0  80   0 -     0 -      ?        00:00:00 kworker/2:0-</span><br><span class="line">0 R  1000   6576   6557  0  80   0 -  7667 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p>当父进程休眠结束，主动获取子进程状态<code>waitpid</code>，随即OS销毁子进程。</p><blockquote><p>实际上，服务器需要不停机运行很长时间，如果出现大量僵尸进程，会占用大量系统资源，导致无法创建新进程而系统奔溃。而且，这种奔溃却很难找出原因。</p></blockquote><br><h4 id="5-3-信号处理"><a href="#5-3-信号处理" class="headerlink" title="5.3 信号处理"></a>5.3 信号处理</h4><p>我们已经知道了进程创建及销毁方法，但还有一个问题没解决。</p><ul><li>子进程究竟何时终止？</li><li>调用waitpid函数后要无休止地等待吗？</li></ul><blockquote><p>父进程往往与子进程一样繁忙，因此不能只调用<code>waitpid</code>函数以等待子进程终止</p></blockquote><h5 id="5-3-1-信号处理signal"><a href="#5-3-1-信号处理signal" class="headerlink" title="5.3.1 信号处理signal"></a>5.3.1 信号处理signal</h5><p><span style="background:#33f22d;font-weight:bolder">解决办法：向操作系统求助</span></p><p>子进程终止的识别主体是操作系统，因此，若操作系统能把如下信息告诉正忙于工作的父进程，将有助于构建高效的程序。</p><blockquote><p>【OS】”嘿，父进程！你创建的子进程终止了!”</p></blockquote><p>此时父进程将暂时放下工作，处理子进程终止相关事宜。这就是信号处理机制【<code>Signal Handling</code>】。</p><ul><li>此处的<strong>信号</strong>是在特定事件发生时由<strong>操作系统</strong>向进程发送的消息。</li><li>另外，为了响应该消息，执行与消息相关的自定义操作的过程称为”信号处理”。</li><li>理论上有31种信号。</li></ul><p>我们想象一下如下场景：</p><ol><li><p>进程∶”嘿，操作系统!如果我之前创建的子进程终止，就帮我调用<code>zombie_handler</code>函数。”</p></li><li><p>操作系统∶”好的！如果你的子进程终止，我会帮你调用<code>zombie_handler</code>函数，你先把该函数要执行的语句编！”</p></li></ol><p>上述场景中进程所讲的相当于”注册信号”过程，即进程的子进程结束时，请求操作系统调用特定函数。该请求通过<code>signal</code>函数调用完成【因此，称<code>signal</code>为信号注册函数】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，signal函数返回值是一个函数指针</span></span><br><span class="line"><span class="comment">//为了在产生信号时调用，返回之前注册的函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数为int型，返回void型函数指针</span></span><br><span class="line"><span class="built_in">void</span>(*<span class="built_in">signal</span>(<span class="type">int</span> signo, <span class="built_in">void</span>(*func)(<span class="type">int</span>))(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//函数指针类型 signal(int signo, 函数指针类型 func)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于下面的内容：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span>(*signal_handler)(<span class="type">int</span>);<span class="comment">//函数指针定义</span></span><br><span class="line">signal_handler <span class="built_in">signal</span>(<span class="type">int</span> signo,signal_handler func);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//第一个参数signo为特殊情况信息，即需要关注的信号量</span></span><br><span class="line"><span class="comment">//第二个参数func为特殊情况下将要调用的函数的地址值（指针）</span></span><br><span class="line"><span class="comment">//发生第一个参数代表的情况时，调用第二个参数所指的函数。</span></span><br></pre></td></tr></table></figure><p>调用上述函数时，下面给出可以在signal函数中注册的部分特殊情况和对应的常数：</p><ul><li><code>SIGALRM</code>∶已到通过调用alarm函数注册的时间。</li><li><code>SIGINT</code>：中断，即输入<code>CTRL+C</code>【Bash条件下的命令行模式下有效】</li><li><code>SIGCHLD</code>∶子进程终止</li><li>待补充</li></ul><p>举例说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、&quot;子进程终止则调用`mychild`函数。&quot;</span></span><br><span class="line"><span class="built_in">signal</span>(SIGCHLD, mychild);</span><br><span class="line"><span class="comment">//此时mychild函数的参数应为int，返回值类型应为void,对应signal函数的第二个参数</span></span><br><span class="line"><span class="comment">//另外，常数SIGCHLD表示子进程终止的情况，应成为signal函数的第一个参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、&quot;已到通过alarm函数注册的时间，请调用timeout函数。&quot;</span></span><br><span class="line"><span class="comment">//3、&quot;输入CTRL+C时调用keycontrol函数。&quot;</span></span><br><span class="line"><span class="comment">//代表这2种情况的常数分别为SIGALRM和SIGINT</span></span><br><span class="line"><span class="built_in">signal</span>(SIGALRM, timeout);</span><br><span class="line"><span class="built_in">signal</span>(SIGINT, keycontrol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// alarm函数，到时间后会激活SIGALRM信号量的timeout函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//返回0或以秒为单位的距SIGALRM信号发生所剩时间</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure><p>以上就是信号注册过程。注册好信号处理后，发生注册信号时【注册的情况发生】，操作系统将调用该信号对应的函数。</p><p>下面以<code>SIGALRM</code>信号量为例：</p><ul><li>如果调用<code>alarm</code>函数的同时向它传递一个正整型参数，相应时间后【以秒为单位】将产生<code>SIGALRM</code>信号。</li><li>若向该函数传递0，则之前对SIGALRM信号的预约将取消。</li><li>如果通过该函数预约信号后未指定该信号对应的处理函数，则【通过调用<code>signal</code>函数】终止进程，不做任何处理。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号处理函数timeout，返回值为void</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig==SIGALRM)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Time out!&quot;</span>);</span><br><span class="line">    <span class="comment">//为了每隔2秒重复产生SIGALRM信号，在信号处理器中调用alarm函数</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号处理函数keycontrol，返回值为void</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keycontrol</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig==SIGINT)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;CTRL+C pressed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//注册SIGALRM、SIGINT信号及相应处理器</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, timeout);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, keycontrol);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预约2秒后发生SIGALRM信号</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更间接的统一处理写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span><span class="comment">//pthread_self</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统一定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_func</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sig)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGALRM:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%d pid:%d\n&quot;</span>,<span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">alarm</span>(<span class="number">2</span>);<span class="comment">//2s后再触发产生SIGALRM信号</span></span><br><span class="line">    <span class="keyword">case</span> SIGINT:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; Ctrl + C press\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson83</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程 ----tid:%d pid:%d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册SIGALRM、SIGINT信号及相应处理器</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, signal_func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signal_func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预约2秒后发生SIGALRM信号</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//主进程一直休眠</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程 ----tid:%d pid:%d\n&quot;</span>, <span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="comment">//sleep(3);</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson83</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) chase@chase-virtual-machine:~/Linux_consoleApplication/bin/x64/Debug$ ./Linux_consoleApplication.out </span><br><span class="line">主线程 ----tid:-733236032 pid:11992</span><br><span class="line">主线程 ----tid:-733236032 pid:11992</span><br><span class="line">tid:-733236032 pid:11992</span><br><span class="line">主线程 ----tid:-733236032 pid:11992</span><br><span class="line">tid:-733236032 pid:11992</span><br><span class="line">主线程 ----tid:-733236032 pid:11992</span><br><span class="line">tid:-733236032 pid:11992</span><br><span class="line">主线程 ----tid:-733236032 pid:11992</span><br><span class="line">tid:-733236032 pid:11992</span><br><span class="line">主线程 ----tid:-733236032 pid:11992</span><br><span class="line">^C Ctrl + C press</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>主线程和子线程线程号完全一致</li><li>两个线程交替打印【也就是说，主线程根本没有休眠100s】</li><li>小结论：信号量会影响休眠</li></ul><blockquote><p>🔺为什么主线程没有休眠100s？</p><p>原因：发生SIGALRM信号时，将唤醒由于调用sleep函数而进入阻塞状态的进程【主线程】。</p><p>调用函数的主体的确是操作系统，但进程处于睡眠状态时无法调用函数。因此，产生信号时，为了调用信号处理器，将唤醒由于调用sleep函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到sleep函数中规定的时间也是如此。</p></blockquote><br><h5 id="5-3-2-Sigaction函数进行信号处理"><a href="#5-3-2-Sigaction函数进行信号处理" class="headerlink" title="5.3.2 Sigaction函数进行信号处理"></a>5.3.2 Sigaction函数进行信号处理</h5><p>前面所学的<code>signal</code>足以用来编写防止僵尸进程生成的代码。下面介绍更强大的<code>sigaction</code>函数，它类似于<code>signal</code>函数，而且完全可以代替<code>signal</code>函数，也更稳定。</p><p>之所以稳定，是因为如下原因∶</p><ul><li><p><code>signal</code>在<code>UNIX</code>系列的不同操作系统中可能存在区别，但<code>sigaction</code>完全相同。</p></li><li><p>实际上现在很少使用<code>signal</code>函数编写程序，它只是为了保持对旧程序的兼容。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span></span>;</span><br><span class="line"><span class="comment">//signo  传递信号信息</span></span><br><span class="line"><span class="comment">//act    对应于第一个参数的信号处理函数（信号处理器）信息。</span></span><br><span class="line"><span class="comment">//oldact 通过此参数获取之前注册的信号处理函数指针，若不需要则传递0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明并初始化sigaction结构体变量，该结构体定义如下。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//保存信号处理函数的指针值（地址值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下两个成员用于指定信号相关的选项和特性,一般初始化为0</span></span><br><span class="line">    <span class="type">sigset_t</span> sa mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Time out!&quot;</span>);</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//为了注册信号处理函数，声明sigaction结构体变量并在sa_handler成员中保</span></span><br><span class="line">    <span class="comment">//存函数指针值。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_handler = timeout;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册SIGALRM信号的处理器。调用alarm函数预约2秒后发生SIGALRM信号。</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;act, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="5-3-3-示例：利用信号处理技术消灭僵尸进程"><a href="#5-3-3-示例：利用信号处理技术消灭僵尸进程" class="headerlink" title="5.3.3 示例：利用信号处理技术消灭僵尸进程"></a>5.3.3 示例：利用信号处理技术消灭僵尸进程</h5><p>子进程终止时将产生<code>SIGCHLD</code>信号，知道这一点就很容易完成消灭僵尸进程。接下来利用<code>sigaction</code>函数消灭僵尸进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Removed proc id: %d \n&quot;</span>, id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child send: %d \n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册SIGCHLD信号对应的处理器</span></span><br><span class="line">    <span class="comment">//若子进程终止，则调用read_childproc函数。</span></span><br><span class="line">    <span class="comment">//处理函数中调用了waitpid函数，所以子进程将正常终止，不会成为僵尸进程</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Hi! I&#x27;m child process&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child proc id: %d \n&quot;</span>, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Hi! I&#x27;m child process&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">24</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child proc id: %d \n&quot;</span>, pid);</span><br><span class="line">            <span class="comment">//for循环∶为了等待发生SIGCHLD信号，使父进程共暂停5次，每次间隔5秒 </span></span><br><span class="line">            <span class="comment">//发生信号时，父进程将被唤醒，因此实际暂停时间不到25秒。</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="5-4-基于多任务的并发服务器"><a href="#5-4-基于多任务的并发服务器" class="headerlink" title="5.4 基于多任务的并发服务器"></a>5.4 基于多任务的并发服务器</h4><blockquote><p>之前写的服务器客户端的代码。举个例子：一个服务端，两个客户端C1/C2，两个客户端同时发送请求，但服务端却是依次受理。【用户量十万才算是小应用，其次是百万、千万、亿级别，假如处理一个连接请求需要1ms，十万级用户量时的最后一个用户需要等待约100s，实际上一般30s作用请求连接都会断开】【瓶颈在于CPU性能】</p><p>而并发服务器接受到连接请求，<code>fork</code>一个子进程来处理，而主进程继续<code>accept</code>新请求。此时，<span style="background:#33f22d">同时存在的用户数量</span>成为新的瓶颈【内存】。</p></blockquote><p>服务端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hand_childProc</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGCHLD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG);<span class="comment">//不要挂起：即此时由操作系统告知父进程：子进程已结束。此时父进程无需挂起等待，直接处理即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s: remove child process:%d\r\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s: Other\r\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handle</span><span class="params">(<span class="type">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server85</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//子进程回收</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = hand_childProc;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);<span class="comment">//父进程向操作系统注册一个动作，即子进程结束时产生SIGCHLD信号量，触发操作系统向父进程报告子进程结束并执行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端: socket-creat bind listen accept</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, client_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serv_socket;</span><br><span class="line">    serv_socket = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_socket, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;bind failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_socket, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;listen failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//accept 单次</span></span><br><span class="line">    <span class="comment">/*socklen_t clientaddr_len = sizeof(client_addr);</span></span><br><span class="line"><span class="comment">    int client = accept(serv_socket, (sockaddr*)&amp;client_addr, &amp;clientaddr_len);</span></span><br><span class="line"><span class="comment">    if (client &gt;= 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        char buffer[2048] = &quot;&quot;;</span></span><br><span class="line"><span class="comment">        ssize_t length = 0;</span></span><br><span class="line"><span class="comment">        while ((length = read(client, buffer, sizeof(buffer))) &gt; 0)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            write(client, buffer, length);</span></span><br><span class="line"><span class="comment">            length = 0;</span></span><br><span class="line"><span class="comment">            memset(buffer, 0, sizeof(buffer));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        close(client);</span></span><br><span class="line"><span class="comment">        printf(&quot;%s(%d):%s: client is closed\n&quot;, __FILE__, __LINE__, __FUNCTION__);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//accept 多次</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//假设服务5次</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> clientaddr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">        <span class="type">int</span> client = <span class="built_in">accept</span>(serv_socket, (sockaddr*)&amp;client_addr, &amp;clientaddr_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s: client is connected!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (client &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">pid_t</span> pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>)<span class="comment">//子进程：客户端</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//fork出的子进程会将服务器套接字和客户端套接字都复制一份，故需要一些处理</span></span><br><span class="line">                <span class="built_in">close</span>(serv_socket);<span class="comment">//子进程不需要服务端套接字</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">2048</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">ssize_t</span> length = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((length = <span class="built_in">read</span>(client, buffer, <span class="built_in">sizeof</span>(buffer))) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">write</span>(client, buffer, length);</span><br><span class="line">                    length = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s: client is closed\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//子进程需要返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//fork失败，资源耗尽</span></span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s: fork failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if(pid&gt;0)//父进程</span></span><br><span class="line">            <span class="built_in">close</span>(client);<span class="comment">//父进程不需要client</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">5</span>) <span class="keyword">break</span>;<span class="comment">//为了演示终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_socket);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client85</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//【之前的TCP客户端 client78 并再简化】</span></span><br><span class="line">    <span class="type">int</span> client = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;Hello！&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strlen</span>(buffer);<span class="comment">//待发送的实际长度</span></span><br><span class="line">        <span class="type">size_t</span> send_len = <span class="number">0</span>;<span class="comment">//已发送的长度</span></span><br><span class="line">        <span class="keyword">while</span> (send_len &lt; len)<span class="comment">//存在未发送的内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">write</span>(client, buffer + send_len, <span class="built_in">strlen</span>(buffer) - send_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;write failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send_len += (<span class="type">size_t</span>)ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="comment">//优化读</span></span><br><span class="line">        <span class="type">size_t</span> read_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (read_len &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> ret = <span class="built_in">read</span>(client, buffer + read_len, len - read_len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;read failed!&quot;</span>, stdout);</span><br><span class="line">                <span class="built_in">close</span>(client);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            read_len += ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;from server:&quot;</span> &lt;&lt; buffer;<span class="comment">//收到回复</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);<span class="comment">//模拟延迟</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//仅循环一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client done!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson85</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程启动服务器</span></span><br><span class="line">        <span class="built_in">server85</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s: wait for server\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);<span class="comment">//等待服务器启动</span></span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//父进程continue</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//子进程启动客户端</span></span><br><span class="line">                <span class="built_in">client85</span>();</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//注意!一定要break</span></span><br><span class="line">                <span class="comment">//在子进程中如果不做break，下一步再进行for，然后创建孙进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson85</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><span style="background:#ff0">在for中fork时，子进程break，父进程continue。</span>【在子进程中如果不做break，下一次for循环时，所有子进程将创建孙进程，总的新进程数量将呈现指数级增长】</li></ul><br><h4 id="5-5-进程间通信"><a href="#5-5-进程间通信" class="headerlink" title="5.5 进程间通信"></a>5.5 进程间通信</h4><p><code>IPC</code>：<code>InterProcess Communication</code>，即进程间通信，<span style="background:#ff0">通过内核提供的缓冲区进行数据交换的机制。【需要开发环境或权限】</span>进程间通信意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应提供两个进程可以同时访问的内存空间。</p><br><p>进程A和B之间的如下例子就是一种进程间通信规则：</p><blockquote><p>“如果我有1个面包，变量bread的值就变为1。如果吃掉这个面包，bread的值又变回0。因此，可以通过变量bread值判断我的状态。” 也就是说，进程A通过变量bread将自己的状态通知给了进程B，进程B通过变量bread听到了进程A的话。</p></blockquote><p>因此，只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据。但是进程具有完全独立的内存结构，就连通过<code>fork</code>函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方法完成。</p><br><h5 id="5-5-1-进程间通信：管道"><a href="#5-5-1-进程间通信：管道" class="headerlink" title="5.5.1 进程间通信：管道"></a>5.5.1 进程间通信：管道</h5><blockquote><p>管道其实有很多种，最常用的应该就是<code>shell</code>中的”<code>|</code>“。</p><p>他其实就是一个管道符，将前面的表达式的输出，引入后面表达式当作输入，比如我们常用的”<code>ps aux|grep ssh</code>“可以查看ssh的相关进程。</p></blockquote><p>我们常用在进程间通信管道的有两种：</p><ul><li>一种是<code>pipe</code>管道，又可以叫做亲族管道；</li><li>与之对应的则是<code>fifo</code>管道，又可以叫做公共管道。</li></ul><p><img src="./5-2.png"></p><p>从上图可以看到，为了完成进程间通信，需要创建管道。值得注意的是：</p><ul><li>管道并非属于进程的资源，而是和套接字一样，属于操作系统【也就不是fork函数的复制对象】。所以，<span style="background:#ff0">两个进程通过操作系统提供的内存空间进行通信。</span></li><li>单条管道具有单向性，双向管道由两条管道构成。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回 0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//Filedes[0] 通过管道接收数据时使用的文件描述符，即管道出口。</span></span><br><span class="line"><span class="comment">//Filedes[1] 通过管道传输数据时使用的文件描述符，即管道入口。</span></span><br><span class="line"><span class="comment">//以长度为2的int数组地址值，作为参数调用上述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和入口。</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的1个文件描述符传递给子进程。如何完成传递呢?</p><p>答案就是调用<code>fork</code>函数。也就是说，<span style="background:#ff0">必须使用父进程创建管道。</span>【出入口文件描述符不能由子进程传递给父进程，故只能由父进程创建<code>pipe</code>】</p><p>单管道：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson87</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;<span class="comment">//0也是标准输入输出的文件描述符</span></span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line">    <span class="type">char</span> str[<span class="number">64</span>] = <span class="string">&quot;send by sub process!\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程 通过管道传递字符串</span></span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>],str,<span class="built_in">sizeof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程从管道接收字符串</span></span><br><span class="line">        <span class="built_in">read</span>(fds[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s server:%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson87</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>一个管道无法完成双向通信任务，有时候需要创建两个管道，各自负责不同的数据流动即可。其过程如下图所示：</p><p><img src="./5-3.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson87</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s2c[<span class="number">2</span>], c2s[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(s2c);</span><br><span class="line">    <span class="built_in">pipe</span>(c2s);</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">64</span>] = <span class="string">&quot;Hello, I am sub-process!\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">64</span>] = <span class="string">&quot;Hello, I am main-process!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程 通过管道传递字符串</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(c2s[<span class="number">1</span>],str1, <span class="built_in">sizeof</span>(str1));</span><br><span class="line">        <span class="built_in">read</span>(s2c[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s from server:%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程从管道接收字符串</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">read</span>(c2s[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s from client:%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">        <span class="built_in">write</span>(s2c[<span class="number">1</span>], str2, <span class="built_in">sizeof</span>(str2));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">getpid</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson87</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(25):lesson87 from client:Hello, I am sub-process!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(28):lesson87 24565</span></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(31):lesson87 24565</span></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(19):lesson87 from server:Hello, I am main-process!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(31):lesson87 24566【由子进程执行】</span></span><br></pre></td></tr></table></figure><p>可以注意到：</p><ul><li>此例中，父进程执行结束后，子进程才收到消息。</li><li>即使主进程执行结束，子进程也可以在管道中读取数据。即管道脱离进程而存在，是属于操作系统的。【管发不管收没收到】</li><li>能读取数据，不能判断进程是否已经结束；因此，可以使用双向管道来模拟应答来查看进程是否结束。【稳定性/确定性】</li></ul><br><h5 id="5-5-2-进程间通信：FIFO"><a href="#5-5-2-进程间通信：FIFO" class="headerlink" title="5.5.2 进程间通信：FIFO"></a>5.5.2 进程间通信：FIFO</h5><blockquote><p>对比<code>pipe</code>管道，他已经可以完成在两个进程之间通信的任务，不过它似乎完成的不够好，也可以说是不够彻底。</p><p><span style="background:#ff0">它只能在两个有亲戚关系的进程之间进行通信</span>，这就大大限制了<code>pipe</code>管道的应用范围。</p><p>我们在很多时候往往希望能够在两个独立的进程之间进行通信，这样就无法使用pipe管道，所以一种能够满足独立进程通信的管道应运而生，就是<code>FIFO</code>管道【先进先出，即先放入管道的消息先出来】。</p></blockquote><p><code>FIFO</code>管道的本质是操作系统中的命名文件。【当然，Linux的理念就是万物皆文件，它在操作系统中以命名文件的形式存在】</p><p>我们可以在操作系统中看见<code>FIFO</code>管道，在你有权限的情况下，甚至可以读写他们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">#使用命令： </span><br><span class="line">mkfifo myfifo</span><br><span class="line"></span><br><span class="line">#使用函数：成功：<span class="number">0</span>；失败：<span class="number">-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>; <span class="meta">#mode权限，同fopen权限【读、写、读写】</span></span><br></pre></td></tr></table></figure><p>内核会针对<code>FIFO</code>文件开辟一个缓冲区，操作<code>FIFO</code>文件，可以操作缓冲区，实现进程通信。一旦使用<code>mkfifo</code>创建了一个<code>FIFO</code>，就可以使用opne打开它，常见的文件IO函数都可以用于FIFO。如：<code>close</code>、<code>read</code>、<code>write</code>、<code>unlink</code>等 。</p><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span><span class="comment">//open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson88</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mkfifo</span>(<span class="string">&quot;./a.fifo&quot;</span>, <span class="number">0666</span>);<span class="comment">//6为可读可写，666对应文件所有者权限、组权限、其他组权限</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">//printf(&quot;%d&quot;, sizeof(&quot;Hello, World!&quot;));//14</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)<span class="comment">//子进程:打开fifo只读</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./a.fifo&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">ssize_t</span> len = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s buffer: %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s length: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, len);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s length: %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程:打开fifo 只写</span></span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./a.fifo&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;Hello, World!&quot;</span>, <span class="number">14</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson88</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(18):lesson88 buffer: Hello, World!</span></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(28):lesson88</span></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(19):lesson88 length: 14</span></span><br><span class="line"><span class="comment">///home/chase/Linux_consoleApplication/main.cpp(21):lesson88 length: 0</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>一般情况下，<code>FIFO</code>被称为命名管道【有文件、文件名，使用 <code>ls -l</code> 命令发现文件类型为<code>p</code>】，<code>pipe</code>被称为匿名管道</li><li>多个进程间通信【以5个为例】，只需要5个<code>FIFO</code>管道即可。各进程只读对应管道，如要通信则只写对应进程的管道文件</li><li><span style="background:#ff0">打开<code>FIFO</code>文件时，read端会阻塞等待write端打开open；wirte端同理，也会阻塞等待另一端的打开。</span></li></ul><p>缺陷：</p><ul><li>通信比较慢：速度受限于文件读写</li><li>read端和write端会占用内存，可能会很大</li><li>由于两端的阻塞等待，如果对方没有连接，则无法抽身离开。</li></ul><br><h5 id="5-5-3-进程间通信：共享内存"><a href="#5-5-3-进程间通信：共享内存" class="headerlink" title="5.5.3 进程间通信：共享内存"></a>5.5.3 进程间通信：共享内存</h5><blockquote><p>在理解共享内存之前，就必须先了解<code>System V IPC</code>通信机制。</p><p><code>System V IPC</code>机制最初是由<code>AT&amp;T System V.2</code>版本的<code>UNIX</code>引入的【UNIX为收费版本】。这些机制是专门用于<code>IPC</code>（<code>Inter-Process Communication</code> 进程间通信）的，它们在同一个版本中被应用，又有着相似的编程接口，所以它们通常被称为<code>System V IPC</code>通信机制。</p><p>共享内存是三个<code>System V IPC</code>机制中的第二个。</p></blockquote><p>共享内存，<span style="background:#ff0">允许不同进程之间共享同一段逻辑内存。</span>对于这段内存，它们都能访问，或者修改它，没有任何限制。所以它是进程间传递大量数据的一种非常有效的方式。【优势：稳定高效、速度快、可用于大量数据的传递，但不能超出固定限制】</p><blockquote><p><span style="background:#33f22d">“共享内存允许不同进程之间共享同一段逻辑内存”，这里是逻辑内存。也就是说共享内存的进程访问的可以不是同一段物理内存，这个没有明确的规定，但是大多数的系统实现都将进程之间的共享内存安排为同一段物理内存。</span></p><p>这些都是基于进程的内存空间都是虚拟内存。共享内存要求申请一块物理内存，然后映射到两个通信进程的地址空间，两个进程都可以对该内存进行读写。</p></blockquote><p>共享内存实际上是由<code>IPC</code>机制分配的一段特殊的物理内存，它可以被映射到该进程的地址空间中，同时也可以被映射到其他拥有权限的进程的地址空间中。就像是使用了<code>malloc</code>分配内存一样，只不过这段内存是可以共享的。</p><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><p><strong>共享内存的创建、映射、访问和删除</strong></p><p>IPC提供了一套API来控制共享内存，使用共享内存的步骤通常是：</p><ol><li><p>创建或获取一段共享内存；</p></li><li><p>将上一步创建的共享内存映射到该进程的地址空间；</p></li><li><p>访问共享内存；</p></li><li><p>将共享内存从当前的进程地址空间分离；</p></li><li><p>删除这段共享内存。</p></li></ol><p>具体如下：</p><p>（1）使用<code>shmget()</code>函数来创建一段共享内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：共享内存的ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">( <span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg )</span></span>;<span class="comment">//share memory get</span></span><br><span class="line"><span class="comment">//key：这段共享内存取的名字，系统利用它来区分共享内存，访问同一段共享内存的不同进程需要传入相同的名字</span></span><br><span class="line"><span class="comment">//size：共享内存的大小</span></span><br><span class="line"><span class="comment">//shmflg：是共享内存的标志，包含9个比特标志位，其内容与创建文件时的mode相同</span></span><br><span class="line"><span class="comment">//有一个特殊的标志IPC_CREAT可以和权限标志以或的形式传入【创建时必须传】</span></span><br><span class="line"><span class="comment">//9为标志位分为文件拥有者、组、组外，相对应读写执行rwx</span></span><br></pre></td></tr></table></figure><blockquote><p>其中，关于<code>key</code>的取值，其本质上是一个整数，取值相同时可进行通信；但万一随意取之后重名，会进行意料之外的通信。</p><p>故一般<code>key</code>使用<code>ftok(&quot;.&quot;, 1)</code>取得。<code>&quot;.&quot;</code>表示当前路径，1是<code>值key</code>，ftok返回一个key，与当前路径相关。</p><p>如果一个进程中有多个共享内存，可以使用<code>值key</code>不断加1来解决。这种取法可以规避大多数冲突重名情况。</p></blockquote><p>（2）使用函数<code>shmat()</code>来映射共享内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数返回值是共享内存的首地址指针</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">shmat</span><span class="params">( <span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span>* shm_addr, <span class="type">int</span> shmflg )</span></span>;<span class="comment">//share memory at</span></span><br><span class="line"><span class="comment">//shm_id：是共享内存的ID，shmget()函数的返回值</span></span><br><span class="line"><span class="comment">//shm_addr：指定共享内存连接到当前进程地址空间的位置，通常传入NULL，表示让系统来进行选择</span></span><br><span class="line"><span class="comment">//如果要自己填，就必须保证不会覆盖、可控</span></span><br><span class="line"><span class="comment">//shmflg：一组控制的标志，通常输入0，也有可能输入SHM_RDONLY，表示共享内存段只读</span></span><br></pre></td></tr></table></figure><p>（3）使用函数<code>shmdt()</code>来分离共享内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">( <span class="type">void</span>* shm_p )</span></span>;<span class="comment">//share memory delete</span></span><br><span class="line"><span class="comment">//shm_p：就是共享内存的首地址指针，也即是shmat()的返回值</span></span><br></pre></td></tr></table></figure><p>（4）使用<code>shmctl()</code>函数来控制共享内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">( <span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds* buf )</span></span>;<span class="comment">//share memory control </span></span><br><span class="line"><span class="comment">//shm_id：是共享内存的标示符，也即是shmget()的返回值,共享内存的ID</span></span><br><span class="line"><span class="comment">//buf：IPC_RMID填NULL</span></span><br><span class="line"><span class="comment">//command：是要采取的动作，它有三个有效值，如下：</span></span><br><span class="line"><span class="comment">//---IPC_STAT---把buf结构中的值设置为共享内存的关联值</span></span><br><span class="line"><span class="comment">//---IPC_SET----如果拥有足够的权限，将共享内存的值设置为buf中的值</span></span><br><span class="line"><span class="comment">//---IPC_RMID---删除共享内存段【🔺】</span></span><br></pre></td></tr></table></figure><p>以下使用共享内存实现进程间通信。这个是写进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//usleep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//待共享的内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">bool</span> sex;</span><br><span class="line">    <span class="type">int</span> signal;<span class="comment">//信号，为了保证读到</span></span><br><span class="line">&#125;STUDENT, * pSTU;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson90</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//key_t的取值：本质上是一个整数，取值相同时可进行通信</span></span><br><span class="line">        <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shm_id == <span class="number">-1</span>)<span class="comment">//失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s Create share memory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//映射</span></span><br><span class="line">        pSTU pstudent = (pSTU)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//访问</span></span><br><span class="line">        pstudent-&gt;id = <span class="number">66666</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(pstudent-&gt;name, <span class="string">&quot;ancasdwdaddadadadwdadwad&quot;</span>);</span><br><span class="line">        pstudent-&gt;age = <span class="number">18</span>;</span><br><span class="line">        pstudent-&gt;sex = <span class="literal">true</span>;</span><br><span class="line">        pstudent-&gt;signal = <span class="number">99</span>;</span><br><span class="line">        <span class="comment">//同步机制</span></span><br><span class="line">        <span class="keyword">while</span> (pstudent-&gt;signal == <span class="number">99</span>)<span class="comment">//直到被读到</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000000</span>);</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;parent wait:&quot;</span>, stdout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分离共享内存</span></span><br><span class="line">        <span class="built_in">shmdt</span>(pstudent);</span><br><span class="line">        <span class="comment">//控制共享内存</span></span><br><span class="line">        <span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//子进程类似，但需要晚一些，等待父进程写入</span></span><br><span class="line">        <span class="comment">//usleep(3000000);//ns级别的sleep，可以控制非常精确，1000为1ms，此处为1s</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm_id == <span class="number">-1</span>)<span class="comment">//失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s Create share memory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//映射</span></span><br><span class="line">        pSTU pstudent = (pSTU)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//访问：读【直到能读到】</span></span><br><span class="line">        <span class="comment">//同步机制</span></span><br><span class="line">        <span class="keyword">while</span> (pstudent-&gt;signal != <span class="number">99</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000000</span>);</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;wait:&quot;</span>, stdout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id:%d\nname:%s\nage:%d\nsex:%s\n&quot;</span>, pstudent-&gt;id, pstudent-&gt;name, pstudent-&gt;age, pstudent-&gt;sex ? <span class="string">&quot;male&quot;</span> : <span class="string">&quot;female&quot;</span>);</span><br><span class="line">        pstudent-&gt;signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">shmdt</span>(pstudent);</span><br><span class="line">        <span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson90</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>需要保证读完前，共享内存的进程还不能结束共享，即必须保证<strong>同步</strong>【外加信号机制，否则没写完就读必然不是想要的结果【代码中的<code>while</code>等待机制】】</li><li>内存访问速度能达到10G/s以上，很可能上面的父进程共享结束，子进程都没开始读【读的其实是空内存】。</li><li>以上存在的需要手动同步的缺陷，可以利用下面的信号量解决</li></ul><br><h5 id="5-5-4-进程间通信：信号量"><a href="#5-5-4-进程间通信：信号量" class="headerlink" title="5.5.4 进程间通信：信号量"></a>5.5.4 进程间通信：信号量</h5><p><span style="background:#13dddd">（1）什么是信号量？</span></p><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。</p><p>临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说<span style="background:#ff0">信号量是用来调协进程对共享资源的访问的。</span></p><p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待【即<code>P(信号变量)</code>】和发送【即<code>V(信号变量)</code>】信息操作。【通过P和释放V】</p><blockquote><p>最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p></blockquote><br><p><span style="background:#13dddd">（2）信号量的工作原理</span></p><p>信号量只能进行两种操作【等待和发送信号】，即<code>P(sv)</code>和<code>V(sv)</code>，具体行为如下：</p><ul><li><code>P(sv)</code>：如果<code>sv</code>的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</li><li><code>V(sv)</code>：如果有其他进程因等待<code>sv</code>而被挂起，就让它恢复运行，如果没有进程因等待<code>sv</code>而挂起，就给它加1。</li></ul><blockquote><p>举个例子：两个进程共享信号量sv，一旦其中一个进程执行了<code>P(sv)</code>操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行<code>P(sv)</code>时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行<code>V(sv)</code>释放信号量，这时第二个进程就可以恢复执行。</p></blockquote><br><p><span style="background:#13dddd">（3）Linux的信号量机制</span></p><p>A：信号量创建函数<code>semget</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个新信号量或取得一个已有信号量</span></span><br><span class="line"><span class="comment">//返回值：成功返回一个相应信号标识符（非零）sem_id，失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span>; </span><br><span class="line"><span class="comment">//key_t ftok(const char *pathname, int proj_ id);创建key键值</span></span><br><span class="line"><span class="comment">//num_sems：指定需要的信号呈数目，它的值几乎总是1</span></span><br><span class="line"><span class="comment">//sem_fags：一组标志</span></span><br></pre></td></tr></table></figure><blockquote><p>第一个参数key【最好自己创建，键值唯一】是整数值【唯一非零】，不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源。</p><p>程序对所有信号量的访问都是间接的，程序先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符 【semget涵数的返回值】，只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。</p><p>对于第三个参数，想要当信号量不存在时创建一个新的信号量，可以和值<code>IPC_CREAT</code>做按位或操作。设置了 <code>IPC_CREAT</code>标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而<code>IPC_CREAT | IPC_EXCL</code>则可以创建一个新的、唯一的信号量，如果信号量已存在，返回一个错误。</p></blockquote><p>B：PV操作<code>semop</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对semid这个信号量指定的变量进行操作，是选择发送（+1）还是等待（-1）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span></span>;</span><br><span class="line"><span class="comment">//return:成功返回一个相应信号标识符（非零）sem_id，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_id：是由semget返回的信号量标识符</span></span><br><span class="line"><span class="comment">//Sops：表示要对信号量进行什么操作</span></span><br><span class="line"><span class="comment">//nsops：是表示操作的信号量个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sembuf：结构的定义如下:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span>&#123;</span><br><span class="line">    <span class="type">short</span> sem_num; <span class="comment">//除非使用一组信号量，否则它为0,从0开始，表示要操作的信号量是第几个;</span></span><br><span class="line">    <span class="type">short</span> sem_op;<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，对第一个变量选择的信号量进行操作；一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="type">short</span> sem_flg; <span class="comment">//默认0，通常为SEM_UNDO,使操作系统跟踪信号，并在进程没有释放该信号量而终止时,操作系统释放信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C：信号量控制函数<code>semctl</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接控制信号量信息:成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> semid,  <span class="type">int</span> semnum, <span class="type">int</span> cmd, …)</span></span>;</span><br><span class="line"><span class="comment">//semid：信号量的标志码(ID)，也就是semget（）函数的返回值</span></span><br><span class="line"><span class="comment">//semnum：操作信号在信号集中的编号，从0开始；</span></span><br><span class="line"><span class="comment">//cmd：命令，表示要进行的操作,参数cmd中可以使用的命令如下</span></span><br><span class="line"><span class="comment">//---IPC_STAT--读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中</span></span><br><span class="line"><span class="comment">//---IPC_SET---设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数</span></span><br><span class="line"><span class="comment">//---IPC_RMID--将信号量集从内存中删除【只能由创建者删除】🔺</span></span><br><span class="line"><span class="comment">//---GETALL----用于读取信号量集中的所有信号量的值</span></span><br><span class="line"><span class="comment">//---GETNCNT---返回正在等待资源的进程数目</span></span><br><span class="line"><span class="comment">//---GETPID----返回最后一个执行semop操作的进程的PID</span></span><br><span class="line"><span class="comment">//---GETVAL----返回信号量集中的一个单个的信号量的值</span></span><br><span class="line"><span class="comment">//---GETZCNT---返回这在等待完全空闲的资源的进程数目</span></span><br><span class="line"><span class="comment">//---SETALL----设置信号量集中的所有的信号量的值SETVAL设置信号量集中的一个单独的信号量的值。</span></span><br><span class="line"><span class="comment">//---SETVAL----设置信号量集中的一个单独的信号量的值🔺</span></span><br></pre></td></tr></table></figure><p><strong>使用信号量改进共享内存的通信方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//usleep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//待共享的内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">bool</span> sex;</span><br><span class="line">&#125;STUDENT, * pSTU;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson90</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">2</span>, IPC_CREAT);<span class="comment">//标志意为：如果不存在则创建</span></span><br><span class="line">        <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, <span class="number">0</span>);<span class="comment">//第0个编号，信号量初始值为0【单个资源】</span></span><br><span class="line">        <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, SETVAL, <span class="number">0</span>);<span class="comment">//第1个编号，信号量初始值为0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm_id == <span class="number">-1</span>)<span class="comment">//失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s Create share memory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//映射</span></span><br><span class="line">        pSTU pstudent = (pSTU)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//访问</span></span><br><span class="line">        pstudent-&gt;id = <span class="number">66666</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(pstudent-&gt;name, <span class="string">&quot;ancasdwdaddadadadwdadwad&quot;</span>);</span><br><span class="line">        pstudent-&gt;age = <span class="number">18</span>;</span><br><span class="line">        pstudent-&gt;sex = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//信号量同步机制【注意此处结构体的赋值方式】</span></span><br><span class="line">        <span class="comment">//序号为0的信号量用于通知子进程可以进行读</span></span><br><span class="line">        sembuf sop = &#123;</span><br><span class="line">            .sem_num = <span class="number">0</span>,<span class="comment">//序号</span></span><br><span class="line">            .sem_op = <span class="number">1</span><span class="comment">//+1,即V操作</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//操作一个信号量，V操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序号为1的信号量用于等待子进程读取结束</span></span><br><span class="line">        sop.sem_op = <span class="number">-1</span>;<span class="comment">//-1,即P操作</span></span><br><span class="line">        sop.sem_num = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//P操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分离共享内存</span></span><br><span class="line">        <span class="built_in">shmdt</span>(pstudent);</span><br><span class="line">        <span class="comment">//控制共享内存</span></span><br><span class="line">        <span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除信号量,只能由创建者删除</span></span><br><span class="line">        <span class="comment">//sleep(10);//观察信号量 ipcs -s</span></span><br><span class="line">        <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">        <span class="built_in">semctl</span>(sem_id, <span class="number">1</span>, IPC_RMID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//子进程，等待父进程写入</span></span><br><span class="line">        <span class="comment">//usleep(3000000);//ns级别的sleep，1000为1ms</span></span><br><span class="line">        <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">2</span>, IPC_CREAT);<span class="comment">//获取父进程信号量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>), <span class="built_in">sizeof</span>(STUDENT), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (shm_id == <span class="number">-1</span>)<span class="comment">//失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s Create share memory failed!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//信号量机制：序号为0的信号量用于通知子进程可以进行读</span></span><br><span class="line">        sembuf sop = &#123;</span><br><span class="line">            .sem_num = <span class="number">0</span>,<span class="comment">//序号</span></span><br><span class="line">            .sem_op = <span class="number">-1</span><span class="comment">//-1,即P操作等待</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//操作一个信号量，V操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//映射</span></span><br><span class="line">        pSTU pstudent = (pSTU)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//访问：读</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id:%d\nname:%s\nage:%d\nsex:%s\n&quot;</span>, pstudent-&gt;id, pstudent-&gt;name, pstudent-&gt;age, pstudent-&gt;sex ? <span class="string">&quot;male&quot;</span> : <span class="string">&quot;female&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//信号量机制：序号为1的信号量通知父进程：子进程读取结束</span></span><br><span class="line">        sop.sem_op = <span class="number">1</span>;<span class="comment">//+1,即V操作</span></span><br><span class="line">        sop.sem_num = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">semop</span>(sem_id, &amp;sop, <span class="number">1</span>);<span class="comment">//V操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">shmdt</span>(pstudent);</span><br><span class="line">        <span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用信号量优化共享内存</span></span><br><span class="line">    <span class="built_in">lesson90</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>相比共享内存，信号量机制不需要地址映射的过程；</li><li>注意此处结构体的赋值方式【43行】</li><li>如果不删除信号量，可使用 <code>ipcs -m</code> 或 <code>ipcs -s</code> 查看进程间通信相关的信息</li><li>很高效，但依然繁琐复杂，一般除非有大内存共享的需求，否则使用消息队列。</li></ul><p>另外一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Description:这个程序是测试信号量的互斥（进程间互斥），命令ipcs和ipcrm可以帮助我们查看 - s（信号量）、 - q（消息队列）、 - m（共享内存）是否创建成功与删除。使用方法：man ipcs 和 man ipcrm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*创建信号量sem_id，IPC_CREAT:不存在就创建，存在就获取。*/</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;/home/nan/test&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create key fail.--%d\n&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create key succeed :--%d\n&quot;</span>, key);</span><br><span class="line">    <span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">1</span>, IPC_CREAT);</span><br><span class="line">    <span class="comment">//1：表示sem_id信号集中，创建信号量的个数，1个；</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sem_id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create sem_id fail.--%d\n&quot;</span>, sem_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create sem_id succeed.--%d\n&quot;</span>, sem_id);</span><br><span class="line">    <span class="comment">/*设置信号量集中的信号量，第二个参数表示操作第1个信号量*/</span></span><br><span class="line">    <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sem_num is : %d\n&quot;</span>, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">    <span class="comment">/*设置信号集sem_id中的信号量值，-1（等待），+1（发送）*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sops = &#123;</span><br><span class="line">        .sem_num = <span class="number">0</span> ,<span class="comment">//信号集中的第几个信号量，0表示第一个</span></span><br><span class="line">        .sem_op = <span class="number">-1</span> ,<span class="comment">//执行等待操作，其他进程等着。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">semop</span>(sem_id, &amp;sops, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;operator sem fail!--%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;operator semop succeed.--%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">/*获取到了锁，则可以实现自己想要的操作，其他进程等着*/</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/home/nan/test/text&quot;</span>, O_RDWR | O_APPEND | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open text fail . --%d\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">&quot;1&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">&quot;2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="comment">/*操作完成后，+1（发送出去），将锁交给其他进程用*/</span></span><br><span class="line">    sops.sem_num = <span class="number">0</span>;</span><br><span class="line">    sops.sem_op = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">semop</span>(sem_id, &amp;sops, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Description:在执行第一个程序时候，执行下面这个程序，可以看到下面的程序处于等待状态。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;/home/nan/test&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create key fail.--%d\n&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create key succeed :--%d\n&quot;</span>, key);</span><br><span class="line">    <span class="type">int</span> sem_id = <span class="built_in">semget</span>(key, <span class="number">1</span>, IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sem_id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create sem_id fail.--%d\n&quot;</span>, sem_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create sem_id succeed.--%d\n&quot;</span>, sem_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sem_num is : %d\n&quot;</span>, <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, GETVAL));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sops = &#123;</span><br><span class="line">    ​	.sem_num = <span class="number">0</span> ,</span><br><span class="line">        ​.sem_op = <span class="number">-1</span> ,</span><br><span class="line">        ​ &#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">semop</span>(sem_id, &amp;sops, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;operator sem fail!--%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;operator semop succeed.--%d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/home/nan/test/text&quot;</span>, O_RDWR | O_APPEND | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open text fail . --%d\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">&quot;3&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="5-5-5-进程间通信：消息队列"><a href="#5-5-5-进程间通信：消息队列" class="headerlink" title="5.5.5 进程间通信：消息队列"></a>5.5.5 进程间通信：消息队列</h5><p>消息队列，提供了一种从一个进程向另一个进程发送一个数据块的方法。</p><ul><li>每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。【如果纯粹发送数据，为什么不开管道呢？】</li><li>我们可以通过发送消息来避免命名管道的同步和阻塞问题，如read端因write端而阻塞；而消息<span style="background:#ff0">不会阻塞，实时性较强</span>。</li><li>但是消息队列与命名管道<code>FIFO</code>一样，每个数据块都有一个最大长度的限制；大数据传输需求使用共享内存。</li><li>消息队列其实就是一个链表。</li></ul><blockquote><p>数据传输量大使用共享内存；数据量小单纯收发数据用<code>FIFO</code>；又不想阻塞用消息队列；不用消息队列，那就用信号量实现，来取消阻塞。</p></blockquote><p><strong>消息队列API：</strong></p><p>创建和访问一个消息队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return：一个以key命名的消息队列的标识符（非零整数），失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">//key_t:与其他的IPC机制一样，程序必须提供一个键来命名某个特定的消息队列[ftok()]</span></span><br><span class="line"><span class="comment">//msgflg是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。</span></span><br><span class="line"><span class="comment">//msgflg可以与IPC_CREAT做或操作，表示当key所命名的消息队列不存在时创建一个消息队列，如果key所命名的消息队列存在时，IPC_CREAT标志会被忽略，而只返回一个标识符</span></span><br></pre></td></tr></table></figure><p>把消息添加到消息队列中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ret:如果调用成功，消息数据的一分副本将被放到消息队列中，并返回0，失败时返回-1.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsend</span><span class="params">(<span class="type">int</span> msgid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">//msgid是由msgget函数返回的消息队列标识符</span></span><br><span class="line"><span class="comment">//msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求:</span></span><br><span class="line"><span class="comment">//---指针msg_ptr所指向的消息结构 一定要是以一个长整型成员变量开始的结构体</span></span><br><span class="line"><span class="comment">//---接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_message</span>&#123; </span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> message_type; <span class="comment">/* The data you wish to transfer*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//msg_sz是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度</span></span><br><span class="line"><span class="comment">//---也就是说msg_sz是不包括长整型消息类型成员变量的长度。</span></span><br><span class="line"><span class="comment">//msgflg用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情【一般不用，进行其他替代处理】</span></span><br></pre></td></tr></table></figure><p>从一个消息队列获取消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return:失败时返回-1</span></span><br><span class="line"><span class="comment">//调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中</span></span><br><span class="line"><span class="comment">//然后删除消息队列中的对应消息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msgid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_st, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">//msgid, msg_ptr, msg_st的作用也函数msgsnd函数的一样</span></span><br><span class="line"><span class="comment">//msgtype可以实现一种简单的接收优先级。</span></span><br><span class="line"><span class="comment">//---如果msgtype为0，就获取队列中的第一个消息。</span></span><br><span class="line"><span class="comment">//---如果它的值大于零，将获取具有相同消息类型的第一个信息。</span></span><br><span class="line"><span class="comment">//---如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。</span></span><br><span class="line"><span class="comment">//msgflg用于控制当队列中没有相应类型的消息可以接收时将发生的事情。</span></span><br></pre></td></tr></table></figure><p>控制消息队列，它与共享内存的<code>shmctl</code>函数相似，它的原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ret:成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msgid, <span class="type">int</span> command, <span class="keyword">struct</span> msgid_ds *buf)</span></span>;</span><br><span class="line"><span class="comment">//command是将要采取的动作，它可以取3个值，</span></span><br><span class="line"><span class="comment">//---IPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。</span></span><br><span class="line"><span class="comment">//---IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值</span></span><br><span class="line"><span class="comment">//---IPC_RMID：删除消息队列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。msgid_ds结构至少包括以下成员：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msgid_ds</span> &#123; </span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid; </span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid; </span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>消息队列示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//usleep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span><span class="comment">//msg</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//待共享的内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="comment">//char data[1024];//buffer</span></span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">char</span> message[<span class="number">256</span>];</span><br><span class="line">    &#125;data;</span><br><span class="line">&#125;MSG, * PMSG;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson92</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> msg_id = <span class="built_in">msgget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">3</span>), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;%s(%d):%s %d\n&quot;, __FILE__, __LINE__, __FUNCTION__,errno);</span></span><br><span class="line">        <span class="comment">//假如errno=38，表示函数未实现</span></span><br><span class="line">        <span class="keyword">if</span> (msg_id == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MSG msg;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//父进程recieve</span></span><br><span class="line">        <span class="built_in">msgrcv</span>(msg_id, &amp;msg, <span class="built_in">sizeof</span>(msg.data), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//获取队列中的第一个消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d name:%s age:%d msg:%s\n&quot;</span>, msg.data.id, msg.data.name, msg.data.age, msg.data.message);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">msgctl</span>(msg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">//子进程:发送消息</span></span><br><span class="line">        <span class="type">int</span> msg_id = <span class="built_in">msgget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">3</span>), IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        MSG msg;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">        msg.type = <span class="number">1</span>;</span><br><span class="line">        msg.data.id = <span class="number">666</span>;</span><br><span class="line">        msg.data.age = <span class="number">18</span>;</span><br><span class="line">        <span class="comment">//msg.data.name = &quot;chase&quot;;</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg.data.name, <span class="string">&quot;chase&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(msg.data.message, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//send</span></span><br><span class="line">        <span class="built_in">msgsnd</span>(msg_id, &amp;msg, <span class="built_in">sizeof</span>(msg.data), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">msgctl</span>(msg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson92</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="5-5-6-socket通信"><a href="#5-5-6-socket通信" class="headerlink" title="5.5.6 socket通信"></a>5.5.6 socket通信</h5><p>socket本质上用于不同网络地址下，两台设备的不同进程间的通信。但二者如果IP地址相同，就变成了IPC，即本机不同进程间的通信。</p><br><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><h3 id="6-linux系统编程：线程"><a href="#6-linux系统编程：线程" class="headerlink" title="6 linux系统编程：线程"></a>6 linux系统编程：线程</h3><h4 id="6-1-理解线程"><a href="#6-1-理解线程" class="headerlink" title="6.1 理解线程"></a>6.1 理解线程</h4><p>线程是在进程中产生的一个执行单元，是<span style="background:#ff0">CPU</span>调度和分配的最小单元。其在同一个进程中与其他线程并行运行，他们可以共享进程内的资源，比如内存、地址空间、打开的文件等等。</p><ul><li><strong>线程</strong>是CPU调度和分派的基本单位【CPU对开发人员来说，最大的价值就是寄存器】</li><li>CPU不会区分某个线程属于哪一个进程，即CPU眼里只有线程；进程运行对应运行进程的主线程。</li><li><strong>进程</strong>是分配资源的基本单位，进程是<span style="background:#ff0">操作系统</span>调度的最小单元【由操作系统控制】</li></ul><blockquote><p>进程：正在运行的程序（狭义），是处于执行期的程序以及它所管理的资源【如打开的文件、挂起的信号、进程状态、地址空间等等】的总称。</p><p>从操作系统核心角度来说，进程是操作系统调度除CPU时间片外进行的资源分配和保护的基本单位，它有一个独立的虚拟地址空间，用来容纳进程映像【如与进程关联的程序与数据】，并以进程为单位对各种资源实施保护，如受保护地访问处理器、文件、外部设备及其他进程【进程间通信】</p></blockquote><p>那到底如何理解进程和线程呢？</p><ol><li><p>计算机有很多资源组成，比如CPU、内存、磁盘、鼠标、键盘等，就像一个工厂由电力系统、作业车间、仓库、管理办公室和工人组成。</p></li><li><p>假定工厂的电力有限，一次只能供给一个或少量几个车间使用。也就是说，一部分车间开工的时候，其他车间都必须停工。【背后的含义就是，单个CPU一次只能运行一个任务，多个CPU能够运行少量任务】</p></li><li><p>线程就好比车间里的工人。一个进程可以包括多个线程，他们协同完成某一个任务。</p></li></ol><p><img src="./6-1.png"></p><p><strong>为什么使用多线程？</strong></p><ol><li>避免阻塞：单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就阻塞了，无法再去做其它的一些功能了。【比如之前的单进程服务端，使用for循环5次服务5个客户端，主线程每次都会卡在accept，直到该客户端服务结束；而多线程则不会阻塞】</li><li>避免CPU空转：应用程序经常会涉及到RPC【远程进程调用】、数据库访问、磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应时，CPU却不能去处理新的请求，导致这种单线程的应用程序性能很差；而使用线程，如果线程阻塞则挂起，等待唤醒。</li><li>提升效率：一个进程要独立拥有4GB的虚拟地址空间，而多个线程可以共享同一地址空间，线程的切换比进程的切换要快得多。下图展示了线程和进程的内存空间关系【涉及上下文切换】：</li></ol><p><img src="./6-2.png"></p><br><h4 id="6-2-线程的创建与运行"><a href="#6-2-线程的创建与运行" class="headerlink" title="6.2 线程的创建与运行"></a>6.2 线程的创建与运行</h4><blockquote><p>Linux下API，pthread库目前已变成跨平台的库，有其Windows版本。</p></blockquote><p>线程创建<code>pthread_create</code>：</p><blockquote><p>线程具有单独的执行流，因此需要单独定义线程的<code>main</code>函数，还需要请求操作系统在单独的执行流中执行该函数，完成该功能的函数如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return：成功时返回 0，失败时返回其他值-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span>* restrict thread, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> * restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *(* start_routine)(<span class="type">void</span> *),<span class="comment">//函数指针，参数是void指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* restrict arg<span class="comment">//不能是局部变量【const常量或new-delete在堆区】</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//thread:保存新创建线程ID的变量地址值。线程与进程相同，也需要用于区分不同线程的ID</span></span><br><span class="line"><span class="comment">//attr:用于传递线程属性的参数，传递NULL时，创建默认属 性的线程</span></span><br><span class="line"><span class="comment">//start_routine:相当于线程main函数的、在单独执行流中执行的函数地址值（函数指针）【必填】</span></span><br><span class="line"><span class="comment">//arg:通过第三个参数传递调用函数时包含传递参数信息的变量地址值</span></span><br></pre></td></tr></table></figure><p>线程等待<code>pthread_join</code>：</p><ul><li>调用<code>pthread_join</code>函数的进程（或线程）将进入等待状态，直到第一个参数为ID的线程终止为止</li><li>而且可以得到线程的main函数返回值，所以该函数比较有用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回[参数中线程的返回值]，失败时返回其他值</span></span><br><span class="line"><span class="comment">//失败的情况：1、等待线程不存在 2、等待线程早已结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> ** status)</span></span>;</span><br><span class="line"><span class="comment">//thread 该参数值ID的线程终止后才会从该函数返回</span></span><br><span class="line"><span class="comment">//status 保存线程的main函数返回值的指针变量地址值</span></span><br></pre></td></tr></table></figure><br><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadEntry</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* msg = <span class="string">&quot;I am from thread!&quot;</span>;<span class="comment">//常量字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s Thread begin:%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, arg);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson94</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pInfo = <span class="string">&quot;Hello World!&quot;</span>;<span class="comment">//常量字符串,会被编译进可执行程序中的数据段</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, threadEntry, (<span class="type">void</span>*)pInfo);<span class="comment">//此处避免使用局部变量【栈】【可能在新线程里反复使用】</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)<span class="comment">//创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid, &amp;result);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread:%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson94</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>可能编译出错，解决办法：附加额外库文件【项目属性 | 链接器 | 输入 | 库依赖项：添加 <code>pthread</code>】；如果是命令行编译：需要添加<code>-lpthread</code></li><li>常量会被编译进可执行文件的数据段【exe可执行文件分为：代码段、数据段、头部，其中头部包含一些资源等】</li></ul><br><h4 id="6-3-线程同步：互斥量"><a href="#6-3-线程同步：互斥量" class="headerlink" title="6.3 线程同步：互斥量"></a>6.3 线程同步：互斥量</h4><p>实例：两个线程实现加减法【直接访问全局变量sum，引入互斥操作】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_inc</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_dec</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        num--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson95</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread_id[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(thread_id+i, <span class="literal">NULL</span>, thread_inc,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(thread_id + i, <span class="literal">NULL</span>, thread_dec, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(thread_id[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread:%d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line">    <span class="comment">//结果是一个伪随机数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson95</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共创建了50个线程，其中一半执行<code>thread_inc</code>函数中的代码，另一半则执行<code>thread_des</code>函数中的代码。全局变量num经过增减过程后应为0。</p><p>但运行结果并不是0，而且每次运行的结果均不同。虽然其原因目前还未知，但可以肯定的是，这对于线程的应用是个大问题。从操作系统层面来解释，变量是存在内存里面，运算是在CPU里面的。如图所示：</p><p><img src="./6-3.png"></p><br><p><strong>线程同步</strong>用于解决线程访问顺序引发的问题。需要同步的情况可以从如下两方面考虑：</p><ol><li>同时访问同一内存空间时发生的情况。</li><li>需要指定访问同一内存空间的线程执行顺序的情况。</li></ol><blockquote><p>“控制（Control）线程执行顺序”的相关内容。假设有A、B两个线程，线程A负责向指定内存空间写入【保存】数据，线程B负责取走该数据。这种情况下，线程A首先应该访问约定的内存空间并保存数据。万一线程B先访问并取走数据，将导致错误结果。像这种需要控制执行顺序的情况也需要使用同步技术。</p></blockquote><p><strong>互斥量</strong>是”<code>Mutual Exclusion</code>“的简写，表示不允许多个线程同时访问。互斥量主要用于解决线程同步访问的问题。为了理解好互斥量，请观察如下对话过程：</p><ul><li><p>A∶”请问里面有人吗?”</p></li><li><p>B∶”是的，有人。”</p></li><li><p>A∶”您好!”</p></li><li><p>B∶”请稍等!”</p></li></ul><p>对于上述对话发生的场景。现实世界中的临界区就是洗手间。洗手间无法同时容纳多人【比作线程】，因此可以将临界区比喻为洗手间。而且这里发生的所有事情几乎可以全部套用到临界区同步过程，洗手间使用规则如下：</p><ul><li><p>为了保护个人隐私，进洗手间时锁上门，出来时再打开；</p></li><li><p>如果有人使用洗手间，其他人需要在外面等待；</p></li><li><p>等待的人数可能很多，这些人需排队进入洗手间。</p></li></ul><p>这就是洗手间的使用规则。同样，线程中为了保护临界区也需要套用上述规则。洗手间中存在，但之前的线程示例中缺少的是什么呢？就是<span style="background:#ff0">锁机制</span>。线程同步中同样需要锁，就像洗手间示例中使用的那样。互斥量就是一把优秀的锁，接下来介绍<span style="background:#ff0">互斥量的创建及销毁函数</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥量的创建和销毁</span></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(pthread <span class="type">mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">//mutex：创建互斥量时传递保存互斥量的变量地址值，销毁时传递需要销毁的互斥量地址值。</span></span><br><span class="line"><span class="comment">//att：r传递即将创建的互斥量属性，没有特别需要指定的属性时传递NULL。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上锁：成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>\* mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁：成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread <span class="type">mutex_t</span>\* mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法：*********************************************</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="comment">//临界区的开始</span></span><br><span class="line"><span class="comment">//..... </span></span><br><span class="line"><span class="comment">// 临界区的结束</span></span><br><span class="line"><span class="built_in">pthreadmutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><p>使用互斥量改造实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_inc</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//实时性更好,但mutex竞争处于弱势</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10000</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread:%d****\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_dec</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//推荐此种方式，效率更高</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread:%d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson95</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//互斥体</span></span><br><span class="line">    <span class="comment">//pthread_mutex_t mutex;</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);<span class="comment">//注意：创建和销毁对应出现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread_id[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(thread_id+i, <span class="literal">NULL</span>, thread_inc,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(thread_id + i, <span class="literal">NULL</span>, thread_dec, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(thread_id[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread:%d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson95</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>互斥量和信号量相似，但不相同。</li><li>简言之，就是利用<code>lock</code>和<code>unlock</code>函数围住临界区的两端。此时互斥量相当于一把锁，阻止多个线程同时访问。</li><li>还有一点需要注意，线程退出临界区时，如果忘了调用<code>pthread_mutex_unlock</code> 函数，那么其他为了进入临界区而调用<code>pthread_mutex_lock</code>函数的线程就无法摆脱阻塞状态【死锁状态】</li></ul><br><h4 id="6-4-线程同步：信号量"><a href="#6-4-线程同步：信号量" class="headerlink" title="6.4 线程同步：信号量"></a>6.4 线程同步：信号量</h4><p>信号量与互斥量极为相似，在互斥量的基础上很容易理解信号量。</p><ul><li>信号量有一个初始Value，互斥量也有，但<code>Value=1</code>。信号量的值代表目前的资源数量，有人wait【P操作】，如果value&gt;0，那就减1，否则等待。使用完资源释放<code>value+1</code>【V操作】。</li><li>也就是说，<code>wait/post</code>【P/V】不一定成对出现。</li><li>初始<code>Value=1</code>的信号量，可以理解为与互斥量等价，但信号量依然可以使用<code>wait/post</code>修改<code>Value</code>。</li></ul><p>信号量创建及销毁方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">//成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">//Sem：创建信号量时传递保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值。</span></span><br><span class="line"><span class="comment">//pshared ：传递其他值时，创建可由多个进程共享的信号量;传递0时，创建只允许1个进程内部使用的信号量。</span></span><br><span class="line"><span class="comment">//我们需要完成同一进程内的线程同步，所以传递0。【早期Linux版本未实现进程间共享】【默认0】</span></span><br><span class="line"><span class="comment">//Value：指定新创建的信号量初始值。</span></span><br></pre></td></tr></table></figure><p>接下来介绍：信号量中相当于互斥量<code>lock</code>、<code>unlock</code>的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;<span class="comment">//【post释放，即V操作】</span></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;<span class="comment">//【wait占用，即P操作】【value&lt;=0时阻塞】</span></span><br><span class="line"><span class="comment">//Sem: 传递保存信号量读取值的变量地址值</span></span><br><span class="line"><span class="comment">//传递给sem_post时信号量增1</span></span><br><span class="line"><span class="comment">//传递给sem_wait时信号量减1</span></span><br></pre></td></tr></table></figure><p>调用<code>sem_init</code>函数时，操作系统将创建信号量对象，此对象中记录着”信号量值”整数。该值在调用<code>sem_post</code>函数时增1，调用<code>sem_wait</code>函数时减1。但信号量的值不能小于0，因此，在信号量为0的情况下调用<code>sem_wait</code>函数时，调用函数的线程将进入阻塞状态【因为函数未返回】。</p><p>当然，此时如果有其他线程调用<code>sem_post</code>函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区【假设信号量的初始值为1】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_wait</span>(&amp;sem);<span class="comment">//信号量变为0...</span></span><br><span class="line"><span class="comment">// 临界区的开始</span></span><br><span class="line"><span class="comment">//...... </span></span><br><span class="line"><span class="comment">//临界区的结束</span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;sem);<span class="comment">// 信号量变为1...</span></span><br></pre></td></tr></table></figure><p>上面的代码结构中，调用<code>sem_wait</code>函数进入临界区的线程在调用<code>sem_post</code>函数前不允许其他线程进入临界区。</p><p>信号量的值在0和1之间跳转，因此，具有这种特性的机制称为”<strong>二进制信号量</strong>“。</p><br><p><strong>实例程序</strong>：</p><ul><li>线程A从用户输入得到值后存入全局变量num<strong>，</strong>此时线程B将取走该值并累加。该过程共进行5次，完成后输出总和并退出程序。</li><li>线程A、线程B按顺序访问变量num，且需要线程同步。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem1;<span class="comment">//是否完成输入</span></span><br><span class="line"><span class="type">sem_t</span> sem2;<span class="comment">//是否完成计算</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_input</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int count = (int)arg;//提示丢失精度</span></span><br><span class="line">    <span class="comment">//int count = reinterpret_cast&lt;int&gt;(arg);//强制类型转换//x64可能不接受</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意此处arg有&amp;，本质是取该值，而不是该值对应地址处的值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;count, &amp;arg, <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//前提：该系统存储为小顶端：即低位在前，高位在后</span></span><br><span class="line">    <span class="comment">//memcpy(&amp;count, 4+(char*)&amp;arg, sizeof(int));//大顶端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input num:&quot;</span>);</span><br><span class="line">        <span class="comment">//sem_wait(&amp;sem2);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程输入，主线程读</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson96</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建信号量【初始化在创建线程前】</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_input, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(count));<span class="comment">//传值可以，但不要传局部变量地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem1);</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="comment">//sem_post(&amp;sem2);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem1);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread:%d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson96</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>利用输入进程的特性【慢】，通过取消信号量<code>sem2</code>来优化程序</li></ul><br><h4 id="6-5-线程的销毁"><a href="#6-5-线程的销毁" class="headerlink" title="6.5 线程的销毁"></a>6.5 线程的销毁</h4><p>Linux线程并不是在首次调用的线程main函数返回时自动销毁，所以用如下两种方法之一加以明确，否则由线程创建的内存空间将一直存在。</p><ul><li>调用<code>pthread_join</code>函数。</li><li>调用<code>pthread_detach</code>函数。</li></ul><p>之前调用过<code>pthread_join</code>函数。调用该函数时，不仅会等待线程终止，还会引导线程销毁。</p><p>但该函数的问题是，在线程终止前，调用该函数的线程将进入阻塞状态。因此，通常通过如下<code>pthread_detach</code>函数调用引导线程销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回，失败时返回其他值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">//thread: 终止的同时需要销毁的线程ID</span></span><br></pre></td></tr></table></figure><ul><li>调用 <code>pthread_detach</code>函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。</li><li>调用该函数后不能再针对相应线程调用<code>pthread_join</code>函数，这需要格外注意。</li><li>虽然还有方法在创建线程时可以指定销毁时机，但与<code>pthread_detach</code>方式相比，结果上没有太大差异</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此外可以通过线程函数来进行自动销毁,无需外部的操作【即由线程自身引导销毁】</span></span><br><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());<span class="comment">//pthread_self()只能在线程内调用</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">pthread_exit</span>(<span class="number">0</span>) ;</span><br></pre></td></tr></table></figure><p>修改上一节的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_input</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());<span class="comment">//******************</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;count, &amp;arg, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input num:&quot;</span>);</span><br><span class="line">        <span class="comment">//sem_wait(&amp;sem2);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//*****************************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="6-6-实战案例：多线程并发服务器的实现"><a href="#6-6-实战案例：多线程并发服务器的实现" class="headerlink" title="6.6 实战案例：多线程并发服务器的实现"></a>6.6 实战案例：多线程并发服务器的实现</h4><p>网络编程+多线程+线程同步实现的聊天服务器【群聊】+客户端</p><blockquote><p>服务器一对多 | 客户端一对一 【CS】</p><p>之前的多进程并发服务器是每次fork一个进程，主进程返回继续accept，这样的开销还是有点大。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span><span class="comment">//errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> clnt_socks[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//初始化【】</span></span><br><span class="line"><span class="type">int</span> clnt_count = <span class="number">0</span>;<span class="comment">//客户端数量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_msg</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">ssize_t</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clnt_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        <span class="keyword">if</span> (clnt_socks[i] &gt;= <span class="number">0</span>)<span class="comment">//避免有的客户端提前退出</span></span><br><span class="line">            <span class="built_in">write</span>(clnt_socks[i], msg, str_len);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_handle_clnt</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程处理客户端</span></span><br><span class="line">    <span class="type">int</span> client_sock = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> str_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(client_sock, message, <span class="built_in">sizeof</span>(message))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//收到客户端消息后，转发到其他用户</span></span><br><span class="line">        <span class="built_in">send_msg</span>(message, str_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发后关闭该客户端套接字</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; clnt_count; i++)//<span class="doctag">TODO:</span>可优化逻辑</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//	if (clnt_socks[i] == client_sock)</span></span><br><span class="line">    <span class="comment">//	&#123;</span></span><br><span class="line">    <span class="comment">//		//注意，此处close与write需要互斥</span></span><br><span class="line">    <span class="comment">//		//pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">    <span class="comment">//		clnt_socks[i] = -1;//优先，避免send_msg中写失败</span></span><br><span class="line">    <span class="comment">//		//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">    <span class="comment">//		break;</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    *(<span class="type">int</span>*)arg = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(client_sock);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server98</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, client_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(::)&#123;&#125;//等价</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client_sock = <span class="built_in">accept</span>(serv_sock, (sockaddr*)&amp;clnt_addr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;accept error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交给线程处理</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        clnt_socks[clnt_count++] = client_sock;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_handle_clnt, clnt_socks + clnt_count - <span class="number">1</span>);<span class="comment">//参数传递客户端socket</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> semid;</span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>] = <span class="string">&quot;[DEFAULT]&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_clnt_send_msg</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端子线程发送消息</span></span><br><span class="line">    <span class="type">int</span> client_sock = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">fgets</span>(message, <span class="built_in">sizeof</span>(message), stdin);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//更安全的printf:用后面的参数填充第一个参数</span></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;[%s]: %s&quot;</span>, name, message);</span><br><span class="line">        <span class="built_in">write</span>(client_sock, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//close(client_sock);//在主进程中close</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semid);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_clnt_recv_msg</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端子线程接受消息</span></span><br><span class="line">    <span class="type">int</span> client_sock = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="type">ssize_t</span> str_len = <span class="built_in">read</span>(client_sock, message, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="keyword">if</span> (str_len &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span>敏感词过滤****************</span></span><br><span class="line">            <span class="built_in">fputs</span>(message, stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semid);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;input your name:&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clnt_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用线程执行客户端操作</span></span><br><span class="line">    <span class="type">pthread_t</span> tid_snd, tid_rev;</span><br><span class="line">    <span class="comment">//此处的传递的参数为局部变量，要么用全局变量，要么保证其寿命比线程长[信号量]</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semid, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid_snd, <span class="literal">NULL</span>, thread_clnt_send_msg, (<span class="type">void</span>*)&amp;clnt_sock);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid_rev, <span class="literal">NULL</span>, thread_clnt_recv_msg, (<span class="type">void</span>*)&amp;clnt_sock);</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semid);<span class="comment">//阻塞等待两个线程结束</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson98</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">server98</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">client</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s From Thread\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson98</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>两处需要互斥量【基本上，线程操作全局变量，都要使用互斥量】<ul><li><code>clnt_count</code>被修改时，需要互斥量</li><li><code>clnt_socks[i]</code>被修改时，需要互斥量</li></ul></li><li>用到的输入输入函数：<code>fputs</code>/<code>snprintf</code>/<code>printf</code> | <code>fgets</code>/<code>fgetc</code></li><li>服务端和客户端执行都需要有参数，服务端为<code>./Linux_consoleApplication.out s</code></li></ul><br><hr style="border-top:1px dashed #8c8b8b;border-bottom:none"><h3 id="7-I-O复用"><a href="#7-I-O复用" class="headerlink" title="7 I/O复用"></a>7 I/O复用</h3><h4 id="7-1-Select模型以及实战案例"><a href="#7-1-Select模型以及实战案例" class="headerlink" title="7.1 Select模型以及实战案例"></a>7.1 Select模型以及实战案例</h4><blockquote><p><code>Select</code>和<code>Epoll</code>都是IO复用的技术，其中<code>Select</code>更简单；但两者都比多进程和多线程复杂</p></blockquote><p>复用的概念：是为了提高物理设备的效率，用<strong>最少的物理要素</strong>传递<strong>最多数据</strong>时使用的技术。</p><blockquote><p>如下图所示，左图结构代表多进程多线程的模式，右图则是IO复用。</p></blockquote><p><img src="./7-1.png"></p><p>多进程服务器的缺点：</p><ul><li>需要大量重复的运算</li><li>大量的内存空间【创建进程或线程、切换，如果内存不足就无法挂起切换】【不可能支持创建百万级别的线程】</li></ul><br><p><strong>复用技术在服务端的应用：一个线程服务所有客户端。</strong></p><p><img src="./7-2.png"></p><blockquote><p>最开始的回声服务器，就是单进程单线程服务器，但会阻塞在<code>accept</code>；现在改为不再accept，而是等有客户端发起连接请求时，再通知本进程处理客户端请求。之后，本线程不断去轮询已连接的客户端。</p></blockquote><br><p><strong>理解select函数并实现服务端：</strong>可参考【<a target="_blank" rel="noopener" href="https://blog.csdn.net/chen_ever/article/details/137544607">Select剖析</a>】</p><p><code>select</code>函数是IO多路复用的函数，它主要的功能是用来等文件描述符中的事件是否就绪，<code>select</code>可以使我们在同时等待多个文件缓冲区 ，减少IO等待的时间，能够提高进程的IO效率。</p><p><code>select()</code>函数允许程序监视多个文件描述符，等待所监视的一个或者多个文件描述符变为“准备好”的状态。所谓的”准备好“状态是指：文件描述符不再是阻塞状态，可以用于某类IO操作了，包括可读，可写，发生异常三种。</p><ol><li>是否存在套接字接收数据？【服务端存在一个socket接收数据】</li><li>无需阻塞传输数据的套接字有哪些？【轮询】</li><li>哪些套接字发生了异常？【轮询】</li></ol><br><p><img src="./7-3.png"></p><p><code>Select</code>模型具体步骤：如上图</p><p>1、设置文件描述符：<code>select</code>函数监视多个文件描述符【不超过1024个，因为本质是轮询，故监视过多会导致轮询时间太长】【<code>Epoll</code>没有数量限制】 【<code>fd_set</code>结构体如上图】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd_set reads;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口函数</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set *fdset);<span class="comment">//将fdset变量的所有位初始化为0</span></span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd，fd_set* fdset);<span class="comment">//在参数dset指向的变量中注册文件描述符fd的信息。</span></span><br><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd，fd_set* fdset);<span class="comment">//从参数fdset指向的变量中清除文件描述符fd的信息</span></span><br><span class="line"><span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd，fd_set* fdset);<span class="comment">//若参数fdset指向的变量中包含文件描述符fd的信息，则返回&quot;真&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><code>fd_set</code>类型本质是一个位图，位图的位置表示相对应的文件描述符，内容表示该文件描述符是否有效。1代表该位置的文件描述符有效，0则表示该位置的文件描述符无效。</li><li>如果将文件描述符<code>2，3</code>设置位图当中，则位图表示的是为1100或0011？</li><li>fd_set的上限是1024个文件描述符。</li></ul></blockquote><p>2、<code>Select</code>函数：等待文件描述符中的事件是否就绪，可以使我们在同时等待多个文件缓冲区 ，减少IO等待的时间，能够提高进程的IO效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回大于0的值，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval* timeout)</span></span>; </span><br><span class="line"><span class="comment">//maxtfd/ndfs ：监视对象文件描述符数量</span></span><br><span class="line"><span class="comment">//即等待的文件描述符的最大值+1，例如：应用进程想要去等待文件描述符3,5,8的事件，则</span></span><br><span class="line"><span class="comment">//nfds=max(3,5,8)+1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//readset：用于检查可读性，即等待读事件的文件描述符集合。如果不关心读事件传NULL</span></span><br><span class="line"><span class="comment">//writeset：等待写事件(缓冲区中是否有空间)的集合，同上</span></span><br><span class="line"><span class="comment">//exceptset:如果内核等待相应的文件描述符发生异常，则将失败的文件描述符设置进exceptfds中。同上</span></span><br><span class="line"><span class="comment">//timeout：一个指向timeval结构的[指针]，用于决定select等待I/O的最长时间。如果为空将一直等待</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">long</span> tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>内核需要从<code>readfds</code>和<code>writefds</code>知道哪些文件描述符需要等待，应用进程需要从<code>readfds</code>和<code>writefds</code>中知道哪些文件描述符的事件就绪</li><li>优势：单线程并发；缺点：并发量有限制，受限于<code>fd_set</code>的长度</li></ul><p><img src="./7-4.png"></p><p><code>Select</code>实现I/O复用服务端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span><span class="comment">//errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server101</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, client_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// select：不采用accept</span></span><br><span class="line">    fd_set reads, copy_reads;<span class="comment">//等待读事件的文件描述符集合</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;reads);</span><br><span class="line">    <span class="built_in">FD_SET</span>(serv_sock, &amp;reads);<span class="comment">//让内核去监控serv_sock上的读操作</span></span><br><span class="line">    timeval timeout = &#123; <span class="number">2</span>,<span class="number">500000</span> &#125;;<span class="comment">//2.5s[秒，微秒]</span></span><br><span class="line">    <span class="type">int</span> max_sock = serv_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        copy_reads = reads;</span><br><span class="line">        <span class="comment">//nfds为最大的文件描述符+1【select相当于主动问，有无连接】</span></span><br><span class="line">        <span class="type">int</span> fd_num = <span class="built_in">select</span>(max_sock + <span class="number">1</span>, &amp;copy_reads, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);<span class="comment">//最大超时timeout=2.5s</span></span><br><span class="line">        <span class="keyword">if</span> (fd_num &lt;= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;select error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(serv_sock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fd_num == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//没有事件发生</span></span><br><span class="line">        <span class="comment">//开始查找事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_sock + <span class="number">1</span>; i++)<span class="comment">//此处循环也是为什么nfds=最大文件描述符+1的原因</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若参数fdset指向的变量【reads】中包含文件描述符fd【i】的信息，则返回&quot;真&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;copy_reads))<span class="comment">//如果该文件描述符i发生读操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == serv_sock)<span class="comment">//服务端，即从未连接过的客户端向客户端发起连接请求</span></span><br><span class="line">                &#123;</span><br><span class="line">                    client_sock = <span class="built_in">accept</span>(serv_sock, (sockaddr*)&amp;clnt_addr, &amp;clnt_adr_sz);</span><br><span class="line">                    <span class="built_in">FD_SET</span>(client_sock, &amp;reads);<span class="comment">//对client_sock也进行监听</span></span><br><span class="line">                    <span class="keyword">if</span> (client_sock &gt; max_sock)</span><br><span class="line">                        max_sock = client_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client is connected: %d\n&quot;</span>,client_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//已连接的客户端</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> buffer[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">ssize_t</span> strlength = <span class="built_in">read</span>(i, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                    <span class="keyword">if</span> (strlength == <span class="number">0</span>)<span class="comment">//客户端结束</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;reads);</span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client is deconnected: %d\n&quot;</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">//简单的回声服务器</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">write</span>(i, buffer, strlength);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client101</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clnt_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> message[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input message:(Q to quit)&quot;</span>);</span><br><span class="line">        <span class="built_in">fgets</span>(message,<span class="built_in">sizeof</span>(message),stdin);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(clnt_sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;From server:%s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson101</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">server101</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">client101</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s OVER!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson101</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="7-2-Epoll模型"><a href="#7-2-Epoll模型" class="headerlink" title="7.2 Epoll模型"></a>7.2 Epoll模型</h4><p>Select模型的缺点：</p><ul><li>调用select函数后，常见的针对所有文件描述符的循环语句【查询是哪一个文件描述符有事件】【可优化为直接报告是哪些文件描述符】</li><li>每次调用select函数时，都需要向该函数传递监视对象信息</li><li><code>fd_set</code>有1024的限制</li></ul><blockquote><p>调用select 函数后，并不是把发生变化的文件描述符单独集中到一起，而是通过观察作为监视对象的<code>fd_set</code>变量的变化，找出发生变化的文件描述符，因此无法避免针对所有监视对象的循环语句。</p><p>而且，作为监视对象的<code>fd_set</code>变量会发生变化，所以调用select函数前应复制并保存原有信息，并在每次调用select函数时传递新的监视对象信息。</p></blockquote><p>那到底哪些因素是提高性能的更大障碍？是调用select函数后常见的针对所有文件描述符对象的循环语句？还是每次需要传递的监视对象信息?</p><p>只看代码的话很容易认为是循环。<span style="background:#ff0">但相比于循环语句，更大的障碍是每次传递监视对象信息。</span>因为传递监视对象信息具有如下含义∶”<strong>每次调用select函数时向操作系统传递监视对象信息。</strong>“</p><p><span style="background:#ff0">应用程序向操作系统传递数据将对程序造成很大负担，而且无法通过优化代码解决，因此将成为性能上的致命弱点。</span></p><p>🔺”那为何需要把监视对象信息传递给操作系统呢?”</p><p>有些函数不需要操作系统的帮助就能完成功能，而有些则必须借助于操作系统。假设各位定义了四则运算相关函数，此时无需操作系统的帮助。但select函数与文件描述符有关，更准确地说，是监视套接字变化的函数。而套接字是由操作系统管理的，所以select函数绝对需要借助于操作系统才能完成功能。【<span style="background:#13dddd">对应了两次内核态与用户态的切换</span>】</p><p>🔺select函数的这一缺点可以通过这种方式弥补∶</p><p>“向操作系统传递<code>1</code>次监视对象，监视范围或内容发生变化由内核只通知发生变化的事项。”【每次返回一个双向链表来表示发生变化的套接字】</p><p>这样就无需每次调用select函数时都向操作系统传递监视对象信息，但前提是操作系统支持这种处理方式（每种操作系统支持的程度和方式存在差异）。</p><blockquote><p>Linux的支持方式是<code>epoll</code>，Windows 的支持方式是<code>IOCP</code>。</p></blockquote><br><p><span style="background:#ff0">Epoll的三大函数：</span> <code>epoll_create</code>、<code>epoll_wait</code>、 <code>epoll_ctl</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll_create</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回epoll文件描述符，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//size：epoll实例的大小。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数从2.3.2版本的开始加入的，2.6版开始引入内核</span></span><br><span class="line"><span class="comment">//Linux最新的内核稳定版本已经到了5.8.14，长期支持版本到了5.4.70</span></span><br><span class="line"><span class="comment">//从2.6.8内核开始的Linux，【会忽略这个参数，但是必须要大于0】</span></span><br><span class="line"><span class="comment">//这个是Linux内核独有的函数</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//epoll_ctl</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span></span>;</span><br><span class="line"><span class="comment">//epfd 用于注册监视对象的epoll例程的文件描述符。</span></span><br><span class="line"><span class="comment">//fd 需要注册的监视对象文件描述符</span></span><br><span class="line"><span class="comment">//op 用于指定监视对象的添加、删除或更改等操作。</span></span><br><span class="line"><span class="comment">//===EPOLL_CTL_ADD   EPOLL_CTL_MOD   EPOLL_CTL_DEL======</span></span><br><span class="line"><span class="comment">//event 监视对象的事件类型</span></span><br><span class="line"><span class="comment">//===EPOLLIN∶需要读取数据的情况。【默认条件触发】</span></span><br><span class="line"><span class="comment">//===EPOLLOUT∶输出缓冲为空，可以立即发送数据的情况【比如要发100字节数据，send返回50，那就需要再调send去填满缓冲区发送】</span></span><br><span class="line"><span class="comment">//===EPOLLPRI∶收到OOB数据的情况。【优先级】</span></span><br><span class="line"><span class="comment">//===EPOLLRDHUP∶断开连接或半关闭【一端关闭，一端认为还存在连接】的情况，这在边缘触发方式下非常有用。</span></span><br><span class="line"><span class="comment">//===EPOLLERR∶发生错误的情况。</span></span><br><span class="line"><span class="comment">//===EPOLLET∶以边缘触发的方式得到事件通知。</span></span><br><span class="line"><span class="comment">//===EPOLLONESHOT∶发生一次事件后，相应文件描述符不再收到事件通知。因此需要向epoll_ctl函数的第二个参数传递</span></span><br><span class="line"><span class="comment">//===EPOLLCTL_MOD，再次设置事件。</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_wait：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回发生事件的文件描述符数，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events,<span class="type">int</span> maxevents,<span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//epfd 表示事件发生监视范围的epol例程的文件描述符</span></span><br><span class="line"><span class="comment">//events 保存发生事件的文件描述符集合的结构体地址值。</span></span><br><span class="line"><span class="comment">//maxevents 第二个参数中可以保存的最大事件数目。</span></span><br><span class="line"><span class="comment">//Timeout：以1/1000秒为单位的等待时间，传递-1时，一直等待直到发生事件。【ms】</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然，select在网络方面用存在很大问题，但由于其timeout的高精度，故常用来做高精度定时器。</p></blockquote><br><h4 id="7-3-Epoll实战案例"><a href="#7-3-Epoll实战案例" class="headerlink" title="7.3 Epoll实战案例"></a>7.3 Epoll实战案例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span><span class="comment">//errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server102</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, client_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Epoll</span></span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;<span class="comment">//Epoll文件描述符，事件数量标记</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>)) == <span class="number">-1</span>)<span class="comment">//必须&gt;0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Epoll error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_event event;<span class="comment">//事件</span></span><br><span class="line">    epoll_event* all_event = <span class="keyword">new</span> epoll_event[<span class="number">100</span>]; <span class="comment">//创建100个空闲事件</span></span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;<span class="comment">//条件触发：有数据输入</span></span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);<span class="comment">//开启监听</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, all_event, <span class="number">100</span>, <span class="number">1000</span>);<span class="comment">//timeout=-1表示无限等待</span></span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Epoll error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//&gt;0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (all_event[i].data.fd == serv_sock)</span><br><span class="line">            &#123;<span class="comment">//必定是有client申请接入</span></span><br><span class="line">                client_sock = <span class="built_in">accept</span>(serv_sock, (sockaddr*)&amp;clnt_addr, &amp;clnt_adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = client_sock;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, client_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client is connected!%d\n&quot;</span>, client_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//必定是客户端</span></span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="type">ssize_t</span> str_len = <span class="built_in">read</span>(all_event[i].data.fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="keyword">if</span> (str_len &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, all_event[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(all_event[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client is closed!%d\n&quot;</span>, client_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">write</span>(all_event[i].data.fd, buffer, str_len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] all_event;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client102</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clnt_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> message[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input message:(Q to quit)&quot;</span>);</span><br><span class="line">        <span class="built_in">fgets</span>(message, <span class="built_in">sizeof</span>(message), stdin);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(clnt_sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;From server:%s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson102</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">server102</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">client102</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s OVER!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson102</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="7-4-边缘触发和条件触发"><a href="#7-4-边缘触发和条件触发" class="headerlink" title="7.4 边缘触发和条件触发"></a>7.4 边缘触发和条件触发</h4><ul><li><p>条件触发【<code>level-triggered</code>，也被称为水平触发<code>LT</code>】: 只要满足条件，就触发一个事件【只要有数据没有被获取，内核就不断通知你】</p></li><li><p>边缘触发【<code>edge-triggered</code>，<code>ET</code>】：每当状态变化时，触发一个事件</p></li></ul><blockquote><p>举个读<code>socket</code>的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个通知应用程序可读。应用程序读了50个字节，然后重新调用<code>api</code>等待IO事件。</p><p>这时，水平触发的API会因为还有50个字节可读，从而立即返回用户一个<code>read ready notification</code>。</p><p>而边缘触发的API会因为可读这个状态没有发生变化而陷入长期等待。</p></blockquote><p>因此，需要注意的是：</p><ul><li>在使用边缘触发的API时，要注意每次都要读到<code>socket</code>返回<code>EWOULDBLOCK</code>为止，否则这个socket就算废了；</li><li>而使用条件触发的API 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个<code>write ready notification</code>。【写事件适合边缘触发，可写是默认状态，不可写才会触发事件】</li></ul><blockquote><p><code>select</code>属于典型的条件触发</p></blockquote><p><strong>条件触发案例：</strong></p><ul><li>修改缓冲区为5B</li><li>修改为边缘触发</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span><span class="comment">//errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server102</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, client_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//TCP</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Epoll</span></span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;<span class="comment">//Epoll文件描述符，事件数量标记</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">5</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>)) == <span class="number">-1</span>)<span class="comment">//必须&gt;0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Epoll error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(serv_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_event event;<span class="comment">//事件</span></span><br><span class="line">    epoll_event* all_event = <span class="keyword">new</span> epoll_event[<span class="number">100</span>]; <span class="comment">//创建100个空闲事件</span></span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;<span class="comment">//条件触发：有数据输入</span></span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);<span class="comment">//开启监听</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, all_event, <span class="number">100</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Epoll error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//&gt;0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (all_event[i].data.fd == serv_sock)</span><br><span class="line">            &#123;<span class="comment">//必定是有client申请接入</span></span><br><span class="line">                client_sock = <span class="built_in">accept</span>(serv_sock, (sockaddr*)&amp;clnt_addr, &amp;clnt_adr_sz);</span><br><span class="line">                event.events = EPOLLIN | EPOLLET;<span class="comment">//边缘触发</span></span><br><span class="line">                event.data.fd = client_sock;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//修改为非阻塞********************</span></span><br><span class="line">                <span class="type">int</span> flag = <span class="built_in">fcntl</span>(client_sock, F_GETFL, <span class="number">0</span>);<span class="comment">//获取文件标志位</span></span><br><span class="line">                <span class="built_in">fcntl</span>(client_sock, F_SETFL, flag | O_NONBLOCK);</span><br><span class="line">                <span class="comment">//********************************</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, client_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client is connected!%d\n&quot;</span>, client_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//一直读，读到出错为止</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                    <span class="type">ssize_t</span> str_len = <span class="built_in">read</span>(all_event[i].data.fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                    <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Epoll error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                        <span class="built_in">close</span>(all_event[i].data.fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (str_len == <span class="number">0</span>)<span class="comment">//此时客户端关闭</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, all_event[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(all_event[i].data.fd);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client is closed!%d\n&quot;</span>, client_sock);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s message \n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);<span class="comment">//5B读写一次</span></span><br><span class="line">                        <span class="built_in">write</span>(all_event[i].data.fd, buffer, str_len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] all_event;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client102</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clnt_sock, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error %d %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> message[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input message:(Q to quit)&quot;</span>);</span><br><span class="line">        <span class="built_in">fgets</span>(message, <span class="built_in">sizeof</span>(message), stdin);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(clnt_sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;From server:%s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lesson102</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">server102</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">client102</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s OVER!\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lesson102</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时的情况：</p><ul><li>如果客户端发送超过5B，此时服务器只读一次没读完，也没有继续读，就算客户端再次发消息写入，也不会触发服务器的读操作【解决：修改为非阻塞状态；且读到<code>EAGAIN</code>】</li><li>运行结果中需要注意的是，客户端发送消息次数和服务器端<code>epollwait</code>函数调用次数。客户端从请求连接到断开连接共发送5次数据，服务器端也相应产生5个事件。</li></ul><br><h4 id="7-5-Epoll为什么用红黑树不用哈希表？"><a href="#7-5-Epoll为什么用红黑树不用哈希表？" class="headerlink" title="7.5 Epoll为什么用红黑树不用哈希表？"></a>7.5 Epoll为什么用红黑树不用哈希表？</h4><blockquote><p>这问题让我受惊了，我都不知道Epoll使用红黑树实现的。</p></blockquote><p>1、红黑树容易缩容</p><p>红黑树容易缩容，在处理完大规模数据后能够很好的缩容。哈希表是不容易缩容的，如果某个时刻，有大量的网络请求通过哈希来记录，触发哈希表扩容，之后这个哈希表很难缩容回去，这也是为什么一些go程序oom的问题，都是go map太大了无法gc。</p><p>2、红黑树处理大规模数据效率高</p><p>红黑树是一种自平衡二叉查找树，它的查询、插入和删除操作的平均复杂度都是O(log n)。而哈希表的查询、插入和删除操作的平均复杂度是O(1)，在处理一些小规模的数据时，哈希表可能表现得更出色，但在处理大规模的数据时，红黑树更加高效稳定。</p><p>3、红黑树能同时支持文件描述符和事件的管理</p><p>在epoll中，红黑树能够同时支持文件描述符和事件的管理，可以快速地定位某个事件对应的文件描述符。而哈希表只能支持根据文件描述符快速查找对应的事件，而对于事件对应的文件描述符则无法快速定位，因此不符合epoll的需求。</p><h5 id="7-5-2-红黑树简介"><a href="#7-5-2-红黑树简介" class="headerlink" title="7.5.2 红黑树简介"></a>7.5.2 红黑树简介</h5><p>红黑树是一种<strong>特定类型的二叉树</strong>，它是在计算机科学中用来组织数据比如数字的块的一种结构。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。由于每一棵红黑树都是一颗二叉排序树，因此，在对红黑树进行查找时，可以采用运用于普通二叉排序树上的查找算法，在查找过程中不需要颜色信息。</p><p>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><ol><li>结点是红色或黑色。</li><li>根结点是黑色。</li><li>所有叶子都是黑色。（叶子是NIL结点）</li><li>每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li></ol><p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。是性质4导致路径上不能有两个连续的红色结点确保了这个结果。最短的可能路径都是黑色结点，最长的可能路径有交替的红色和黑色结点。因为根据性质5所有最长的路径都有相同数目的黑色结点，这就表明了没有路径能多于任何其他路径的两倍长。因为红黑树是一种特化的二叉查找树，所以红黑树上的只读操作与普通二叉查找树相同。</p><p>在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量（O(log n)）的颜色变更（这在实践中是非常快速的）并且不超过三次树旋转（对于插入是两次）。这允许插入和删除保持为 O(log n)次，但是它导致了非常复杂的操作。</p><h5 id="7-5-3-哈希表简介"><a href="#7-5-3-哈希表简介" class="headerlink" title="7.5.3 哈希表简介"></a>7.5.3 哈希表简介</h5><p>散列表（Hash table，也叫哈希表），<strong>是根据关键码值（Key value）而直接进行访问的数据结构</strong>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希（Hash）表，函数f(key)为哈希（Hash）函数。若关键字为<strong>k</strong>，则其值存放在<strong>f(k)**的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系</strong>f<strong>为散列函数，按这个思想建立的表为散列表。对不同的关键字可能得到同一散列地址，即</strong>k1≠k2<strong>，而</strong>f(k1)==f(k2)<strong>，这种现象称为</strong>冲突<strong>（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数</strong>f(k)**和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</p><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p><p>常用方法：</p><ol><li><strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key)中已经有值了，就往下一个找，直到H(key)中没有值了，就放进去。</li><li><strong>数字分析法</strong>：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</li><li><strong>平方取中法</strong>：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</li><li><strong>折叠法</strong>：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。</li><li><strong>随机数法</strong>：选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。</li><li><strong>除留余数法</strong>：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p，p≤m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。</li></ol><p><strong><em>延伸阅读1：红黑树与哈希的区别\</em></strong></p><ul><li>红黑树是有序的，哈希是无序的，可以根据是否需要排序来选择用哪个。</li><li>红黑树占用的内存小（仅需要为其存在的节点分配内存），而哈希事先应该分配足够的内存存储散列表，即便有些哈希槽可能弃用，可以根据内存限制情况选择用哪个。</li><li>红黑树查找和删除的时间复杂度都是O(log n)，哈希查找和删除的时间复杂度都是O(1)，但哈希并不一定就比红黑树快，因为哈希还有哈希函数耗时，还可能产生哈希冲突。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Moustache 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Moustache</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/" title="Linux快速入门">https://hammerzer.github.io/2024/04/13/Linux-Quick-Start/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%A1%86%E6%9E%B6/" rel="tag"><i class="fa fa-tag"></i> 操作系统与框架</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2024/03/22/Overview-of-modern-foundation-models-1/" rel="prev" title="动手学深度学习-现代基础模型概览一"><i class="fa fa-chevron-left"></i> 动手学深度学习-现代基础模型概览一</a></div><div class="post-nav-item"><a href="/2024/05/29/Linux-Quick-Start2/" rel="next" title="Linux快速入门-2">Linux快速入门-2 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CONTENT-OUTLINE"><span class="nav-number">1.</span> <span class="nav-text">CONTENT OUTLINE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%87%E3%80%81%E7%9B%AE%E5%BD%95"><span class="nav-number">2.</span> <span class="nav-text">〇、目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-Ubuntu%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">一 Ubuntu问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">1 安装虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 安装步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%85%B3%E4%BA%8EVMware%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 关于VMware的一些问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-%E8%A7%A3%E5%86%B3%E8%99%9A%E6%8B%9F%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E3%80%90%E5%85%B3%E4%BA%8EBIOS%E8%AE%BE%E7%BD%AE%E3%80%91"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">1.2.1 解决虚拟启动问题【关于BIOS设置】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-%E8%A7%A3%E5%86%B3%E8%99%9A%E6%8B%9F%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E3%80%90%E5%85%B3%E4%BA%8EBIOS%E8%AE%BE%E7%BD%AE%E5%B7%B2%E5%AE%8C%E6%88%90%E3%80%91"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">1.2.2 解决虚拟启动问题【关于BIOS设置已完成】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-%E7%9B%B8%E5%85%B3%E7%BB%84%E5%90%88%E9%94%AE"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">1.2.3 相关组合键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84VM%E6%97%A0%E6%B3%95%E5%AE%8C%E6%88%90%E5%AE%89%E8%A3%85VM-Tool%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">1.2.4 新版本的VM无法完成安装VM-Tool的解决办法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%B3%E4%BA%8EUbuntu%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">2 关于Ubuntu遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E5%A4%A7%E5%B0%8F%E8%B0%83%E6%95%B4"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 屏幕显示大小调整</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%88%9D%E5%A7%8Bsu%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 初始su密码错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-Ubuntu%E4%B8%8A%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 Ubuntu上修改主机名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-Ubuntu%E5%AE%89%E8%A3%85%E4%B8%80%E7%9B%B4%E5%8D%A1%E9%BB%91%E5%B1%8F"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.4 Ubuntu安装一直卡黑屏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E4%BF%AE%E6%94%B9%E6%9C%80%E4%BD%B3apt%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.5 修改最佳apt下载服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E9%94%99%E8%AF%AF%EF%BC%9A%E6%97%A0%E6%B3%95%E5%BE%97%E5%88%B0%E9%94%81"><span class="nav-number">3.2.6.</span> <span class="nav-text">2.6 错误：无法得到锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-Ubuntu%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E6%97%B6%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BAbase%E7%8E%AF%E5%A2%83"><span class="nav-number">3.2.7.</span> <span class="nav-text">2.7 Ubuntu打开终端时自动退出base环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-%E8%A7%A3%E5%8E%8B%E6%8F%90%E5%8F%96VMware-Tool%E6%97%B6%E6%8A%A5%E9%94%99"><span class="nav-number">3.2.8.</span> <span class="nav-text">2.8 解压提取VMware-Tool时报错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AE%B9%E5%88%B0Windows"><span class="nav-number">3.2.9.</span> <span class="nav-text">2.9 虚拟机内容到Windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%97%B6%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E6%BA%90"><span class="nav-number">3.2.10.</span> <span class="nav-text">2.10 安装软件包时无法找到源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-Ubuntu%E5%90%AF%E5%8A%A8%E5%8D%A1%E4%BD%8F"><span class="nav-number">3.2.11.</span> <span class="nav-text">2.11 Ubuntu启动卡住</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-12-Ubuntu%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.12.</span> <span class="nav-text">2.12 Ubuntu版本问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-13-Ubuntu%E8%8E%B7%E5%8F%96ip"><span class="nav-number">3.2.13.</span> <span class="nav-text">2.13 Ubuntu获取ip</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Ubuntu-%E5%88%86%E5%8C%BA%E5%8F%B7Sda%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-number">3.3.</span> <span class="nav-text">3 Ubuntu 分区号Sda的解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Ubuntu%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">3.4.</span> <span class="nav-text">4 Ubuntu快捷键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.1 操作系统快捷键和命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Vim-%E5%91%BD%E4%BB%A4%E5%92%8C%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.2 Vim 命令和快捷键</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-Vim-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">4.2.1 Vim 的三种模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-Vim-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">4.2.2 Vim 的基本操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-Vim-%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">4.2.3 Vim 的高级功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-4-Vim-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">4.2.4 Vim 的实际应用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-5-Vim-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">4.2.5 Vim 使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%80%9A%E7%94%A8%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4"><span class="nav-number">3.5.</span> <span class="nav-text">5 通用终端命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-Linux%E7%AE%80%E4%BB%8B"><span class="nav-number">4.</span> <span class="nav-text">二 Linux简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.1.</span> <span class="nav-text">1 系统介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.</span> <span class="nav-text">2 基本命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-ls%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.1 ls命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">-a：列出所有的文件或者文件夹</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#l%EF%BC%9A%E5%88%97%E5%87%BA%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">-l：列出详细信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#h%EF%BC%9A%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">-h：增加可读性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#R%EF%BC%9A%E9%80%92%E5%BD%92%E8%AE%BF%E9%97%AE"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">-R：递归访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q%EF%BC%9A%E6%96%87%E4%BB%B6%E5%90%8D%E7%94%A8%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%8C%85%E8%A3%B9"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">-Q：文件名用双引号包裹</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#t%EF%BC%9A%E6%8C%89%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.1.6.</span> <span class="nav-text">-t：按时间排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-echo%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2 echo命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-cd%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.3.</span> <span class="nav-text">2.3 cd命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-head%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.4.</span> <span class="nav-text">2.4 head命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-tail%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.5.</span> <span class="nav-text">2.5 tail命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-ps%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.6.</span> <span class="nav-text">2.6 ps命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-cp%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.7.</span> <span class="nav-text">2.7 cp命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-rm%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.8.</span> <span class="nav-text">2.8 rm命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-chmod%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.9.</span> <span class="nav-text">2.9 chmod命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.2.9.1.</span> <span class="nav-text">2.9.1 基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-%E7%AC%A6%E5%8F%B7%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.9.2.</span> <span class="nav-text">2.9.2 符号模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-3-%E5%85%AB%E8%BF%9B%E5%88%B6%E8%AF%AD%E6%B3%95"><span class="nav-number">4.2.9.3.</span> <span class="nav-text">2.9.3 八进制语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-4-%E6%8E%A5%E5%9B%9B%E4%BD%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">4.2.9.4.</span> <span class="nav-text">2.9.4 接四位数字的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-5-%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.2.9.5.</span> <span class="nav-text">2.9.5 权限修改示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-chown"><span class="nav-number">4.2.10.</span> <span class="nav-text">2.10 chown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%E3%80%90%F0%9F%94%BA%E3%80%91"><span class="nav-number">4.2.11.</span> <span class="nav-text">2.11 其他命令【🔺】</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E3%80%90%F0%9F%94%BA%E3%80%91"><span class="nav-number">4.3.</span> <span class="nav-text">3 常见错误【🔺】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E9%95%9C%E5%83%8F%E6%BA%90%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1 镜像源问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Systemd%E4%B8%8Eservice"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2 Systemd与service</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-VS%E4%B8%AD%E7%AA%81%E5%8F%91%E7%9A%84%E6%9C%AA%E7%9F%A5%E9%94%99%E8%AF%AF"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3 VS中突发的未知错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-Linux%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8"><span class="nav-number">5.</span> <span class="nav-text">三 Linux开发入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">5.1.</span> <span class="nav-text">1 开发环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-gcc%E5%AE%89%E8%A3%85"><span class="nav-number">5.1.1.</span> <span class="nav-text">1.1 gcc安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-ssh%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">5.1.2.</span> <span class="nav-text">1.2 ssh服务的安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.3.</span> <span class="nav-text">1.3 相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-gcc%E5%AE%89%E8%A3%85%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">1.3.1 gcc安装时出现的锁问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-gcc%E5%AE%89%E8%A3%85%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85%E5%80%99%E9%80%89"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">1.3.2 gcc安装时出现的没有安装候选</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-VS2022%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%9A%E4%B8%BB%E6%9C%BA%E5%90%8D%E4%B8%8E%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">1.3.2 VS2022连接远程Linux服务器报错：主机名与端口不存在</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BALinux%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%A1%B9%E7%9B%AE"><span class="nav-number">5.2.</span> <span class="nav-text">2 创建Linux控制台项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Linux%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">3 Linux标准库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.1 字符串函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.2 数据转换函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.3.</span> <span class="nav-text">3.3 格式化输入输出函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%B8%B8%E7%94%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">3.3.1 常用输入输出函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-printf%E5%87%BD%E6%95%B0format%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">3.3.2 printf函数format详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-scanf%E5%87%BD%E6%95%B0format%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">3.3.3 scanf函数format详解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.4.</span> <span class="nav-text">3.4 权限控制函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-Linux%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">3.4.1 Linux权限说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-Linux%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">3.4.2 Linux权限控制函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-I-O%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.5.</span> <span class="nav-text">3.5 I&#x2F;O函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-1-open-create%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">3.5.1 open&#x2F;create函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">3.5.2 文件操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-3-%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">3.5.3 其他文件操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-4-%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="nav-number">5.3.5.4.</span> <span class="nav-text">3.5.4 文件控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-5-%E7%BB%83%E4%B9%A0"><span class="nav-number">5.3.5.5.</span> <span class="nav-text">3.5.5 练习</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.6.</span> <span class="nav-text">3.6 进程控制函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-1-%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">5.3.6.1.</span> <span class="nav-text">3.6.1 执行文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-2-%E5%BB%BA%E7%AB%8B%E6%96%B0%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.6.2.</span> <span class="nav-text">3.6.2 建立新进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-3-%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.6.3.</span> <span class="nav-text">3.6.3 结束进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-4-%E6%94%B9%E5%8F%98%E8%BF%9B%E7%A8%8B%E6%B5%81%E7%A8%8B%E3%80%90%E6%81%A2%E5%A4%8D%E8%BF%9B%E7%A8%8B%E3%80%91"><span class="nav-number">5.3.6.4.</span> <span class="nav-text">3.6.4 改变进程流程【恢复进程】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-Wait%E7%AD%89%E5%BE%85"><span class="nav-number">5.3.6.5.</span> <span class="nav-text">3.6.5 Wait等待</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.7.</span> <span class="nav-text">3.7 文件和目录函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-1-%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.7.1.</span> <span class="nav-text">3.7.1 文件指针操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-2-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.7.2.</span> <span class="nav-text">3.7.2 文件内容操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-3-%E6%96%87%E4%BB%B6%E5%86%85%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.7.3.</span> <span class="nav-text">3.7.3 文件内指针操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-4-%E6%96%87%E4%BB%B6%E6%B5%81%E6%A0%87%E5%BF%97"><span class="nav-number">5.3.7.4.</span> <span class="nav-text">3.7.4 文件流标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-5-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.7.5.</span> <span class="nav-text">3.7.5 目录操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">5.4.</span> <span class="nav-text">4 网络编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.4.1.</span> <span class="nav-text">4.1 网络的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-%E7%BD%91%E7%BB%9C%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">4.1.1 网络的物理结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-2-%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80-IP"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">4.1.2 网络中的地址(IP)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-3-%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">4.1.3 网络中的端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-number">5.4.1.4.</span> <span class="nav-text">4.1.4 什么是协议？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-5-TCP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="nav-number">5.4.1.5.</span> <span class="nav-text">4.1.5 TCP协议基础</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">5.4.2.</span> <span class="nav-text">4.2 套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">4.2.1 什么是套接字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%90socket%E5%87%BD%E6%95%B0%E3%80%91"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">4.2.2 套接字的创建【socket函数】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BB%91%E5%AE%9A%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E3%80%90bind%E5%87%BD%E6%95%B0%E3%80%91"><span class="nav-number">5.4.2.3.</span> <span class="nav-text">4.2.3 套接字绑定地址和端口【bind函数】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-4-listen%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.4.</span> <span class="nav-text">4.2.4 listen函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-5-accept%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.5.</span> <span class="nav-text">4.2.5 accept函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-TCP%E7%BC%96%E7%A8%8B"><span class="nav-number">5.4.3.</span> <span class="nav-text">4.3 TCP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1-TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">4.3.1 TCP&#x2F;IP协议栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">4.3.2 TCP服务端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-3-connect%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.3.3.</span> <span class="nav-text">4.3.3 connect函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">5.4.3.4.</span> <span class="nav-text">4.3.4 TCP客户端</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">5.4.4.</span> <span class="nav-text">4.4 实现迭代服务器&#x2F;客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-%E8%BF%AD%E4%BB%A3%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.4.4.1.</span> <span class="nav-text">4.4.1 迭代服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.4.2.</span> <span class="nav-text">4.4.2 回声服务器实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.4.4.3.</span> <span class="nav-text">4.4.3 回声服务器存在的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-4-%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.4.4.</span> <span class="nav-text">4.4.4 回声服务器实战：计算器的网络实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-TCP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">5.4.5.</span> <span class="nav-text">4.5 TCP底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-1-TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84I-O%E7%BC%93%E5%86%B2"><span class="nav-number">5.4.5.1.</span> <span class="nav-text">4.5.1 TCP套接字的I&#x2F;O缓冲</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-2-TCP%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="nav-number">5.4.5.2.</span> <span class="nav-text">4.5.2 TCP的内部原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">5.4.5.3.</span> <span class="nav-text">4.5.3 TCP三次握手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-4-TCP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">5.4.5.4.</span> <span class="nav-text">4.5.4 TCP数据传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-5-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.4.5.5.</span> <span class="nav-text">4.5.5 TCP四次挥手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-6-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">5.4.5.6.</span> <span class="nav-text">4.5.6 TCP如何保证可靠传输</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-UDP%E7%BC%96%E7%A8%8B"><span class="nav-number">5.4.6.</span> <span class="nav-text">4.6 UDP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-1-UDP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">5.4.6.1.</span> <span class="nav-text">4.6.1 UDP基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-2-UDP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">5.4.6.2.</span> <span class="nav-text">4.6.2 UDP服务端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-3-UDP%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.4.6.3.</span> <span class="nav-text">4.6.3 UDP回声服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-4-UDP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">5.4.6.4.</span> <span class="nav-text">4.6.4 UDP客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-5-UDP%E7%9A%84%E4%BC%A0%E8%BE%93%E7%89%B9%E6%80%A7%E5%92%8C%E8%B0%83%E7%94%A8"><span class="nav-number">5.4.6.5.</span> <span class="nav-text">4.6.5 UDP的传输特性和调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9"><span class="nav-number">5.4.7.</span> <span class="nav-text">4.7 套接字的多种可选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-1-I-O%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F"><span class="nav-number">5.4.7.1.</span> <span class="nav-text">4.7.1 I&#x2F;O缓冲大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-2-SO-SNDBUF-amp-SO-RCVBUF"><span class="nav-number">5.4.7.2.</span> <span class="nav-text">4.7.2 SO_SNDBUF &amp;SO_RCVBUF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-3-SO-REUSEADDR"><span class="nav-number">5.4.7.3.</span> <span class="nav-text">4.7.3 SO_REUSEADDR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-4-TCP-NODELAY"><span class="nav-number">5.4.7.4.</span> <span class="nav-text">4.7.4 TCP_NODELAY</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-Questions"><span class="nav-number">5.4.8.</span> <span class="nav-text">4.8 Questions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5 linux系统编程：进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.1 进程的概念以及应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">5.1.1 服务端类型和并发服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-2-%E6%A6%82%E5%BF%B5"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">5.1.2 概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-3-%E9%80%9A%E8%BF%87fork-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.5.1.3.</span> <span class="nav-text">5.1.3 通过fork 函数创建进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.2 进程和僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-number">5.5.3.</span> <span class="nav-text">5.3 信号处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86signal"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">5.3.1 信号处理signal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-Sigaction%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">5.3.2 Sigaction函数进行信号处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E6%B6%88%E7%81%AD%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.5.3.3.</span> <span class="nav-text">5.3.3 示例：利用信号处理技术消灭僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E5%9F%BA%E4%BA%8E%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.5.4.</span> <span class="nav-text">5.4 基于多任务的并发服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">5.5.5.</span> <span class="nav-text">5.5 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A%E7%AE%A1%E9%81%93"><span class="nav-number">5.5.5.1.</span> <span class="nav-text">5.5.1 进程间通信：管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9AFIFO"><span class="nav-number">5.5.5.2.</span> <span class="nav-text">5.5.2 进程间通信：FIFO</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">5.5.5.3.</span> <span class="nav-text">5.5.3 进程间通信：共享内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">5.5.5.4.</span> <span class="nav-text">5.5.4 进程间通信：信号量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.5.5.5.</span> <span class="nav-text">5.5.5 进程间通信：消息队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-6-socket%E9%80%9A%E4%BF%A1"><span class="nav-number">5.5.5.6.</span> <span class="nav-text">5.5.6 socket通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.6.</span> <span class="nav-text">6 linux系统编程：线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.6.1.</span> <span class="nav-text">6.1 理解线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="nav-number">5.6.2.</span> <span class="nav-text">6.2 线程的创建与运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">5.6.3.</span> <span class="nav-text">6.3 线程同步：互斥量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">5.6.4.</span> <span class="nav-text">6.4 线程同步：信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-number">5.6.5.</span> <span class="nav-text">6.5 线程的销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.6.6.</span> <span class="nav-text">6.6 实战案例：多线程并发服务器的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-I-O%E5%A4%8D%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">7 I&#x2F;O复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-Select%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="nav-number">5.7.1.</span> <span class="nav-text">7.1 Select模型以及实战案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-Epoll%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.7.2.</span> <span class="nav-text">7.2 Epoll模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-Epoll%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="nav-number">5.7.3.</span> <span class="nav-text">7.3 Epoll实战案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="nav-number">5.7.4.</span> <span class="nav-text">7.4 边缘触发和条件触发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-Epoll%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="nav-number">5.7.5.</span> <span class="nav-text">7.5 Epoll为什么用红黑树不用哈希表？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-2-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="nav-number">5.7.5.1.</span> <span class="nav-text">7.5.2 红黑树简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">5.7.5.2.</span> <span class="nav-text">7.5.3 哈希表简介</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Moustache" src="/images/180-180.png"><p class="site-author-name" itemprop="name">Moustache</p><div class="site-description" itemprop="description">我是小胡子</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">79</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/hammerzer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hammerzer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:stellar_lzu@163.com" title="E-Mail → mailto:stellar_lzu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Chase</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">1.9m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">29:30</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script size="300" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JRehDoQ6pHXV1zKg09AMNLFt-gzGzoHsz',
      appKey     : 'cRAt4W15KiQdrIuHlQrRrtIl',
      placeholder: "Just go go",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>