<!DOCTYPE html><html lang="zh-CN"><head><script src="https://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/180-180.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/32-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/16-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hammerzer.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="ONTENT OUTLINE 这是来自别人的一段笔记，关于 React-Hooks  Hooks + TS 搭建一个任务管理系统"><meta property="og:type" content="article"><meta property="og:title" content="React-Hooks"><meta property="og:url" content="https://hammerzer.github.io/2024/01/05/React-Hooks/index.html"><meta property="og:site_name" content="Moustache&#39;s Blog"><meta property="og:description" content="ONTENT OUTLINE 这是来自别人的一段笔记，关于 React-Hooks  Hooks + TS 搭建一个任务管理系统"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/hook-ts-jira-1.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211006203414683.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211006224843631.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211006233238264.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007003107927.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007144245611.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007172612517.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007172656899.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-create.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008140324136.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008170502500.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008172232127.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-search.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008211259106.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008212554826.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-search-keep.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-search1.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-router-jump.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-router-title.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-kanban-show.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211010135726728.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211010140655996.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211010140908606.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-epic-show.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211012154536792.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211012160029127.png"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-epic-router.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-kanban-drag.gif"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210924105645394.png"><meta property="og:image" content="https://img.shields.io/badge/GitHub-ff79c6"><meta property="og:image" content="https://img.shields.io/badge/weChat-Ljc--10c-blue"><meta property="og:image" content="https://img.shields.io/badge/juejin-brightgreen"><meta property="og:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/reactjs.jpg"><meta property="article:published_time" content="2024-01-05T07:52:54.000Z"><meta property="article:modified_time" content="2025-01-19T03:19:15.900Z"><meta property="article:author" content="Moustache"><meta property="article:tag" content="框架与工具"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/hook-ts-jira-1.png"><link rel="canonical" href="https://hammerzer.github.io/2024/01/05/React-Hooks/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>React-Hooks | Moustache's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Moustache's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Moustache's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">小胡子的私人空间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">36</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">79</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hammerzer.github.io/2024/01/05/React-Hooks/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/180-180.png"><meta itemprop="name" content="Moustache"><meta itemprop="description" content="我是小胡子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Moustache's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React-Hooks</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-05 15:52:54" itemprop="dateCreated datePublished" datetime="2024-01-05T15:52:54+08:00">2024-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-19 11:19:15" itemprop="dateModified" datetime="2025-01-19T11:19:15+08:00">2025-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-End/" itemprop="url" rel="index"><span itemprop="name">Front End</span></a> </span></span><span id="/2024/01/05/React-Hooks/" class="post-meta-item leancloud_visitors" data-flag-title="React-Hooks" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> <span>℃</span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2024/01/05/React-Hooks/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2024/01/05/React-Hooks/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>60k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>54 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="ONTENT-OUTLINE"><a href="#ONTENT-OUTLINE" class="headerlink" title="ONTENT OUTLINE"></a>ONTENT OUTLINE</h2><blockquote><p>这是来自别人的一段笔记，关于 React-Hooks</p></blockquote><p>Hooks + TS 搭建一个任务管理系统</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/hook-ts-jira-1.png" alt="hook-ts-jira-1"></p><span id="more"></span><h2 id="一-登录注册页面"><a href="#一-登录注册页面" class="headerlink" title="一 登录注册页面"></a>一 登录注册页面</h2><h3 id="💌-前言"><a href="#💌-前言" class="headerlink" title="💌 前言"></a>💌 前言</h3><p>这篇文章是这个专栏中的第一篇文章，因此就写点前言吧~，简单的介绍一下吧</p><p>最近刚学完 React 的一些基本内容，教学视频已经看完了，然后也学习了一下 TS 这门强类型的语言，对前端开发简直就是利器。同时也了解了一下 Hooks 的一些内容，但是对这部分掌握的不是很好，因此跟着视频利用 <code>Hooks + TS4 + Router6</code>做了一个任务管理系统练练手。在做这个 hooks 的项目之前，也有跟着做过一个基于 <code>React 16.4 版本 + Redux</code> 实现的简书博客平台，对 <code>Redux</code> 也有一定的了解。</p><p>扯这么多，来说说这个项目吧！</p><blockquote><p>这个项目是跟着视频做的并不是完全由我创新的 😥，因此<strong>如果文章有侵权行为的话，麻烦联系一下删除</strong>（应该不会吧，毕竟文章是我自己写的）</p></blockquote><p>这个项目采用的技术栈是 <code>React Hooks + TS4</code></p><p>主要实现的功能有 ：用户登录注册，项目列表的展示，项目的 CRUD，项目详情展示，看板及任务组管理…</p><p>接下来的系列更文，将会围绕实现这些功能，以及在项目中遇到的难题，提出一些问题和解决方案。</p><p>强迫自己开启这个专栏是想要更加深入的理解，自己写的代码是什么意思，能够如何优化，了解更多代码上的细节，而不是跟着老师敲完代码就算了…，因此这个专栏会尽我所能将知识点囊括齐全！</p><p>高能预警：本项目采用了很多的 <code>custom hook</code> ，真的非常不错</p><p>下面开始今天的主题，实现登录注册页面</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211006203414683.png" alt="image-20211006203414683"></p><h3 id="1-用状态驱动页面更新"><a href="#1-用状态驱动页面更新" class="headerlink" title="1 用状态驱动页面更新"></a>1 用状态驱动页面更新</h3><p>为什么第一个要讲“用状态驱动页面更新”呢？</p><p>我们需要通过当前的<strong>登录状态</strong>，来展示不一样的页面。通过状态来做很多的事情…</p><p>首先我们需要通过 <code>useState</code> ，来创建两个状态，一个是 <code>isRegister</code> 用来标识是展示登录界面还是注册界面，当 <code>isRegister</code> 为 <code>true</code> 时展示注册页面</p><p>第二个状态是<strong>错误状态</strong>，用来接收登录页面的错误信息，当有错误发生时，都会丢到这个变量当中</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识当前是注册还是登录，false 表示当前是登录状态</span></span><br><span class="line"><span class="keyword">const</span> [isRegister, setIsRegister] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> [error, setError] = useState&lt;<span class="title class_">Error</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>在上面的两行代码中，值得注意的是，通过 <code>useState</code> 创建的变量类型默认会是<strong>初始化</strong>时的类型</p><p>也就是说 <code>isRegister</code> 的类型会因为我们初始化时传的 <code>false</code> 变成 <code>boolean</code> 类型</p><p>而对于 <code>error</code> 而已，在不加泛型的情况下，它默认会是 <code>null</code> 类型，因此，在后面对它赋值 <code>Error</code> 对象类型时，会发生错误，因此在这里我们需要定义泛型 <code>Error | null</code> 这样 <code>error</code> 就能接收 <code>Error</code> 类型了~</p><p>现在我们的状态设置好了，接下来看看如何驱动页面更新呢，那一个例子讲讲</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Button</span> <span class="keyword">type</span>=&#123;<span class="string">&#x27;link&#x27;</span>&#125; onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">setIsRegister</span>(!isRegister)&#125;&gt;&#123;isRegister ? <span class="string">&#x27;已经有账号了？直接登录&#x27;</span> : <span class="string">&#x27;没有账号？注册新账号&#x27;</span>&#125;&lt;/<span class="title class_">Button</span>&gt;</span><br></pre></td></tr></table></figure><p>这个是登录和注册切换的按钮，当点击这个按钮时，会触发 <code>setIsRegister</code> 改变 <code>isRegister</code> 的值，我们通过这个值的 <code>true or false</code> 来判断展示的内容</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* 判断展示登录页面还是注册页面 */</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">    isRegister ? <span class="language-xml"><span class="tag">&lt;<span class="name">RegisterScreen</span> <span class="attr">onError</span>=<span class="string">&#123;setError&#125;</span> /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">LoginScreen</span> <span class="attr">onError</span>=<span class="string">&#123;setError&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当为 <code>true</code> 的时候展示注册页面，在这里我们将两个页面抽象出了两个组件，将逻辑分开来，我们通过 <code>props</code> 向这两个组件传递了 <code>onError</code> 方法，在组件中可以通过调用这个方法来设置 <code>error</code> 状态的值，再展示到页面上</p><p>在这里值得我们注意的是，和类式组件不同，函数式组件会默认的接收 <code>props</code> 参数，因此我们不需要显式的去使用 <code>props</code> 我们可以直接在参数列表中<strong>解构</strong>出来，这样我们整个项目开发完成都不会见到一个 <code>props</code></p><h3 id="2-通过-Antd-布局页面"><a href="#2-通过-Antd-布局页面" class="headerlink" title="2 通过 Antd 布局页面"></a>2 通过 Antd 布局页面</h3><p>关于布局方面采用的是 <code>flex</code> 布局，主要是通过 Antd 组件来实现的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ShadowCard</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            isRegister ? &#x27;请注册&#x27; : &quot;请登录&quot;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBox</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span></span></span><br><span class="line">    &#123;<span class="comment">/* 判断展示登录页面还是注册页面 */</span>&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        isRegister ? <span class="language-xml"><span class="tag">&lt;<span class="name">RegisterScreen</span> <span class="attr">onError</span>=<span class="string">&#123;setError&#125;</span> /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">LoginScreen</span> <span class="attr">onError</span>=<span class="string">&#123;setError&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="title class_">Divider</span> /&gt;</span><br><span class="line">    &#123;<span class="comment">/* 点击切换状态 */</span>&#125;</span><br><span class="line">    &lt;<span class="title class_">Button</span> <span class="keyword">type</span>=&#123;<span class="string">&#x27;link&#x27;</span>&#125; onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">setIsRegister</span>(!isRegister)&#125;&gt;&#123;isRegister ? <span class="string">&#x27;已经有账号了？直接登录&#x27;</span> : <span class="string">&#x27;没有账号？注册新账号&#x27;</span>&#125;&lt;/<span class="title class_">Button</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">ShadowCard</span>&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>ShadowCard</code> 其实是对 <code>Antd</code> 中的 <code>Card</code> 组件进行了<strong>加工</strong>，让它有了一些<strong>阴影</strong>，同时对它进行了一定的布局</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件加样式，给Card组件更改样式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ShadowCard</span> = <span class="title function_">styled</span>(<span class="title class_">Card</span>)<span class="string">`</span></span><br><span class="line"><span class="string">    width: 40rem;</span></span><br><span class="line"><span class="string">    min-height: 56rem;</span></span><br><span class="line"><span class="string">    padding: 3.2rem 4rem;</span></span><br><span class="line"><span class="string">    box-shadow: rgba(0,0,0,0.1) 0 0 10px;</span></span><br><span class="line"><span class="string">    text-align: center;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>在 <code>emotion</code> 中，想要个 Antd 组件添加样式，我们只需要用 <code>styled(组件名)</code> 即可</p><p>对于登录和注册页面，采用的是 Antd 中的 <code>Form</code> 表单实现的，在控制好盒子大小后，基本不需要过多的布局</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Form</span> onFinish=&#123;handleSubmit&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">username</span>&#x27;&#125; <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请输入用户名</span>&#x27; &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&quot;<span class="attr">用户名</span>&quot;&#125; <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&quot;<span class="attr">username</span>&quot;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">password</span>&#x27;&#125; <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请输入密码</span>&#x27; &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&quot;<span class="attr">密码</span>&quot;&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&quot;<span class="attr">password</span>&quot;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">LongButton</span> <span class="attr">loading</span>=<span class="string">&#123;isLoading&#125;</span> <span class="attr">htmlType</span>=<span class="string">&#123;</span>&quot;<span class="attr">submit</span>&quot;&#125; <span class="attr">type</span>=<span class="string">&#123;</span>&quot;<span class="attr">primary</span>&quot;&#125;&gt;</span>登录<span class="tag">&lt;/<span class="name">LongButton</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Form</span>&gt;</span><br></pre></td></tr></table></figure><p>对于登录注册的关键就是，<strong>通过前台认证之后，发送请求开启认证即可</strong>，关键就在于这个认证如何实现，当然如果只是简单的发请求是非常简单的，但是往后想想，我们会有<strong>很多个请求</strong>，如果我们每次都写一遍那串代码，那代码的冗余程度可想而知。</p><p>因此我们想在这里抽象出两个 <code>custom hook</code> ，<strong>一个用来获取数据，一个用来处理异步请求</strong>，写这两个之前，我们先写一个专门用来发送请求的文件，我们将我们关于登录注册的请求全部写在这个文件当中，再暴露出去，这样代码看起来思路更加清晰</p><h3 id="3-编写-auth-provider-文件"><a href="#3-编写-auth-provider-文件" class="headerlink" title="3 编写 auth-provider 文件"></a>3 编写 auth-provider 文件</h3><p>我们在这个文件中来处理我们需要发送的相关请求，首先，由于我们需要实现刷新后仍保持登录状态的效果，我们需要设置 <code>token</code> ，并且对于 <code>token</code> 数据我们是放在本地存储当中的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存本地存储中的 token 键</span></span><br><span class="line"><span class="keyword">const</span> localStorageKey = <span class="string">&quot;__auth_provider_token__&quot;</span>;</span><br><span class="line"><span class="comment">// 获取 token 的值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getToken</span> = (<span class="params"></span>) =&gt; <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(localStorageKey);</span><br></pre></td></tr></table></figure><p>通过封装一个函数用来获取我们本地的 <code>token</code> 值</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">handleUserResponse</span> = (<span class="params">&#123; user &#125;: &#123; user: User &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(localStorageKey, user.<span class="property">token</span> || <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> user; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这个函数来设置本地 <code>token</code> ，在登录注册后调用</p><p><strong>处理登录请求</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params"><span class="attr">data</span>: &#123; username: <span class="built_in">string</span>; password: <span class="built_in">string</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/login`</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="title function_">async</span> (response) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleUserResponse</span>(<span class="keyword">await</span> response.<span class="title function_">json</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">await</span> response.<span class="title function_">json</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在其他文件中调用这个 <code>login</code> 时就会返回这个 <code>fetch</code> 能够发送登录的请求，当成功返回结果时，就会调用前面的函数来设置一个本地的 <code>token</code> 值，用来保存用户的登录状态</p><p>这里有个比较重要的点：由于我们的请求都是异步的因此我们在 <code>then</code> 中需要采用 <code>async await</code> 的方式，优雅的解决这个由于异步造成的 undefined 的问题，对于其他注册和登出的请求也是如此</p><p>在编写好几个请求函数之后，我们需要编写一个 <code>useAsync</code> 函数用来专门处理异步请求</p><h3 id="4-编写-useAsync-发送异步请求"><a href="#4-编写-useAsync-发送异步请求" class="headerlink" title="4 编写 useAsync 发送异步请求"></a>4 编写 useAsync 发送异步请求</h3><p>我们已经能够发送请求获取<strong>登录信息</strong>了，为什么我们还需要再编写一个这样的 <code>custom hook</code> 呢？</p><p>首先，我们在上面确实是能够满足我们最基本的业务需求了，我们编写这个 <code>custom hook</code> 能够帮我们将这个异步函数给具体化，什么是具体化呢？</p><p>我们先来看看这个 <code>custom hook</code> 返回的结果</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 请求状态</span></span><br><span class="line">    <span class="attr">isIdle</span>: state.<span class="property">stat</span> === <span class="string">&#x27;idle&#x27;</span>, </span><br><span class="line">    <span class="attr">isLoading</span>: state.<span class="property">stat</span> === <span class="string">&#x27;loading&#x27;</span>,</span><br><span class="line">    <span class="attr">isError</span>: state.<span class="property">stat</span> === <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="attr">isSuccess</span>: state.<span class="property">stat</span> === <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">    <span class="comment">// run 接收一个promise 对象，返回执行结果</span></span><br><span class="line">    run,</span><br><span class="line">    setData,</span><br><span class="line">    setError,</span><br><span class="line">    <span class="comment">// retry 被调用重新执行 run，让state 更新</span></span><br><span class="line">    retry,</span><br><span class="line">    ...state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这些返回的结果，相信已经有了一定的想法，我们可以通过这个 <code>hook</code> 来直视到<strong>异步函数的执行过程</strong>，而且又能将过程<strong>抽象</strong>在这个 hook 当中，在外部，我们只需要 <code>run</code> 一下，就能得到结果，这不正是我们想要的吗？</p><p>我们<strong>不想关注异步的细节</strong>，什么 <code>then</code> 啊，<code>async</code> 啊，这些我们都不想关心，我们想要的是，<strong>执行后的结果</strong>，因此这个 hook 需要帮我们解决这些问题！这在优化我们代码中起着非常重要的作用</p><p>对于这个 hook 的实现，比较复杂，类型复杂，</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span>&lt;D&gt; &#123;</span><br><span class="line">    <span class="attr">error</span>: <span class="title class_">Error</span> | <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回的数据</span></span><br><span class="line">    <span class="attr">data</span>: D | <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 请求过程状态</span></span><br><span class="line">    <span class="attr">stat</span>: <span class="string">&#x27;idle&#x27;</span> | <span class="string">&#x27;loading&#x27;</span> | <span class="string">&#x27;error&#x27;</span> | <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义<strong>初始化状态的接口</strong></p><p>初始化我们的初始状态</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">defaultInitialState</span>: <span class="title class_">State</span>&lt;<span class="literal">null</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">stat</span>: <span class="string">&#x27;idle&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">error</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先写一个 hook 来帮我们判断组件<strong>是否卸载</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用这个dispatch 会帮我们判断 mountedRef 组件是否被卸载</span></span><br><span class="line"><span class="keyword">const</span> useSafeDispatch = &lt;T&gt;<span class="function">(<span class="params"><span class="attr">dispatch</span>: (...args: T[]) =&gt; <span class="built_in">void</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mountedRef = <span class="title function_">useMountedRef</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useCallback</span>(<span class="function">(<span class="params">...<span class="attr">args</span>: T[]</span>) =&gt;</span> (mountedRef.<span class="property">current</span> ? <span class="title function_">dispatch</span>(...args) : <span class="built_in">void</span> <span class="number">0</span>), [dispatch, mountedRef])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用这个 hook 时，将会接收到当前组件的状态，当组件被卸载后，我们就不需要再将数据返回了，如果返回的话，就会造成数据无法渲染的情况从而报错，因此，我们编写这个 hook 也是出于这样的考虑</p><p>我们通过监听 <code>safeDispatch</code> 的变化来该判断当前的状态，同时我们可以通过 <code>setData</code> 来传递返回的数据，再通过 <code>safeDispatch</code> 来发送 <code>dispatch</code> 设置响应</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> safeDispatch = <span class="title function_">useSafeDispatch</span>(dispatch)</span><br><span class="line"><span class="comment">// 正常响应时的数据处理</span></span><br><span class="line"><span class="keyword">const</span> setData = <span class="title function_">useCallback</span>(<span class="function">(<span class="params"><span class="attr">data</span>: D</span>) =&gt;</span> <span class="title function_">safeDispatch</span>(&#123;</span><br><span class="line">    data,</span><br><span class="line">    <span class="attr">stat</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">    <span class="attr">error</span>: <span class="literal">null</span></span><br><span class="line">&#125;), [safeDispatch])</span><br><span class="line"><span class="comment">// 发生错误时的错误处理</span></span><br><span class="line"><span class="keyword">const</span> setError = <span class="title function_">useCallback</span>(<span class="function">(<span class="params"><span class="attr">error</span>: <span class="title class_">Error</span></span>) =&gt;</span> <span class="title function_">safeDispatch</span>(&#123;</span><br><span class="line">    error,</span><br><span class="line">    <span class="attr">stat</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">&#125;), [safeDispatch])</span><br></pre></td></tr></table></figure><p>当然还有一些其他的状态也需要这样编写，基本一致</p><p>在这里我们开始编写我们的 <code>run</code> 函数，这个函数是主入口，<strong>用于触发异步请求</strong>，首先从我们的调用上来看 <code>run(login(values))</code> 我们只想传递一个 <code>promise</code> 对象就能获得所有的结果，</p><p>首先我们需要先判断一下，传入的对象是不是 <code>promise</code> 对象，如果不是则直接抛出错误</p><p>当进入 <code>run</code> 函数后，我们需要将 <code>stat</code> 状态置为 <code>loading</code> 状态，这样我们可以通过这个值来实现请求 loading 的效果，</p><p>最后我们返回一个 <code>promise</code> 对象的执行结果，在这个返回当中有很多值得探讨的地方</p><p>为了获取到传入的 <code>promise</code> 对象<strong>抛出的错误</strong>，我需要使用 <code>then</code> 中的第二个参数来接收这 <strong>错误对象</strong>，再返回这个错误，才能使用 <code>catch</code> 获取，正常情况下，<code>catch</code> 获取不到这个错误</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run是主入口，触发异步请求</span></span><br><span class="line"><span class="comment">// 采用useCallback,只有依赖中的数据发生变化的时候，run才会被重新定义</span></span><br><span class="line"><span class="keyword">const</span> run = <span class="title function_">useCallback</span>(<span class="function">(<span class="params"><span class="attr">promise</span>: <span class="title class_">Promise</span>&lt;D&gt;, runConfig?: &#123; retry: () =&gt; <span class="built_in">Promise</span>&lt;D&gt; &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入的不是 promise，直接 throw</span></span><br><span class="line">    <span class="keyword">if</span> (!promise || !promise.<span class="property">then</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请传入 Promise 类型数据&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义重新刷新一次，返回一个有上一次 run 执行时的函数</span></span><br><span class="line">    <span class="title function_">setRetry</span>(<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (runConfig?.<span class="property">retry</span>) &#123;</span><br><span class="line">            <span class="title function_">run</span>(runConfig?.<span class="title function_">retry</span>(), runConfig)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 如果是 promise 则设置状态，开始 loading</span></span><br><span class="line">    <span class="title function_">safeDispatch</span>(&#123; <span class="attr">stat</span>: <span class="string">&#x27;loading&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 返回一个promise对象处理数据        </span></span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功则处理stat</span></span><br><span class="line">            <span class="comment">// 判断组件状态</span></span><br><span class="line">            <span class="title function_">setData</span>(data)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;, <span class="title function_">async</span> (err) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 接收到扔来的错误，再扔一下</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">await</span> err)</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 错误抛出了，但是接不住</span></span><br><span class="line">            <span class="title function_">setError</span>(error)</span><br><span class="line">            <span class="keyword">if</span> (config.<span class="property">throwOnError</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;, [config.<span class="property">throwOnError</span>, safeDispatch, setData, setError])</span><br></pre></td></tr></table></figure><p>在这个 <code>hook</code> 中有太多值得我们学习的地方</p><p>首先当我们的 <code>custom hook</code> 返回的值是一个函数时，我们最好用 <code>useCallback</code> 来包一下，这样能解决无限循环的问题</p><p>在我们的请求当中需要对异步情况做出特别的处理，利用 <code>async</code> 来解决这些问题</p><p>对于数据的类型，需要我们对泛型有很清晰的认识</p><h3 id="5-编写-useAuth-获取用户信息"><a href="#5-编写-useAuth-获取用户信息" class="headerlink" title="5 编写 useAuth 获取用户信息"></a>5 编写 useAuth 获取用户信息</h3><p>在编写好 <code>useAsync</code> hook 后，我们需要 通过 <code>useAuth</code> 来<strong>获取用户的信息</strong>，主要是依赖于 <code>useAsync</code> ，这也能体现出 <code>useAsync</code> 的巨大威力</p><p>在这个 <code>custom hook</code> 当中，我们会采用 <code>useAsync</code> 暴露的方法，同时也会采用到 <code>react-query</code> 处理缓存，利用 <code>context</code> 来实现<strong>数据共享</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAuth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 由于在使用 context 时，需要在子节点中声明一下这个 context</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">AuthContext</span>)</span><br><span class="line">    <span class="comment">// 如果这个 context 不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;useAuth必须在 context 中使用&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回这个 context 数据中心</span></span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用这个 hook 的时候，就会<strong>返回这个 context 对象</strong> ，<code>AuthContext</code> ，当然不会这么简单，关键在于我们如何将这些数据存储在 <code>context</code> 当中</p><p>我们编写一个 <code>AuthProvider</code> 方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">AuthProvider</span> = (<span class="params">&#123; children &#125;: &#123; children: ReactNode &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 设置一个user变量 ，由于user 的类型由初始化的类型而定，但不能是 null ，我们需要进行类型断言</span></span><br><span class="line">    <span class="comment">// const [user, setUser] = useState&lt;User | null&gt;(null)</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: user, error, isLoading, isIdle, isError, run, <span class="attr">setData</span>: setUser &#125; = useAsync&lt;<span class="title class_">User</span> | <span class="literal">null</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>()</span><br><span class="line">    <span class="comment">// 设置三个函数 登录 注册 登出</span></span><br><span class="line">    <span class="comment">// setUser 是一个简写的方式 原先是：user =&gt; setUser(user)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params"><span class="attr">form</span>: <span class="title class_">AuthForm</span></span>) =&gt; auth.<span class="title function_">login</span>(form).<span class="title function_">then</span>(setUser)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">register</span> = (<span class="params"><span class="attr">form</span>: <span class="title class_">AuthForm</span></span>) =&gt; auth.<span class="title function_">register</span>(form).<span class="title function_">then</span>(setUser)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">logout</span> = (<span class="params"></span>) =&gt; auth.<span class="title function_">logout</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setUser</span>(<span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 清除数据缓存</span></span><br><span class="line">        queryClient.<span class="title function_">clear</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 当组件挂载时，初始化 user</span></span><br><span class="line">    <span class="title function_">useMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">run</span>(<span class="title function_">bootstrapUser</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">        <span class="comment">// 当初始化和加载中的时候显示loading</span></span><br><span class="line">        <span class="keyword">if</span> (isIdle || isLoading) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageLoading</span> /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isError) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageErrorFallback</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 返回一个 context 容器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AuthContext.Provider</span> <span class="attr">children</span>=<span class="string">&#123;children&#125;</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">user</span>, <span class="attr">login</span>, <span class="attr">logout</span>, <span class="attr">register</span> &#125;&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们这个方法返回了一个 <code>provider</code> 容器，这需要我们对 <code>context</code> 有一定的了解，我们需要使用 <code>provider</code> 来包裹数据共享的范围，只有在这个范围内的元素才能使用这些数据</p><p>这里的意思是，所有的子元素都能够使用这个 <code>context</code> 容器 ，我们在使用的时候</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">AuthProvider</span>&gt;</span><br><span class="line">    &#123;children&#125;</span><br><span class="line">&lt;/<span class="title class_">AuthProvider</span>&gt;</span><br></pre></td></tr></table></figure><p>这样<strong>所有的子元素都能共享</strong>它的 <code>context</code> 容器</p><p>接下来我们看看这个函数都写了什么，首先我们调用 <code>useAsync</code> 解构出了它的部分返回结果，这些都是我们后面可能会用到的</p><p>在这里我们对<strong>当前的状态进行了判断</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当初始化和加载中的时候显示loading</span></span><br><span class="line">    <span class="keyword">if</span> (isIdle || isLoading) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageLoading</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageErrorFallback</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当状态为 <code>loading</code> 时我们展示一个加载框，当 <code>error</code> 时，展示一个<strong>错误提示框</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当组件挂载时，初始化 user</span></span><br><span class="line">    <span class="title function_">useMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">run</span>(<span class="title function_">bootstrapUser</span>())</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>在组件刚挂载时，我们先检查是否存在 <code>token</code> 如果有，我们就对他进行<strong>自动登录</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持用户登录状态，在组件挂载的时候就调用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bootstrapUser</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 从本地取出 token</span></span><br><span class="line">    <span class="keyword">const</span> token = auth.<span class="title function_">getToken</span>()</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">// 如果有值，就去发送请求获得 user 信息</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">http</span>(<span class="string">&#x27;me&#x27;</span>, &#123; token &#125;)</span><br><span class="line">        user = data.<span class="property">user</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 user</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们还将 <code>auth-provider</code> 中编写的三个方法，一同存放到了 <code>context</code> 容器当中，这样我们可以在外部调用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">AuthContext</span>.<span class="property">Provider</span> children=&#123;children&#125; value=&#123;&#123; user, login, logout, register &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这里的 value 设置的就是它的 context 容器中的值</p><p>通过编写这个 custom hook 我们对 <code>useAsync</code> 有了更好的理解，同时也学会了如何使用 <code>context</code> 来进行数据的共享</p><h3 id="6-按钮触发函数执行"><a href="#6-按钮触发函数执行" class="headerlink" title="6 按钮触发函数执行"></a>6 按钮触发函数执行</h3><p>在编写完了前面的几个 <code>custom hook</code> 之后，我们已经将数据接口转到了 <code>context</code> 当中，因此我们在调用里面的内容时，只需要调用 <code>useAuth</code> 来解构出对应的数据即可</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login.tsx</span></span><br><span class="line"><span class="keyword">const</span> &#123; login &#125; = <span class="title function_">useAuth</span>()</span><br><span class="line"><span class="comment">// 采用 useAsync 来封装异步请求，添加loading</span></span><br><span class="line"><span class="keyword">const</span> &#123; run, isLoading &#125; = <span class="title function_">useAsync</span>(<span class="literal">undefined</span>, &#123; <span class="attr">throwOnError</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p>我们得到了 login 函数，同时也得到了 <code>isLoading</code> 的状态</p><p>当表单提交时，会触发 <code>Form</code> 组件中的 <code>onFinish</code> 事件，我们给他绑定了一个 <code>handleSubmit</code> 方法，用于发送请求</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleSubmit</span> = <span class="keyword">async</span> (<span class="params"><span class="attr">values</span>: &#123; username: <span class="built_in">string</span>, password: <span class="built_in">string</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 采用 antd 组件库后代码优化</span></span><br><span class="line">    <span class="comment">// 这里的catch 会捕获错误，调用 onError 这个函数相当于是 error =&gt; onError(error) </span></span><br><span class="line">    <span class="comment">// 由于在index中传入的props是，onError=&#123;setError&#125; 因此就相当于 setError(error)</span></span><br><span class="line">    <span class="title function_">run</span>(<span class="title function_">login</span>(values)).<span class="title function_">catch</span>(onError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样我们就能够成功的发送请求，并且返回结果，当有错误发生时，会触发 <code>catch</code> 中的 <code>onError</code> 设置 <code>index</code> 中的 <code>error</code> 状态，显示在页面当中</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个登录注册页面当中，我们可以<strong>学到以下几点</strong></p><ol><li>context 状态管理</li><li>custom hook 在 react 中的强大威力</li><li>当 custom hook 返回函数时，需要使用 useCallback 包裹</li><li>多利用解构赋值，来优化代码</li><li>useState 设置的变量，类型会跟随初始值的类型</li><li>对于不同的事务，我们最好能分离出来写，这样我们的主文件思路会非常清晰</li><li>利用 CSS in JS 解决样式混乱的问题</li></ol><br><h2 id="二-项目列表展示"><a href="#二-项目列表展示" class="headerlink" title="二 项目列表展示"></a>二 项目列表展示</h2><h3 id="💡-知识点抢先看"><a href="#💡-知识点抢先看" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h3><p>这篇文章将讲到以下几个知识点</p><ul><li>antd 组件库渲染项目列表</li><li><code>...</code> <strong>更多</strong>按钮的实现</li><li>通过 <strong>URL 进行状态管理</strong></li><li>封装项目列表中的 <code>url</code> 操作</li></ul><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211006224843631.png" alt="image-20211006224843631"></p><h3 id="1-antd-组件库渲染项目列表"><a href="#1-antd-组件库渲染项目列表" class="headerlink" title="1 antd 组件库渲染项目列表"></a>1 antd 组件库渲染项目列表</h3><p>首先我们先来讲讲页面中最重要的列表，这里采用的是 Antd 组件库中的 <code>Table</code> 组件为基础架构，我们在它的基础上重新创建了一个 <code>List</code> 组件表示我们的项目列表</p><p>大概的结构如下</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params">&#123; users, ...props &#125;: <span class="title class_">ListProps</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Table</span> <span class="attr">rowKey</span>=<span class="string">&#123;</span>&quot;<span class="attr">id</span>&quot;&#125; <span class="attr">pagination</span>=<span class="string">&#123;false&#125;</span> <span class="attr">columns</span>=<span class="string">&#123;[</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        // <span class="attr">此处省略6个</span> &#123;&#125; <span class="attr">结构</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    ]&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要向 <code>columns</code> 中注入数据，在这里我们的 <code>List</code> 组件接收了需要使用的数据，用户数据以及相关配置项</p><p>这里利用的是一个<strong>类型的继承</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ListProps</span> <span class="keyword">extends</span> <span class="title class_">TableProps</span>&lt;<span class="title class_">Project</span>&gt; &#123;</span><br><span class="line">    <span class="attr">users</span>: <span class="title class_">User</span>[];</span><br><span class="line">    refresh?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过这个接口继承了 <code>Table</code> 组件原先的所有 <code>props</code> 参数的类型的基础上，又添加了几个类型，这样我们的数据既能符合需求，也能顺利的<strong>穿透</strong>到 <code>Table</code> 组件中。同时我们需要给 <code>Table</code> 组件指定数据源 <code>dataSource</code> ，在这样处理后，我们直接可以使用 <code>&#123;...props&#125;</code> 即可</p><blockquote><p>在这里我们使用的 <code>Project</code> 泛型，其实也指定了 <code>dataSource</code> 的类型，也是 <code>columns</code> 中的获取数据类型</p></blockquote><p>根据我们 UI 图，这里一共需要有6个数据：收<strong>藏情况、名称、部门、负责人、创建时间、更多按钮</strong></p><p>这里将从三个问题来讲解如何渲染数据</p><ol><li><strong>如何分列渲染数据？</strong></li></ol><p>我们通过 <code>Table</code> 组件的 <code>columns</code> 属性添加对象的方式来实现 <code>List</code> 中的每一列，简单的说就是组件自带的属性，直接配置就好，这里的 <code>title</code> 也就是用来设置列头的标题</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">    <span class="comment">//其他配置</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 其他5列</span></span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211006233238264.png" alt="image-20211006233238264"></p><p>不用标题的话可以不设置 <code>title</code> 属性</p><ol start="2"><li><strong>如何显示数据呢？</strong></li></ol><p>我们可以使用 <code>dataIndex</code> 以及 <code>render</code> 来实现</p><p><strong>首先</strong> <code>dataIndex</code> 这个是 <code>columns</code> 中的一个 <code>API</code> ，我们可以通过它来指定<strong>列数据的来源</strong></p><blockquote><p><code>dataIndex</code> : 列数据在数据项中对应的路径，支持通过数组查询嵌套路径</p></blockquote><p>对于部门的数据展示</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;部门&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;organization&#x27;</span>,</span><br><span class="line">    <span class="attr">sorter</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">name</span>.<span class="title function_">localeCompare</span>(b.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它可以指定从哪里来获取这些数据，这里就是指定从 <code>project</code> 内直接获取数据</strong></p><p>我们这里采用的就是这种方法，这样就能直接的对数据进行<strong>列渲染</strong></p><p><strong>同时</strong>我们还可以采用 <code>render</code> 方法</p><blockquote><p>生成复杂数据的渲染函数，参数分别为当前行的值，当前行数据，行索引</p></blockquote><p>一般用来处理一些比较难的逻辑，比如 名称</p><p>我们采用的就是 <code>render</code> 来渲染</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">    <span class="attr">sorter</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">name</span>.<span class="title function_">localeCompare</span>(b.<span class="property">name</span>),</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">value, project</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;String(project.id)&#125;</span>&gt;</span>&#123;project.name&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先值得注意的是，这里的 <code>render</code> 和其他的 <code>render</code> 不同，这里的 <code>render</code> 更像是一个函数，我们通过传递参数，然后返回结构，就能渲染在页面上</p><blockquote><p>function(text, record, index) {}</p></blockquote><p>它接收三个参数，都是可选的，分别是当前行的值，<strong>当前行数据</strong>，行索引</p><p>这里特别注意的是当前行数据，我们可以直接使用 <code>props</code> 中的数据，这里我们传入的是 <code>project</code> ，最后返回一个 <code>Link</code> 元素，这样渲染到页面上的就是一个 <code>Link</code> 标签</p><ol start="3"><li><strong>如何实现列排序呢？</strong></li></ol><p>在 <code>columns</code> 中有一个 <code>sorter</code> API，我们可以通过它来实现排序</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sorter</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">name</span>.<span class="title function_">localeCompare</span>(b.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p>通过名字大小写来排序</p><blockquote><p>其实这里讲的都是 <code>Table</code> 组件的用法而已，查看文档也能实现</p></blockquote><p>在这里有一些列中渲染的是<strong>一个组件</strong>，在后面会讲到</p><h3 id="2-更多按钮的实现"><a href="#2-更多按钮的实现" class="headerlink" title="2 更多按钮的实现"></a>2 更多按钮的实现</h3><p>在 <code>Table</code> 列表的 <code>columns</code> 属性中我们的最后一列（更多），采用的是一个封装的组件，这样可以减少我们 <code>Table</code> 组件的代码，同时实现组件复用（这次没有用到）</p><p>更多按钮的实现也是利用了一个 Antd 库中的 <code>Dropdown</code> 和 <code>Menu</code> 组件，实现一个下拉框的效果</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Dropdown</span> overlay=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">onClick</span>=<span class="string">&#123;editProject(project.id)&#125;</span> <span class="attr">key</span>=<span class="string">&#123;</span>&#x27;<span class="attr">edit</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ButtonNoPadding</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">link</span>&#x27;&#125;&gt;</span>编辑<span class="tag">&lt;/<span class="name">ButtonNoPadding</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> confirmDeleteProject(project.id)&#125; key=&#123;&#x27;delete&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ButtonNoPadding</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">link</span>&#x27;&#125;&gt;</span>删除<span class="tag">&lt;/<span class="name">ButtonNoPadding</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ButtonNoPadding</span> <span class="attr">type</span>=<span class="string">&#123;</span>&quot;<span class="attr">link</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ButtonNoPadding</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Dropdown</span>&gt;</span><br></pre></td></tr></table></figure><p>利用 <code>overlay</code> 配置一个 <code>Menu</code> 组件，在 <code>Menu</code> 中配置<strong>下拉显示的内容</strong> ,<code>Dropdown</code> 中直接配置 <strong>当前显示的内容</strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007003107927.png" alt="image-20211007003107927"></p><p>这个就是实现的效果，这里封装了一个 <code>ButtonNoPadding</code> 组件，是一个 Antd 中去除 <code>padding</code> 的 <code>Button</code> 组件</p><blockquote><p>关于删改的实现后面会讲解</p></blockquote><p>关于布局就涉及这么多，接下来才是重头戏</p><h3 id="3-通过-URL-进行状态管理"><a href="#3-通过-URL-进行状态管理" class="headerlink" title="3 通过 URL 进行状态管理"></a>3 通过 URL 进行状态管理</h3><p>这里有很多的问题！！！</p><p>在这里我们就讲几个 <code>custom hook</code> 吧</p><ul><li><code>useUrlQueryParam</code></li><li><code>useSetUrlSearchParam</code></li></ul><p>这两个 <code>hook</code> 分别是用与返回页面 <code>url</code> 中的 <code>query</code> 和设置当前的 <code>URL</code> 地址的</p><p>知道了它们的作用，我们来一步步实现它</p><p>首先在这里有人可能会有疑惑我们为什么不将这两个 <code>hook</code> 写成一个呢？</p><blockquote><p>这里一开始实现的时候是写的一个 <code>hook</code> ，但是到后面逻辑复杂了之后，就会出现无限循环的情况，同时造成 <code>url</code> 的重复跳转，难以实现我们的逻辑，因此我们将两个逻辑分离开来，让它的功能更加具体化</p></blockquote><p>这里我们先来写 <code>useSetUrlSearchParam</code> ，因为在我们的查看逻辑中使用了这部分的代码</p><h4 id="1-useSetUrlSearchParam"><a href="#1-useSetUrlSearchParam" class="headerlink" title="1. useSetUrlSearchParam"></a>1. useSetUrlSearchParam</h4><p><strong>首先</strong>我们使用 <code>react-router-dom</code> 中的 <code>useSearchParams</code> 这个 <code>hook</code> ，它返回一个 <code>searchParams</code> 和 <code>setSearchParams</code>，从用法上来看有点像 <code>useState</code> ，通过这个 <code>hook</code> 可以来处理我们的<strong>查询字符串</strong></p><p>在这里我们接收一个参数 <code>params</code> ，也就是查询字符串，用来设置我们的 <code>url</code>，例如我们的编辑页面的 <code>url</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007144245611.png" alt="image-20211007144245611"></p><p>是通过拼接了一个 <code>editingProjectId=id</code> 实现的，<strong>转化成代码</strong>的话就是我们这里的 <code>params</code> ，在传递的时候是以对象<strong>键值对</strong>的方式来传递的，因此在这里我们对 <code>params</code> 的类型的定义应该符合这个规则</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">params</span>: &#123; [key <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">unknown</span> &#125;</span><br></pre></td></tr></table></figure><p>对于初学 TS 的来说，<strong>如何理解这样的类型定义</strong>呢？</p><p>我们指定 <code>params</code> 的类型是一个对象 <code>&#123;&#125;</code> ，它的 <code>:</code> 左侧也就是 <code>key</code> 被指定为 <code>string</code> ，右侧 <code>unknown</code> 指定 <code>value</code> 的类型</p><p>在我们成功接收到这个 <code>params</code> 时，我们将这个数据解构出来，与原先 <code>url</code> 中存在的 <code>query</code> 一同经过清理之后，将得到的对象传递给 <code>setSearchParams</code> 来设置当前的 <code>url</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这个单独得 hook 来 set search param</span></span><br><span class="line"><span class="comment">// 把输入框的内容映射到url地址上</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useSetUrlSearchParam</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">params</span>: &#123; [key <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">unknown</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> o = <span class="title function_">cleanObject</span>(&#123;</span><br><span class="line">            ...<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(searchParams),</span><br><span class="line">            ...params</span><br><span class="line">        &#125;) <span class="keyword">as</span> <span class="title class_">URLSearchParamsInit</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">setSearchParams</span>(o)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>讲讲我自己对这里的理解吧</strong></p><p>由于我们这部分采用的是 SPA</p><p>一方面我们需要实现打开网址时，显示对应的页面，另一方面我们需要实现我们的跳转</p><p>我们在这里采用的这样的方式：<strong>在我们点击创建或者编辑时，我们将当前的项目列表组件切换成编辑组件</strong>，同时我们通过我们封装的 <code>custom hook</code> 来<strong>手动的更改</strong>当前的 <code>url</code>，从而实现了 <code>url</code> <strong>与数据与页面相匹配</strong></p><h4 id="2-useUrlQueryParam"><a href="#2-useUrlQueryParam" class="headerlink" title="2. useUrlQueryParam"></a>2. useUrlQueryParam</h4><p>首先再次明确我们这个 hook 的功能：返回页面 <code>url</code> 中的 <code>query</code> ，同时利用 <code>useSetUrlSearchParam</code> 返回的方法来设置 <code>url</code></p><p>我们先来明确以下这个 <code>hook</code> <strong>接收的参数和返回的值</strong></p><blockquote><p>接收一个 keys 的数组，也就是 <code>query</code> 中的键名的数组，返回一个数组，第一个元素是一个对象保存着 <code>key-value</code> ，第二个元素是一个方法，也就是修改 <code>url</code> 的方法</p></blockquote><p>接下来我们再来确定以下<strong>接收参数的类型</strong></p><blockquote><p>这里我们接收一个泛型 <code>K</code> 的数组，同时由于这是 <code>key</code> ，这个 <code>K</code> 应当继承 <code>string</code></p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">keys</span>: K[])</span><br></pre></td></tr></table></figure><p>接下来我们来引入一些我们需要用到的方法，查询和设置</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一些实用的方法来处理 URL 的查询字符串</span></span><br><span class="line"><span class="keyword">const</span> [searchParams] = <span class="title function_">useSearchParams</span>()</span><br><span class="line"><span class="keyword">const</span> setSearchParams = <span class="title function_">useSetUrlSearchParam</span>() <span class="comment">// 引入这个自定义的方法，不使用原生自带的</span></span><br></pre></td></tr></table></figure><p>我们再来研究以下如何返回当前 <code>url</code> 的 <code>query</code> 对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useMemo</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> keys.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 解决当get 的值是null 时的默认值</span></span><br><span class="line">        <span class="keyword">return</span> &#123; ...prev, [key]: searchParams.<span class="title function_">get</span>(key) || <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">        <span class="comment">// 传入的是一个 key 类型在 K 中值为 string 的对象</span></span><br><span class="line">    &#125;, &#123;&#125; <span class="keyword">as</span> &#123; [key <span class="keyword">in</span> K]: <span class="built_in">string</span> &#125;),</span><br><span class="line">    [keys, searchParams]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>首先我们通过 <code>reduce</code> <strong>遍历</strong>传入的 <code>keys</code> 数组，每一次遍历都将使用 <code>searchParams</code> 方法去<strong>查找对应的</strong> <code>value</code> 值，遍历完成后会<strong>返回整个对象</strong>，利用 <code>reduce</code> 将每次的 <code>key-value</code> 添加到 <code>&#123;&#125;</code> 中，最后全部返回</p><p>这里我们给 <code>reduce</code> 传入了第二个参数，<strong>指定了我们传入的函数的初始值</strong></p><p>同时在这里我们采用了 <code>useMemo</code> 这个 <code>hook</code> 来优化我们的代码，只有在依赖项改变的时候才会重新计算，这样可以<strong>解决无限循环</strong>的问题（<strong>todo</strong>: 关于无限循环的问题之后出一篇文）</p><p>接下来我们来研究返回数组的第二个值</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值限定在我们设置的范围之内</span></span><br><span class="line">(<span class="attr">params</span>: <span class="title class_">Partial</span>&lt;&#123; [key <span class="keyword">in</span> K]: <span class="built_in">unknown</span> &#125;&gt;) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 把 fromEntries 转化为一个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">setSearchParams</span>(params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单，直接将传入的 <code>params</code> 传递给 <code>setSearchParams</code> 中添加就可以了~</p><p>在这里我们采用了一个 <code>Partial</code> 方法，它是 <code>TS</code> 联合类型中的一个点，它可以把指定的泛型中的类型都<strong>变成可选</strong>的</p><p><strong>底层实现</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后一个非常重要的点是 <code>as const</code> ，这个也是 <code>TS</code> 中比较高级的用法，也叫做 <strong>const 断言</strong>，否则会错乱</p><p>关于 const 断言，做个简单的解释，如果没有使用 <code>as const</code> 的话，会默认的进行类型推断，<code>return</code> 返回的是一个函数类型的数组，但是它完全忘记了有两个元素，因此会丢失返回数组中元素的类型，采用 <code>const</code> 断言，就能指示使表达式的字面类型不被扩展</p><p>未采用 <code>const</code> 断言</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007172612517.png" alt="image-20211007172612517"></p><p>采用 <code>const</code> 断言</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211007172656899.png" alt="image-20211007172656899"></p><p>能明显感受出来它们的不同</p><p>以下是 <code>return</code> 的完整代码</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="title function_">useMemo</span>(</span><br><span class="line">        <span class="function">() =&gt;</span> keys.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; ...prev, [key]: searchParams.<span class="title function_">get</span>(key) || <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">        &#125;, &#123;&#125; <span class="keyword">as</span> &#123; [key <span class="keyword">in</span> K]: <span class="built_in">string</span> &#125;),</span><br><span class="line">        [keys, searchParams]</span><br><span class="line">    ),</span><br><span class="line">    <span class="function">(<span class="params"><span class="attr">params</span>: <span class="title class_">Partial</span>&lt;&#123; [key <span class="keyword">in</span> K]: <span class="built_in">unknown</span> &#125;&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">setSearchParams</span>(params)</span><br><span class="line">    &#125;</span><br><span class="line">] <span class="keyword">as</span> <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>为了给下一篇文章搭建好梯子，接下来我们写一下我们这两个 <code>custom hook</code> 在 <code>project</code> 列表中的应用</p><h3 id="4-封装项目列表中的-url-操作"><a href="#4-封装项目列表中的-url-操作" class="headerlink" title="4 封装项目列表中的 url 操作"></a>4 封装项目列表中的 url 操作</h3><p>由于我们在 <code>project</code> 列表中会大量使用到 <code>url</code> 操作，为了能将我们的代码更加简洁，我们利用 <code>useUrlQueryParam</code> 这个轮子来造车，在这个基础上将 <code>project</code> 的特定 <code>keys</code> 传入即可，这样我们在 <code>project</code> 中使用时，就可以直接调用对应的 <code>searchParams</code> 方法</p><p>这里我们讲 3 个 <code>custom hook</code></p><ul><li>useProjectsSearchParams</li><li>useProjectsQueryKey</li><li>useProjectModel</li></ul><h4 id="1-useProjectsSearchParams"><a href="#1-useProjectsSearchParams" class="headerlink" title="1. useProjectsSearchParams"></a>1. useProjectsSearchParams</h4><p>这一个 <code>hook</code> 就是 <code>useUrlQueryParam</code> 的作用，只是将它具体到了 <code>project</code> 中使用</p><p>返回的是一个数组，第一个元素是查找的数据，第二个是修改的方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useProjectsSearchParams</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 要搜索的数据</span></span><br><span class="line">    <span class="comment">// 返回的是一个新的对象，造成地址不断改变，不断的渲染</span></span><br><span class="line">    <span class="comment">// 用这个方法来设置路由地址跟随输入框变化</span></span><br><span class="line">    <span class="comment">// 服务器返回的都是 string 类型</span></span><br><span class="line">    <span class="keyword">const</span> [param, setParam] = <span class="title function_">useUrlQueryParam</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;personId&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment">// 采用 useMemo 解决 重复调用的问题</span></span><br><span class="line">        <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; ...param, <span class="attr">personId</span>: <span class="title class_">Number</span>(param.<span class="property">personId</span>) || <span class="literal">undefined</span> &#125;), [param]),</span><br><span class="line">        setParam</span><br><span class="line">    ] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用这个 <code>hook</code> 的时候，<strong>直接调用</strong>即可，因为我们已经指定了它的 <code>keys</code> 数组为 <code>[&#39;name&#39;, &#39;personId&#39;]</code>，这个是在 <strong>搜索模块</strong> 中使用的 <code>hook</code></p><h4 id="2-useProjectsQueryKey"><a href="#2-useProjectsQueryKey" class="headerlink" title="2. useProjectsQueryKey"></a>2. useProjectsQueryKey</h4><p>这个 <code>hook</code> 用来返回 <code>query</code> 的键值对，返回的是 <code>&#123;name: &#39;&#39;, personId: undefined&#125;</code> 样式</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useProjectsQueryKey</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [params] = <span class="title function_">useProjectsSearchParams</span>()</span><br><span class="line">    <span class="comment">// &#123;name: &#x27;&#x27;, personId: undefined&#125;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;projects&#x27;</span>, params]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用的时候也是直接调用即可返回数据</p><h4 id="3-useProjectModel"><a href="#3-useProjectModel" class="headerlink" title="3. useProjectModel"></a>3. useProjectModel</h4><p>我们通过这个 <code>hook</code> 来判断当前的状态<strong>是不是在创建、编辑</strong>，如果是的话我们就显示出我们对应的页面</p><p>首先我们先从利用 <code>useUrlQueryParams</code> 来获取到页面的 <code>query</code> 对象</p><p>再<strong>通过对象解构的方式，解构出对应的数据</strong>，例如这里我们解构出 <code>query</code> 中的 <code>projectCreate</code> 字段</p><p>那第一个来说就是利用 <code>useUrlQueryParam</code> 传入 <code>projectCreate</code> 来在 <code>url</code> 中查找有没有这个字段，<strong>返回查找的结果</strong>，同时返回一个可以修改它的函数 <code>setProjectCreate</code> ，这就是我们的 <code>url custom hook</code> 发挥的作用了</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [&#123; projectCreate &#125;, setProjectCreate] = <span class="title function_">useUrlQueryParam</span>([</span><br><span class="line">    <span class="string">&#x27;projectCreate&#x27;</span></span><br><span class="line">])</span><br><span class="line"><span class="comment">// 判断当前是不是在编辑，解构出当前编辑项目的 id</span></span><br><span class="line"><span class="keyword">const</span> [&#123; editingProjectId &#125;, setEditingProjectId] = <span class="title function_">useUrlQueryParam</span>([</span><br><span class="line">    <span class="string">&#x27;editingProjectId&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>在接下来的代码中就是<strong>封装一些更改它们的方法</strong>，暴露出去给外部直接调用，例如<strong>控制 modal 页面的开关</strong>，<code>open</code> 和 <code>close</code> 方法，<strong>控制编辑页面</strong>开启的 <code>startEdit</code> 方法</p><p>代码逻辑非常简单，我们只需要调用对应的 <code>set...</code> 方法来改变 <code>url</code> 中的对应键值对的值就可以了</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">open</span> = (<span class="params"></span>) =&gt; <span class="title function_">setProjectCreate</span>(&#123; <span class="attr">projectCreate</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">startEdit</span> = (<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt; <span class="title function_">setEditingProjectId</span>(&#123; <span class="attr">editingProjectId</span>: id &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">close</span> = (<span class="params"></span>) =&gt; <span class="title function_">setUrlParams</span>(&#123;</span><br><span class="line">    <span class="attr">editingProjectId</span>: <span class="literal">undefined</span>, <span class="attr">projectCreate</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>例如 <code>open</code> 我们通过 <code>setProjectCreate(&#123; projectCreate: true &#125;)</code> 将 <code>projectCreate</code> 改成 <code>true</code> 表示当前正在创建的页面</p><p>关于这个 <code>editingProjectId</code> 我们可以通过 <code>useProject</code> 这个 <code>custom hook</code> 来获取（或许在下一篇会讲到，这里不展开），采用的是 <code>react-query</code> ， 它返回的是一个 <code>data</code> 数 据</p><p>最后我们暴露这些方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 采用 id才是最佳选择，这样不用等待数据返回就能打开编辑框</span></span><br><span class="line">    <span class="attr">projectModelOpen</span>: projectCreate === <span class="string">&#x27;true&#x27;</span> || <span class="title class_">Boolean</span>(editingProjectId),</span><br><span class="line">    open,</span><br><span class="line">    close,</span><br><span class="line">    startEdit,</span><br><span class="line">    editingProject,</span><br><span class="line">    isLoading</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的 <code>project</code> 列表下的 <code>url</code> 控制操作 <code>hook</code> 就全部完成了</p><p>那么这篇文章就到这里结束了，在接下来的文章中，会利用这些封装好的 <code>hook</code> <strong>去实现项目列表的增删改查以及乐观更新等功能</strong></p><h3 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a>📌 总结</h3><ol><li>在这篇文章中我们写了大量的 <code>custom hook</code> ，也更加的熟练了它的写法和好处</li><li>对 <code>const</code> 断言有了一定的了解</li><li>学会了如何使用 <code>Table</code> 、<code>Dropdown</code> 等组件</li><li>大致的认识了 <code>useMemo</code> 的用法</li><li>对 <code>useSearchParams</code> 有了一定的了解</li><li><code>TS</code> 中的联合类型有了更深的理解</li></ol><br><h2 id="三-项目列表功能模块"><a href="#三-项目列表功能模块" class="headerlink" title="三 项目列表功能模块"></a>三 项目列表功能模块</h2><h2 id="💡-知识点抢先看-1"><a href="#💡-知识点抢先看-1" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h2><ul><li>实现对项目的增删改查</li><li>收藏功能的实现</li><li>利用乐观更新来优化用户体验</li></ul><h3 id="1-实现对项目的增删改查"><a href="#1-实现对项目的增删改查" class="headerlink" title="1 实现对项目的增删改查"></a>1 实现对项目的增删改查</h3><h4 id="1-模态框的实现"><a href="#1-模态框的实现" class="headerlink" title="1. 模态框的实现"></a>1. 模态框的实现</h4><p>首先我们先理顺现在的思路，我们现在的单页面都已经布局好了，还有几个功能没有实现，创建项目、编辑项目、删除项目、收藏项目、查找项目（这个在下一篇讲）</p><p>先来看看我们的效果图</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-create.gif" alt="jira-project-create"></p><p>我们的创建项目和编辑项目<strong>都是在一个弹出的模态框</strong>内实现的，仔细观察，会发现我们的项目列表并没有消失，效果看起来是<strong>叠加</strong>的。这样，我们接下来就可以<strong>先写创建项目和编辑项目的模态框</strong>，我们只需要将被编辑的<strong>项目数据</strong>传递给模态框就可以了，对于创建项目，我们给一个<strong>空白</strong>的即可</p><p>这里我们的抽拉效果，采用的是 <code>antd</code> 中的 <code>Drawer</code> 组件实现的，对这个组件不熟悉的可以看看：<a target="_blank" rel="noopener" href="https://ant.design/components/drawer-cn/#header">Drawer</a></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008140324136.png" alt="image-20211008140324136"></p><p>从描述上来看，它会<strong>覆盖住父窗体的内容</strong>，正符合我们的想法，我们只需要将 <code>Form</code> 表单丢进这个 <code>Drawer</code> 组件中即可，</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Drawer</span></span><br><span class="line">    forceRender=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">    onClose=&#123;closeModel&#125;</span><br><span class="line">    visible=&#123;projectModelOpen&#125;</span><br><span class="line">    width=&#123;<span class="string">&#x27;100%&#x27;</span>&#125; &gt;</span><br><span class="line">    &#123;</span><br><span class="line">        isLoading ? <span class="language-xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">size</span>=<span class="string">&#123;</span>&#x27;<span class="attr">large</span>&#x27;&#125; /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ErrorBox</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Form</span> <span class="attr">form</span>=<span class="string">&#123;form&#125;</span> <span class="attr">layout</span>=<span class="string">&#123;</span>&quot;<span class="attr">vertical</span>&quot;&#125; <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">40rem</span>&#x27; &#125;&#125; <span class="attr">onFinish</span>=<span class="string">&#123;onFinish&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;/* 节省篇幅，此处省略了名称、部门和负责人的 form.Item */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &quot;<span class="attr">right</span>&quot; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;/* 点击提交触发onFinish方法 */&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">loading</span>=<span class="string">&#123;mutateLoading&#125;</span> <span class="attr">type</span>=<span class="string">&#123;</span>&quot;<span class="attr">primary</span>&quot;&#125; <span class="attr">htmlType</span>=<span class="string">&#123;</span>&quot;<span class="attr">submit</span>&quot;&#125; &gt;</span>提交<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="title class_">Drawer</span>&gt;</span><br></pre></td></tr></table></figure><p>在这个组件中我们设置了 <code>forceRender</code> 属性，这个属性可以<strong>控制是否强制渲染</strong>，这也是为了解决，我们在刚打开时，组件未渲染导致<strong>报错</strong>的问题</p><p>同时我们也可以发现，我们在当中设置了<strong>三元判断</strong>，这样是为了优化我们的用户体验，前面也提过了，我们整个项目采用的是 <code>react-query</code> 进行 <code>url</code> 管理，在它的 <code>API</code> 中有能够返回 <code>isLoading</code> 状态的 <code>hook</code> 也就是我们的<strong>数据请求的完成状态</strong>，这也让我们可以利用这个 <code>isLoading</code> 去实现这个 <code>Spin</code> 的<strong>加载效果</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isLoading ? <span class="language-xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">size</span>=<span class="string">&#123;</span>&#x27;<span class="attr">large</span>&#x27;&#125; /&gt;</span></span> : &lt;<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>这样其实我们的 <code>modal</code> 就已经做好了，接下来我们来完善一下这个 <code>modal</code> 的<strong>周边措施</strong>，当我们创建完成或者编辑完成时，我们需要关闭 <code>modal</code> ，在我们的 <code>useProjectModel</code> 中已经暴露了 <code>close</code> 方法，我们只需要在 <code>onFinish</code> 中调用即可</p><blockquote><p>当 <code>form</code> 表单成功提交时，会自动调用 <code>onFinish</code> 方法，同时会将 <code>form</code> 表单中的数据作为参数，因此我们采用 <code>useMutateProject</code> 这个 <code>hook</code> 来将数据维护到 <code>url</code> 中</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useMutateProject = editingProject ? useEditProject : useAddProject</span><br><span class="line"><span class="keyword">const</span> &#123; mutateAsync, error, <span class="attr">isLoading</span>: mutateLoading &#125; = <span class="title function_">useMutateProject</span>(<span class="title function_">useProjectsQueryKey</span>())</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onFinish</span> = (<span class="params"><span class="attr">values</span>: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">mutateAsync</span>(&#123; ...editingProject, ...values &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        form.<span class="title function_">resetFields</span>()</span><br><span class="line">        <span class="title function_">close</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们采用了 2 个 <code>custom hook</code> ，<code>useEditProject</code> 和 <code>useAddProject</code>，接下来我们就讲讲这两个 hook</p><blockquote><p><strong>tips</strong>：<code>form.resetFields</code> 方法可以重置表单，也就是一个清空表单的效果</p></blockquote><h4 id="2-封装增删改查-hook引出"><a href="#2-封装增删改查-hook引出" class="headerlink" title="2. 封装增删改查 hook引出"></a>2. 封装增删改查 hook引出</h4><p>在上一小节中，我们也看到了这些 <code>hook</code> 的使用，我们在使用的时候只需要传递一个 <code>queryKey</code> ，就能够返回一个 <code>mutate</code> 以及一些相关的配置，这些我们并没有手动的去写，那它是怎么实现的呢？</p><p>这其实利用的是 <code>useMutation</code> 这个 <code>react-query</code> 中的原生 <code>hook</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">    <span class="function">(<span class="params"><span class="attr">params</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">Project</span>&gt;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`projects`</span>, &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: params</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">useAddConfig</span>(queryKey)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这里我们传递了两个参数，<strong>第一个参数是异步请求，第二个参数是相关的配置项</strong></p><p>这样它就能返回一个用来实现乐观更新的 <code>mutate</code> 和 <code>mutateAsync</code> 我们可以自己选用，一个是同步的一个是异步的</p><p>在我们使用的时候，只需要要像发送请求一样，传递我们的数据即可</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="title function_">mutateAsync</span>(&#123; ...editingProject, ...values &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    form.<span class="title function_">resetFields</span>()</span><br><span class="line">    <span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>例如我们的编辑效果就采用了异步的方法</p><p>下面我们来编写这些 <code>hook</code></p><h4 id="3-useEditProject"><a href="#3-useEditProject" class="headerlink" title="3. useEditProject"></a>3. useEditProject</h4><p>这是在编辑项目时需要调用的 <code>hook</code> 当我们编辑完之后，我们就可以调用这个 <code>hook</code> 暴露 <code>mutate</code> ，接着调用 <code>mutate</code> 来发送数据请求</p><p>首先我们还是逃不开我们的 <code>http</code> 这个 <code>hook</code> 所有的<strong>异步请求都是通过这里来发送的</strong></p><p>我们先返回我们的 <code>fetch</code> 方法封装的 <code>client</code> 函数 ，最后返回一个 <code>useMutation</code> 函数<strong>调用的返回值</strong>，这个函数接收 2 个参数，<strong>一个是我们需要发的请求，一个是配置项</strong></p><p>我们通过 <code>client</code> 封装我们需要发送的请求，在编辑情况下，我们需要<strong>传递</strong> <code>id</code> 来获取需要编辑的项目，<code>data</code> 则是整个传递过来的 <code>params</code> 这里面将包括了我们需要的数据，<strong>为什么可以看出来呢？</strong></p><p>我们在给 <code>params</code> 限定类型时，采用了 <code>Partial&lt;Project&gt;</code> 这表明了 <code>params</code> 的变量和变量类型，必须<strong>来自</strong>于 <code>Project</code> 这个封装好的项目信息<strong>接口</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type/project.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Project</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">personId</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">pin</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">organization</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">created</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/project.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useEditProject</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 实现乐观更新</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="function">(<span class="params"><span class="attr">params</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">Project</span>&gt;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`projects/<span class="subst">$&#123;params.id&#125;</span>`</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;PATCH&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: params</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">useEditConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>config</code> 这些 <code>hook</code> 的配置，在乐观更新中会讲到</p><p>接下来我们再来处理添加请求</p><h4 id="4-useAddProject"><a href="#4-useAddProject" class="headerlink" title="4. useAddProject"></a>4. useAddProject</h4><p>这几个 <code>hook</code> 的相似度非常高，都是一个套路，写习惯了 <code>custom hook</code> 真的可以轻松拿捏的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAddProject</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="function">(<span class="params"><span class="attr">params</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">Project</span>&gt;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`projects`</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: params</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">useAddConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们同样的方式传递我们的 <code>params</code> 参数，使用 <code>useMutation</code> 来处理我们的请求</p><h4 id="5-useDeleteProject"><a href="#5-useDeleteProject" class="headerlink" title="5. useDeleteProject"></a>5. useDeleteProject</h4><p>处理删除的请求，对于删除项目只需要传递 <code>id</code> 就可以了，删除指定 <code>id</code> 的项目</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDeleteProject</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="function">(<span class="params">&#123; id &#125;: &#123; id: <span class="built_in">number</span> &#125;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`projects/<span class="subst">$&#123;id&#125;</span>`</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">useDeleteConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>useMutation</code> 的一点理解</p><p>从上面的代码中我们可以可以发现，它都是用来处理我们的请求，我们传递一个异步请求，它也能返回一个请求的函数 (<code>mutate</code>)，因此可以理解为，使用这个 <code>hook</code> 包装我们的异步请求，让它具有能够乐观更新的功能，其他的功能和我们自己封装的 <code>client</code> 方法一致</p></blockquote><h4 id="6-实现编辑，创建功能"><a href="#6-实现编辑，创建功能" class="headerlink" title="6. 实现编辑，创建功能"></a>6. 实现编辑，创建功能</h4><p>我们在点击编辑按钮时，首先需要弹出 <code>modal</code> 编辑信息点击保存后，才需要调用发送请求</p><p><strong>上代码</strong></p><p>首先先处理 <code>modal</code> 的显示和关闭</p><p>（截取下拉框的关键代码）我们在点击编辑按钮时，会触发 <code>editProject</code> 方法，这个方法会触发 <code>startEdit</code> ，它是 <code>useProjectModel</code> 这个 <code>custom hook</code> 暴露出来的 用来开启 <code>modal</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">editProject</span> = (<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt; <span class="function">() =&gt;</span> <span class="title function_">startEdit</span>(id)</span><br><span class="line">&lt;<span class="title class_">Menu</span>.<span class="property">Item</span> onClick=&#123;<span class="title function_">editProject</span>(project.<span class="property">id</span>)&#125; key=&#123;<span class="string">&#x27;edit&#x27;</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p><code>modal</code> 开启来，现在我们需要将视线聚焦在 <code>project-modal</code> 这个文件当中，来处理在这个页面上的请求了！</p><p>在我们调用 <code>startEdit</code> 时，会将页面的 <code>url</code> 设置成 <code>editingProjectId</code> ，因此我们需要在 <code>modal</code> 中先<strong>判断一下这个页面开启的请求是来自于编辑还是创建，</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useMutateProject = editingProject ? useEditProject : useAddProject</span><br></pre></td></tr></table></figure><p>这样我们的 <code>useMutateProject</code> 就是这两个中的一个，在后面就没有什么担忧了</p><p>然后我们直接传递当前的 <code>queryKey</code> 给这个 <code>hook</code> 暴露出我们需要的 <code>mutate</code> 这个请求函数，以及错误状态和请求状态</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; mutateAsync, error, <span class="attr">isLoading</span>: mutateLoading &#125; = <span class="title function_">useMutateProject</span>(<span class="title function_">useProjectsQueryKey</span>())</span><br></pre></td></tr></table></figure><p>当我们的 <code>form</code> 表单被提交时，我们调用这个方法传递我们 <code>params</code> 发送请求</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onFinish</span> = (<span class="params"><span class="attr">values</span>: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">mutateAsync</span>(&#123; ...editingProject, ...values &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        form.<span class="title function_">resetFields</span>()</span><br><span class="line">        <span class="title function_">close</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的创建编辑功能就实现了</p><h4 id="7-删除功能"><a href="#7-删除功能" class="headerlink" title="7. 删除功能"></a>7. 删除功能</h4><p>这里有一个比较好玩的东西，当我们点击删除时，不能立即执行，我们需要用户确认后才能发送请求，因此我们需要再多封装一层函数 <code>confirmDeleteProject</code> ，用来提示用户是否确定删除</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Menu</span>.<span class="property">Item</span> onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">confirmDeleteProject</span>(project.<span class="property">id</span>)&#125; key=&#123;<span class="string">&#x27;delete&#x27;</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>再这里我们采用了 <code>antd</code> 组件中的 <code>Modal</code> 组件下的 <code>confirm</code> 框</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">confirmDeleteProject</span> = (<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Modal</span>.<span class="title function_">confirm</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;你确定删除项目吗？&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;点击确定删除&#x27;</span>,</span><br><span class="line">        <span class="attr">okText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        <span class="title function_">onOk</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">deleteProject</span>(&#123;id&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里配置我们的提示框的相关信息，以及确定后执行的操作，这里当 <code>onOk</code> 时会调用 <code>deleteProject</code> 来发送请求，从这个命名也知道它调用的是 <code>useDeleteProject</code> ，这也是命名规范的好处之一</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008170502500.png" alt="image-20211008170502500"></p><p>这样，我们的删除功能就也实现了，关于增删改就写到这里，在这里我们又写了大量的 <code>custom hook</code>，自己提升还是很大的</p><h3 id="2-收藏功能的实现"><a href="#2-收藏功能的实现" class="headerlink" title="2 收藏功能的实现"></a>2 收藏功能的实现</h3><p>对于这个小星星的样式，我们采用的是 <code>Antd</code> 中而定 <code>Rate</code> 组件</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008172232127.png" alt="image-20211008172232127"></p><p>它大概长这个样子它可以通过 <code>count</code> 来控制星星的个数，因此我们重新封装一个 <code>Pin</code> 组件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PinProps</span> <span class="keyword">extends</span> <span class="title class_">React</span>.<span class="title class_">ComponentProps</span>&lt;typeof <span class="title class_">Rate</span>&gt; &#123;</span><br><span class="line">    <span class="attr">checked</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    onCheckedChange?: <span class="function">(<span class="params"><span class="attr">checked</span>: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Pin</span> = (<span class="params">&#123; checked, onCheckedChange, ...restProps &#125;: <span class="title class_">PinProps</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Rate</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        // <span class="attr">一颗星</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">count</span>=<span class="string">&#123;1&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;checked</span> ? <span class="attr">1</span> <span class="attr">:</span> <span class="attr">0</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;num</span> =&gt;</span> onCheckedChange?.(!!num)&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;...restProps&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们新封装的 <code>Pin</code> 组件也需要拥有 <code>Rate</code> 组件的属性，因此我们采用了一个<strong>继承</strong>的操作 ，我们可以通过 <code>React.ComponentProps&lt;typeof Rate&gt;</code> 来获取 <code>Rate</code> 中的<strong>所有 <code>props</code> 类型</strong>，也就是<strong>接收参数</strong>的类型，我们将我们的 <code>Pin</code> 组件的 <code>props</code> 参数用上这个类型就可以了</p><blockquote><p>这里采用了一个 <code>!!num</code> 的高端操作，其实就是一个转化成 <code>boolean</code> 类型的方法</p></blockquote><p>接着我们就可以在 <code>columns</code> 中使用这个 <code>Pin</code> 组件了，在星星状态改变时调用编辑方法，改变数据中的 <code>pin</code> 状态</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Pin</span> <span class="attr">checked</span>=<span class="string">&#123;true&#125;</span> <span class="attr">disabled</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span>,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">value, project</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Pin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">checked</span>=<span class="string">&#123;project.pin&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            // <span class="attr">利用柯里化技术</span>，<span class="attr">首先传入</span> <span class="attr">id</span> ,<span class="attr">在传入pin</span> ，<span class="attr">最后执行</span> <span class="attr">mutate</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onCheckedChange</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">pinProject</span>(<span class="attr">project.id</span>)</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在这里我们采用柯里化的方式优化了这段代码，我们在编写 <code>pinProject</code> 时，采用了柯里化的方式，一次接收一个参数，返回一个函数，最后执行 <code>mutate</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; mutate &#125; = <span class="title function_">useEditProject</span>(<span class="title function_">useProjectsQueryKey</span>())</span><br><span class="line"><span class="comment">// 指定修改的pin id 即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pinProject</span> = (<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt; <span class="function">(<span class="params"><span class="attr">pin</span>: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="title function_">mutate</span>(&#123; id, pin &#125;)</span><br></pre></td></tr></table></figure><p>这样我们的收藏功能就成功的实现了</p><h3 id="3-实现乐观更新"><a href="#3-实现乐观更新" class="headerlink" title="3 实现乐观更新"></a>3 实现乐观更新</h3><p>接下来我们来谈谈这个乐观更新，可能很多人都不太知道乐观更新是什么东西，我们先来科普一下</p><blockquote><p>采用乐观更新，用户界面的行为就像在从服务器收到实际确认之前成功完成更改一样 ，它乐观地认为它最终会得到确认而不是错误。这可以提供更快速的用户体验。</p><p>简单的说，我们的页面信息会在服务器请求结果返回之前去更新，例如收藏按钮，如果我们的请求时间为 5s，那么不采用乐观更新，收藏的按钮就会在 <code>5s</code> 之后采用亮起，而采用乐观更新，则会默认的认为服务器返回的结果必然成功，我们先做去预判，先在用户点击的时候直接亮起按钮，请求让它慢慢请求去吧</p></blockquote><p>现在我们就来编写一下乐观更新的代码吧~，在前面的 <code>hook</code> 中我们的第二个参数 <code>config</code> 没有讲，它就是实现乐观更新的关键</p><p>首先我们需要编写一个 <code>useConfig</code> ，这个在几个 <code>hook</code> 中都必须使用到，因为利用 <code>useMutation</code> 这个 API 来实现乐观更新，会牵扯到 <code>useMutation</code> 生命周期的问题，我们封装一个 <code>useConfig</code> 来编写这些生命周期函数</p><p>在这个 hook 中我们使用了大量的 <code>any</code> ，无关大雅</p><p>我们在成功、提交、失败中设置了相应的回调，来处理不同的请求情况</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乐观更新,用来生产代码的 hook</span></span><br><span class="line"><span class="comment">// 这里的类型非常的复杂采用了很多的any ，代价是可以接受的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useConfig</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span>, <span class="attr">callback</span>: (target: <span class="built_in">any</span>, old?: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>[]</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 生命周期函数</span></span><br><span class="line">        <span class="attr">onSuccess</span>: <span class="function">() =&gt;</span> queryClient.<span class="title function_">invalidateQueries</span>(queryKey),</span><br><span class="line">        <span class="comment">// 提交请求</span></span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">onMutate</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">            <span class="comment">// 数据列表</span></span><br><span class="line">            <span class="keyword">const</span> previousItems = queryClient.<span class="title function_">getQueryData</span>(queryKey)</span><br><span class="line">            queryClient.<span class="title function_">setQueryData</span>(queryKey, <span class="function">(<span class="params">old?: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">callback</span>(target, old)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> &#123; previousItems &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">onError</span>(<span class="params"><span class="attr">error</span>: <span class="built_in">any</span>, <span class="attr">newItem</span>: <span class="built_in">any</span>, <span class="attr">context</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">            <span class="comment">// 发生错误继续缓存旧的值</span></span><br><span class="line">            queryClient.<span class="title function_">setQueryData</span>(queryKey, context.<span class="property">previousItems</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来简单讲讲这些 API 吧</p><ol><li><code>queryClient.invalidateQueries</code>： 在提交成功/失败之后都进行重新查询更新状态</li><li><code>queryClient.getQueryData</code>：获取缓存的旧值</li><li><code>queryClient.setQueryData</code>：设置值</li></ol><p>接下来我们来编写相应的 <code>config</code> ，那 <code>delete</code> 来讲</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDeleteConfig</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; <span class="title function_">useConfig</span>(queryKey, <span class="function">(<span class="params">target, old</span>) =&gt;</span> old?.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> !== target.<span class="property">id</span>) || [])</span><br></pre></td></tr></table></figure><p>这段代码它其实就只是传入了我们删除项目的数据，然后通过 <code>filter</code> 整理了一下数据传递给了 <code>useConfig</code> ，因此，这几个都是类似的只是传递的参数不一样</p><p><code>useConfig</code> 接收 2 个参数，一个是 <code>queryKey</code> ，一个是新值旧值的函数</p><p>因此我们通过 <code>filter</code> 从旧数据中过滤掉被删除的项目，这样返回的数据就是我们所要的新数据了</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useEditConfig</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; <span class="title function_">useConfig</span>(queryKey, <span class="function">(<span class="params">target, old</span>) =&gt;</span> old?.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === target.<span class="property">id</span> ? &#123; ...item, ...target &#125; : item) || [])</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAddConfig</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; <span class="title function_">useConfig</span>(queryKey, <span class="function">(<span class="params">target, old</span>) =&gt;</span> old ? [...old, target] : [])</span><br></pre></td></tr></table></figure><p>同理这两个 <code>hook</code> 也这么写，通过数组的方法筛选出新的数据即可</p><p>这样我们的乐观更新的逻辑就完成了！</p><blockquote><p>对于底层的实现原理，还不是很熟悉，所以表诉的可能不大清楚</p></blockquote><hr><p>那么这部分的内容就到这里了，下一篇将会讲关于搜索部分的实现~</p><h3 id="📌-总结-1"><a href="#📌-总结-1" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>通过这篇文章我们可以学会以下这些内容</p><ol><li>在 antd 组件的基础上封装新的组件</li><li>采用乐观更新优化体验</li><li>项目的增删查功能</li><li>采用 <code>react-query</code> 进行状态管理</li><li>柯里化解决实际问题</li></ol><br><h2 id="四-搜索功能实现"><a href="#四-搜索功能实现" class="headerlink" title="四 搜索功能实现"></a>四 搜索功能实现</h2><h3 id="💡-知识点抢先看-2"><a href="#💡-知识点抢先看-2" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h3><ul><li>封装 userSelect 组件</li><li>将输入框内容映射到 url 上</li><li>利用防抖优化输入框请求</li></ul><p>先献上效果图</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-search.gif" alt="jira-project-search"></p><h3 id="1-封装-UserSelect-组件"><a href="#1-封装-UserSelect-组件" class="headerlink" title="1 封装 UserSelect 组件"></a>1 封装 UserSelect 组件</h3><p>这次的项目采用的是 <code>Antd</code> 组件库，在这部分中我们采用 <code>Form</code> 表单以及 <code>Input</code> 来实现搜索框的样式，对于下拉框，将采用以 <code>Select</code> 组件为基础的 <code>UserSelect</code> 自定义组件</p><p>重新封装 <code>Select</code> 组件，在这里我们首先是封装了一个 <code>IdSelect</code> 组件，再在这个组件的基础上抽象一个 <code>UserSelect</code> 组件</p><p>这样做的目的是为了让 <code>IdSelect</code> 组件能够<strong>实现复用</strong></p><p>下面我们先来写 <code>IdSelect</code> 组件吧，从名字上也可以看出，它是通过 <code>id</code> 来选择 <code>option</code> 的</p><p>在前面的文章中，我们也有提到过，利用 <code>antd</code> 组件来封装自定义组件，需要<strong>继承它的原先的类型</strong>，来保持它的 <code>props</code> 正常工作</p><p>我们先来看看 <code>IdSelect</code> 应当接收的<strong>参数类型</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Select 身上的方法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SelectProps</span> = <span class="title class_">React</span>.<span class="property">ComponentProps</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Select</span>&gt;</span><br><span class="line"><span class="comment">// 在 type 中定义公共类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IdSelectProps</span> <span class="keyword">extends</span> <span class="title class_">Omit</span>&lt;<span class="title class_">SelectProps</span>, &#x27;value&#x27; | &quot;onChange&quot; | &quot;options&quot; | &quot;defaultOptionName&quot;&gt; &#123;</span><br><span class="line">    value?: <span class="title class_">Raw</span> | <span class="literal">null</span> | <span class="literal">undefined</span>,</span><br><span class="line">    <span class="comment">// onChange 只能传入number</span></span><br><span class="line">    onChange?: <span class="function">(<span class="params">value?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">    defaultOptionName?: <span class="built_in">string</span>,</span><br><span class="line">    options?: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">id</span>: <span class="built_in">number</span> &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的类型还是比较复杂的</p><p>首先是 <code>SelectProps</code> 定义的一个类型等于 <code>Select</code> 的类型，再在 <code>IdSelectProps</code> 的类型中继承部分的 <code>SelectProps</code> 类型</p><p><strong>为什么说是部分呢？</strong></p><p>由于我们原生的 <code>Select</code> 组件中对于 <code>onChange</code> 属性的类型是采用泛型来定义的，这会导致我们的 <code>number</code> 类型数据转化成 <code>string</code> ，总之就会导致最后的后端返回数据的类型和 <code>Select</code> 中的类型不一致，因此我们需要将 <code>onChange</code> 限制为 <code>number</code> 类型</p><p>这个是 <code>onChange</code> 的<strong>类型声明</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange?: <span class="function">(<span class="params"><span class="attr">value</span>: <span class="title class_">ValueType</span>, <span class="attr">option</span>: <span class="title class_">OptionsType</span>[<span class="built_in">number</span>] | <span class="title class_">OptionsType</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>同时对于一些类型我们有自己明确的类型，因此我们不需要采用它原生的类型，我们自己重新定义</p><p>因此我们采用 <code>Omit</code> 关键字来除去 <code>SelectProps</code> 中的部分类型声明，重新写一份</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Omit</span>&lt;<span class="title class_">SelectProps</span>, <span class="string">&#x27;value&#x27;</span> | <span class="string">&quot;onChange&quot;</span> | <span class="string">&quot;options&quot;</span> | <span class="string">&quot;defaultOptionName&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这样我们就完成了对 <code>Select</code> 数据类型的封装，接着我们需要将一些相关的配置<strong>全部传递</strong>给它们</p><p>例如，<code>value</code> 属性的默认值，<code>onChange</code> 的执行时机，以及 <code>defaultOptionName</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">IdSelect</span> = (<span class="params"><span class="attr">props</span>: <span class="title class_">IdSelectProps</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onChange, defaultOptionName, options, ...restProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Select</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    // <span class="attr">这里设置了value</span> ：<span class="attr">0</span> ，<span class="attr">当我们数据还没有返回的时候</span>，<span class="attr">它会显示</span> <span class="attr">负责人字样</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;options?.length</span> ? <span class="attr">toNumber</span>(<span class="attr">value</span>) <span class="attr">:</span> <span class="attr">0</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;value</span> =&gt;</span> onChange?.(toNumber(value) || undefined)&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;...restProps&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            defaultOptionName ? <span class="tag">&lt;<span class="name">Select.Option</span> <span class="attr">value</span>=<span class="string">&#123;0&#125;</span>&gt;</span>&#123;defaultOptionName&#125;<span class="tag">&lt;/<span class="name">Select.Option</span>&gt;</span> : null</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            options?.map(option =&gt; <span class="tag">&lt;<span class="name">Select.Option</span> <span class="attr">key</span>=<span class="string">&#123;option.id&#125;</span> <span class="attr">value</span>=<span class="string">&#123;option.id&#125;</span>&gt;</span>&#123;option.name&#125;<span class="tag">&lt;/<span class="name">Select.Option</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的思路很简单，当没有 <code>options</code> 时，<code>value</code> 设置为 <code>0</code> ，显示<strong>默认负责人</strong>。同时我们需要对传入的 <code>value</code> 进行类型转化，保证它是 <code>number</code> 类型</p><p>这样我们的 <code>IdSelect</code> 就封装好了，它相对于 <code>Select</code> 有更加严格的类型要求，以确保我们传递的参数类型不会出错</p><p>接着我们将这个 <code>IdSelect</code> 特殊化到 <code>User</code> 中，再封装一个 <code>UserSelect</code> 给 <code>project</code> 中按照人员查找来使用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">UserSelect</span> = (<span class="params"><span class="attr">props</span>:<span class="title class_">React</span>.<span class="title class_">ComponentProps</span>&lt;<span class="keyword">typeof</span> <span class="title class_">IdSelect</span>&gt;</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">data</span>:users&#125; = <span class="title function_">useUsers</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">IdSelect</span> <span class="attr">options</span>=<span class="string">&#123;users||</span> []&#125; &#123;<span class="attr">...props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">IdSelect</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写熟练了真是随便拿捏</p><p>同样的，我们的数据类型继承自 <code>IdSelect</code> ，然后，我们先直接传入我们的 <code>Users</code> 数据，实现了一个 <code>UserSelect</code></p><p><strong>为什么这样就可以了呢？</strong></p><p>我们将数据传递下去之后，得到的 <code>Select</code> 就是一个人员列表了，这样我们只需要做一些其他配置就可以了，<strong>不需要考虑人员数据的问题</strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008211259106.png" alt="image-20211008211259106"></p><p><strong>接着</strong>，我们在搜索部分的 <code>Form</code> 表单中，使用这个组件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search-panel.tsx</span></span><br><span class="line">&lt;<span class="title class_">UserSelect</span></span><br><span class="line"><span class="comment">// 默认选项</span></span><br><span class="line">    defaultOptionName=&#123;<span class="string">&#x27;负责人&#x27;</span>&#125;</span><br><span class="line">    value=&#123;param.<span class="property">personId</span>&#125;</span><br><span class="line">    onChange=&#123;<span class="function"><span class="params">value</span> =&gt;</span></span><br><span class="line">        <span class="title function_">setParam</span>(&#123;</span><br><span class="line">            ...param,</span><br><span class="line">            <span class="attr">personId</span>: value</span><br><span class="line">        &#125;)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在这里我们配置了默认选型，以及通过 <code>props</code> 传递的用户 <code>id</code> （<code>param.personId</code>），同时在输入框被选择时触发的事件，用来操控我们的页面 <code>url</code> 变化</p><h3 id="2-将输入框内容映射到-url-上"><a href="#2-将输入框内容映射到-url-上" class="headerlink" title="2 将输入框内容映射到 url 上"></a>2 将输入框内容映射到 url 上</h3><p>在上一小节我们最后谈到了 <code>url</code> 的变化，确实如此，当我们在输入框中输入内容时，或者时 <code>Select</code> 中选择内容时，都应该要<strong>映射到 <code>url</code> 中</strong>，这样我们将 <code>url</code> 复制在新页面打开，还会<strong>保留同样的信息</strong>，这种功能也是非常常见的，例如<strong>掘金社区</strong>的文章标题，<code>h1、h2</code> 标签</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211008212554826.png" alt="image-20211008212554826"></p><p>因此我们有理由，有必要实现这样的功能！</p><p>想到 <code>url</code> 操作，我们很容易想到我们的 <code>useProjectsQueryKey</code> 这一类 <code>hook</code>，当然这有一定的关系</p><p>在这里我们需要使用我们之前封装过的 <strong><code>useProjectsSearchParams</code></strong> 这个 <code>custom hook</code> ，</p><p>我们先再看看这个 <code>hook</code> 的源码</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useProjectsSearchParams</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 返回的是一个新的对象，造成地址不断改变，不断的渲染</span></span><br><span class="line">    <span class="keyword">const</span> [param, setParam] = <span class="title function_">useUrlQueryParam</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;personId&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment">// 采用 useMemo 解决 重复调用的问题</span></span><br><span class="line">        <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; ...param, <span class="attr">personId</span>: <span class="title class_">Number</span>(param.<span class="property">personId</span>) || <span class="literal">undefined</span> &#125;), [param]),</span><br><span class="line">        setParam</span><br><span class="line">    ] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单梳理一下，就是通过 <code>useUrlQueryParam</code> 来设置和查询相关的<code>query</code> 数据，返回的是一个数组，形式类似于 <code>useState</code> ，一个是值，一个更改这个值</p><p>我们可以看到这个 <code>hook</code> 监听的 <code>url query</code> 是 <code>name、personId</code> 也就是<strong>项目名和负责人</strong>，正符合我们的查询需求</p><p>我们先在 <code>ProjectListScreen</code> 这个 <code>project</code> 的最外层组件中暴露 <code>hook</code> 中返回的两个方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [param, setParam] = <span class="title function_">useProjectsSearchParams</span>()</span><br></pre></td></tr></table></figure><p>这样如果我们通过 <code>setParam</code> 导致了 <code>param</code> 的变化，就会触发 <code>useUrlQueryParam</code> <strong>实现页面的 <code>url</code> 的更新</strong></p><p>例如这里的<strong>搜索模块</strong>，我们通过 <code>props</code> 传递 <code>setParam</code> 方法给子组件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">SearchPanel</span> users=&#123;users || []&#125; param=&#123;param&#125; setParam=&#123;setParam&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在子组件中使用这个方法来控制 <code>param</code> 的变化，从而引起 <code>url</code> 的变化</p><p>例如，我们在监听 <code>input</code> 框输入时</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Input</span></span><br><span class="line">    <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span></span><br><span class="line">    placeholder=&#123;<span class="string">&#x27;项目名&#x27;</span>&#125;</span><br><span class="line">    value=&#123;param.<span class="property">name</span>&#125;</span><br><span class="line">    onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">setParam</span>(&#123;</span><br><span class="line">        ...param,</span><br><span class="line">        <span class="attr">name</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>我们在 <code>onChange</code> 中调用了 <code>setParam</code> 设置了新的 <code>param</code> 值，在 <code>UserSelect</code> 中同样的采用这样的方式修改 <code>param</code> 值，触发 <code>url</code> 的更新，这样我们的功能就实现了一半了，接下来我们需要<strong>利用当前用户查询的 <code>param</code> 去获取数据</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; isLoading, error, <span class="attr">data</span>: list&#125; = <span class="title function_">useProjects</span>(param, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>返回获取到的结果和状态即可，这里采用的 <code>useProjects</code> ，是一个封装的 <code>custom hook</code> ，它会在 <code>param</code> 变化时 ，<strong>通过 <code>useQuery</code> 不断的请求数据</strong>，这也是我们返回的数据中能够有 <code>isLoading、error</code> 这些的原因</p><p><strong>在这里提一下 <code>useQuery</code></strong> ，它是 <code>reacy-query</code> 中的一个 <code>api</code> ，用来做缓存的，接收的第一个参数是用来起名字，第二个参数是异步请求，它会把请求的结果放到缓存中，但是<strong>这个缓存不是浏览器缓存</strong></p><p>第一个参数可以是一个数组，类似于 <code>useEffect</code> ，当依赖项变化的时候就会触发 <code>useQuery</code> 重新执行</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useProjects</span> = (<span class="params">param?: <span class="title class_">Partial</span>&lt;<span class="title class_">Project</span>&gt;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 当 param 变化的时候触发 useQuery 重新渲染，我们需要在第一个参数中传入一个数组，数组的第二位传入依赖</span></span><br><span class="line">    <span class="keyword">return</span> useQuery&lt;<span class="title class_">Project</span>[]&gt;([<span class="string">&#x27;projects&#x27;</span>, param], <span class="function">() =&gt;</span> <span class="title function_">client</span>(<span class="string">&#x27;projects&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的功能也算是基本实现了，但是我们打开控制台会发现有很多很多的请求，这并不是我们想要的，因此我们可以采用防抖，<strong>每隔多少秒，再请求一次</strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-search-keep.gif" alt="jira-project-search-keep"></p><h3 id="3-useDebounce-实现防抖"><a href="#3-useDebounce-实现防抖" class="headerlink" title="3 useDebounce 实现防抖"></a>3 useDebounce 实现防抖</h3><p>为了减少请求的次数，我们封装了一个 <code>useDebounce</code> 方法，用来对数据进行防抖操作</p><p>关于防抖不必多说了吧，这里我们采用的是 <code>useState</code> 来创建这个全局变量，通过 <code>set...</code> 来控制它值的变化，也就这一点不一样的地方</p><p>简单说一说这里的泛型吧，这里我们采用了一个泛型 <code>V</code> ，第一个 <code>&lt;V&gt;</code> 是用来做泛型声明的，它的类型由我们传入的 <code>value</code> 来指定，<code>value</code> 是什么就是什么</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useDebounce = &lt;V&gt;(<span class="attr">value</span>: V, delay?: <span class="built_in">number</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置一个 debouncedValue 值，用于暂存值，以及监控变化</span></span><br><span class="line">    <span class="keyword">const</span> [debouncedValue, setDebouncedValue] = <span class="title function_">useState</span>(value)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 接收一个定时器，参数为一个函数和延时时间 </span></span><br><span class="line">        <span class="comment">// 每次value变化，设置一个定时器</span></span><br><span class="line">        <span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">setDebouncedValue</span>(value), delay)</span><br><span class="line">        <span class="comment">// 每次上一个useEffect 的定时器被清除，相当于上一个定时器被卸载了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        <span class="comment">// 监听value 和 delay 变化，当参数变化时，重新调用这个函数设置定时器</span></span><br><span class="line">    &#125;, [value, delay])</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">return</span> debouncedValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-search1.gif" alt="jira-project-search1"></p><h3 id="📌-总结-2"><a href="#📌-总结-2" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>在这篇文章中我们做完了项目列表的搜索模块，我们能学到这些东西</p><ol><li>已有组件封装新的组件参数类型问题</li><li>如何 实现了输入框与 <code>url</code> 统一</li><li>采用 <code>hook</code> 实现防抖</li></ol><br><h2 id="五-路由跳转页面"><a href="#五-路由跳转页面" class="headerlink" title="五 路由跳转页面"></a>五 路由跳转页面</h2><h3 id="💡-知识点抢先看-3"><a href="#💡-知识点抢先看-3" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h3><ul><li>利用 <code>router 6</code> 实现路由跳转</li><li>封装 <code>useDocumentTitle</code> 来<strong>设置文档的标题</strong></li></ul><p>实现效果</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-router-jump.gif" alt="jira-project-router-jump"></p><h3 id="1-利用-router-实现路由跳转"><a href="#1-利用-router-实现路由跳转" class="headerlink" title="1 利用 router 实现路由跳转"></a>1 利用 router 实现路由跳转</h3><p>实现跳转我们先把视线放到点击的链接上，在这里我们给项目利用了 <code>Link</code> 组件进行包裹，同时采用 <code>to</code> 属性实现了 <code>url</code> 的转变</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">    <span class="attr">sorter</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">name</span>.<span class="title function_">localeCompare</span>(b.<span class="property">name</span>),</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">value, project</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;String(project.id)&#125;</span>&gt;</span>&#123;project.name&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当我们点击第一个项目时，会将路由跳转到了 <code>projects/1</code> 地址下，这样显然是不能找到对应的页面的，它缺少了页面的标识</p><p>我们在 <code>project/index.tsx</code> 文件中，编写侧边栏的样式，以及设置路由的跳转，这里我们需要采用 <code>react-router</code> ，以及 <code>antd</code> 配合实现</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Aside</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Menu</span> <span class="attr">mode</span>=<span class="string">&#123;</span>&#x27;<span class="attr">inline</span>&#x27;&#125; <span class="attr">selectedKeys</span>=<span class="string">&#123;[routeType]&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&#123;</span>&#x27;<span class="attr">kanban</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;<span class="attr">kanban</span>&#x27;&#125;&gt;</span>看板<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&#123;</span>&#x27;<span class="attr">epic</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;<span class="attr">epic</span>&#x27;&#125;&gt;</span>任务组<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Aside</span>&gt;</span><br></pre></td></tr></table></figure><p>在这里我们采用了 <code>Menu</code> 菜单标签，利用了 <code>react-router-dom</code> 中的 <code>Link</code> 组件来实现地址的跳转，侧边栏对地址的操作，会导致右侧，看板和任务组的切换，因此我们需要给右侧配置相应的 <code>Route</code> 连接组件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Main</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">kanban</span>&#x27;&#125; <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">KanbanScreen</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">epic</span>&#x27;&#125; <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">EpicScreen</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        &#123;/* 默认路由是push，相当于又成为了栈顶，也就是当前页面被push了两次，第一次的值不匹配第二次才匹配 */&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;/* 采用replace这样就能替换掉传入的栈顶元素，下面的路由成为了栈顶*/&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#123;window.location.pathname</span> + &#x27;/<span class="attr">kanban</span>&#x27;&#125; <span class="attr">replace</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Main</span>&gt;</span><br></pre></td></tr></table></figure><p>在这里我们需要设置一个 <code>Navigate</code> 用来做路由跳转的兜底方案，当上面<strong>两个都没有匹配</strong>上时，我们将它的地址<strong>拼接</strong>上 <code>/kanban</code> 强制的跳转到 <code>/kanban</code> 页面，这也是实现我们<strong>从项目列表点击跳转后显示看板页面的原因</strong></p><p>在这里有很多值得注意的地方，我们在这里采用了 <code>replace</code> 来<strong>替换路由，这是有原因的！</strong></p><p>浏览器的历史记录就像一个<strong>栈的数据结构</strong>，当我们采用 <code>to</code> 跳转时，实际上是向栈中 <code>push</code> 了一个路由地址，这里我们采用 <code>Navigate</code> 来进行<strong>设置默认路由</strong>，它的操作也是 <code>push</code>，也就是说，我们为了跳转到当前页面被 <code>push</code> 了<strong>两次</strong></p><p>因此当我们点击返回上一页时，又会跳转到当前的 <code>kanban</code> 页面，又向栈中 <code>push</code> 了<strong>两个地址</strong>，这样我们的返回就永远在这里不断地循环，<strong>永远返回不去上一页。</strong></p><p>因此在这里我们需要采用 <code>repalce</code> 去<strong>替换栈顶那个匹配不上的路由地址！</strong></p><p><strong>Q&amp;A</strong></p><p><strong>在实现这部分的时候，遇到了一些问题，稍微提及一下，给后人乘凉</strong></p><p>由于使用的是最新版的 <code>router</code> 在安装的时候，会让你选择版本，目前应该是更新到了 <code>react-router6 - beta4</code> 版本了，在这个版本中使用 <code>Navigate</code> 会有问题，这个 <code>Navigate</code> 的默认路由不会生效，具体原因不是很清楚，遇到这种情况可以降低一下版本到 <code>beta0</code></p><p>这个版本中是没有问题的</p><h3 id="2-封装-useDocumentTitle-来设置文档的标题"><a href="#2-封装-useDocumentTitle-来设置文档的标题" class="headerlink" title="2 封装 useDocumentTitle 来设置文档的标题"></a>2 封装 useDocumentTitle 来设置文档的标题</h3><p>在上面我们已经顺利的实现了路由跳转，对 <code>Router</code> 有了一定的理解，接下来我们来做一个好玩的 <code>hook</code> ，它用来控制文档的标题</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-router-title.gif" alt="jira-project-router-title"></p><p>大概的效果是这样，这个 <code>hook</code> 我们可以<strong>迁移到其他的项目中使用，复用性很高</strong></p><p>我们先理一下思路</p><ol><li>首先需要获取到当前的 <code>title</code></li><li>在调用 <code>hook</code> 的时候需要接收一个 <code>title</code> ，并设置一个 <code>title</code></li><li>会不会有时候设置 <code>title</code> 一样 ，不需要重新设置呢</li></ol><p>我们先来看看我们实现好的 <code>useDocumentTitle</code> 是如何使用的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useDocumentTitle</span>(<span class="string">&#x27;项目列表&#x27;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>第一个参数传递的是需要设置的 <code>title</code> ，第二个参数用来配置 <code>title</code> 在组件卸载时是不是需要变化</p><p>首先我们先来设置一下它接收的参数类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDocumentTitle</span> = (<span class="params"><span class="attr">title</span>: <span class="built_in">string</span>, <span class="attr">keepOnUnmount</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们接收传来的 <code>title</code> 和 配置选项</p><p>首先我们先让 <code>title</code> 能够驱动页面 <code>title</code> 的更新</p><p>我们利用 <code>useEffect</code> 来实现在 <code>title</code> 变化时，修改文档标题</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = title</span><br><span class="line">&#125;, [title])</span><br></pre></td></tr></table></figure><p>接下来我们来处理，组件在卸载时不变化的情况，为什么需要添加这个逻辑呢？</p><p>如果我们不添加这个逻辑的话，需要每个页面都指定 <code>title</code> 如果未指定就会显示默认的 <code>title</code> ，因此我们增加了这个可选配置项</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 useRef 自定义 hook 它会一直帮我们保存好这个 title值，不会改变，</span></span><br><span class="line"><span class="keyword">const</span> oldTitle = <span class="title function_">useRef</span>(<span class="variable language_">document</span>.<span class="property">title</span>).<span class="property">current</span></span><br></pre></td></tr></table></figure><p>首先我们采用 <code>useRef</code> 来保存当前的 <code>title</code>，也就是更改前的 <code>title</code></p><p>接着我们采用 <code>useEffect</code> 来处理在组件卸载时的 <code>title</code> 变化</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 利用闭包不指定依赖得到的永远是旧title ，是代码初次运行时的 oldTitle</span></span><br><span class="line">    <span class="comment">// 不利于别人阅读</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepOnUnmount) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">title</span> = oldTitle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [keepOnUnmount, oldTitle])</span><br></pre></td></tr></table></figure><p>这里我们利用到了闭包的知识， <code>oldTitle</code> 一直是初次运行的 <code>title</code></p><h3 id="📌-总结-3"><a href="#📌-总结-3" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>这篇文章没有太多的内容，写了一个简单的 <code>hook</code> ，稍稍总结一下</p><ol><li>利用 <code>Router</code> 实现路由跳转</li><li>避免 <code>react-router</code> 版本问题，产生的错误</li><li>封装高复用性的 <code>hook</code> <code>useDocumentTitle</code></li></ol><br><h2 id="六-看板页面展示"><a href="#六-看板页面展示" class="headerlink" title="六  看板页面展示"></a>六 看板页面展示</h2><h3 id="💡-知识点抢先看-4"><a href="#💡-知识点抢先看-4" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h3><ul><li>封装 <code>KanbanColumn</code> 来布局页面</li><li>编写大量的 <code>custom hook</code> 来处理看板数据</li><li>对 <code>useQuery</code> 有进一步的了解</li><li>利用 <code>filter</code> 实现数据的统一性</li></ul><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-kanban-show.gif" alt="jira-project-kanban-show"></p><h3 id="一、处理看板数据的-custom-hook"><a href="#一、处理看板数据的-custom-hook" class="headerlink" title="一、处理看板数据的 custom hook"></a>一、处理看板数据的 custom hook</h3><p>在这里我们需要先解决以下<strong>获取看板数据</strong>的问题，有了数据我们才能更好的驱动视图</p><p>我们将这些 <code>hook</code> 单独写在一个 <code>kanban.ts</code> 写在 <code>util</code> 文件夹内，这个文件夹中的 <code>hook</code> 都是一些<strong>复用性高的，和页面关系不大</strong>的 <code>hook</code></p><h4 id="1-useKanbans"><a href="#1-useKanbans" class="headerlink" title="1. useKanbans"></a>1. useKanbans</h4><p>这里获取数据的方法和前面获取项目数据的方法一样，我们采用 <code>useQuery</code> 来进行缓存看板数据，这里我们需要接收一个 <code>param</code> 作为参数，传递当前的 <code>projectId</code> 即可，当这个 <code>id</code> 变化时，表示切换了其他项目的看板，我们需要<strong>重新请求以下</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useKanbans</span> = (<span class="params">param?: <span class="title class_">Partial</span>&lt;<span class="title class_">Kanban</span>&gt;</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 采用 useHttp 来封装请求</span></span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 映射一个 名为 kanbans 的缓存数据，当 param 变化时，重新发送请求，写入缓存</span></span><br><span class="line">    <span class="keyword">return</span> useQuery&lt;<span class="title class_">Kanban</span>[]&gt;([<span class="string">&#x27;kanbans&#x27;</span>, param], <span class="function">() =&gt;</span> <span class="title function_">client</span>(<span class="string">&#x27;kanbans&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装好了 <code>usekanbans</code> ,我们已经能够获取项目中的看板数据了，接下来我们在封装一个 <code>custom hook</code> 来获取 <code>projectId</code> ，以实现 <code>useKanBans</code> 的用处</p><h4 id="2-useProjectIdInUrl"><a href="#2-useProjectIdInUrl" class="headerlink" title="2. useProjectIdInUrl"></a>2. useProjectIdInUrl</h4><p>我们在 <code>kanban</code> 文件夹，下的 <code>util</code> 中编写这段代码，因为它和项目有着直接的关系</p><p>首先在我们之前的路由处理中，我们将我们的 <code>projectId</code> 映射到了 <code>url</code> 上，我们可以通过<strong>解析这个 <code>url</code> 地址来得到当前页面请求的项目 <code>id</code></strong></p><p>这里我们采用 <code>react-router</code> 中的 <code>hook</code> 来得到 <code>pathname</code>，它的格式是这样的 <code>/projects/1/kanban</code></p><p>因此我们通过<strong>正则表达式</strong>来获取出当中的数字也就是我们的 <code>proejctId</code> ，最后返回这个 <code>id</code> 的数字类型即可</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useProjectIdInUrl</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = <span class="title function_">useLocation</span>()</span><br><span class="line">    <span class="comment">// 返回的是一个数组</span></span><br><span class="line">    <span class="keyword">const</span> id = pathname.<span class="title function_">match</span>(<span class="regexp">/projects\/(\d+)/</span>)?.[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-useProjectInUrl"><a href="#3-useProjectInUrl" class="headerlink" title="3. useProjectInUrl"></a>3. useProjectInUrl</h4><p>有了我们的 <code>projectId</code> ，我们就可以使用通过它来获取我们的项目数据，这样我们就能获取到我们的<strong>项目的名称</strong>，显示到页面上</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 id 获取项目信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useProjectInUrl</span> = (<span class="params"></span>) =&gt; <span class="title function_">useProject</span>(<span class="title function_">useProjectIdInUrl</span>())</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: currentProject &#125; = <span class="title function_">useProjectInUrl</span>()</span><br><span class="line">&lt;h1&gt;&#123;currentProject?.<span class="property">name</span>&#125;看板&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>写到这里我们已经能够获取到看板数据以及项目信息了，接下来我们需要来获取对应的任务信息</p><h4 id="4-useKanbanSearchParams"><a href="#4-useKanbanSearchParams" class="headerlink" title="4. useKanbanSearchParams"></a>4. useKanbanSearchParams</h4><p>为了避免我们获取到的看板数据是全部项目中的看板数据，我们需要将 <code>id</code> 转为 <code>key-value</code> 传递给 <code>useKanbans</code> 来获取数据</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useKanbanSearchParams</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">projectId</span>: <span class="title function_">useProjectIdInUrl</span>() &#125;)</span><br></pre></td></tr></table></figure><h4 id="5-useTasks"><a href="#5-useTasks" class="headerlink" title="5. useTasks"></a>5. useTasks</h4><p>接着我们需要来获取 <code>task</code> 数据，也就是我们这个项目的<strong>任务数据</strong></p><p>和获取 <code>kanban</code> 数据一样，我们需要采用 <code>useQuery</code> 来处理</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useTasks</span> = (<span class="params">param?: <span class="title class_">Partial</span>&lt;<span class="title class_">Task</span>&gt;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 搜索框请求在这里触发</span></span><br><span class="line">    <span class="keyword">return</span> useQuery&lt;<span class="title class_">Task</span>[]&gt;([<span class="string">&#x27;tasks&#x27;</span>, param], <span class="function">() =&gt;</span> <span class="title function_">client</span>(<span class="string">&#x27;tasks&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里就讲讲类型吧~</p><p>在这里我们接收一个可选的参数，<code>Task</code> ，<code>Task</code> 是我们封装在 <code>types</code> 中的一个<strong>共享接口</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// 经办人</span></span><br><span class="line">    <span class="attr">processorId</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">projectId</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 任务组</span></span><br><span class="line">    <span class="attr">epicId</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">kanbanId</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// bug or task</span></span><br><span class="line">    <span class="attr">typeId</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">note</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义的都是后端<strong>返回的数据类型</strong></p><p><code>Partial</code> 的作用是，让接口中的变量都变成<strong>可选的</strong></p><p>这样我们就也实现了对看板中的 <code>task</code> 获取，接下来同样的我们需要实现获取对应看板中的 <code>task</code></p><h4 id="6-useTasksSearchParams"><a href="#6-useTasksSearchParams" class="headerlink" title="6. useTasksSearchParams"></a>6. useTasksSearchParams</h4><p>为了让我们获取到的任务数据来自于当前的看板我们也需要封装一个 <code>searchParams</code> 来获取相应项目下的看板信息</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useTaskSearchParams</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">projectId</span>: <span class="title function_">useProjectIdInUrl</span>() &#125;)</span><br></pre></td></tr></table></figure><p>在之后，我们会对这个 <code>hook</code> 进行改造</p><h3 id="二、封装-KanbanColumn-渲染页面"><a href="#二、封装-KanbanColumn-渲染页面" class="headerlink" title="二、封装 KanbanColumn 渲染页面"></a>二、封装 KanbanColumn 渲染页面</h3><h4 id="1-看板和任务数据统一"><a href="#1-看板和任务数据统一" class="headerlink" title="1. 看板和任务数据统一"></a>1. 看板和任务数据统一</h4><p>明确我们这个组件的作用，我们需要用它来渲染每一列的看板</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211010135726728.png" alt="image-20211010135726728"></p><p>大概是这样一个布局，首先，因为我们需要将<strong>任务渲染到对应的看板列表</strong>下，因此首先我们需要解决数据的问题</p><p>我们在 <code>KanbanColumn</code> 中获取数据，在这里我们需要十分明确，这个我们的这个组件它<strong>只是渲染一列</strong>，我们通过遍历实现多列，这个很关键</p><p>我们在 <code>column</code> 中获取所有的 <code>task</code> 数据，<strong>通过 <code>filter</code> 方法，将它筛选出来</strong>，这样，最后得到的就是和 <code>kanbanId</code> 匹配的 <code>task</code> 数据</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: allTasks &#125; = <span class="title function_">useTasks</span>(<span class="title function_">useTasksSearchParams</span>())</span><br><span class="line"><span class="comment">// 对数据进行分类，返回的是三段数据，都是数组</span></span><br><span class="line"><span class="keyword">const</span> tasks = allTasks?.<span class="title function_">filter</span>(<span class="function"><span class="params">task</span> =&gt;</span> task.<span class="property">kanbanId</span> === kanban.<span class="property">id</span>)</span><br></pre></td></tr></table></figure><p><strong>在这里有一个很有意思的问题</strong></p><p>我们个每一个 <code>column</code> 都绑定了一个 <code>useTasks</code> ，按理说它应该会发送<strong>多次的请求</strong> ，我们来看看到底是不是这样</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211010140655996.png" alt="image-20211010140655996"></p><p>在这里我们可以发现它一共发送了 2次请求，但是我启动的这个看板中有三个 <code>column</code></p><p>不妨我们再多添加几个 <code>column</code> ，我们再来看看</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211010140908606.png" alt="image-20211010140908606"></p><p>在这里始终都是只有2个请求，那这是为什么呢？</p><p>其实在我们在遍历添加 <code>kanbanColumns</code> 组件时，只会发起一个请求，即使，我们给每一个 <code>column</code> 都绑定了 <code>useTask</code></p><p>这是因为，我们采用的 <code>react-query</code> 的功劳，在我们采用 <code>useQuery</code> 时，<strong>如果在 2s 之内有相同的 <code>queryKey</code> 发出请求的话，就会合并这些请求，只会发出一个</strong></p><p>现在我们已经有了每个看板下的 <code>Task</code> 数据了，我们只需要遍历渲染即可，这里我们采用的还是 <code>Antd</code> 组件库</p><h4 id="2-useTaskTypes-处理不同类型任务的-icon"><a href="#2-useTaskTypes-处理不同类型任务的-icon" class="headerlink" title="2. useTaskTypes 处理不同类型任务的 icon"></a>2. useTaskTypes 处理不同类型任务的 icon</h4><p>在我们的任务中又分为 <code>bug</code> 和 <code>task</code>，我们都会有相应的图标展示</p><p>在这里我们在 <code>utils</code> 下封装一个 <code>useTaskTypes</code> 来获取 <code>task</code> 的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useTaskTypes</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 获取所有的task type</span></span><br><span class="line">    <span class="keyword">return</span> useQuery&lt;<span class="title class_">TaskType</span>[]&gt;([<span class="string">&#x27;taskTypes&#x27;</span>], <span class="function">() =&gt;</span> <span class="title function_">client</span>(<span class="string">&#x27;taskTypes&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们封装一个 <code>TaskTypeIcon</code> 小组件，来返回类型对应的 <code>icon</code> ，这里我们只需要接收一个 <code>taskid</code> 作为参数，用来<strong>判断这个任务是什么类型</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过type渲染图片</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TaskTypeIcon</span> = (<span class="params">&#123; id &#125;: &#123; id: <span class="built_in">number</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: taskTypes &#125; = <span class="title function_">useTaskTypes</span>()</span><br><span class="line">    <span class="keyword">const</span> name = taskTypes?.<span class="title function_">find</span>(<span class="function"><span class="params">taskType</span> =&gt;</span> taskType.<span class="property">id</span> === id)?.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;</span>&#x27;<span class="attr">task-icon</span>&#x27;&#125; <span class="attr">src</span>=<span class="string">&#123;name</span> === <span class="string">&#x27;task&#x27;</span> ? <span class="attr">taskIcon</span> <span class="attr">:</span> <span class="attr">bugIcon</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、处理任务的搜索功能"><a href="#三、处理任务的搜索功能" class="headerlink" title="三、处理任务的搜索功能"></a>三、处理任务的搜索功能</h3><h4 id="1-useTasksSearchParams"><a href="#1-useTasksSearchParams" class="headerlink" title="1. useTasksSearchParams"></a>1. useTasksSearchParams</h4><p>在我们前面已经有用到这个 <code>hook</code> 了，现在，我们需要添加一些代码，来实现<strong>搜索框的逻辑</strong>，在之前我们通过这个来返回用户 <code>id</code> 的对象，这个功能也不能遗忘噢~</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useTasksSearchParams</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 搜索内容</span></span><br><span class="line">    <span class="keyword">const</span> [param] = <span class="title function_">useUrlQueryParam</span>([</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;typeId&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;processorId&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tagId&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="comment">// 获取当前的项目id用来获取看板数据</span></span><br><span class="line">    <span class="keyword">const</span> projectId = <span class="title function_">useProjectIdInUrl</span>()</span><br><span class="line">    <span class="comment">// 返回的数组，并监听 param变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        projectId,</span><br><span class="line">        <span class="attr">typeId</span>: <span class="title class_">Number</span>(param.<span class="property">typeId</span>) || <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">processId</span>: <span class="title class_">Number</span>(param.<span class="property">processorId</span>) || <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">tagId</span>: <span class="title class_">Number</span>(param.<span class="property">tagId</span>) || <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">name</span>: param.<span class="property">name</span></span><br><span class="line">    &#125;), [projectId, param])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们封装的这个方法，用于返回最小的 <code>task</code> 列表数据，这里需要实现的搜索功能在前面的项目搜索框也实现过了，采用 <code>useSetUrlSearchParam</code> 来修改当前的 <code>url</code> 地址，来造成数据的变化，又由于，我们这个 <code>hook</code> 返回的数据中的依赖项发生改变，造成了显示内容的改变，从而达到搜索效果</p><h4 id="2-重置按钮"><a href="#2-重置按钮" class="headerlink" title="2. 重置按钮"></a>2. 重置按钮</h4><p>在这里勇个比较有意思的按钮，清楚筛选器，它实现的方法请求非常的简单，我们只需要将所有的数据重置为 <code>undefined</code> ，我们的 <code>clean</code> 函数，就会讲 <code>query</code> <strong>修理为空，这样我们返回的数据就会是全部的数据</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setSearchParams</span>(&#123;</span><br><span class="line">        <span class="attr">typeId</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">processId</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">tagId</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、看板的增删改查功能"><a href="#四、看板的增删改查功能" class="headerlink" title="四、看板的增删改查功能"></a>四、看板的增删改查功能</h3><p>这部分的内容和之前的项目列表相似度很高，我们这里就不详细讲了，稍微解释以下这些 <code>hook</code> 的作用</p><h4 id="1-useAddKanban"><a href="#1-useAddKanban" class="headerlink" title="1. useAddKanban"></a>1. useAddKanban</h4><p>接着我们需要处理看板增删的 <code>hook</code> ，在这里我们有必要采用乐观更新来实现，不然在服务器请求慢时，造成页面假死过长</p><p>和前面一样，我们采用 <code>useMutation</code> 来封装 <code>http</code> 请求，返回一个被处理过的 <code>mutate</code> 请求方式或者 <code>mutateAsync</code> 异步请求方式</p><p>在这里我们接收了一个 <code>queryKey</code> 作为参数，这里它是一个数组<strong>第一个元素是缓存中的数据名称</strong>，第二个元素是它的重新刷新的依赖</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAddKanban</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 处理 http 请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="function">(<span class="params"><span class="attr">params</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">Kanban</span>&gt;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`kanbans`</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: params</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// 配置乐观更新</span></span><br><span class="line">        <span class="title function_">useAddConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>config</code> 配置中，我们将在 <code>old</code> 元素中，通过数组解构的方式，将新数据添加到了缓存中，这样我们就实现了对数据的更改</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAddConfig</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; <span class="title function_">useConfig</span>(queryKey, <span class="function">(<span class="params">target, old</span>) =&gt;</span> old ? [...old, target] : [])</span><br></pre></td></tr></table></figure><h4 id="2-useDeleteKanban"><a href="#2-useDeleteKanban" class="headerlink" title="2. useDeleteKanban"></a>2. useDeleteKanban</h4><p><strong>删除看板</strong>的 <code>hook</code> ，在这里我们采用同样的方法，采用的 <code>config</code> 也是我们之前就封装过的，对于所有的增删改都成立的 <code>hook</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除看板</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDeleteKanban</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="function">(<span class="params">&#123; id &#125;: &#123; id: <span class="built_in">number</span> &#125;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`kanbans/<span class="subst">$&#123;id&#125;</span>`</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">useDeleteConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里接收的参数只有 <code>id</code> ，删除看板的 <code>id</code></p><h3 id="五、任务的增删改查功能"><a href="#五、任务的增删改查功能" class="headerlink" title="五、任务的增删改查功能"></a>五、任务的增删改查功能</h3><p>增删改查的功能都差不多，只是传递的参数不一样罢了，在这里，我们就拿一个编辑功能来讲</p><p>我们首先封装了一个控制 <code>modal</code> 开关的 <code>hook</code> <code>useTasksModel</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [form] = <span class="title function_">useForm</span>()</span><br><span class="line"><span class="keyword">const</span> &#123; editingTaskId, editingTask, close &#125; = <span class="title function_">useTasksModel</span>()</span><br><span class="line"><span class="comment">// 解构一个 task 方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">mutateAsync</span>: editTask, <span class="attr">isLoading</span>: editLoading &#125; = <span class="title function_">useEditTask</span>(<span class="title function_">useTasksQueryKey</span>())</span><br><span class="line"><span class="comment">// 添加一个删除任务的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">mutateAsync</span>: deleteTask &#125; = <span class="title function_">useDeleteTask</span>(<span class="title function_">useTasksQueryKey</span>())</span><br><span class="line"><span class="comment">// 点击取消时，调用close同时清空表单</span></span><br></pre></td></tr></table></figure><p>在这里我们暴露出了很多关于任务增删改查的方法，只要调用即可，这里我们在 <code>modal</code> 中，绑定了 <code>onOk</code> 以及 <code>onCancel</code> 方法</p><p>这里有个值得注意的地方</p><p>我们这次采用的是 <code>mutateAsync</code> 异步执行，因此我们需要采用 <code>await</code> 进行等待执行结果</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onCancel</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">close</span>()</span><br><span class="line">    form.<span class="title function_">resetFields</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onOk</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取表单数据</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">editTask</span>(&#123; ...editingTask, ...form.<span class="title function_">getFieldsValue</span>() &#125;)</span><br><span class="line">    <span class="comment">// 关闭表单</span></span><br><span class="line">    <span class="title function_">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="📌-总结-4"><a href="#📌-总结-4" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>在这篇文章中我们做完了看板页面的制作，我们能学到这些东西</p><ol><li>熟悉了增删改查的操作</li><li>了解了 <code>useQuery</code> 的用法</li><li>对 <code>modal</code> 组件有了更多的了解</li><li>了解了 <code>react-query</code> 能够优化请求次数</li></ol><br><h2 id="七-任务组页面实现"><a href="#七-任务组页面实现" class="headerlink" title="七 任务组页面实现"></a>七 任务组页面实现</h2><h3 id="💡-知识点抢先看-5"><a href="#💡-知识点抢先看-5" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h3><ul><li>增删任务组功能</li><li>路由跳转</li></ul><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-epic-show.gif" alt="jira-project-epic-show"></p><h3 id="一、页面布局"><a href="#一、页面布局" class="headerlink" title="一、页面布局"></a>一、页面布局</h3><p>这部分已经写过好几次了，速战速决</p><h4 id="1-布局的简单介绍"><a href="#1-布局的简单介绍" class="headerlink" title="1. 布局的简单介绍"></a>1. 布局的简单介绍</h4><p>这里我们采用的是 <code>antd</code> 中的 <code>List</code> 组件，顶部左右两侧采用的是自己封装的 <code>Row</code> 组件，让它们排列在两侧，链接跳转部分采用的 <code>Link</code> 组件，通过遍历数据的方式实现渲染</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211012154536792.png" alt="image-20211012154536792"></p><h4 id="2-数据的获取"><a href="#2-数据的获取" class="headerlink" title="2. 数据的获取"></a>2. 数据的获取</h4><p>在这里我们需要获取到我们的任务数据，在这里我们需要写一个获取数据的 <code>custom hook</code>： <code>useEpics</code> ，和其他获取数据的 <code>hook</code> 一样</p><p>我们接收一个 <code>param</code> 数据对象，通过 <code>useQuery</code> 发送请求</p><blockquote><p>再复习一下，它的第二个参数是一个异步事件，第一个参数是<strong>元组</strong>，当依赖项 <code>param</code> 发生改变时，会重新发送请求，更新缓存中的 <code>epics</code> 数据内容</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useEpics</span> = (<span class="params">param?: <span class="title class_">Partial</span>&lt;<span class="title class_">Epic</span>&gt;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="keyword">return</span> useQuery&lt;<span class="title class_">Epic</span>[]&gt;([<span class="string">&#x27;epics&#x27;</span>, param], <span class="function">() =&gt;</span> <span class="title function_">client</span>(<span class="string">&#x27;epics&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>epic/index.ts</code> 中使用 ，获取任务组数据 <code>epics</code> 以及用于跳转链接的 <code>tasks</code> 数据</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于任务的信息</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: epics &#125; = <span class="title function_">useEpics</span>(<span class="title function_">useEpicSearchParams</span>())</span><br><span class="line"><span class="comment">// 获取任务组中的任务列表</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: tasks &#125; = <span class="title function_">useTasks</span>(&#123; <span class="attr">projectId</span>: currentProject?.<span class="property">id</span> &#125;)</span><br></pre></td></tr></table></figure><p>这样我们就实现了<strong>数据的获取</strong></p><p>接下来我们来看看如何在组件中使用这两个数据的</p><p>对于 <code>epics</code> 它作为我们需要渲染的主内容，需要通过 <code>List.Item</code> 进行渲染</p><p>在 <code>List</code> 组件中，我们可以传入我们的数据源 <code>dataSource</code> ，通过 <code>renderItem</code> 属性，对 <code>epics</code> 数据进行遍历</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">List</span> dataSource=&#123;epics&#125; renderItem=&#123;<span class="function"><span class="params">epic</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">List.Item</span>&gt;</span><span class="tag">&lt;/<span class="name">List.Item</span>&gt;</span></span> /&gt;</span><br></pre></td></tr></table></figure><p>这样我们的 <code>epic</code> 就是每一个任务数据通过<strong>对象取值</strong>方式就能获取需要的数据</p><p>在这里主要提一下对于时间的渲染</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20211012160029127.png" alt="image-20211012160029127"></p><p><strong>后端给我们返回的数据格式是时间戳，我们需要将她转变成这种格式便于阅读</strong></p><p>在这里我们采用了一个 <code>dayjs</code> 的库，通过 <code>format</code> 方法确定了她输出的时间格式 <code>YYYY-MM-DD</code> ，只需要传入它的时间即可</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;开始时间：&#123;<span class="title function_">dayjs</span>(epic.<span class="property">start</span>).<span class="title function_">format</span>(<span class="string">&quot;YYYY-MM-DD&quot;</span>)&#125;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>结束时间：&#123;dayjs(epic.end).format(&quot;YYYY-MM-DD&quot;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="二、增删任务组功能"><a href="#二、增删任务组功能" class="headerlink" title="二、增删任务组功能"></a>二、增删任务组功能</h3><p>首先我们先来实现删除任务组的功能</p><h4 id="1-删除任务组"><a href="#1-删除任务组" class="headerlink" title="1. 删除任务组"></a>1. 删除任务组</h4><p><strong>实现思路</strong>如下</p><ol><li>点击删除按钮，弹出提示框</li><li>确认删除</li><li>调用接口删除缓存</li></ol><p><strong>代码实现</strong></p><p>当我们点击删除时，我们调用 <code>confirmDeleteEpic</code> 函数，进行删除确认</p><p>这个函数封装的是一个 <code>Modal.config</code> 组件</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除时的提示框</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">confirmDeleteEpic</span> = (<span class="params"><span class="attr">epic</span>: <span class="title class_">Epic</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Modal</span>.<span class="title function_">confirm</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">`你确定删除项目组<span class="subst">$&#123;epic.name&#125;</span>吗？`</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;点击确定删除&#x27;</span>,</span><br><span class="line">        <span class="attr">okText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        <span class="title function_">onOk</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 确认时调用删除</span></span><br><span class="line">            <span class="title function_">deleteEpic</span>(&#123; <span class="attr">id</span>: epic.<span class="property">id</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在点击确认时，正式调用删除接口 <code>deleteEpic</code> ，传入我们删除的任务组 <code>id</code> ，即可删除</p><p>我们来看看如何实现这个 <code>deleteEpic</code></p><p>首先我们还是需要封装一个 <code>useDeleteEpic</code> 的 <code>hook</code> 用来<strong>处理删除请求</strong>，这里采用 <code>useMutation</code> 来处理，传入当前的 <code>id</code> ，<strong>配置删除的 <code>config</code> 对象</strong></p><blockquote><p>写到这里自己也对 <code>useMutation</code> 有了进一步的认识，它可以接收两个参数，第一个参数我们<strong>传入我们的异步请求</strong>，第二个参数来配置 <code>config</code> <strong>如何处理缓存中的数据</strong></p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除看板</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDeleteEpic</span> = (<span class="params"><span class="attr">queryKey</span>: <span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="comment">// 这里我没有出现问题，视频出现了问题</span></span><br><span class="line">        <span class="comment">// 直接（id:number)</span></span><br><span class="line">        <span class="function">(<span class="params">&#123; id &#125;: &#123; id: <span class="built_in">number</span> &#125;</span>) =&gt;</span> <span class="title function_">client</span>(<span class="string">`epics/<span class="subst">$&#123;id&#125;</span>`</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">useDeleteConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的删除功能就实现了</p><h4 id="2-添加任务组功能"><a href="#2-添加任务组功能" class="headerlink" title="2. 添加任务组功能"></a>2. 添加任务组功能</h4><p>实现思路</p><ol><li>写一个 <code>create-epic</code> 页面</li><li>写入新增任务组信息</li><li>提交创建请求</li></ol><p><strong>代码实现</strong></p><p>首先我们需要在 <code>epic</code> 文件夹目录下创建一个 <code>create-epic</code> 文件，用来编写创建任务页面</p><blockquote><p>这样做的好处是能够将复杂部分分离出来，使得主文件中的代码量减少，阅读性更佳</p></blockquote><p>新增任务组页面，我们同样采用的是 <code>Drawer</code> 组件来实现</p><p>值得注意的是我们必须要添加 <code>forceRender=&#123;true&#125;</code> 组件，否则在页面第一次加载时会报错</p><p>在 <code>Drawer</code> 组件中同样的我们采用了 <code>Form</code> 组件，<strong>当表单提交时自动调用 <code>onFinish</code> 方法，处理添加请求</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onFinish</span> = <span class="keyword">async</span> (<span class="params"><span class="attr">values</span>: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 仅仅传一个values 不够，需要传入 projectid</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">addEpic</span>(&#123; ...values, projectId &#125;)</span><br><span class="line">    props.<span class="title function_">onClose</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们采用的时一个 <code>async</code>、<code>await</code> 的组合，等待接口返回结果后我们再关闭窗口，但是由于我们采用了乐观更新，这里其实只要写入缓存中就会关闭窗口了</p><p>同时为了让 <code>Form</code> 表单在窗口关闭时自动清空，这里我们采用了 <code>useEffect</code> 来实现，在依赖项中写入 <code>visible</code> 监听变化</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    form.<span class="title function_">resetFields</span>()</span><br><span class="line">&#125;, [form, props.<span class="property">visible</span>])</span><br></pre></td></tr></table></figure><p>这样我们的创建功能也实现了，最后我们再稍微讲讲任务组 <code>item</code> 中的路由跳转</p><h3 id="三、路由跳转"><a href="#三、路由跳转" class="headerlink" title="三、路由跳转"></a>三、路由跳转</h3><p>当我们点击下面的任务时，需要跳转到看板页面对应任务的编辑窗口，我们来看看效果图</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-epic-router.gif" alt="jira-project-epic-router"></p><p>其实这只要我们的路由地址配置好了就没有问题了</p><p>我们来看看如何配置这个跳转的<strong>路由地址</strong></p><p>指定到对应的 <code>editingTaskId</code> 页面，这样窗口就会弹出来了，这样是我们采用 <code>url</code> 进行状态管理的好处</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to=&#123;<span class="string">`/projects/<span class="subst">$&#123;currentProject?.id&#125;</span>/kanban?editingTaskId=<span class="subst">$&#123;task.id&#125;</span>`</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>那么我们如何将对应的任务绑定到对应的任务组下呢？</strong></p><p>这里我们采用 <code>filter</code> 来实现，当 <code>task</code> 下的 <code>epicId</code> 和 <code>epic</code> 下的 <code>id</code> 一致时说明是这个任务组下的，我们遍历渲染即可</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tasks?.<span class="title function_">filter</span>(<span class="function"><span class="params">task</span> =&gt;</span> task.<span class="property">epicId</span> === epic.<span class="property">id</span>)</span><br><span class="line">        .<span class="title function_">map</span>(<span class="function"><span class="params">task</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginRight:</span> &#x27;<span class="attr">20px</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;task.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            // <span class="attr">链接到看板页面</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">projects</span>/$&#123;<span class="attr">currentProject</span>?<span class="attr">.id</span>&#125;/<span class="attr">kanban</span>?<span class="attr">editingTaskId</span>=<span class="string">$&#123;task.id&#125;</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;task.name&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：采用 <code>map</code> 是一定要注意 <code>key</code> 唯一噢~</p></blockquote><hr><h3 id="📌-总结-5"><a href="#📌-总结-5" class="headerlink" title="📌 总结"></a>📌 总结</h3><ol><li>能够熟练的实现了增删功能</li><li>认识到了 <code>url</code> 状态管理的好处</li><li>采用合适的数组的方法可以极好的帮助我们实现功能</li></ol><br><h2 id="八-拖拽功能实现"><a href="#八-拖拽功能实现" class="headerlink" title="八 拖拽功能实现"></a>八 拖拽功能实现</h2><h3 id="💡-知识点抢先看-6"><a href="#💡-知识点抢先看-6" class="headerlink" title="💡 知识点抢先看"></a>💡 知识点抢先看</h3><ul><li>给看板添加拖拽功能</li><li>讲解 HTML5 中的 <code>drop</code> 和 <code>drag</code></li></ul><h3 id="一、给看板添加拖拽功能"><a href="#一、给看板添加拖拽功能" class="headerlink" title="一、给看板添加拖拽功能"></a>一、给看板添加拖拽功能</h3><p>这一篇文章就只讲一个部分，正如标题所说，添加一个<strong>拖拽功能</strong></p><p>实现效果像这样</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/jira-project-kanban-drag.gif" alt="jira-project-kanban-drag"></p><p>我们实现这个功能采用了一个 <code>react-beautiful-dnd</code> 的库，关于这个库可以查看 ： <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-beautiful-dnd">npm官网</a></p><p>关于这个库的使用呢，我们简单的介绍一下，首先我们需要定义一个 <code>Droppable</code> 组件来包裹我们的拖拽的元素，表示这块区域的内容我们能够拖拽，其次需要对<strong>放的地方</strong>，也就是我们的元素添加一个 <code>Draggable</code> 组件包裹，用来表示这块区域是能够放下的区域</p><p>在这里是重写了自带的 <code>Drop</code> 和 <code>Drag</code> 组件</p><p><strong>这部分比较难，搞得不是很懂，提几个点吧</strong></p><ul><li>在这里我们想要抽离出一个 <code>children</code> 属性，不使用原生的 <code>children</code> 属性</li><li>由于 API 的要求，我们需要预留接收 <code>ref</code>，这里我们采用转发的方式来实现，通过 <code>forwardRef</code> 的方式来实现</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DropChild</span> = <span class="title class_">React</span>.<span class="property">forwardRef</span>&lt;<span class="title class_">HTMLDivElement</span>, <span class="title class_">DropChildProps</span>&gt;(<span class="function">(<span class="params">&#123; children, ...props &#125;, ref</span>) =&gt;</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;/* api要求加的 */&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;props.provided?.placeholder&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="1-实现-Drop-组件"><a href="#1-实现-Drop-组件" class="headerlink" title="1. 实现 Drop 组件"></a>1. 实现 <code>Drop</code> 组件</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个文件相当于重构了 drop 原生组件</span></span><br><span class="line"><span class="comment">// 定义一个类型，不想用 自带的 children ，采用自己的</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DropProps</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">DroppableProps</span>, <span class="string">&#x27;children&#x27;</span>&gt; &amp; &#123; <span class="attr">children</span>: <span class="title class_">ReactNode</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Drop</span> = (<span class="params">&#123; children, ...props &#125;: <span class="title class_">DropProps</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Droppable</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            (provided =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                if (React.isValidElement(children)) &#123;</span></span><br><span class="line"><span class="language-xml">                    // 给所有的子元素都加上props属性</span></span><br><span class="line"><span class="language-xml">                    return React.cloneElement(children, &#123;</span></span><br><span class="line"><span class="language-xml">                        ...provided.droppableProps,</span></span><br><span class="line"><span class="language-xml">                        ref: provided.innerRef,</span></span><br><span class="line"><span class="language-xml">                        provided</span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Droppable</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现-Drag-组件"><a href="#2-实现-Drag-组件" class="headerlink" title="2. 实现 Drag 组件"></a>2. 实现 <code>Drag</code> 组件</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DragProps</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">DraggableProps</span>, <span class="string">&#x27;children&#x27;</span>&gt; &amp; &#123; <span class="attr">children</span>: <span class="title class_">ReactNode</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Drag</span> = (<span class="params">&#123; children, ...props &#125;: <span class="title class_">DragProps</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Draggable</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            provided =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                if (React.isValidElement(children)) &#123;</span></span><br><span class="line"><span class="language-xml">                    return React.cloneElement(children, &#123;</span></span><br><span class="line"><span class="language-xml">                        ...provided.draggableProps,</span></span><br><span class="line"><span class="language-xml">                        ...provided.dragHandleProps,</span></span><br><span class="line"><span class="language-xml">                        ref: provided.innerRef</span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Draggable</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-拖拽持久化"><a href="#3-拖拽持久化" class="headerlink" title="3. 拖拽持久化"></a>3. 拖拽持久化</h4><p>写好了两个组件，虽然很难，可以直接 <code>cv</code> 一下这部分的代码。</p><ul><li>理解起来还是挺可以的，使用 <code>Drop</code> 组件包裹拖得位置，用 <code>Drag</code> 组件包裹放的位置</li><li>最后我们需要持久化我们的状态，这里采用的是原生组件中自带的 <code>onDragEnd</code> 方法来实现</li></ul><p>我们在这里需要再实现一个 <code>hook</code> 来实现这个功能，很难</p><p>这里我们通过 <code>if</code> 判断它当前<strong>是拖的看板还是任务</strong>，判断一下是<strong>左右</strong>还是<strong>上下</strong>拖拽，通过组件中自带的方法计算出放下的 <code>id</code> 和拿起来的 <code>id</code> 将它插入到这个 <code>kanban</code> 任务中即可</p><blockquote><p>当我们拖拽完成时，会返回 <code>source</code> 和 <code>destination</code> 对象，这里面有我们拖拽的相关信息</p></blockquote><p>如果是 <code>column</code> 的话就是看板之间的拖拽，我们需要调用我们新封装的一个 <code>useReorderKanban</code> 方法进行持久化</p><p>如果是 <code>row</code> 则调用任务之间的持久化方法 <code>useRecordTask</code> 方法进行持久化</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDragEnd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 先取到看板</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: kanbans &#125; = <span class="title function_">useKanbans</span>(<span class="title function_">useKanbanSearchParams</span>())</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">mutate</span>: reorderKanban &#125; = <span class="title function_">useReorderKanban</span>(<span class="title function_">useKanbansQueryKey</span>())</span><br><span class="line">    <span class="comment">// 获取task信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: allTasks = []&#125; = <span class="title function_">useTasks</span>(<span class="title function_">useTasksSearchParams</span>())</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">mutate</span>: reorderTask &#125; = <span class="title function_">useReorderTask</span>(<span class="title function_">useTasksQueryKey</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useCallback</span>(<span class="function">(<span class="params">&#123; source, destination, <span class="keyword">type</span> &#125;: <span class="title class_">DropResult</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!destination) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看板排序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;COLUMN&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> fromId = kanbans?.[source.<span class="property">index</span>].<span class="property">id</span></span><br><span class="line">            <span class="keyword">const</span> toId = kanbans?.[destination.<span class="property">index</span>].<span class="property">id</span></span><br><span class="line">            <span class="comment">// 如果没变化的时候直接return</span></span><br><span class="line">            <span class="keyword">if</span> (!fromId || !toId || fromId === toId) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断放下的位置在目标的什么方位</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">type</span> = destination.<span class="property">index</span> &gt; source.<span class="property">index</span> ? <span class="string">&#x27;after&#x27;</span> : <span class="string">&#x27;before&#x27;</span></span><br><span class="line">            <span class="title function_">reorderKanban</span>(&#123; fromId, <span class="attr">referenceId</span>: toId, <span class="keyword">type</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;ROW&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过 + 转变为数字</span></span><br><span class="line">            <span class="keyword">const</span> fromKanbanId = +source.<span class="property">droppableId</span></span><br><span class="line">            <span class="keyword">const</span> toKanbanId = +destination.<span class="property">droppableId</span></span><br><span class="line">            <span class="comment">// 不允许跨版排序</span></span><br><span class="line">            <span class="keyword">if</span> (fromKanbanId !== toKanbanId) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取拖拽的元素</span></span><br><span class="line">            <span class="keyword">const</span> fromTask = allTasks.<span class="title function_">filter</span>(<span class="function"><span class="params">task</span> =&gt;</span> task.<span class="property">kanbanId</span> === fromKanbanId)[source.<span class="property">index</span>]</span><br><span class="line">            <span class="keyword">const</span> toTask = allTasks.<span class="title function_">filter</span>(<span class="function"><span class="params">task</span> =&gt;</span> task.<span class="property">kanbanId</span> === fromKanbanId)[destination.<span class="property">index</span>]</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (fromTask?.<span class="property">id</span> === toTask?.<span class="property">id</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">reorderTask</span>(&#123;</span><br><span class="line">                <span class="attr">fromId</span>: fromTask?.<span class="property">id</span>,</span><br><span class="line">                <span class="attr">referenceId</span>: toTask?.<span class="property">id</span>,</span><br><span class="line">                fromKanbanId,</span><br><span class="line">                toKanbanId,</span><br><span class="line">                <span class="attr">type</span>: fromKanbanId === toKanbanId &amp;&amp; destination.<span class="property">index</span> &gt; source.<span class="property">index</span> ? <span class="string">&#x27;after&#x27;</span> : <span class="string">&#x27;before&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [allTasks, kanbans, reorderKanban, reorderTask])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-useReorderKanban"><a href="#4-useReorderKanban" class="headerlink" title="4. useReorderKanban"></a>4. useReorderKanban</h4><p>通过传入一组数据，包括起始位置，插入位置，在插入位置的前面还是后面，这些数据，进行后台接口的判断，来进行持久化，这里采用的 <code>useMutation</code> 就是前面讲的，使用方法都很熟练了</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持久化数据接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useReorderKanban</span> = (<span class="params"><span class="attr">queryKey</span>:<span class="title class_">QueryKey</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">        <span class="function">(<span class="params"><span class="attr">params</span>: <span class="title class_">SortProps</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">client</span>(<span class="string">&#x27;kanbans/reorder&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">data</span>: params,</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">useReorderKanbanConfig</span>(queryKey)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-在-HTML5-中新增的-Drop-和-Drag"><a href="#5-在-HTML5-中新增的-Drop-和-Drag" class="headerlink" title="5. 在 HTML5 中新增的 Drop 和 Drag"></a>5. 在 HTML5 中新增的 Drop 和 Drag</h4><p>当我们需要设置某个元素可拖放时，只需要 <code>draggable</code> 设置为 <code>true</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当拖放执行时，会发生 <code>ondragstart</code> 和 <code>setData()</code></p><p>执行 <code>ondragstart</code> 会调用一个函数 <code>drag</code> 函数，它规定了被拖拽的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">event</span>)</span><br><span class="line">&#123;</span><br><span class="line">    event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;Text&quot;</span>,ev.<span class="property">target</span>.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>Text</code> 时我们需要添加到 <code>drag object</code> 中的数据类型</p></blockquote><p>在何处放置被拖动的数据</p><blockquote><p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p><p>这要通过调用 <code>ondragover</code> 事件的 <code>event.preventDefault()</code> 方法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="title function_">preventDefault</span>()</span><br></pre></td></tr></table></figure><p>当防止时会发生 <code>drop</code> 事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drop</span>(<span class="params">ev</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ev.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">var</span> data=ev.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line">    ev.<span class="property">target</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><ul><li>调用 <code>preventDefault()</code> 来避免浏览器对数据的默认处理（<code>drop</code> 事件的默认行为是以链接形式打开）</li><li>通过 <code>dataTransfer.getData(&quot;Text&quot;)</code> 方法获得被拖的数据。该方法将返回在 <code>setData()</code> 方法中设置为相同类型的任何数据。</li><li>被拖数据是被拖元素的 <code>id (&quot;drag1&quot;)</code></li><li>把被拖元素追加到放置元素（目标元素）中</li></ul><p>(参考于<a target="_blank" rel="noopener" href="https://www.runoob.com/html/html5-draganddrop.html">菜鸟教程</a>)</p><p>可以亲自试一试：<a target="_blank" rel="noopener" href="https://codepen.io/linjc55/pen/ZEJWBrN">在线演示</a></p><h3 id="📌-总结-6"><a href="#📌-总结-6" class="headerlink" title="📌 总结"></a>📌 总结</h3><ol><li>大概了解了一下如何使用 <code>react-beautiful-dnd</code></li><li>关于拖拽持久化有了大概的认识</li><li>了解了 HTML5 中的 <code>drop</code> 和 <code>drag</code></li></ol><br><h2 id="终-项目总结"><a href="#终-项目总结" class="headerlink" title="终 项目总结"></a>终 项目总结</h2><h3 id="💡-内容抢先看"><a href="#💡-内容抢先看" class="headerlink" title="💡 内容抢先看"></a>💡 内容抢先看</h3><ul><li>技术栈</li><li>Q&amp;A 文档</li></ul><p>整个项目已经学习完了，也做出来了，但是缺少后端服务器，还无法上线，稍做总结吧~</p><h3 id="一、采用技术栈"><a href="#一、采用技术栈" class="headerlink" title="一、采用技术栈"></a>一、采用技术栈</h3><p>本文采用了以下技术</p><ul><li>React 17</li><li>React Hook</li><li>TS4</li><li>Hook + Content</li><li>React Query</li><li>CSS in JS</li><li>React Router 6</li></ul><p>采用 <code>content</code> 来做全局状态管理</p><p>利用 <code>React Query</code> 进行 <code>url</code> 缓存，实现 <code>url</code> 状态管理</p><p>利用 <code>CSS in JS</code> 来替代传统组织式的 CSS 代码，将 HTML 与 CSS 选择器解耦，实现真正的组件化</p><p>利用 <code>TS4</code> 来规范 <code>JS</code> 进行类型检查，规范代码</p><h3 id="二、Q-amp-A-文档"><a href="#二、Q-amp-A-文档" class="headerlink" title="二、Q&amp;A 文档"></a>二、Q&amp;A 文档</h3><h4 id="1-怎么实现页面刷新后仍然是上一次的状态？"><a href="#1-怎么实现页面刷新后仍然是上一次的状态？" class="headerlink" title="1. 怎么实现页面刷新后仍然是上一次的状态？"></a>1. 怎么实现页面刷新后仍然是上一次的状态？</h4><p>通过 <code>token</code> 以及本地存储实现，我们在登录时，会将token 存储到本地中，这一步不需要我们手动操作，用的老师的库会自动实现。我们在初始化页面的时候，需要挂载一个 <code>useMount</code> 方法进行初始化，在这个函数里，主要进行的是 <code>token</code> 令牌的判断，如果存在 <code>token</code> 我们就，发送一个请求去获取用户数据 <code>data</code></p><p>然后返回 <code>user</code> 数据</p><h4 id="2-为什么使用-catch-中的-err-会报错呢？"><a href="#2-为什么使用-catch-中的-err-会报错呢？" class="headerlink" title="2. 为什么使用 catch 中的 err 会报错呢？"></a>2. 为什么使用 catch 中的 err 会报错呢？</h4><p>在 <code>TS4.4</code> 版本中规定了 <code>catch</code> 中的 <code>err</code> 对象默认类型为 <code>unknown</code> ，因此我们不能用它向其他东西赋值，我们可以先进行类型设置</p><p>那为什么使用连写的方式就可以呢 <code>login(values).catch(onError)</code> 原因是，我们的 <code>login</code> 调用是异步的，但是一旦调用就会执行 <code>catch</code> ，因此获取不到值</p><p>一方面可以采用 <code>async</code> 来解决，也可以连写</p><h4 id="3-为什么控制台打印-error-总是-null"><a href="#3-为什么控制台打印-error-总是-null" class="headerlink" title="3. 为什么控制台打印 error 总是 null"></a>3. 为什么控制台打印 error 总是 null</h4><p>原因是 Hook 中的事件是异步的，例如 <code>useState</code> 是异步的，会先执行打印 <code>error</code></p><p>严重问题，error 无法获取</p><p>解决！！！！</p><p>通过 <code>then</code> 的第二个参数，获取到返回错误的 <code>promise</code> 对象，然后，再通过 <code>throw</code> 抛出这个错误</p><p>被外层的 <code>catch</code> 接收，注意！！抛出错误中的 <code>then</code> 方法是一个异步事件，需要通过 <code>async</code> 来解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 成功则处理stat</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="title function_">setData</span>(data)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;222&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;, <span class="title function_">async</span>(err) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">    <span class="comment">// 卧槽，尼玛的，解决了catch 获取不到错误的问题</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">await</span> err.<span class="title function_">then</span>())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其他代码不变</p><p>同时注意，在 <code>fetch</code> 中返回错误，不能用 return 需要用 <code>throw</code> ，抛出 promise 错误</p><h4 id="4-页面的不同-title-是如何实现的？"><a href="#4-页面的不同-title-是如何实现的？" class="headerlink" title="4. 页面的不同 title 是如何实现的？"></a>4. 页面的不同 title 是如何实现的？</h4><p>采用自定义的 hook <code>useDocumentTitle</code> ，监听title 的变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDocumentTitle</span> = (<span class="params"><span class="attr">title</span>: <span class="built_in">string</span></span>) =&gt;&#123;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = title</span><br><span class="line">    &#125;, [title])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这不是最优的方案，直接这样使用会造成页面退出时获取标题丢失，我们想要的是，当我们退出登录时，标题会到 <code>jira 平台...</code> 字样</p><p>我们需要将页面中的最开始的那个 <code>title</code> 保存起来，也就是 <code>jira...</code> 然后，在当前页面被卸载时，改变这个 <code>title</code></p><p>我们可以利用 <code>hook</code> 天然的闭包特性来实现，但是这样会造成的问题是，不利于别人阅读我们的代码，闭包还是一个挺难发现的东西，在 <code>hook</code> 中</p><p>我们可以使用 <code>useRef</code> ，它能够帮我们保存变量的最初始状态，也就是 <code>jira...</code> ，因此这样也可以解决我们的问题，我们添加多一个 <code>useEffect</code> 来监听页面的卸载，当卸载时我们就设置会原先的 <code>title</code></p><p>最终版 <code>useDocumentTitle</code> 自定义 <code>hook</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 title 的 hook</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDocumentTitle</span> = (<span class="params"><span class="attr">title</span>: <span class="built_in">string</span>, <span class="attr">keepOnUnmount</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 利用 useRef 自定义 hook 它会一直帮我们保存好这个 title值，不会改变，</span></span><br><span class="line">    <span class="keyword">const</span> oldTitle = <span class="title function_">useRef</span>(<span class="variable language_">document</span>.<span class="property">title</span>).<span class="property">current</span></span><br><span class="line">    <span class="comment">// const oldTitle = document.title</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = title</span><br><span class="line">    &#125;, [title])</span><br><span class="line">    <span class="comment">// 页面卸载时，重新设置为原来的 title</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 利用闭包不指定依赖得到的永远是旧title ，是代码初次运行时的 oldTitle</span></span><br><span class="line">        <span class="comment">// 不利于别人阅读</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!keepOnUnmount) &#123;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">title</span> = oldTitle</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [keepOnUnmount, oldTitle])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-为什么采用-Navigate-会无法设置默认跳转呢？"><a href="#5-为什么采用-Navigate-会无法设置默认跳转呢？" class="headerlink" title="5. 为什么采用 Navigate 会无法设置默认跳转呢？"></a>5. 为什么采用 Navigate 会无法设置默认跳转呢？</h4><p>盲猜版本迭代</p><p>艹，不要安装 <code>beta4</code> 版本，安装 <code>beta.0</code> ，第四版中的 <code>Navigate</code> 失效了</p><h4 id="6-在采用-antd-自定义组件的时候，如何开放更多的类型呢？"><a href="#6-在采用-antd-自定义组件的时候，如何开放更多的类型呢？" class="headerlink" title="6. 在采用 antd 自定义组件的时候，如何开放更多的类型呢？"></a>6. 在采用 antd 自定义组件的时候，如何开放更多的类型呢？</h4><p>我们可以利用 <code>React</code> 自带的方法，获取到组件身上的全部类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SelectProps</span> = <span class="title class_">React</span>.<span class="property">ComponentProps</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Select</span>&gt;</span><br></pre></td></tr></table></figure><p>然后，通过 <code>extends</code> 来继承 <code>SelectProps</code> 身上的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdSelectProps</span> <span class="keyword">extends</span> <span class="title class_">SelectProps</span> </span><br></pre></td></tr></table></figure><p>但是这样会有类型冲突的问题</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210924105645394.png" alt="image-20210924105645394"></p><p>因此我们需要排除掉我们在这里使用过的类型，采用 <code>Omit</code> 方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdSelectProps</span> <span class="keyword">extends</span> <span class="title class_">Omit</span>&lt;<span class="title class_">SelectProps</span>, &#x27;value&#x27; | &quot;onChange&quot; | &quot;options&quot; | &quot;defaultOptionName&quot;&gt;</span><br></pre></td></tr></table></figure><p>这样我们定义的类型就能够接收所有的 <code>props</code> 了，最后还要解构一下其他的 <code>props</code> 噢</p><h4 id="7-什么时候命名-ts，tsx-文件呢？"><a href="#7-什么时候命名-ts，tsx-文件呢？" class="headerlink" title="7. 什么时候命名 ts，tsx 文件呢？"></a>7. 什么时候命名 ts，tsx 文件呢？</h4><p>当包含模板文件的时候采用 <code>tsx</code> 文件，不包含模板代码的时候使用 <code>ts</code> 文件，不然会引起误会</p><h4 id="8-在代码中出现的-是什么意思呢"><a href="#8-在代码中出现的-是什么意思呢" class="headerlink" title="8. 在代码中出现的 !! 是什么意思呢"></a>8. 在代码中出现的 !! 是什么意思呢</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onCheckedChange?.(!!num)</span><br></pre></td></tr></table></figure><p>例如这里的 <code>!!num</code></p><p>它代表的意思是 <code>Boolean(num)</code> 将 <code>num</code> 转化成 <code>boolean</code> 类型 <code>true or false</code></p><h4 id="9-在组件中我们不能使用-hook，那我们如何更改组件状态呢？"><a href="#9-在组件中我们不能使用-hook，那我们如何更改组件状态呢？" class="headerlink" title="9. 在组件中我们不能使用 hook，那我们如何更改组件状态呢？"></a>9. 在组件中我们不能使用 hook，那我们如何更改组件状态呢？</h4><p>我们可以在我们的自定义 hook 中，暴露一个函数，我们通过调用这个函数来实现状态的更新</p><h4 id="10-在请求数据返回之前如果页面被卸载了，造成报错如何解决"><a href="#10-在请求数据返回之前如果页面被卸载了，造成报错如何解决" class="headerlink" title="10. 在请求数据返回之前如果页面被卸载了，造成报错如何解决"></a>10. 在请求数据返回之前如果页面被卸载了，造成报错如何解决</h4><p>这个问题的来源是，我们在请求数据的时候，<strong>我们登出了页面</strong>，当前的 <code>setData</code> <strong>还没有结束</strong>，当完成时，需要渲染的页面已经不存在了，因此我们<strong>需要判断一下</strong>，页面是否被卸载再来渲染组件</p><p>为此我们写了一个自定义的 <code>hook</code> 用来判断组件是否被卸载</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useMountedRef</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> mountedRef = <span class="title function_">useRef</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 通过 useEffect hook 来监听组件状态 </span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        mountedRef.<span class="property">current</span> = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            mountedRef.<span class="property">current</span> = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> mountedRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要利用了 <code>useEffect</code> 的特性，当组件卸载时执行 <code>return</code> ，当我们写自定义 hook 的话，如果返回一个函数，非常大概率是需要使用 <code>useMemo</code> 或 <code>useCallback</code></p><p>非常重要</p><h4 id="11-怎么理解-component-composition-这种透传数据的模式"><a href="#11-怎么理解-component-composition-这种透传数据的模式" class="headerlink" title="11. 怎么理解 component composition 这种透传数据的模式"></a>11. 怎么理解 component composition 这种透传数据的模式</h4><p>引用官网的一句话</p><blockquote><p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p><p><strong>如果你只是想避免层层传递一些属性，<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">组件组合（component composition）</a>有时候是一个比 context 更好的解决方案。</strong></p></blockquote><p><strong>我们把我们需要用到数据的那个组件直接丢到数据来源的 props 身上</strong> ，然后消费数据，把消费完的组件，也就是要被渲染到页面的内容，通过 <code>props</code> 传回来。这就是 <code>component compositon</code> ，简单粗暴，我们在原来的地方，直接渲染这个组件即可</p><p>例如：我们在 <code>Page</code> 组件中需要传递个 <code>Auth</code> 组件 <code>user</code> 信息，它们之间有很多的深层嵌套</p><p>我们可以这么做 （官网例子）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.<span class="property">user</span>;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;props.avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;userLink&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们有这样的组件：</span></span><br><span class="line">&lt;<span class="title class_">Page</span> user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...Page的子组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;...&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...PageLayout的子组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">userLink</span>=<span class="string">&#123;...&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&#123;props.<span class="property">userLink</span>&#125;</span><br></pre></td></tr></table></figure><p>这样我们只用传递 <code>userLink</code> 即可，</p><h4 id="12-为什么创建和编辑中的关闭按钮，只有一个起作用？"><a href="#12-为什么创建和编辑中的关闭按钮，只有一个起作用？" class="headerlink" title="12. 为什么创建和编辑中的关闭按钮，只有一个起作用？"></a>12. 为什么创建和编辑中的关闭按钮，只有一个起作用？</h4><p>造成这个问题主要原因在于这段代码</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">close</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setEditingProjectId</span>(&#123; <span class="attr">editingProjectId</span>: <span class="literal">undefined</span> &#125;);</span><br><span class="line">    <span class="title function_">setProjectCreate</span>(&#123; <span class="attr">projectCreate</span>: <span class="literal">undefined</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现哪条语句在前面，哪个就生效，在前面的那个不会生效，初步判断造成问题的原因是异步操作，但是还没有找到解决的方法</p><p>更正问题来源：由于后面的那一条会把前面的数据重新设置上去造成的</p><p>最终将这里的两次调用抽成了一次，将 <code>seturl...</code> 函数抽象成两个，一个读取，一个设置</p><h4 id="13-搜索框的功能是如何实现的？"><a href="#13-搜索框的功能是如何实现的？" class="headerlink" title="13. 搜索框的功能是如何实现的？"></a>13. 搜索框的功能是如何实现的？</h4><p>在 <code>useTask</code> 中触发，发送请求</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useTasks</span> = (<span class="params">param?: <span class="title class_">Partial</span>&lt;<span class="title class_">Task</span>&gt;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">    <span class="comment">// 搜索框请求在这里触发</span></span><br><span class="line">    <span class="keyword">return</span> useQuery&lt;<span class="title class_">Task</span>[]&gt;([<span class="string">&#x27;tasks&#x27;</span>, param], <span class="function">() =&gt;</span> <span class="title function_">client</span>(<span class="string">&#x27;tasks&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-如何部署到-github-上？"><a href="#14-如何部署到-github-上？" class="headerlink" title="14. 如何部署到 github 上？"></a>14. 如何部署到 github 上？</h4><ol><li><p>部署github，创建一个 名字.github.io</p></li><li><p><code>yarn add gh-pages -D</code> 安装包</p></li><li><pre><code class="shell">// 在 package.json 中配置一下
&quot;predeploy&quot;: &quot;npm run build&quot;,
&quot;deploy&quot;: &quot;gh-pages -d build -r git@github.com:linjunc/linjunc.github.io.git -b main&quot;
</code></pre></li><li><p>执行 <code>npm run deploy</code> 命令</p></li></ol><h4 id="15-useMemo-和-useCallback-有什么区别？"><a href="#15-useMemo-和-useCallback-有什么区别？" class="headerlink" title="15. useMemo 和 useCallback 有什么区别？"></a>15. useMemo 和 useCallback 有什么区别？</h4><ul><li><code>useCallback</code> ：就是返回一个函数，只有在依赖项发生变化的时候才会更新。<strong>一般在函数返回函数时，需要使用 <code>useCallback</code> 来包裹</strong>。更多的时<strong>防止子组件重新渲染</strong></li></ul><blockquote><p><code>useCallback</code> 返回一个<strong>函数</strong>，当把它返回的这个函数作为子组件使用时，可以避免每次父组件更新时都重新渲染这个子组件,子组件一般配合 <code>memo</code> 使用</p></blockquote><ul><li><code>useMemo</code>：传递一个创建函数和依赖项，创建函数会需要返回一个值，只有在<strong>依赖项发生改变的时候，才会重新调用此函数</strong>，返回一个新的值。<strong>这里的改变，不表示地址的改变，只有值得改变</strong>。主要<strong>能够优化当前组件也可以优化子组件</strong></li></ul><blockquote><p><code>useMemo</code> 返回的的是一个<strong>值</strong>，用于避免在每次渲染时都进行高开销的计算</p></blockquote><br><br><h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 align="center">👋 这里是 React 学习天堂</h2><p align="center">希望你能有所收获, 期待你的 Star</p><p align="center"><a target="_blank" rel="noopener" href="https://github.com/linjunc"><img src="https://img.shields.io/badge/GitHub-ff79c6" alt="github"></a><img src="https://img.shields.io/badge/weChat-Ljc--10c-blue" alt="wechat"> <a target="_blank" rel="noopener" href="https://juejin.cn/user/1460594842018446"><img src="https://img.shields.io/badge/juejin-brightgreen" alt="juejin"></a></p><h5><p align="center"><i>If you like this series or learn something from it, please<a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study">★</a> this repository to show your support! 🤩</i></p><p></p><h5 align="center">本仓库非常适合 React 的学习者，持续收集 React 相关的技术好文，如果有什么问题、错误的地方或者有什么想要添加的内容，欢迎与我联系！</h5><p></p></h5><p align="center"><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study"><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/reactjs.jpg"></a></p><h2 id="React-基础学习"><a href="#React-基础学习" class="headerlink" title="React 基础学习"></a>React 基础学习</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89--%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%20jsx%E8%AF%AD%E6%B3%95.md">基础知识以及 jsx 语法</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B.md">面向组件编程</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%20--%20%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md">生命周期 LifeCycle</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89--%20diffing%20%E7%AE%97%E6%B3%95.md">diffing 算法</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89--%20%E5%88%9D%E5%A7%8B%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6.md">认识脚手架</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89--%20TodoList%20%E6%A1%88%E4%BE%8B.md">TodoList 案例</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89--%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.md">脚手架配置代理</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89--%20GitHub%20%E6%90%9C%E7%B4%A2%E6%A1%88%E4%BE%8B.md">GitHub 搜索案例</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89--%20%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83.md">消息订阅发布</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89--%20React%20%E8%B7%AF%E7%94%B1.md">React 路由</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89--%20React%20%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82.md">React 路由传参</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89--%20React%20%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC.md">React 路由跳转</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89--%20antd%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.md">antd 组件库的基本使用</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89--%20redux%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.md">redux 基本使用</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89--%20React-Redux%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.md">React-Redux 基本使用</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89--%20%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB.md">数据共享</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89--%20React%20%E6%89%A9%E5%B1%95.md">React 扩展</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/React%E6%A0%B8%E5%BF%83%20--%20React-Hooks.md">React Hooks</a></li></ul><h2 id="React-源码解析"><a href="#React-源码解析" class="headerlink" title="React 源码解析"></a>React 源码解析</h2><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/readme.html">专栏介绍</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/fiberidea.html">React 设计理念</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/constructure.html">React Fiber 架构</a></li></ul><p><strong>Render 阶段</strong></p><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/render/beginwork.html">Render 阶段 - beginWork</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/render/completework.html">Render 阶段 - completeWork</a></li></ul><p><strong>commit 阶段</strong></p><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/commit/commit.html">commit 阶段流程概览</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/commit/beforemutation.html">BeforeMutation 阶段</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/commit/mutation.html">Mutation 阶段</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/commit/layout.html">Layout 阶段</a></li></ul><p><strong>Diff 算法</strong></p><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/diff/diffpre.html">Diff 算法概览</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/diff/singlediff.html">单节点 Diff</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/diff/arraydiff.html">多节点的 Diff</a></li></ul><p><strong>状态更新</strong></p><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/update/update.html">状态更新流程概览</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/update/priority.html">优先级更新</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/update/updatecode.html">状态更新调度源码解析</a></li></ul><p><strong>Scheduler 模块</strong></p><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/scheduler/scheduler-origin.html">Scheduler 实现原理</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/scheduler/scheduler.html">Scheduler 源码解析</a></li></ul><p><strong>Hooks 实现</strong></p><ul><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/hooks.html">React Hooks 源码概览</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/useState.html">React Hooks useState 源码</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/usereducer.html">useReducer 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/usecontext.html">useContext 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/useeffect.html">useEffect 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/uselayouteffect.html">useLayoutEffect 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/useref.html">useRef 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/usememo-callback.html">useCallback &amp; useMemo 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/useId.html">useId 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/usetransition.html">useTransition 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/hooks/qa.html">Q &amp; A</a></li></ul><h2 id="React-进阶电子书"><a href="#React-进阶电子书" class="headerlink" title="React 进阶电子书"></a>React 进阶电子书</h2><ul><li><a target="_blank" rel="noopener" href="https://react.iamkasong.com/">React 技术揭秘</a></li><li><a target="_blank" rel="noopener" href="https://xiaochen1024.com/article_item/600ac4384bf83f002edaf54a">人人都能读懂的 react 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://react.jokcy.me/">React 源码解析</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/book/6945998773818490884">React 进阶实践指南</a></li><li><a target="_blank" rel="noopener" href="https://github.com/AttackXiaoJinJin/reactExplain">reactExplain</a></li><li><a target="_blank" rel="noopener" href="https://7kms.github.io/react-illustration-series/">图解React原理系列</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/column/6961274930306482206">React 进阶专栏</a></li><li><a target="_blank" rel="noopener" href="https://linjuncheng.cn/pages/react/hard/readme.html">React 源码解析 – 基于v18</a></li></ul><h2 id="React-精选文章"><a href="#React-精选文章" class="headerlink" title="React 精选文章"></a>React 精选文章</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904019660537869">走进React Fiber 架构</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903975112671239">这可能是最通俗的 React Fiber(时间分片) 打开方式</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6943896410987659277">走进React Fiber的世界</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903973585944589">详解 react diff</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6955636911214067720">一文吃透react事件系统原理</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6909271104440205326">React 事件系统工作原理</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7069555976717729805">react-router v6 通关指南</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6944863057000529933">一文吃透react-hooks原理</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7078511027091931167">React 18 超全升级指南</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904200824946696">从React源码分析渲染更新流程</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903890467454989">React小技巧汇总</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7118937685653192735">React 全部 Hooks 使用大全 （包含 React v18 版本</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7114491826694389768">React Hooks 源码学习</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7085542534943883301">2022 的 React 生态</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7118752985068339237">React 原理 – 浅析 React Fiber 架构</a></li></ul><h2 id="React-Hooks-实战项目"><a href="#React-Hooks-实战项目" class="headerlink" title="React Hooks 实战项目"></a>React Hooks 实战项目</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E4%B8%80%EF%BC%89%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2.md">项目介绍&amp;登录注册</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E4%BA%8C%EF%BC%89%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA.md">项目列表展示</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E4%B8%89%EF%BC%89%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97.md">项目列表功能模块</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E5%9B%9B%EF%BC%89%20%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0.md">搜索功能实现</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2.md">路由跳转页面</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E5%85%AD%EF%BC%89%E7%9C%8B%E6%9D%BF%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA.md">看板页面展示</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E4%B8%83%EF%BC%89%E4%BB%BB%E5%8A%A1%E7%BB%84%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0.md">任务组页面实现</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E5%85%AB%EF%BC%89%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0.md">拖拽功能实现</a></li><li><a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study/blob/main/React%20Hooks%20%E9%A1%B9%E7%9B%AE/%EF%BC%88%E7%BB%88%EF%BC%89%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93.md">项目总结</a></li></ul><h5><p align="center"><i>If you like this series or learn something from it, please<a target="_blank" rel="noopener" href="https://github.com/linjunc/react-study">★</a> this repository to show your support! 🤩</i></p><p></p><h5 align="center">以上就是这个仓库的全部内容了，祝愿大家有个美好的未来如果有什么问题、错误的地方或者有什么想要添加的内容，欢迎与我联系！</h5><p></p></h5><br><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Moustache 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Moustache</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://hammerzer.github.io/2024/01/05/React-Hooks/" title="React-Hooks">https://hammerzer.github.io/2024/01/05/React-Hooks/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/" rel="tag"><i class="fa fa-tag"></i> 框架与工具</a> <a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/12/05/Accumulation-of-data-processing-methods/" rel="prev" title="数据处理方法积累"><i class="fa fa-chevron-left"></i> 数据处理方法积累</a></div><div class="post-nav-item"><a href="/2024/01/09/python-crawler/" rel="next" title="Python爬虫">Python爬虫 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ONTENT-OUTLINE"><span class="nav-number">1.</span> <span class="nav-text">ONTENT OUTLINE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2"><span class="nav-number">2.</span> <span class="nav-text">一 登录注册页面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%8C-%E5%89%8D%E8%A8%80"><span class="nav-number">2.1.</span> <span class="nav-text">💌 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%94%A8%E7%8A%B6%E6%80%81%E9%A9%B1%E5%8A%A8%E9%A1%B5%E9%9D%A2%E6%9B%B4%E6%96%B0"><span class="nav-number">2.2.</span> <span class="nav-text">1 用状态驱动页面更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%9A%E8%BF%87-Antd-%E5%B8%83%E5%B1%80%E9%A1%B5%E9%9D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">2 通过 Antd 布局页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BC%96%E5%86%99-auth-provider-%E6%96%87%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">3 编写 auth-provider 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BC%96%E5%86%99-useAsync-%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">2.5.</span> <span class="nav-text">4 编写 useAsync 发送异步请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BC%96%E5%86%99-useAuth-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-number">2.6.</span> <span class="nav-text">5 编写 useAuth 获取用户信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8C%89%E9%92%AE%E8%A7%A6%E5%8F%91%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="nav-number">2.7.</span> <span class="nav-text">6 按钮触发函数执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA"><span class="nav-number">3.</span> <span class="nav-text">二 项目列表展示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B"><span class="nav-number">3.1.</span> <span class="nav-text">💡 知识点抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-antd-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%B8%B2%E6%9F%93%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">1 antd 组件库渲染项目列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9B%B4%E5%A4%9A%E6%8C%89%E9%92%AE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.</span> <span class="nav-text">2 更多按钮的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%9A%E8%BF%87-URL-%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">3 通过 URL 进行状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useSetUrlSearchParam"><span class="nav-number">3.4.1.</span> <span class="nav-text">1. useSetUrlSearchParam</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useUrlQueryParam"><span class="nav-number">3.4.2.</span> <span class="nav-text">2. useUrlQueryParam</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B0%81%E8%A3%85%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84-url-%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.</span> <span class="nav-text">4 封装项目列表中的 url 操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useProjectsSearchParams"><span class="nav-number">3.5.1.</span> <span class="nav-text">1. useProjectsSearchParams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useProjectsQueryKey"><span class="nav-number">3.5.2.</span> <span class="nav-text">2. useProjectsQueryKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-useProjectModel"><span class="nav-number">3.5.3.</span> <span class="nav-text">3. useProjectModel</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93"><span class="nav-number">3.6.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97"><span class="nav-number">4.</span> <span class="nav-text">三 项目列表功能模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B-1"><span class="nav-number">5.</span> <span class="nav-text">💡 知识点抢先看</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="nav-number">5.1.</span> <span class="nav-text">1 实现对项目的增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A8%A1%E6%80%81%E6%A1%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.1.</span> <span class="nav-text">1. 模态框的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B0%81%E8%A3%85%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-hook%E5%BC%95%E5%87%BA"><span class="nav-number">5.1.2.</span> <span class="nav-text">2. 封装增删改查 hook引出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-useEditProject"><span class="nav-number">5.1.3.</span> <span class="nav-text">3. useEditProject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-useAddProject"><span class="nav-number">5.1.4.</span> <span class="nav-text">4. useAddProject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-useDeleteProject"><span class="nav-number">5.1.5.</span> <span class="nav-text">5. useDeleteProject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%BE%91%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="nav-number">5.1.6.</span> <span class="nav-text">6. 实现编辑，创建功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="nav-number">5.1.7.</span> <span class="nav-text">7. 删除功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%94%B6%E8%97%8F%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">2 收藏功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E6%9B%B4%E6%96%B0"><span class="nav-number">5.3.</span> <span class="nav-text">3 实现乐观更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-1"><span class="nav-number">5.4.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">四 搜索功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B-2"><span class="nav-number">6.1.</span> <span class="nav-text">💡 知识点抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B0%81%E8%A3%85-UserSelect-%E7%BB%84%E4%BB%B6"><span class="nav-number">6.2.</span> <span class="nav-text">1 封装 UserSelect 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%86%E8%BE%93%E5%85%A5%E6%A1%86%E5%86%85%E5%AE%B9%E6%98%A0%E5%B0%84%E5%88%B0-url-%E4%B8%8A"><span class="nav-number">6.3.</span> <span class="nav-text">2 将输入框内容映射到 url 上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-useDebounce-%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96"><span class="nav-number">6.4.</span> <span class="nav-text">3 useDebounce 实现防抖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-2"><span class="nav-number">6.5.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2"><span class="nav-number">7.</span> <span class="nav-text">五 路由跳转页面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B-3"><span class="nav-number">7.1.</span> <span class="nav-text">💡 知识点抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%A9%E7%94%A8-router-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="nav-number">7.2.</span> <span class="nav-text">1 利用 router 实现路由跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%81%E8%A3%85-useDocumentTitle-%E6%9D%A5%E8%AE%BE%E7%BD%AE%E6%96%87%E6%A1%A3%E7%9A%84%E6%A0%87%E9%A2%98"><span class="nav-number">7.3.</span> <span class="nav-text">2 封装 useDocumentTitle 来设置文档的标题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-3"><span class="nav-number">7.4.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E7%9C%8B%E6%9D%BF%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA"><span class="nav-number">8.</span> <span class="nav-text">六 看板页面展示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B-4"><span class="nav-number">8.1.</span> <span class="nav-text">💡 知识点抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%A4%84%E7%90%86%E7%9C%8B%E6%9D%BF%E6%95%B0%E6%8D%AE%E7%9A%84-custom-hook"><span class="nav-number">8.2.</span> <span class="nav-text">一、处理看板数据的 custom hook</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useKanbans"><span class="nav-number">8.2.1.</span> <span class="nav-text">1. useKanbans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useProjectIdInUrl"><span class="nav-number">8.2.2.</span> <span class="nav-text">2. useProjectIdInUrl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-useProjectInUrl"><span class="nav-number">8.2.3.</span> <span class="nav-text">3. useProjectInUrl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-useKanbanSearchParams"><span class="nav-number">8.2.4.</span> <span class="nav-text">4. useKanbanSearchParams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-useTasks"><span class="nav-number">8.2.5.</span> <span class="nav-text">5. useTasks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-useTasksSearchParams"><span class="nav-number">8.2.6.</span> <span class="nav-text">6. useTasksSearchParams</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%B0%81%E8%A3%85-KanbanColumn-%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="nav-number">8.3.</span> <span class="nav-text">二、封装 KanbanColumn 渲染页面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%9C%8B%E6%9D%BF%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%BB%9F%E4%B8%80"><span class="nav-number">8.3.1.</span> <span class="nav-text">1. 看板和任务数据统一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useTaskTypes-%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84-icon"><span class="nav-number">8.3.2.</span> <span class="nav-text">2. useTaskTypes 处理不同类型任务的 icon</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD"><span class="nav-number">8.4.</span> <span class="nav-text">三、处理任务的搜索功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useTasksSearchParams"><span class="nav-number">8.4.1.</span> <span class="nav-text">1. useTasksSearchParams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%87%8D%E7%BD%AE%E6%8C%89%E9%92%AE"><span class="nav-number">8.4.2.</span> <span class="nav-text">2. 重置按钮</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%9C%8B%E6%9D%BF%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%8A%9F%E8%83%BD"><span class="nav-number">8.5.</span> <span class="nav-text">四、看板的增删改查功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useAddKanban"><span class="nav-number">8.5.1.</span> <span class="nav-text">1. useAddKanban</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useDeleteKanban"><span class="nav-number">8.5.2.</span> <span class="nav-text">2. useDeleteKanban</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%8A%9F%E8%83%BD"><span class="nav-number">8.6.</span> <span class="nav-text">五、任务的增删改查功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-4"><span class="nav-number">8.7.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E4%BB%BB%E5%8A%A1%E7%BB%84%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.</span> <span class="nav-text">七 任务组页面实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B-5"><span class="nav-number">9.1.</span> <span class="nav-text">💡 知识点抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="nav-number">9.2.</span> <span class="nav-text">一、页面布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B8%83%E5%B1%80%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.2.1.</span> <span class="nav-text">1. 布局的简单介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-number">9.2.2.</span> <span class="nav-text">2. 数据的获取</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%A2%9E%E5%88%A0%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%8A%9F%E8%83%BD"><span class="nav-number">9.3.</span> <span class="nav-text">二、增删任务组功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1%E7%BB%84"><span class="nav-number">9.3.1.</span> <span class="nav-text">1. 删除任务组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%8A%9F%E8%83%BD"><span class="nav-number">9.3.2.</span> <span class="nav-text">2. 添加任务组功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="nav-number">9.4.</span> <span class="nav-text">三、路由跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-5"><span class="nav-number">9.5.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.</span> <span class="nav-text">八 拖拽功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8A%A2%E5%85%88%E7%9C%8B-6"><span class="nav-number">10.1.</span> <span class="nav-text">💡 知识点抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BB%99%E7%9C%8B%E6%9D%BF%E6%B7%BB%E5%8A%A0%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD"><span class="nav-number">10.2.</span> <span class="nav-text">一、给看板添加拖拽功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0-Drop-%E7%BB%84%E4%BB%B6"><span class="nav-number">10.2.1.</span> <span class="nav-text">1. 实现 Drop 组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0-Drag-%E7%BB%84%E4%BB%B6"><span class="nav-number">10.2.2.</span> <span class="nav-text">2. 实现 Drag 组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8B%96%E6%8B%BD%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">10.2.3.</span> <span class="nav-text">3. 拖拽持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-useReorderKanban"><span class="nav-number">10.2.4.</span> <span class="nav-text">4. useReorderKanban</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%9C%A8-HTML5-%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84-Drop-%E5%92%8C-Drag"><span class="nav-number">10.2.5.</span> <span class="nav-text">5. 在 HTML5 中新增的 Drop 和 Drag</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-6"><span class="nav-number">10.3.</span> <span class="nav-text">📌 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">终 项目总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-%E5%86%85%E5%AE%B9%E6%8A%A2%E5%85%88%E7%9C%8B"><span class="nav-number">11.1.</span> <span class="nav-text">💡 内容抢先看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%87%87%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="nav-number">11.2.</span> <span class="nav-text">一、采用技术栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Q-amp-A-%E6%96%87%E6%A1%A3"><span class="nav-number">11.3.</span> <span class="nav-text">二、Q&amp;A 文档</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8E%E4%BB%8D%E7%84%B6%E6%98%AF%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">11.3.1.</span> <span class="nav-text">1. 怎么实现页面刷新后仍然是上一次的状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-catch-%E4%B8%AD%E7%9A%84-err-%E4%BC%9A%E6%8A%A5%E9%94%99%E5%91%A2%EF%BC%9F"><span class="nav-number">11.3.2.</span> <span class="nav-text">2. 为什么使用 catch 中的 err 会报错呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0-error-%E6%80%BB%E6%98%AF-null"><span class="nav-number">11.3.3.</span> <span class="nav-text">3. 为什么控制台打印 error 总是 null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%8D%E5%90%8C-title-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">11.3.4.</span> <span class="nav-text">4. 页面的不同 title 是如何实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8-Navigate-%E4%BC%9A%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E8%B7%B3%E8%BD%AC%E5%91%A2%EF%BC%9F"><span class="nav-number">11.3.5.</span> <span class="nav-text">5. 为什么采用 Navigate 会无法设置默认跳转呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%9C%A8%E9%87%87%E7%94%A8-antd-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BC%80%E6%94%BE%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">11.3.6.</span> <span class="nav-text">6. 在采用 antd 自定义组件的时候，如何开放更多的类型呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%91%BD%E5%90%8D-ts%EF%BC%8Ctsx-%E6%96%87%E4%BB%B6%E5%91%A2%EF%BC%9F"><span class="nav-number">11.3.7.</span> <span class="nav-text">7. 什么时候命名 ts，tsx 文件呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%E5%91%A2"><span class="nav-number">11.3.8.</span> <span class="nav-text">8. 在代码中出现的 !! 是什么意思呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-hook%EF%BC%8C%E9%82%A3%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E5%91%A2%EF%BC%9F"><span class="nav-number">11.3.9.</span> <span class="nav-text">9. 在组件中我们不能使用 hook，那我们如何更改组件状态呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E5%9C%A8%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E4%B9%8B%E5%89%8D%E5%A6%82%E6%9E%9C%E9%A1%B5%E9%9D%A2%E8%A2%AB%E5%8D%B8%E8%BD%BD%E4%BA%86%EF%BC%8C%E9%80%A0%E6%88%90%E6%8A%A5%E9%94%99%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">11.3.10.</span> <span class="nav-text">10. 在请求数据返回之前如果页面被卸载了，造成报错如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-component-composition-%E8%BF%99%E7%A7%8D%E9%80%8F%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.3.11.</span> <span class="nav-text">11. 怎么理解 component composition 这种透传数据的模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BC%96%E8%BE%91%E4%B8%AD%E7%9A%84%E5%85%B3%E9%97%AD%E6%8C%89%E9%92%AE%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">11.3.12.</span> <span class="nav-text">12. 为什么创建和编辑中的关闭按钮，只有一个起作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E6%90%9C%E7%B4%A2%E6%A1%86%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">11.3.13.</span> <span class="nav-text">13. 搜索框的功能是如何实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%E5%88%B0-github-%E4%B8%8A%EF%BC%9F"><span class="nav-number">11.3.14.</span> <span class="nav-text">14. 如何部署到 github 上？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-useMemo-%E5%92%8C-useCallback-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">11.3.15.</span> <span class="nav-text">15. useMemo 和 useCallback 有什么区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadMe"><span class="nav-number">12.</span> <span class="nav-text">ReadMe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">13.</span> <span class="nav-text">👋 这里是 React 学习天堂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">If you like this series or learn something from it, please★ this repository to show your support! 🤩 本仓库非常适合 React 的学习者，持续收集 React 相关的技术好文，如果有什么问题、错误的地方或者有什么想要添加的内容，欢迎与我联系！</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">本仓库非常适合 React 的学习者，持续收集 React 相关的技术好文，如果有什么问题、错误的地方或者有什么想要添加的内容，欢迎与我联系！</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="nav-number">14.</span> <span class="nav-text">React 基础学习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">15.</span> <span class="nav-text">React 源码解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E8%BF%9B%E9%98%B6%E7%94%B5%E5%AD%90%E4%B9%A6"><span class="nav-number">16.</span> <span class="nav-text">React 进阶电子书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0"><span class="nav-number">17.</span> <span class="nav-text">React 精选文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-Hooks-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE"><span class="nav-number">18.</span> <span class="nav-text">React Hooks 实战项目</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">18.0.0.1.</span> <span class="nav-text">If you like this series or learn something from it, please★ this repository to show your support! 🤩 以上就是这个仓库的全部内容了，祝愿大家有个美好的未来如果有什么问题、错误的地方或者有什么想要添加的内容，欢迎与我联系！</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">18.0.0.2.</span> <span class="nav-text">以上就是这个仓库的全部内容了，祝愿大家有个美好的未来如果有什么问题、错误的地方或者有什么想要添加的内容，欢迎与我联系！</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Moustache" src="/images/180-180.png"><p class="site-author-name" itemprop="name">Moustache</p><div class="site-description" itemprop="description">我是小胡子</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">79</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/hammerzer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hammerzer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:stellar_lzu@163.com" title="E-Mail → mailto:stellar_lzu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Chase</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">1.9m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">29:30</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script size="300" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JRehDoQ6pHXV1zKg09AMNLFt-gzGzoHsz',
      appKey     : 'cRAt4W15KiQdrIuHlQrRrtIl',
      placeholder: "Just go go",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>