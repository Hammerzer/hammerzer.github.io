<!DOCTYPE html><html lang="zh-CN"><head><script src="https://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/180-180.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/32-32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/16-16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hammerzer.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="CONTENT OUTLINEC++ 核心编程  内存分区模型 引用 函数提高 类和对象 运算符重载 类的继承 类的多态 编译器"><meta property="og:type" content="article"><meta property="og:title" content="CPP-BASE-2"><meta property="og:url" content="https://hammerzer.github.io/2024/03/12/cpp-base-2/index.html"><meta property="og:site_name" content="Moustache&#39;s Blog"><meta property="og:description" content="CONTENT OUTLINEC++ 核心编程  内存分区模型 引用 函数提高 类和对象 运算符重载 类的继承 类的多态 编译器"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp1-2.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp2-3-4.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp2-3-5.png"><meta property="og:image" content="https://hammerzer.github.io/.io//2-4-1.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp1-3.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp1-4.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp1-5.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp1-6.jpg"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp1-7.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp7-6.png"><meta property="og:image" content="https://hammerzer.github.io/.io//cpp10-1.png"><meta property="article:published_time" content="2024-03-12T02:22:00.000Z"><meta property="article:modified_time" content="2025-01-19T03:19:15.153Z"><meta property="article:author" content="Moustache"><meta property="article:tag" content="CPP基础"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hammerzer.github.io/.io//cpp1-2.png"><link rel="canonical" href="https://hammerzer.github.io/2024/03/12/cpp-base-2/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>CPP-BASE-2 | Moustache's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Moustache's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Moustache's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">小胡子的私人空间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">34</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">78</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hammerzer.github.io/2024/03/12/cpp-base-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/180-180.png"><meta itemprop="name" content="Moustache"><meta itemprop="description" content="我是小胡子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Moustache's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">CPP-BASE-2</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-03-12 10:22:00" itemprop="dateCreated datePublished" datetime="2024-03-12T10:22:00+08:00">2024-03-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-19 11:19:15" itemprop="dateModified" datetime="2025-01-19T11:19:15+08:00">2025-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a> </span></span><span id="/2024/03/12/cpp-base-2/" class="post-meta-item leancloud_visitors" data-flag-title="CPP-BASE-2" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> <span>℃</span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2024/03/12/cpp-base-2/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2024/03/12/cpp-base-2/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>169k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2:34</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><p>C++ 核心编程</p><ul><li>内存分区模型</li><li>引用</li><li>函数提高</li><li>类和对象</li><li>运算符重载</li><li>类的继承</li><li>类的多态</li><li>编译器</li></ul><span id="more"></span><h2 id="二、C-核心编程"><a href="#二、C-核心编程" class="headerlink" title="二、C++ 核心编程"></a>二、C++ 核心编程</h2><h3 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h3><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值,局部变量等【速度快、容量小】</li><li>堆区：由程序员分配和释放，若程序员不释放,程序结束时由操作系统回收【自由存储区】</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h4 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h4><p>​ 在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​ <strong>代码区：</strong></p><p>​ 存放 CPU 执行的机器指令</p><p>​ 代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​ 代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​ <strong>全局区：</strong></p><p>​ 全局变量和静态变量存放在此.</p><p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​ <span style="background:#ff0">该区域的数据在程序结束后由操作系统释放</span>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="/.io//cpp1-2.png"></p><p><strong>总结</strong>：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量 和 字符串常量</li></ul><h4 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h4><p>​ <strong>栈区：</strong></p><p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>堆区：</strong></p><p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​ 在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把数据开辟到堆区</span></span><br><span class="line">    <span class="comment">// 指针本质上在栈区，但数据放在堆区</span></span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h4 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h4><p>C++中利用==new==操作符在堆区开辟数据【基于C语言的内存分配实现】</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>语法：<code>new 数据类型</code>【利用new创建的数据，会返回该数据对应的类型的指针；失败则返回0】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line">    <span class="type">int</span> *pp = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];<span class="comment">//分配了3个</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用delete释放堆区数据【堆区数据由用户释放】</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">delete</span>[] pp;<span class="comment">//释放多个[]定义的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-动态内存分配【C】"><a href="#1-4-动态内存分配【C】" class="headerlink" title="1.4 动态内存分配【C】"></a>1.4 动态内存分配【C】</h4><p>C语言中的<strong>内存动态分配 <code>malloc</code> 函数</strong>：<code>void* malloc(size_t size);</code>【size_t 是自定义类型：unsigned】</p><p>功能：为用户分配 <code>size</code> 字节内存，并返回内存分配的地址【该地址为<code>void</code>类型】；分配失败返回0。</p><p>下面的代码应该是一种新手常见的错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int a[x];// 报错：x必须为常量</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(x * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 堆区</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 最好写成 p == nullptr【c++】，在面向对象编程有优势</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;内存分配失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一个内存分配的函数</strong>：<code>void* calloc(x, sizeof(int));</code> 其与<code>malloc</code>有两点区别：</p><ul><li>只需提供元素个数，函数内部完成乘法计算</li><li>自动初始化为0</li></ul><p><strong>第三个函数</strong>【重新分配】：<code>void* realloc(void* _Block, size_t Size);</code>；如果分配失败返回0</p><blockquote><p><strong>注意：</strong>上面的函数分配的都是连续的内存</p></blockquote><p><strong>第四个函数</strong>： <code>void free(void* Block);</code></p><blockquote><p><code>free</code>后的指针变为悬挂指针，需要重置为0来避免出错</p></blockquote><p><strong>补充：内存拷贝函数</strong>【<code>void* memcpy(void* _Dst, const void* _Src, Size_t Size);</code>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(b, a, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// Size为字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：内存设置函数</strong>【<code>void* memset(void* _Dst, int val, Size_t Size);</code>】</p><p>功能：将该区域的每一个子节设置为<code>val</code></p><blockquote><p>注意：其设置的是每一个字节，如果用0x123h来设置，最高位会被舍弃，结果等价于用0x23h来操作</p></blockquote><h4 id="1-5-动态分配内存的风险"><a href="#1-5-动态分配内存的风险" class="headerlink" title="1.5 动态分配内存的风险"></a>1.5 动态分配内存的风险</h4><h5 id="1-5-1-悬挂指针"><a href="#1-5-1-悬挂指针" class="headerlink" title="1.5.1 悬挂指针"></a>1.5.1 悬挂指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// C中</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">205</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">255</span>; <span class="comment">// 悬挂指针还能继续使用就很危险</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++</span></span><br><span class="line">    <span class="type">int</span>* pp = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000</span>];</span><br><span class="line">    pp[<span class="number">0</span>] = <span class="number">205</span>;</span><br><span class="line">    <span class="type">int</span>* tmp = pp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] pp;</span><br><span class="line">    <span class="comment">// delete pp; //现阶段不会报错，但加入面向对象后会报错</span></span><br><span class="line">    <span class="comment">// pp[20] = 10; // 报错！</span></span><br><span class="line">    tmp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 居然未报错！!!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-5-2-内存碎片"><a href="#1-5-2-内存碎片" class="headerlink" title="1.5.2 内存碎片"></a>1.5.2 内存碎片</h5><p>对于嵌入式开发等对内存要求高的方向，需要注意；除此以外，new和delete，以及足够的虚拟内存也会帮助解决内存碎片的问题。</p><br><h3 id="2、引用"><a href="#2、引用" class="headerlink" title="2、引用"></a>2、引用</h3><h4 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h4><p>**作用： **给变量起别名【别名与原变量的内存地址一致，用于提高代码效率】</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> aa[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x : aa)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x + <span class="number">1</span>; <span class="comment">// 会对原数组操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h4><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变【有时“改变”的时候，被视为赋值操作】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">    <span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">    c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h4><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递【别名与原名相同】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">// 交换失败</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">// 交换成功</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">// 交换成功</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h4 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h4><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><blockquote><p>静态变量只被定义一次【涉及内存分配，也只有一次】，程序结束自动释放</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量【栈区】</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">// 内存已经被回收--【第一次读结果正确，第二次读错误】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>; <span class="comment">// 静态变量【全局区 | 程序结束由系统释放】</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">    <span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>() = <span class="number">1000</span>; <span class="comment">// ！！！！！！！！！！</span></span><br><span class="line">    <span class="comment">// 返回a的引用，之后对a进行操作</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h4><p>本质：<strong>引用的本质在c++内部实现是一个指针常量。</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">    ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = a; </span><br><span class="line">    ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h4 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h4><p><strong>作用：</strong>常量引用主要用来修饰<strong>形参</strong>，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，<strong>防止形参改变实参</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//v += 10;</span></span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">    <span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-右值引用"><a href="#2-7-右值引用" class="headerlink" title="2.7 右值引用"></a>2.7 右值引用</h4><p>函数参数：右值引用【优化内存开销】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    x = x + <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add(20 + 1);//错误：非常量引用的初始值必须为左值</span></span><br><span class="line">    <span class="comment">// 当实际应用中，20+1是大型结构体时，就很有用了</span></span><br><span class="line">    <span class="comment">//add(x + 20 + 1);// x+20的临时值，被称为【右值】【也可以暂时理解为等号左边的为左值，但也不太准确】</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    *(a + <span class="number">1</span>) = <span class="number">100</span>;<span class="comment">// a+1也是临时值，故为右值</span></span><br><span class="line">    <span class="type">int</span>&amp; y = x; <span class="comment">// 左值引用</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; z = <span class="number">20</span> + <span class="number">200</span>;<span class="comment">// 右值引用</span></span><br><span class="line">    <span class="comment">//int&amp;&amp; z = x;//错误</span></span><br><span class="line">    z = <span class="number">1000</span>; <span class="comment">// z的值还是不变【右值引用无法写入】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右值引用应用</span></span><br><span class="line">    <span class="built_in">add1</span>(z<span class="number">+20</span><span class="number">+200</span>);<span class="comment">// 省去了为中间变量分配内存再读写的开销【z+20的tmp】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Role <span class="title">createM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123; <span class="number">10</span>,<span class="number">20</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Role r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; r.hp &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; r.mp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showR</span><span class="params">(Role&amp;&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; r.hp &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; r.mp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左值引用【左值引用无法传递这种不明确的内存空间】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showL</span><span class="params">(Role&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; r.hp &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; r.mp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// createM返回结构体，show接到后一一赋值</span></span><br><span class="line">    <span class="built_in">show</span>(<span class="built_in">createM</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用右值引用来避免重复的变量赋值</span></span><br><span class="line">    <span class="built_in">showR</span>(<span class="built_in">createM</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用左值引用</span></span><br><span class="line">    <span class="built_in">showL</span>(<span class="built_in">createM</span>());<span class="comment">// 错误：非常量的引用的初始值必须为左值，而该函数的返回值是个右值，只是个临时变量而已</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-引用的其他注意"><a href="#2-8-引用的其他注意" class="headerlink" title="2.8 引用的其他注意"></a>2.8 引用的其他注意</h4><h5 id="2-8-1-类型转换"><a href="#2-8-1-类型转换" class="headerlink" title="2.8.1 类型转换"></a>2.8.1 类型转换</h5><ul><li>引用传参不允许隐式类型转换</li><li>数组引用及数组引用传参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add1</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add2</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> y = <span class="number">1.1f</span>;</span><br><span class="line">    <span class="built_in">add1</span>(y);<span class="comment">// 无报错</span></span><br><span class="line">    <span class="comment">//add2(y); // 错误：引用传参时，不允许隐式类型转换，因为引用本质是指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组引用</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 首先b是引用，之后是数组的引用</span></span><br><span class="line">    <span class="built_in">int</span>(&amp;b)[<span class="number">100</span>] = a;</span><br><span class="line">    <span class="comment">//int(&amp;b)[10] = a;// 长度需要对应</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="2-8-2-指针和引用的异同"><a href="#2-8-2-指针和引用的异同" class="headerlink" title="2.8.2 指针和引用的异同"></a>2.8.2 指针和引用的异同</h5><p>相同点：都是地址的概念。指针指向一块内存，它的内容是所指内存的地址【逻辑地址】；而引用则是某块内存的别名，本质在c++内部实现是一个指针常量。</p><p>区别：</p><ul><li>访问方式不同：指针保存的是所指对象的地址【实体】，引用仅仅是对象的别名【非实体】，<strong>引用不占内存</strong>。指针需要通过解引用间接访问，而引用是直接访问。</li><li>非空区别：引用不能为空，指针可以为空。</li><li>可修改区别：引用必须在定义时就初始化，并且不能改变所指的对象；而指针可以改变地址，从而改变所指的对象。</li><li>合法性区别：引用是类型安全的，而指针不是 【引用比指针多了类型检查】。</li></ul><br><h3 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h3><h4 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h4><p>在C++中，函数的形参列表中的形参是可以有<strong>默认值</strong>的。</p><p>语法：<code>返回值类型 函数名 （参数= 默认值）&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果【函数声明 | 函数实现】只能有一处设置默认值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h4><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><blockquote><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-函数的本质"><a href="#3-3-函数的本质" class="headerlink" title="3.3 函数的本质"></a>3.3 函数的本质</h4><h5 id="3-3-1-学习底层"><a href="#3-3-1-学习底层" class="headerlink" title="3.3.1 学习底层"></a>3.3.1 学习底层</h5><blockquote><p>查看反汇编：打断点 / 开始调试 / 调试-窗口-反汇编</p><p>建议一：调整为 <code>Release</code>【发布模式】，可以减少无用的多余汇编，便于理解</p><p>建议二：解决方案的工程右击选择属性，选择【C/C++ | 优化】优化已禁用，便于初级理解汇编</p></blockquote><p><img src="/.io//cpp2-3-4.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Add &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示Add函数的字节码</span></span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)Add;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%X\n&quot;, (unsigned char)str[i]);//16进制</span></span><br><span class="line">        cout &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)str[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//str[1] = 25;// 该内存不允许更改</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因此，函数名本质是个地址，该地址空间存放代码。</p></blockquote><h5 id="3-3-2-从函数的角度理解栈"><a href="#3-3-2-从函数的角度理解栈" class="headerlink" title="3.3.2 从函数的角度理解栈"></a>3.3.2 从函数的角度理解栈</h5><p><strong>问题：</strong>变量的本质是对应的内存空间，因此每个变量都需要独立的内存空间。在实际开发过程中，一个函数可能被重复调用，如果每次都重新分配内存空间，那么系统开销会非常大；也不能提前分配固定大小的内存【万一一次也不被调用】。</p><p>由此才用了栈的概念，这是一段提前分配好的内存空间，主要用来存放临时变量。这样做，只需要管理好栈的读写，就可以避免频繁的内存分配和内存浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">Ave</span>(a, b);</span><br><span class="line">    c = c + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; Add &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">Add</span>(<span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反汇编分析见【<code>CPP-BASE-supplement</code>】</p></blockquote><ul><li>栈是预先分配好的连续的内存空间，其中包含局部变量、函数参数等，通过esp、ebp来控制创建和释放</li><li>栈平衡如果被破坏，函数可能无法返回正确的位置。【利用此原理，可以控制目标程序进入指定位置，来获取目标操作系统的控制权限，即栈攻击】</li></ul><blockquote><p>栈溢出攻击示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class16.7.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">100000000</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n&quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n 你的系统已经被我们拿下! hacked by 黑兔档案局:[ID:000001 ]\n&quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n              加群:868267304 解除\n&quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n\\&gt;正在传输硬盘数据....已经传输&quot;</span> &lt;&lt; x++ &lt;&lt; <span class="string">&quot;个文件......\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;&gt;&#x27;</span>)&lt;&lt; std::<span class="built_in">setw</span>(x % <span class="number">60</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n\\&gt;摄像头已启动!&lt;==============\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;#&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(x % <span class="number">60</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n\\&gt;数据传输完成后将启动自毁程序!CPU将会温度提升到200摄氏度\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入学员的年龄:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; rt;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> total&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> age[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        age[i] = <span class="built_in">GetAge</span>();</span><br><span class="line">        total += age[i];</span><br><span class="line">        <span class="comment">//将AGE[I]保存到数据库中</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (age[i++]);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;======= 驴百万学院 学员总年龄统计计算系统 =====\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n                API:&quot;</span>&lt;&lt;Hack&lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n[说明:最多输入10个学员的信息,当输入0时代表输入结束]\n\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n驴百万学院的学员总年龄为:&quot;</span> &lt;&lt; <span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-4-函数指针"><a href="#3-4-函数指针" class="headerlink" title="3.4 函数指针"></a>3.4 函数指针</h4><blockquote><p><code>函数返回类型 （*函数指针变量名）（参数类型 名称，...）</code></p><p>例：<code>int (*pAdd)(int a, int b)</code>【只要符合返回值类型和参数类型即可指向】</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef int(*)(int, int) p;// 错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*p)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pp = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Addf</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数指针</span></span><br><span class="line">    <span class="comment">// int (*pAdd)(int a, int b); // 也可</span></span><br><span class="line">    <span class="built_in">int</span> (*pAdd)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line">    <span class="comment">//int (*pAdd)(int, int) &#123; Add &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">pAdd</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强行指向【强制转换】</span></span><br><span class="line">    <span class="built_in">int</span> (*pAddf)(<span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>))Addf;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">pAdd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在的问题：强转语句过长</span></span><br><span class="line">    <span class="comment">// 解决一：typedef重定义</span></span><br><span class="line">    p pAddf1 = (p)Addf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决二：using 推荐</span></span><br><span class="line">    pp pAddf2 = (pp)Addf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体作为参数的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的本质：多个基本类型的组合，估以下的定义都是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*pr)</span><span class="params">(Role)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*p)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> pp = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">using</span> ppr = <span class="built_in">int</span>(*)(Role);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exp</span><span class="params">(Role r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.hp + r.mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针的用法之一🔺🔺🔺</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, pp x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">x</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数指针</span></span><br><span class="line">    Role r1&#123; <span class="number">10</span>,<span class="number">20</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Exp</span>(r1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pr ptrExp1 = Exp;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ptrExp1</span>(r1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p ptrExp1 = (p)Exp;<span class="comment">// 二者的参数不同，但本质一致，只需要一次强制转换</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ptrExp1</span>(r1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：指针函数是函数，其返回值是指针；而函数指针是指针，是指向函数的指针。</p></blockquote><h4 id="3-5-函数重载"><a href="#3-5-函数重载" class="headerlink" title="3.5 函数重载"></a>3.5 函数重载</h4><h5 id="3-5-1-函数重载概述"><a href="#3-5-1-函数重载概述" class="headerlink" title="3.5.1 函数重载概述"></a>3.5.1 函数重载概述</h5><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li><li>非纯C环境</li></ul><p><strong>注意:</strong></p><ul><li>函数的返回值不可以作为函数重载的条件【重载不能仅仅是返回值不同】</li><li>参数是指针或数组，其本质都是指针，属于相同类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-函数重载注意事项"><a href="#3-5-2-函数重载注意事项" class="headerlink" title="3.5.2 函数重载注意事项"></a>3.5.2 函数重载注意事项</h5><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数，产生歧义的不可以重载</li><li>函数重载的函数参数，如果是临时变量【比如经过强制类型转换后的值，这样的值只是临时变量】是无法被引用的【引用的本质是指针，而临时变量是没有固定内存地址的】</li><li>函数重载的函数参数，一个是<code>int</code>，一个是 <code>const int</code>，本质都无法印象外部变量，因此属于相同情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不用时，可以编译成功；但使用不可编译</span></span><br><span class="line"><span class="comment">void func(int a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;func (int a) 调用 &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-函数模板"><a href="#3-6-函数模板" class="headerlink" title="3.6 函数模板"></a>3.6 函数模板</h4><blockquote><p>对函数重载的补充</p></blockquote><p>函数模板是面向编译器的，对于不确定的类型可以声明未知类型代替，对于确定的可以直接指定。除此以外，就是函数，可以有默认参数、重载等。</p><h5 id="3-6-1-举例"><a href="#3-6-1-举例" class="headerlink" title="3.6.1 举例"></a>3.6.1 举例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ave</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> a&#123; <span class="number">1</span> &#125;, b&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave</span>(a, b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以显式地为函数模板指定类型</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ave(2,2.0f) &lt;&lt; endl; //	编译器无法推断</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">2.0f</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-函数模板和重载"><a href="#3-6-2-函数模板和重载" class="headerlink" title="3.6.2 函数模板和重载"></a>3.6.2 函数模板和重载</h5><p>当函数模板中，使用指针传参时，会出现一系列问题，这些问题需要额外的处理。</p><p><strong>注意优先级：</strong>函数重载 &gt; 函数模板例外处理 &gt; 函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">bigger</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板例外处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">bigger</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="type">float</span>* <span class="title">bigger</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">100</span> &#125;, b&#123; <span class="number">200</span> &#125;;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其答案是否正确，依赖于a，b的内存地址大小</span></span><br><span class="line">    c = *<span class="built_in">bigger</span>(&amp;a, &amp;b); </span><br><span class="line">    <span class="comment">// 需要定义函数模板的例外情况</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板的重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">100</span> &#125;, b&#123; <span class="number">200</span> &#125;, d&#123; <span class="number">300</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave</span>(a, b, d) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-3-函数模板参数"><a href="#3-6-3-函数模板参数" class="headerlink" title="3.6.3 函数模板参数"></a>3.6.3 函数模板参数</h5><ul><li>函数模板参数的默认值【直接指定 | 间接指定】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">TR <span class="title">ave</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TR = <span class="type">int</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">TR <span class="built_in">aveT1</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">2.22</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 或者为TR指定默认参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">aveT1</span>(<span class="number">3</span>, <span class="number">2.22</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 或者为TR间接指定默认参数</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非类型的模板参数【指定类型的变量】【可处理不定长数组问题】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> max = <span class="number">2000</span>, <span class="type">int</span> min, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">changeHp</span>(T&amp; hp, T damage)<span class="comment">// 需要指定max和min【其不是变量】,可指定默认值</span></span><br><span class="line">&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> max = <span class="number">2000</span>, <span class="type">int</span> min = <span class="number">1000</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">changeHp2</span>(T&amp; hp, T damage)<span class="comment">// 需要指定max和min【其不是变量】,可指定默认值</span></span><br><span class="line">&#123;</span><br><span class="line">    hp -= damage;</span><br><span class="line">    <span class="keyword">if</span> (hp &gt; max) hp = max;</span><br><span class="line">    <span class="keyword">return</span> hp &lt; min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理不定长数组问题</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">short</span> COUNT&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T(&amp;ary)[COUNT])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T all&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        all += ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all / COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hp = <span class="number">2500</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">2000</span>;</span><br><span class="line">    <span class="built_in">changeHp</span>&lt;<span class="number">2000</span>, <span class="number">1000</span>&gt;(hp, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// changeHp&lt;x, 1000&gt;(hp, 100);</span></span><br><span class="line">    <span class="comment">// changeHp2(hp, 100);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hp:&quot;</span> &lt;&lt; hp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用非类型的模板参数处理不定长数组问题</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ave:&quot;</span> &lt;&lt; <span class="built_in">ave</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//decltype((hp)) aa;</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-4-函数模板本质"><a href="#3-6-4-函数模板本质" class="headerlink" title="3.6.4 函数模板本质"></a>3.6.4 函数模板本质</h5><p>对下面代码得出的反汇编进行分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">ave</span>(<span class="built_in">short</span>(<span class="number">100</span>), <span class="built_in">short</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    12:     ave(100, 200);</span><br><span class="line">00007FF77F60255B  mov         edx,0C8h  </span><br><span class="line">00007FF77F602560  mov         ecx,64h  </span><br><span class="line">00007FF77F602565  call        00007FF77F60167C  </span><br><span class="line">    13:     ave(short(100), short(200));</span><br><span class="line">00007FF77F60256A  mov         dx,0C8h  </span><br><span class="line">00007FF77F60256E  mov         cx,64h  </span><br><span class="line">00007FF77F602572  call        00007FF77F601681  </span><br></pre></td></tr></table></figure><p>可以看到，同一个函数的调用地址不同，即编译器根据模板生成了两个函数。</p><p>也就是说，每次调用模板函数，编译器都会生成一个函数，但完全相同的模板参数的函数只生成一次【方便的空间代价】</p><p>总的来说，函数模板的语法，是跟编译器打交道。</p><h5 id="3-6-5-练习：万能排序"><a href="#3-6-5-练习：万能排序" class="headerlink" title="3.6.5 练习：万能排序"></a>3.6.5 练习：万能排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp&#123; a &#125;;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bigsort=true:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T* ary, <span class="type">unsigned</span> count, <span class="type">bool</span> bigsort = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> bcase = bigsort ? ary[j] &gt; ary[j - <span class="number">1</span>]:ary[j] &lt; ary[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (bcase) <span class="built_in">Swap</span>(ary[j], ary[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>]&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    string str[<span class="number">3</span>]&#123; <span class="string">&quot;12&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;01&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">sort</span>(str, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : str)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-推断函数模板"><a href="#3-7-推断函数模板" class="headerlink" title="3.7 推断函数模板"></a>3.7 推断函数模板</h4><h5 id="3-7-1-auto"><a href="#3-7-1-auto" class="headerlink" title="3.7.1 auto"></a>3.7.1 auto</h5><p><code>auto</code> 可以声明一个变量，让编译器根据变量的值来推断变量类型。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a&#123;<span class="number">123</span>&#125;; <span class="comment">// 等价于 int a&#123;123&#125;;</span></span><br></pre></td></tr></table></figure><p>利用 <code>auto</code> 的这一特性，我们可以利用<code>auto</code>来创建一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面的 <code>auto</code> 的例子只是演示，<code>auto</code> 的应用场景并非这里</p><p><strong><code>auto</code> 的注意事项</strong></p><ul><li><code>auto</code> 不能保留 <code>const</code> 属性【如 <code>auto</code> 变量用 <code>const</code> 的变量赋值】</li><li><code>auto</code> 变量可由函数返回值赋值</li><li><code>auto</code> 会优先推断为值类型，而非引用类型【即如，变量 <code>a</code> 及其引用别名 <code>la</code>，为 <code>auto</code> 变量赋值，推断为变量a的类型】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个引用大小，要求返回原值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为auto时，优先推断为值类型，而非引用类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">auto bigger(int&amp; a, int&amp; b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return a &gt; b ? a : b;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弥补：拖尾函数【指定auto的类型】</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">biggerT</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> -&gt; <span class="type">int</span>&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">100</span> &#125;, b&#123; <span class="number">200</span> &#125;, d&#123; <span class="number">300</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将大的值直接改为500【此处b大，即直接将b改为500】</span></span><br><span class="line">    <span class="built_in">bigger</span>(a, b) = <span class="number">500</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">biggerT</span>(a, b) = <span class="number">600</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 注：显示不了引用而已</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;auto的类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="built_in">biggerT</span>(a, b)).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-2-decltype"><a href="#3-7-2-decltype" class="headerlink" title="3.7.2 decltype"></a>3.7.2 decltype</h5><p><code>decltype</code> <strong>关键字</strong>可以得出一个表达式的<strong>类型</strong>。<strong>语法</strong>：<code>decltype(表达式)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">5</span>&#125;, c&#123;<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> b&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>* pc&#123;&amp;c&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经历运算后的右值</span></span><br><span class="line"><span class="keyword">decltype</span>(a - b) x; <span class="comment">// 相当于 unsigned x; 【int - unsigned = unsigned】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 经历运算后的左值【*pc也算运算，简介运算符】</span></span><br><span class="line"><span class="keyword">decltype</span>(*pc) y; <span class="comment">// int&amp; y;</span></span><br><span class="line"><span class="keyword">decltype</span>(pc[<span class="number">0</span>]) y; <span class="comment">// int&amp; y;</span></span><br><span class="line"><span class="keyword">decltype</span>(pc[<span class="number">5</span>]) y; <span class="comment">// int&amp; y; // 有固定地址，只是没有访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 经历运算后的右值</span></span><br><span class="line"><span class="keyword">decltype</span>(*pc + <span class="number">1</span>) z; <span class="comment">// int z;</span></span><br><span class="line"><span class="comment">// 经历运算后的右值</span></span><br><span class="line"><span class="keyword">decltype</span>((a)) z; <span class="comment">// int&amp; z;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>unsigned</code> 的容量更大，故运算前 <code>int</code> 先转换为 <code>unsigned</code> 再运算</p></blockquote><p><code>decltype</code> 关键字处理原则：</p><ul><li>如果 <code>decltype</code> 内的表达式没有经历过任何运算，那么得出的数据类型与表达式的数据类型相同，并且可以保留 <code>const</code> 和引用【<code>auto</code> 不会保留】</li><li>若其经历过运算，那么得出的数据类型根据运算结果是否有固定的内存地址【即左值】来决定。如果为左值，则就是该左值的数据类型；如果为右值，则为该结果的类型【如上例子中 的变量 <code>x</code>】。</li><li>如果 <code>decltype</code> 的表达式是一个函数，那么得到的数据类型由函数返回值确定【<strong>编译器不会执行函数</strong>，但 <code>auto</code> 是会执行函数的】</li></ul><h5 id="3-7-3-auto-gt-decltype-拖尾"><a href="#3-7-3-auto-gt-decltype-拖尾" class="headerlink" title="3.7.3 auto-&gt;decltype 拖尾"></a>3.7.3 <code>auto-&gt;decltype</code> 拖尾</h5><blockquote><p>对 <code>auto</code> 中案例的补充</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个引用大小，要求返回原值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弥补：拖尾函数【指定auto的类型】</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">biggerT</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> -&gt; <span class="type">int</span>&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用decltype推断类型【此时的表达式是有固定地址的左值，则推断类型为int&amp;】</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">biggerTT</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14之后的写法优化</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">biggerTTT</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">100</span> &#125;, b&#123; <span class="number">200</span> &#125;, d&#123; <span class="number">300</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将大的值直接改为500【此处b大，即直接将b改为500】</span></span><br><span class="line">    <span class="built_in">bigger</span>(a, b) = <span class="number">500</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">biggerT</span>(a, b) = <span class="number">600</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">biggerTT</span>(a, b) = <span class="number">700</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">biggerTTT</span>(a, b) = <span class="number">800</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-4-推断函数模板的返回类型"><a href="#3-7-4-推断函数模板的返回类型" class="headerlink" title="3.7.4 推断函数模板的返回类型"></a>3.7.4 推断函数模板的返回类型</h5><p>尝试将以下函数修改为函数模板，对于第二个函数，依靠目前的知识无法完成【参数的类型不同】，下面是解决办法【多申明几个位置类型变量】：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法模板化：需要两种类型T1,T2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave2</span><span class="params">(<span class="type">float</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ave3</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ave1的模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ave</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ave2的模板化: 多申明几种类型【这样很笨重】</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">T2 <span class="title">ave2T1</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">T1 <span class="title">ave2T2</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ave3的模板化: 多申明几种类型template &lt;typename T1, typename T2&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> TR&gt;</span><br><span class="line"><span class="function">TR <span class="title">ave3T1</span><span class="params">(T1 a, T2 b)</span> <span class="comment">// 这样写无法确定TR的类型，故报错【需要显式指定】</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">TR <span class="title">ave3T2</span><span class="params">(T1 a, T2 b)</span> <span class="comment">// 这样写无法确定TR的类型，故报错【需要显式指定第一个】</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave2T1</span>(<span class="number">3.2</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 可以显式指定类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave2T1</span>&lt;<span class="type">float</span>, <span class="type">int</span>&gt;(<span class="number">3.2</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须显式指定类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave3T1</span>&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">2.22</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 必须指定第一个类型，后面的可选</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">ave3T2</span>&lt; <span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">2.22</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面推断函数模板的返回类型：【以比较两个不同类型值大小的代码为例】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">T1 <span class="title">bigger</span><span class="params">(T1 a, T2 b)</span> <span class="comment">// 函数返回值类型存在问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auto推断返回类型【c++14以后】</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">biggerAuto</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auto推断返回类型【c++14以前】</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">biggerAuto1</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auto推断返回类型【c++14以后,biggerAuto1的简写，默认是对return后表达式的推断】</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">biggerAuto2</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">biggerAuto3</span><span class="params">(T1&amp; a, T2&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int | char</span></span><br><span class="line">    <span class="type">char</span> a = <span class="number">98</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bigger</span>(a, <span class="number">1000</span>) &lt;&lt; endl; <span class="comment">// bigger被实例化为char类型，因此返回值1000转为char类型会导致高位丢失</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bigger</span>(<span class="number">1000</span>, a) &lt;&lt; endl; <span class="comment">// 输出1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto推断类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">biggerAuto</span>(a, <span class="number">1000</span>) &lt;&lt; endl;<span class="comment">// 推断为int</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">biggerAuto3</span>(c, b) &lt;&lt; endl;<span class="comment">// 推断为float【int与float比较结果必为float】</span></span><br><span class="line">    <span class="comment">// 但上面的返回类型本应该是引用，为什么不是引用？</span></span><br><span class="line">    <span class="comment">// 原因：存在类型转换，就无法将引用作为返回值类型【此处必然是float的引用，但如果较大值为int，就无法传出】</span></span><br><span class="line">    <span class="comment">//float&amp; lx = b;//报错</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-C语言和C-联合编程"><a href="#3-8-C语言和C-联合编程" class="headerlink" title="3.8 C语言和C++联合编程"></a>3.8 C语言和C++联合编程</h4><h5 id="3-8-1-static-inline"><a href="#3-8-1-static-inline" class="headerlink" title="3.8.1 static inline"></a>3.8.1 static inline</h5><p>利用 <code>static</code> 可以声明一个静态变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p><code>static</code> 的变量，如果没有指定初始化，会自动初始化为0；且无论有无指定初始化值，都只会初始化一次！另外，此类变量位于全局区，生命周期很长，不会随函数运行结束而被释放。</p><p>使用 <code>inline</code> 来申明一个内联函数【老C++语法，基本已淘汰】，内联函数将会建议编译器把此函数处理成内联代码以提高性能【该建议是否被采纳，由编译器决定，现阶段的编译器都很智能，没必要去显式要求】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 有可能被有优化为 c = 1 + 2</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-2-从编译器角度理解定义和声明"><a href="#3-8-2-从编译器角度理解定义和声明" class="headerlink" title="3.8.2 从编译器角度理解定义和声明"></a>3.8.2 从编译器角度理解定义和声明</h5><ul><li>声明不涉及内存分配，但定义涉及内存分配</li><li>extern 关键字来声明变量，针对全局变量的声明【在函数内的变量声明没意义，故报错】</li><li>全局变量在全局区有固定的地址，函数变量没有固定的地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数ave的声明【也建议写变量名，便于理解】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 声明可以多次，但定义只能有一次【函数声明默认有前缀 extern】</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> all, all&#123;<span class="number">12</span>&#125;;<span class="comment">// 均是变量的定义，都涉及内存分配</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ALL; <span class="comment">// extern关键字：变量的声明【声明可以多次】</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数ave的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ALL = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/.io//cpp2-3-5.png"></p><h5 id="3-8-3-头文件和源文件"><a href="#3-8-3-头文件和源文件" class="headerlink" title="3.8.3 头文件和源文件"></a>3.8.3 头文件和源文件</h5><p>在本文件中调用其他文件中的函数，需要提前在本文件中声明即可。但随着声明越来越多，引入头文件，头文件中就是所谓了声明集合，最后 <code>include</code> 在本文件中即可。</p><blockquote><p>头文件中可以写函数定义，但从编译器角度解释是不合适，从代码编写规范角度也不合适。</p><p>在编译器角度，编译器先将所有 <code>cpp</code> 源文件编译为目标文件【obj文件】【可能是按首字母顺序】，然后用<code>obj</code>文件组合为目标程序。而对于头文件，除非源文件调用，否则不会主动去编译；而且，源文件调用头文件的本质，就是将头文件的内容复制到源文件中而已。</p><p>此时，如果没有发生函数重载，在同一个工程中，就不能出现同名函数【联系头文件的复制本质，可知不同文件中也不能有同名函数】。如果在头文件中定义了函数【声明可以多次，但定义只能一次】，就会出现重定义的错误。</p><p><strong>解决</strong>：声明可以多次，但定义只能一次</p><p><strong>例外情况：</strong>静态函数【<code>static void fun()&#123;&#125;</code>】，此类函数仅在使用该函数的文件内有效；内联函数；静态变量【<code>static int a;</code>】</p></blockquote><p>头文件中可以用 <code>extern</code> 声明全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 现有库，已经被安装在了系统中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;emath.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明即可调用同级文件中的函数</span></span><br><span class="line"><span class="comment">//int ave(int, int);</span></span><br><span class="line"><span class="comment">//int ave(int, int);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;emath.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  <span class="comment">// 对某个特定源文件来说，emath.h 仅被调用1次【部分编译器不支持】</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>可以替代 <code>#pragma once</code> 的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;emath.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEMATH_ <span class="comment">// 如果没有定义宏变量 _HEMATH_，就执行下面的</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEMATH_</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!_HEMATH_</span></span></span><br></pre></td></tr></table></figure><p>该预编译指令的现实场景用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若没有VIP的宏定义，根本不会被编译【可用于编译为两个版本的文件】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWelcome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _VIP</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你好！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_VIP</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<code>#pragma once</code> 依赖文件，<code>#ifdef</code> 依赖宏定义名，且功能更强大</p><h5 id="3-8-4-extern"><a href="#3-8-4-extern" class="headerlink" title="3.8.4 extern"></a>3.8.4 extern</h5><p>在开发中，会面临C与C++混用的情况，它们对函数的处理是不同的。</p><p>对于上节提到的函数重定义的报错，C++中的报错提示为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">C++支持函数重载，故函数名为下：</span></span><br><span class="line">&quot;int _cdecl ave(void)&quot;(?ave@@YAHXZ)已经在class1.obj中定义</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">C不支持函数重载</span></span><br><span class="line">_ave已经在e.obj中定义</span><br></pre></td></tr></table></figure><p>故同时存在C++文件和C文件时，由于编译后名字不同，故不会发生函数重定义的错误。</p><p>混用正确调用的例子：【三种写法】</p><ul><li><code>extern &quot;C&quot; int ave();</code></li><li><code>extern &quot;C&quot; &#123;...&#125;</code> 大括号中是所有C风格的函数</li><li>在cpp源文件中，<code>extern &quot;C&quot; &#123;#include &quot;e.h&quot;;&#125;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//int ave();</span></span><br><span class="line"><span class="comment">//extern &quot;C&quot; int ave();</span></span><br><span class="line"><span class="comment">// 或合起来写</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.c：C风格</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// control.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;e.h&quot;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;e.h&quot;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt; ave()&lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 报错：无法解析该函数符号&quot;int _cdecl ave(void)&quot;(?ave@@YAHXZ)</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">ave</span>()&lt;&lt; std::endl; <span class="comment">// 为e.h添加extern &quot;c&quot;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾，C无法使用C++风格的函数【比如，C下编译器只会找名为<code>_ave</code>的函数】，此类型情况的<strong>解决办法</strong>是，在定义时，用上面 <code>extern “C”</code>的写法将C++风格的函数声明为C风格的函数。</p><p>反过来，C风格的写法下，无法识别 <code>extern &quot;C&quot;</code>。该问题的解决办法是：使用宏来判别风格类型。</p><blockquote><p>C++风格下，默认定义了一个宏，名为<code>__cplusplus</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;emath.h&quot;</span>;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmath.h&quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的写法，可以保证一个源文件能同时在C或C++风格下运行。</p><blockquote><p>注意：C++风格的函数被声明为C风格的函数时，就在也不支持函数重载了。</p></blockquote><p>特别注意一个错误：【LNK4042：C和C++源文件混用的问题】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// math.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// math.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// control.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">5</span>)&lt;&lt; std::endl; </span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">5</span>)&lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译错误：</span></span><br><span class="line"><span class="comment">//LNK2019:无法解析外部符号&quot;int _cdecl ave(int,int)&quot;(?ave@@YAHXZ)...</span></span><br></pre></td></tr></table></figure><p>该错误的原理要联系到编译的过程：编译器先将各个源文件编译为obj目标文件，再链接为目标程序。而在上面的代码中，<code>math.cpp</code> 和 <code>math.c</code> 都会被编译为<code>math.obj</code>，故找不到某一个函数。</p><h5 id="3-8-5-封装自己的SDK：hongxin"><a href="#3-8-5-封装自己的SDK：hongxin" class="headerlink" title="3.8.5 封装自己的SDK：hongxin"></a>3.8.5 封装自己的SDK：hongxin</h5><p>生成<code>.lib</code>文件【静态库】【属性 | 常规 | 配置类型 | 静态库】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hongxin.h</span></span><br><span class="line"><span class="comment">// lib库文件都应该有说明文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hongxin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetVersion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hongxin.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hongxin.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hongxin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成静态库sdk：【右键工程 | 生成】，在工程目录中lib文件就是库文件【名字可更改】，可以配合头文件【说明文档】，在加一个示例程序就可以发布给别人用。当然，更多的是直接做成安装包【SDK】。</p><p>如果不安装，在新项目中使用lib文件，需要配置【属性 | VC++目录 | 包含目录】，将目录跟在后面即可。使用时，使用 <code>#include &lt;newname.h&gt;</code>；此时，还没将库文件放入，同样配置【… | 库目录】</p><p>但编译器不会主动链接库文件，需要手动完成【两种方法】</p><ul><li><code>#pragma comment(lib, &quot;hongxin.lib&quot;)</code></li><li>【属性 | 链接器 | 输入 | 附加依赖项】加入hongxin.lib【会去库目录找文件】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//newproject.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hongxin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;hongxin.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; hongxin::<span class="built_in">GetVersion</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-6-自定义创建项目模板"><a href="#3-8-6-自定义创建项目模板" class="headerlink" title="3.8.6 自定义创建项目模板"></a>3.8.6 自定义创建项目模板</h5><p>【顶层任务栏：项目 | 导出模板 | 项目模板 | 可配置名称、图标 | 自动导入+完成】</p><p>生成一个zip文件，当下次创建新项目时，在所有语言下，就会出现自定义的模板。</p><blockquote><p>发布的zip文件的再使用：直接copy到【我的文档 | Visual Studio xxxx | Templates | ProjectTemplates】</p></blockquote><h5 id="3-8-7-函数调用约定"><a href="#3-8-7-函数调用约定" class="headerlink" title="3.8.7 函数调用约定"></a>3.8.7 函数调用约定</h5><blockquote><p><code>__cdecl</code> <code>__stdcall</code> <code>__fastcall</code> <code>__thiscall</code>【类访问】 <code>__nakedcall</code>【驱动】</p></blockquote><p>函数调用约定时函数调用与被调用者之间的一种协定，主要包括两个内容：如果传递参数？如何恢复栈平衡？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先push b，再push a</span></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ave</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数名被编译器修改为<code>__cdecl</code>+xxx，其参数入栈顺序从右到左；而堆栈平衡：谁调用谁平衡</p><p>正因为<code>__cdecl</code>这种堆栈平衡方式，能够支持不定量参数；</p><p>另一种暂时没遇到过的函数调用约定是：<code>__stdcall</code>。其参数入栈顺序从右到左；但此类函数的堆栈平衡恢复由原函数本身负责。从汇编角度，由<code>ret 8</code>完成</p><blockquote><p>Windows 编程中<code>WINAPI CALLBACK</code> 都是<code>__stdcall</code> 的宏，生成的函数名会加下划线，后面跟@和参数尺寸</p></blockquote><p>第三种函数调用约定是：<code>__fastcall</code>。其第一个参数通过ecx传递，第二个参数通过edx传递，剩余参数入栈顺序从右到左；此类函数的堆栈平衡恢复由原函数本身负责。【执行速度快，优先通过寄存器传参】【三参数时，汇编由 <code>ret 4</code> 返回】【x64默认为<code>__fastcall</code>】</p><br><h3 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h3><blockquote><p>以下才是C++的内容</p></blockquote><p>OOP【Object Oriented Programmming】即面向对象编程，是一种编程思想，通过把我们编程中遇到的事物抽象程对象来编程；与OOP相对的还有：面向对象设计OOD、面向对象分析OOA【OOP应当遵循OOD】</p><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h4><h5 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1 封装的意义</h5><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​ 在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//获取到圆的周长</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//2 * pi  * r</span></span><br><span class="line">        <span class="comment">//获取圆的周长</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">    <span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    c<span class="number">1.</span>m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        m_id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">    stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">    stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ul><li>public 公共权限</li><li>protected 保护权限【与继承相关】</li><li>private 私有权限【默认】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_Car;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">    <span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h5><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为<strong>私有</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    C1 c1;</span><br><span class="line">    c<span class="number">1.</span>m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">    C2 c2;</span><br><span class="line">    c<span class="number">2.</span>m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h5><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名设置可读可写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄 </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置为只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">    <span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line">    string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//姓名设置</span></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄设置</span></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置</span></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-1-4-成员函数"><a href="#4-1-4-成员函数" class="headerlink" title="4.1.4 成员函数"></a>4.1.4 成员函数</h5><ul><li>占用空间</li><li><code>inline</code> 内联函数</li></ul><p>类的占用空间大小：类变量大小【类成员函数为所有类对象公用，不占对象的存储空间 | <code>sizeof</code>】</p><p>空类的大小：1字节【使用该空类实例化后，编译器为区分实例对象，默认加入1字节用于区分】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(Role&amp; r)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Role::Act</span><span class="params">(Role&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r.hp -= damage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Role::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hpRecover = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role user;</span><br><span class="line">    P p1, p2;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(user) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般工程化时，一个类可能很多人在用，所以一般在单独文件中创建类【源文件|添加类】，生成一个头文件【类声明】，一个cpp源文件【成员函数定义】</p></blockquote><p><strong>inline内联函数</strong>：类似于<code>getHp()</code>等直接返回值的函数，推荐用inline写法【推荐直接写在头文件中】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getHp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果此类函数在声明类时未使用inline修饰，在定义时也可以加上inline，以定义为准【重写原则】</p></blockquote><h5 id="4-1-5-const"><a href="#4-1-5-const" class="headerlink" title="4.1.5 const"></a>4.1.5 const</h5><ul><li>常函数</li><li>常对象</li><li>const类型转换</li></ul><p><strong>常函数：</strong></p><ul><li>成员函数<strong>后</strong>加<code>const</code>后我们称为这个函数为<strong>常函数</strong></li><li>常函数内<strong>不可以修改成员属性</strong>【引用也不可返回，因为引用的本质是指针，返回引用后可能会存在修改风险】【解决办法1：直接返回值不返回引用；解决办法2：再用const修饰函数返回值，要求不允许更改】</li><li>成员属性声明时<strong>加关键字<code>mutable</code>后</strong>，在常函数中依然<strong>可以修改</strong></li><li>常函数内的 <code>this</code> 指针也变成了<code>const</code>指针</li></ul><blockquote><p>mutable：可变的【场景：如需要在常函数中记录被调用次数，即需要某变量++】</p></blockquote><p><strong>常对象：</strong></p><ul><li>声明对象前加 <code>const</code> 称该对象为常对象</li><li>常对象的成员变量的值不能被改变</li><li>常对象<strong>只能调用常函数</strong>【意味着不能调用函数去改变成员变量值，没有任何方式改变对象的成员值】</li></ul><blockquote><p>也有人建议：凡是不涉及修改成员变量值的成员函数，都可以后加const修饰，以便于常对象调用；</p><p>另外，也可以利用函数重载，提供非const版本和const版本【仅是否const，就可以构成重载】</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        m_A = <span class="number">0</span>;</span><br><span class="line">        m_B = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">    <span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">    <span class="comment">//const Person* const this; 等同于下函数的声明const</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//const Type* const pointer;</span></span><br><span class="line">        <span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">        <span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mA = 10000;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">    cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">    person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常对象访问成员函数</span></span><br><span class="line">    person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const 类型转化</strong>：<code>const_cast</code> 可以将一个const变量的常量属性去掉，只有在极少数的情况下需要用此功能【一种C方式，一种C++方式，有区别】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(Role&amp; r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        r.hp -= damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHp</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//this-&gt;hp = 2;// 不可以修改</span></span><br><span class="line">        <span class="keyword">return</span> hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLv</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//const版本不能返回引用，有修改风险【两个解决办法】</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//const int&amp; GetLv() const&#123;&#125;【解决方法2】</span></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">GetLv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHp</span><span class="params">(<span class="type">int</span> hp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：编码时要求不是常量，故需要转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Role* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">setHp</span>(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Role user&#123;&#125;;</span><br><span class="line">    Role monster;</span><br><span class="line">    <span class="type">const</span> Role* puser&#123; &amp;user &#125;;<span class="comment">// 用一个常对象，给常量指针赋值</span></span><br><span class="line">    <span class="comment">// puser-&gt;damage = 2;// 错误：因为puser是一个常量指针，其指向的值不能修改</span></span><br><span class="line">    puser-&gt;<span class="built_in">GetHp</span>(); <span class="comment">// 常对象只能调用常函数</span></span><br><span class="line">    cout &lt;&lt; monster.<span class="built_in">GetHp</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    monster.<span class="built_in">GetLv</span>() = <span class="number">200</span>;<span class="comment">// 【仅演示，实际不这样写】非const函数可以返回引用，但const函数不可以</span></span><br><span class="line">    cout &lt;&lt; monster.<span class="built_in">GetLv</span>() &lt;&lt; endl;<span class="comment">//200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="comment">//test(&amp;user);// 需要转换</span></span><br><span class="line">    <span class="built_in">test</span>((Role*)(&amp;user));<span class="comment">//强制类型转换【C】</span></span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">const_cast</span>&lt;Role*&gt;(&amp;user));<span class="comment">//【C++】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h4><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h5 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h5><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题。一个对象或者变量没有初始状态，对其使用后果是未知；同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个特殊的成员函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写<code>void</code></li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写<code>void</code></li><li>函数名称与类名相同。在名称前加上符号 <code>~</code></li><li>析构函数<strong>不可以有参数</strong>，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也可以使用default关键字定义析构函数</span></span><br><span class="line">    <span class="comment">//~Person()=default;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    Person p;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin &gt;&gt; a;<span class="comment">// 输入0时，p被销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nending&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-引入构造函数"><a href="#4-2-2-引入构造函数" class="headerlink" title="4.2.2 引入构造函数"></a>4.2.2 引入构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMP</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mp; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMP</span><span class="params">(<span class="type">int</span> _mp)</span> </span>&#123; mp = _mp; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1&#123; <span class="number">100</span>,<span class="number">200</span> &#125;;<span class="comment">// 可以使用&#123;&#125;构造，但一旦有私有变量，就不可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TT t2&#123; 100,200 &#125;;//错误</span></span><br><span class="line">    <span class="comment">//TT t2&#123; 100 &#125;;//错误</span></span><br><span class="line">    <span class="comment">// 先给t2赋值</span></span><br><span class="line">    TT t2&#123;&#125;;</span><br><span class="line">    t<span class="number">2.</span>hp = <span class="number">100</span>;</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">SetMP</span>(<span class="number">200</span>);</span><br><span class="line">    TT t3&#123; t2 &#125;;<span class="comment">// 相当于 = 赋值，即t3=t2;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-3-构造函数的分类及调用"><a href="#4-2-3-构造函数的分类及调用" class="headerlink" title="4.2.3 构造函数的分类及调用"></a>4.2.3 构造函数的分类及调用</h5><p><strong>两种分类方式：</strong></p><ul><li>按参数分为： 有参构造和无参构造</li><li>按类型分为： 普通构造和拷贝构造</li></ul><p><strong>三种调用方式：</strong></p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数---------！！！不允许修改原件</span></span><br><span class="line">    <span class="comment">//为什么必须是引用？如果不是引用，相当于又定义了个临时类实例Person tmp(p);即陷入死循环</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123; <span class="comment">// 【const + 引用】</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1  括号法，常用</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//【注意1】：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">    <span class="comment">//Person p2();---------------错误【被认为是函数声明】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 显式法</span></span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">    <span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【注意2】：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">// Person(p3) === Person p3; </span></span><br><span class="line">    <span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h5><blockquote><p>调用规则 | <code>default</code> 关键字 | <code>explicit</code> 关键字</p></blockquote><p>默认情况下，<strong>c++编译器至少给一个类添加3个函数</strong></p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数（对属性进行值拷贝）</p><p><strong>构造函数调用规则</strong>如下：</p><ul><li>如果用户定义<strong>有参构造函数</strong>，c++<strong>不再提供默认无参构造</strong>，<strong>但是会提供默认拷贝构造</strong></li></ul><ul><li>如果用户定义<strong>拷贝构造函数</strong>，c++<strong>不会再提供其他构造函数</strong></li></ul><blockquote><p>只要定义过构造函数，默认构造函数就不会被定义。但有时候我们希望依然自动提供一个默认构造函数，要么自己显示补充，要么需要关键字 <code>default</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//手动补充默认构造函数</span></span><br><span class="line">    <span class="comment">/*Person() &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="built_in">Person</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该两种写法中，<code>default</code> 的执行效率更高，但手动补充的方式功能可以更丰富</p></blockquote><p>需要注意的一点：默认构造函数与带默认参数的构造函数可能发生重复，编译器无法区分，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发生错误，无法重载！</span></span><br><span class="line">    <span class="built_in">Person</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 建议保留，删除默认构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a = <span class="number">100</span>) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用规则演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">    Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">    Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>explict</code> 关键字修饰构造函数：</strong>禁止类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBig</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.age &gt; age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">100</span>)</span>, <span class="title">p2</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 此处的【50】发生了默认的类型转换，且调用带参构造函数</span></span><br><span class="line">    cout &lt;&lt; p<span class="number">1.</span><span class="built_in">isBig</span>(p2) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">isBig</span>(<span class="number">50</span>) &lt;&lt; endl;<span class="comment">//1 0</span></span><br><span class="line">    <span class="comment">// 等价于 p1.isBig(Person(50))</span></span><br><span class="line">    <span class="comment">// 可以使用explicit修饰构造函数来禁用类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-5-深入理解构造函数"><a href="#4-2-5-深入理解构造函数" class="headerlink" title="4.2.5 深入理解构造函数"></a>4.2.5 深入理解构造函数</h5><p>使用<strong>初始化列表初始化</strong>，优势在于</p><ul><li>效率更高【类实例化要先分配内存空间，然后给成员变量设定默认值，再调用构造函数初始化；但初始化列表直接代替设定默认值，直接用初始化列表设定变量值，再调用构造函数】</li><li>在某些情况下，只能使用这种方式初始化【成员变量中有结构体类型或类类型】【涉及类的继承】</li></ul><p>劣势在于：类实例化要先分配内存空间，然后使用初始化列表设置默认值【自上往下，即无论初始化列表中的初始化顺序如何，都会按类定义成员变量的顺序进行初始化】。如下例中，列表中hp定义在前，且hp依赖与lv，但lv还未初始化，会导致数值随机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/*Role(int _hp, int _lv) &#123;</span></span><br><span class="line"><span class="comment">        hp = _hp;</span></span><br><span class="line"><span class="comment">        lv = _lv;</span></span><br><span class="line"><span class="comment">    &#125;*/</span><span class="comment">//等价于下：使用初始化列表来初始化</span></span><br><span class="line">    <span class="built_in">Role</span>(<span class="type">int</span> _hp, <span class="type">int</span> _lv) :hp&#123;_hp&#125;,lv &#123; _lv &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>委托构造</strong>：【在一个构造函数中，其一部分的任务由另一个构造函数完成，故为了避免代码重复，使用委托构造】当调用该构造函数时，先执行委托构造函数，再执行本构造函数。</p><p>注意：</p><ul><li>只能跟随一个委托构造函数</li><li>不能再使用初始化列表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Role</span>(<span class="type">int</span> _hp, <span class="type">int</span> _lv) :<span class="built_in">Role</span>(_lv)<span class="comment">// 委托构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Role</span>(<span class="type">int</span> _lv)</span><br><span class="line">    &#123;</span><br><span class="line">        lv = _lv;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-2-6-拷贝构造函数"><a href="#4-2-6-拷贝构造函数" class="headerlink" title="4.2.6 拷贝构造函数"></a>4.2.6 拷贝构造函数</h5><p>拷贝构造函数【也称副本构造函数】，编译器默认指定了一个拷贝构造函数。</p><ul><li>调用方式</li><li>拷贝构造函数中，可访问同类型类的私有变量</li><li>拷贝构造函数的参数应为常右值引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Role</span>(<span class="type">int</span> _hp, <span class="type">int</span> _lv) :<span class="built_in">Role</span>(_lv)<span class="comment">// 委托构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Role</span>(Role&amp; role) :hp&#123; role.hp &#125; <span class="comment">// 严格意义上要加const，如果不是引用会导致死循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//hp = role.hp;// 此处为同类中访问成员变量，故可访问私有变量；若为不同类，不可访问私有</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> lv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Role <span class="title">user</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="function">Role <span class="title">user1</span><span class="params">(user)</span></span>;<span class="comment">//调用拷贝构造</span></span><br><span class="line">    Role user2 = user1;<span class="comment">//调用拷贝构造【等价于Role user2&#123;user1&#125;;】</span></span><br><span class="line"></span><br><span class="line">    user2 = user1;<span class="comment">// 不会调用拷贝构造,而是重载运算符</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拷贝构造函数调用时机</strong>：C++中拷贝构造函数【也称副本构造函数】调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = p.mAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">    <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person newman3;</span></span><br><span class="line">    <span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-7-深拷贝与浅拷贝"><a href="#4-2-7-深拷贝与浅拷贝" class="headerlink" title="4.2.7 深拷贝与浅拷贝"></a>4.2.7 深拷贝与浅拷贝</h5><blockquote><p>深浅拷贝是面试经典问题，也是常见的一个坑</p></blockquote><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">        <span class="comment">// m_height = p.m_height; // 编译器默认</span></span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">        <span class="comment">// *p.m_height : 具体数值【解引用】</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数：会将堆区开辟的数据做释放！！</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span>* m_height; <span class="comment">// 为了把身高数据，开辟到堆区</span></span><br><span class="line">    <span class="comment">// 注意：构造函数中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 报错：浅拷贝错误</span></span><br><span class="line">    <span class="comment">// 【会把p1数据地址复制过去，若p1释放则原堆区释放数据，但p2会重复释放】</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p<span class="number">1.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">1.</span>m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">2.</span>m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供<strong>拷贝构造函数</strong>，防止浅拷贝带来的问题</p></blockquote><h5 id="4-2-8-初始化列表"><a href="#4-2-8-初始化列表" class="headerlink" title="4.2.8 初始化列表"></a>4.2.8 初始化列表</h5><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">////传统方式初始化</span></span><br><span class="line">    <span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">//	m_A = a;</span></span><br><span class="line">    <span class="comment">//	m_B = b;</span></span><br><span class="line">    <span class="comment">//	m_C = c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表方式初始化</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-9-练习：hstring"><a href="#4-2-9-练习：hstring" class="headerlink" title="4.2.9 练习：hstring"></a>4.2.9 练习：hstring</h5><p>实现功能：</p><ul><li>构造函数：<code>hstring str(&quot;你好！&quot;);</code></li><li>副本构造函数：<code>hstring strA(str);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* hstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> length;</span><br><span class="line">    <span class="comment">// 求字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> len&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//while(str[len++])</span></span><br><span class="line">        <span class="keyword">while</span> (str[len])</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;len:&quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>()<span class="comment">// 默认构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        length = <span class="number">1</span>;<span class="comment">//注意：空字符串长度为1</span></span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//hstr = str;// 很明显的错误</span></span><br><span class="line">        <span class="comment">//hstr = (char*)str;//无报错，但编译错误：析构函数无法释放未分配的内存</span></span><br><span class="line">        length = <span class="built_in">getLength</span>(str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this length&quot;</span> &lt;&lt; length&lt;&lt;endl;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[length];</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, str, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认拷贝构造：直接赋值hstr和length，其中hstr的直接复制导致析构函数无法释放未分配的内存</span></span><br><span class="line">    <span class="comment">//副本构造函数</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        length = str.length;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[length];</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, str.hstr, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用委托构造,功能同上</span></span><br><span class="line">    <span class="comment">/*hstring(const hstring&amp; str):hstring(show())</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//动态改变内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        length = <span class="built_in">getLength</span>(str);</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[length];</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, str, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数：释放堆区空间</span></span><br><span class="line">    ~<span class="built_in">hstring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hstring str1;</span><br><span class="line">    cout &lt;&lt; str<span class="number">1.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">hstring <span class="title">str2</span><span class="params">(<span class="string">&quot;你好！地球人！&quot;</span>)</span></span>;<span class="comment">//14字节</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(str<span class="number">2.</span><span class="built_in">show</span>()) &lt;&lt; endl;<span class="comment">// 18</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; endl;<span class="comment">// 除了14字节的7个字符，还有乱码</span></span><br><span class="line"></span><br><span class="line">    <span class="function">hstring <span class="title">str3</span><span class="params">(str2)</span></span>;</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str<span class="number">3.</span><span class="built_in">setStr</span>(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在bug，显示如下【为什么申请了14个字节，但实际给了30个？】</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dd14</span><br><span class="line">this length14</span><br><span class="line"><span class="number">30</span></span><br><span class="line">你好！地球人！葺葺葺鸊钧?</span><br><span class="line">你好！地球人！葺葺葺鐶?</span><br><span class="line">dd6</span><br><span class="line">你好！葺葺葺葺葺</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p><strong>🔺分析解决</strong>：初始化问题【须多申请一个位置存放结束位置，并将其全部初始化为0】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hstr = <span class="keyword">new</span> <span class="type">char</span>[length<span class="number">+1</span>];</span><br><span class="line"><span class="built_in">memset</span>(hstr, <span class="number">0</span>, length<span class="number">+1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(hstr, str, length);</span><br></pre></td></tr></table></figure><br><h4 id="4-3-类与对象的本质"><a href="#4-3-类与对象的本质" class="headerlink" title="4.3 类与对象的本质"></a>4.3 类与对象的本质</h4><h5 id="4-3-1-C-对象模型"><a href="#4-3-1-C-对象模型" class="headerlink" title="4.3.1 C++对象模型"></a>4.3.1 C++对象模型</h5><p>在C++中，类内的成员变量和成员函数分开存储，<strong>只有非静态成员变量才属于类的对象上</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空对象占用内存空间为：1</span></span><br><span class="line">    <span class="comment">// C++ 编译器会给每一个空对象分配一个字节的空间，是为了区分空对象占用内存的位置</span></span><br><span class="line">    Person1 p;</span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;size of p is &quot;</span> &lt;&lt;  <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_A; <span class="comment">// 非静态成员变量 属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 占用空间为4【内存对齐】</span></span><br><span class="line">    Person2 p;</span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;size of p is &quot;</span> &lt;&lt;  <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_A; <span class="comment">// 非静态成员变量 属于类的对象上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 占用空间为4【内存对齐】  ---- 不包含静态变量</span></span><br><span class="line">    Person3 p;</span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;size of p is &quot;</span> &lt;&lt;  <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        mA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">    <span class="type">int</span> mA;</span><br><span class="line">    <span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">    <span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h5><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><blockquote><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p></blockquote><p>this指针的<strong>用途</strong>：</p><ul><li>当形参和成员变量同名时，可用this指针来区分【解决命名冲突】</li><li>在类的非静态成员函数中<strong>返回对象本身</strong>，可使用 <code>return *this</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🔺返回引用，不会重新创建对象；值返回会通过拷贝函数创建新对象</span></span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//返回对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 返回引用---实现链式编程</span></span><br><span class="line">    p<span class="number">2.</span><span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处*this的用法：本质同下三行</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="type">int</span>&amp; c = *p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h5><p>C++中空指针也是可以调用成员函数的，但是也要<strong>注意有没有用到<code>this</code>指针</strong></p><blockquote><p>如果用到this指针，需要加以判断保证代码的健壮性</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证代码健壮性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 默认为 cout &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person * p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">    p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-4-静态成员"><a href="#4-3-4-静态成员" class="headerlink" title="4.3.4 静态成员"></a>4.3.4 静态成员</h5><p>静态成员就是在成员变量和成员函数前加上关键字<code>static</code>，称为静态成员</p><blockquote><p>静态变量只被定义一次【涉及内存分配，也只有一次】，程序结束自动释放</p><p>讲到过 <code>static</code> 的地方，目前是【1 程序分区模型】【2.4 引用做函数返回值】【3.8 C语言和C++联合编程 static inline】【6 编译器 OOD】</p></blockquote><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据【静态成员变量不占类大小】</li><li>在编译阶段分配内存【即类未实例化时就可访问，非静态成员变量在实例化时分配内存】</li><li><strong>类内声明，类外初始化</strong>【否则链接错误】</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数【即类未实例化时就可访问】</li><li>静态成员函数<strong>只能访问静态成员变量</strong>【可能非静态成员变量还没有分配内存空间】</li><li>类的静态成员函数不能是const【即不能是常函数】【常函数即不改变成员属性，而且静态成员函数本身就不能访问非静态的成员变量，故没有意义】</li><li>类的静态成员函数不能使用this指针【可能使用this指针改变非静态成员变量】</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="comment">// c++17新语法：静态成员变量初始化【&#123;&#125;默认0】【记得在析构函数中count--】</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;<span class="comment">// 在构造函数中count++,可用于统计实例个数</span></span><br><span class="line">    <span class="comment">//静态成员常量【counter值无法更改】</span></span><br><span class="line">    <span class="comment">//inline const static int counter&#123;&#125;;// 有了const可以省略inline</span></span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;<span class="comment">//仅可定义基本类型的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员变量特点：</span></span><br><span class="line">    <span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">    <span class="comment">//2 类内声明，类外初始化[存在例外]</span></span><br><span class="line">    <span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Person类的大小：sizeof(Person)不包括静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p<span class="number">1.</span>m_A = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p<span class="number">2.</span>m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p<span class="number">2.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数特点：</span></span><br><span class="line">    <span class="comment">//1 程序共享一个函数</span></span><br><span class="line">    <span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">    <span class="comment">//  【因为非静态变量只能通过对象访问】</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p<span class="number">1.f</span>unc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-5-malloc与new的本质区别"><a href="#4-3-5-malloc与new的本质区别" class="headerlink" title="4.3.5 malloc与new的本质区别"></a>4.3.5 malloc与new的本质区别</h5><p>对于普通的数据类型来说malloc和new没什么区别；但是对于类来说，malloc仅仅是分配内存，new除了分配内存以外还会调用构造函数！</p><p>对于普通的数据类型来说free和delete没有什么区别；但是对于类来说，free仅仅是释放内存空间，而delete不仅释放内存空间，还会调用类的析构函数</p><p>对于普通的数据类型来说delete和delete[]没有什么区别；但是对于类来说，delete仅仅是释放内存空间，且调用第一个元素的析构函数，而delete[]不仅释放内存空间，还会调用每一个元素的析构函数</p><blockquote><p>另外，new一个指针会进行类型检查，而malloc出来的指针是无类型的，不进行类型检查</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_count&#123;&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;<span class="comment">// c++17的inline</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ++count &lt;&lt; <span class="string">&quot;个T被构造&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">2</span>;</span><br><span class="line">    ~<span class="built_in">T</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; m_count-- &lt;&lt; <span class="string">&quot;个T被析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t1 = (T*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    std::cout &lt;&lt; t1[<span class="number">2</span>].test &lt;&lt; std::endl;<span class="comment">//-842150451</span></span><br><span class="line">    T* t2 = <span class="keyword">new</span> T[<span class="number">20</span>];<span class="comment">// 涉及了构造函数或析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于普通的数据类型来说malloc和new没什么区别</span></span><br><span class="line">    <span class="type">int</span>* pint = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    pint[<span class="number">2</span>] = <span class="number">25</span>;</span><br><span class="line">    std::cout &lt;&lt; pint[<span class="number">2</span>] &lt;&lt; std::endl;<span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(t1);</span><br><span class="line">    <span class="built_in">free</span>(pint);</span><br><span class="line">    <span class="comment">//free(t2);//直接报错：释放类的空间而没有调用类的析构函数</span></span><br><span class="line">    <span class="comment">//delete t2;// 调用析构函数后报错：t2是个指针数组【即只销毁了第一个对象】</span></span><br><span class="line">    <span class="keyword">delete</span>[] t2;<span class="comment">// 注意：从第100个开始销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-6-从底层理解类"><a href="#4-3-6-从底层理解类" class="headerlink" title="4.3.6 从底层理解类"></a>4.3.6 从底层理解类</h5><ul><li>类的函数调用约定this call【x86 32位】</li><li>为什么静态成员函数没有this指针？【使用<code>__cdecl</code>函数调用约定】</li><li>为什么静态成员函数不能访问类的非静态成员变量？【根本就没有传递this指针】</li><li>类真的一定有构造函数吗？</li></ul><blockquote><p>x86 32位操作系统下，观察汇编代码【Release模式下，禁用代码优化；代码生成|禁用安全检查】</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp + a + b;</span><br><span class="line">        <span class="comment">// 相当于：return this.hp + a + b;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非静态的类函数调用为<code>__thiscall</code>，其不同于普通函数和类静态函数的调用约定【上一次讨论函数调用约定：<code>3.8.7 函数调用约定</code>】</p><p><img src="/.io//2-4-1.png"></p><p><code>_thicall</code> 是C++中类的成员函数访问时定义的函数调用约定</p><p>(1）寄存器<code>ecx</code>用来存放类的指针</p><p>(2) 参数由右到左入栈</p><p>(3) 堆栈由被调用者负责恢复</p><p>类中的<strong>非静态成员函数</strong>都可以使用this指针，this指针本质上来讲就是把对象的指针通过寄存器ecx传入成员函数的。因此，类中成员函数访问其成员变量时，都是通过指针+偏移的形式来访间的，不管是否明确使用this指针。【注意：约定使用 <code>exc</code>，不是铁律，可以调整，这属于<strong>4.3.7 自定义类的函数调用</strong> 】</p><p>对于类的<strong>静态成员函数</strong>，本质上是采用的<code>_cdecl</code>约定</p><p>(1）参数由右到左入栈</p><p>(1）由调用者恢复堆栈平衡</p><p>因为类的静态成员函数本质上就是一个普通的函数，所以根本没有传递对象的指针。因此：</p><ul><li>类的静态成员函数也就不能访问其成员变量；</li><li>而类的静态成员变量本质上相当于一个全局变量，有着固定的内存地址，与类对象并无关系。所以类的静态成员，可以在类没有实例的情况下，通过【<code>类::静态成员</code>】这样的形式来访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp + a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1;</span><br><span class="line">    <span class="comment">//t1.Add(10, 20);</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetNum</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类的<strong>静态成员变量</strong>，可以在上图中看到，静态成员函数调用静态成员变量时，直接使用全局变量的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123; <span class="number">0</span> &#125;;<span class="comment">//c++17新语法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp + a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1;</span><br><span class="line">    <span class="comment">//t1.Add(10, 20);</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetNum</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<strong>类真的一定有构造函数吗？</strong></p><p>我们在学习类时，每个类都有一个默认构造函数，如果没有显式指定，编译器会为我们添加一个空的默认构造函数 <code>T()&#123;&#125;</code>。</p><p>但是我们在逆向后会发现，类T大部分的时候是没有默认构造函数的。这是因为C/C++标准委员会要求每一个类都有默认构造函数，而一个空的构造函数实际上没有任何意义，所以某些情况下编译器会删除掉没有意义的构造函数，这是编译器优化的功劳。原则上来讲，每一个类都有默认构造函数。</p><p>当然，如果在类定义的时候，给类成员变量赋初值，这时候的默认构造函数就有了意义，编译器会添加默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp &#123;<span class="number">200</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-3-7-自定义类的函数调用"><a href="#4-3-7-自定义类的函数调用" class="headerlink" title="4.3.7 自定义类的函数调用"></a>4.3.7 自定义类的函数调用</h5><p>由上一节中引出，在类成员函数的调用约定 <code>thiscall</code> 中，默认使用exc传递this指针。但也可以自定义调用约定，以下进行介绍：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeAct</span><span class="params">(<span class="type">int</span> damage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hp = hp - damage;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BeAct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> _stdcall <span class="title">BeAct1</span><span class="params">(<span class="type">int</span> damage1, <span class="type">int</span> damage2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hp = hp - damage1;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BeAct1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> _cdecl <span class="title">BeAct2</span><span class="params">(<span class="type">int</span> damage1, <span class="type">int</span> damage2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hp = hp - damage1;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BeAct1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role p;</span><br><span class="line">    p.<span class="built_in">BeAct</span>(<span class="number">20</span>);<span class="comment">// 默认将p的地址传入ecx作为this指针</span></span><br><span class="line">    p.<span class="built_in">BeAct1</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// 使用stdcall的调用约定</span></span><br><span class="line">    p.<span class="built_in">BeAct2</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// 使用cdecl的调用约定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编如下：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">22</span>:     p.BeAct(<span class="number">20</span>);<span class="comment">// 默认将p的地址传入ecx作为this指针</span></span><br><span class="line"><span class="number">008</span>F1084  push        <span class="number">14</span>h  </span><br><span class="line"><span class="number">008</span>F1086  lea         ecx,[p]  <span class="comment">//ecx作为this</span></span><br><span class="line"><span class="number">008</span>F1089  call        Role::BeAct (<span class="number">08</span>F1000h)  </span><br><span class="line">    <span class="number">23</span>:     p.BeAct1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">008</span>F108E  push        <span class="number">2</span>  </span><br><span class="line"><span class="number">008</span>F1090  push        <span class="number">1</span>  </span><br><span class="line"><span class="number">008</span>F1092  lea         eax,[p]  <span class="comment">// 将p作为参数传递，使用eax</span></span><br><span class="line"><span class="number">008</span>F1095  push        eax  </span><br><span class="line"><span class="number">008</span>F1096  call        Role::BeAct1 (<span class="number">08</span>F1040h)  </span><br><span class="line">    <span class="number">29</span>:     p.BeAct2(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// 使用cdecl的调用约定</span></span><br><span class="line"><span class="number">005</span>A10DB  push        <span class="number">2</span>  </span><br><span class="line"><span class="number">005</span>A10DD  push        <span class="number">1</span>  </span><br><span class="line"><span class="number">005</span>A10DF  lea         ecx,[p]  <span class="comment">// 将p作为参数传递，使用栈</span></span><br><span class="line"><span class="number">005</span>A10E2  push        ecx  </span><br><span class="line"><span class="number">005</span>A10E3  call        Role::BeAct2 (<span class="number">05</span>A1080h)  </span><br><span class="line"><span class="number">005</span>A10E8  add         esp,<span class="number">0</span>Ch  </span><br><span class="line">    <span class="number">30</span>: &#125;</span><br></pre></td></tr></table></figure><br><h4 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h4><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p><strong>友元的目的</strong>就是==让一个函数或者类 访问另一个类中私有成员==，友元的关键字为 <strong>friend</strong></p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><blockquote><p>注意：友元会破坏类的封装性，所以只会在特定场景下使用；友元类关系不是平等的。</p><p>注意：友元不具有传递性</p></blockquote><h5 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h5><p>可以访问友元类中私有的成员变量和成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">    <span class="comment">// 声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Building b;</span><br><span class="line">    <span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>; <span class="comment">// 先声明【🔺注意：类的编译也是顺序进行】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">    <span class="comment">// !!! 友元声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    goodGay  gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="4-5-嵌套类"><a href="#4-5-嵌套类" class="headerlink" title="4.5 嵌套类"></a>4.5 嵌套类</h4><h5 id="4-5-1-类对象作为类成员"><a href="#4-5-1-类对象作为类成员" class="headerlink" title="4.5.1 类对象作为类成员"></a>4.5.1 类对象作为类成员</h5><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员。那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_PhoneName = name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Phone</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">    <span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造！！！</span></span><br><span class="line">    <span class="comment">//析构顺序与构造相反</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">WeaponLV</span></span><br><span class="line">&#123;</span><br><span class="line">    normal=<span class="number">0</span>,</span><br><span class="line">    high,</span><br><span class="line">    rare,</span><br><span class="line">    myth</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这个类只有在 Role中才用到，可以将Weapon定义在Role中，被称为嵌套类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Weapon</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    short lv;</span></span><br><span class="line"><span class="comment">    WeaponLV wlv;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span><span class="comment">//外层类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//外层类的公有静态函数可被直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与写在外面相比，区别在于：作用域不同，Weapon的作用域仅在Role中有效</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Weapon</span><span class="comment">//嵌套类【随着嵌套类内容的增多，会越来越臃肿，故只声明】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Weapon* <span class="title">ReturnW</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">short</span> lv;</span><br><span class="line">        WeaponLV wlv;</span><br><span class="line">        <span class="built_in">Weapon</span>();</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">wtest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    Weapon leftHands;<span class="comment">// 将嵌套类定义在下面，会报错：不允许使用不完整的类型【未来可能会修复】</span></span><br><span class="line">    <span class="comment">//解决：将嵌套类定义在外层类内【不装杯】</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">common_test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="built_in">Role</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 外层类只能访问嵌套类的公有静态函数</span></span><br><span class="line">        Weapon::<span class="built_in">wtest</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外层类外定义嵌套类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Role::Weapon</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Weapon* ReturnW();</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    short lv;</span></span><br><span class="line"><span class="comment">    WeaponLV wlv;</span></span><br><span class="line"><span class="comment">    Weapon();</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义构造函数</span></span><br><span class="line">Role::Weapon::<span class="built_in">Weapon</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">test</span>();<span class="comment">//可直接访问外层类的【公有静态函数|静态 成员变量】</span></span><br><span class="line">    <span class="comment">//common_test();// 不可直接访问普通函数【需要实例】</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waepon!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似友元【可通过实例直接访问外层类的私有成员变量】</span></span><br><span class="line">    Role role;</span><br><span class="line">    role.mp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类外定义函数【可能出错】</span></span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">ReturnW</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role r1;</span><br><span class="line">    <span class="comment">//Weapon w1;//不在作用域内</span></span><br><span class="line">    Role::Weapon w1;<span class="comment">// 要求嵌套类是public,private封装的嵌套类无法访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套类受到封装的限制，只有当嵌套类是共有public时，才可以通过实例直接访问</li><li>嵌套类可直接访问外层类的【公有静态函数|公有静态成员变量】，而不能访问普通成员</li><li>外层类只能访问嵌套类的公有静态函数</li><li>类似友元【嵌套类可通过实例直接访问外层类的私有成员变量；相反，外层类无法通过实例直接访问嵌套类的私有成员变量】</li><li>枚举类型也可放入类中，但收到封装性质的影响【只有是共有public时，才可以通过实例直接访问】</li></ul><h5 id="4-5-2-局部类"><a href="#4-5-2-局部类" class="headerlink" title="4.5.2 局部类"></a>4.5.2 局部类</h5><p>定义在函数内的类称为局部类【非必要不用】</p><ul><li>局部类的定义必须写在类内</li><li>局部类中不允许使用静态成员变量</li><li>局部类可以访问全局变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> hp;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="comment">//static int aa;//不允许使用静态成员变量</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetHP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            a++;<span class="comment">//访问全局变量</span></span><br><span class="line">            x++;<span class="comment">//不可访问局部类的变量【有争议】</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span>&#123;&#125;<span class="comment">// 允许使用静态成员函数【有争议】</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-2-嵌套类的模块化问题"><a href="#4-5-2-嵌套类的模块化问题" class="headerlink" title="4.5.2 嵌套类的模块化问题"></a>4.5.2 嵌套类的模块化问题</h5><p>分文件编写嵌套类时，很可能遇到此问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Skill</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>::Skill</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role::Skill sk;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆为多文件形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;Role.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Skill.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Skill</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;Skill.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>::Skill</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;main&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Skill.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>错误原因在于：<code>&quot;Skill.h&quot;</code>中的<code>Role</code>需要<code>&quot;Role.h&quot;</code>中的定义，包含后<code>Role</code>的定义却在下方，是顺序问题【即变成如下的形式：故出错】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;Skill.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Role.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>::Skill</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Skill</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：删除<code>&quot;Role.h&quot;</code>中的 <code>#include &quot;Skill.h&quot;</code></p><br><h3 id="5-运算符重载"><a href="#5-运算符重载" class="headerlink" title="5 运算符重载"></a>5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="5-1-运算符重载"><a href="#5-1-运算符重载" class="headerlink" title="5.1 运算符重载"></a>5.1 运算符重载</h4><h5 id="5-1-1-运算符重载的概念"><a href="#5-1-1-运算符重载的概念" class="headerlink" title="5.1.1 运算符重载的概念"></a>5.1.1 运算符重载的概念</h5><ul><li>概念</li><li>类成员函数实现</li><li>非成员函数实现运算符重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：返回类型 operator运算符()&#123;&#125;</span></span><br><span class="line"><span class="comment">// 如</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Role&amp; role)&#123;&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> Age;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> Height;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; pa, Person&amp; pb);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">unsigned</span> <span class="type">short</span> _Age, <span class="type">unsigned</span> <span class="type">short</span> _h) :Age&#123; _Age &#125;, Height&#123; _h &#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getAge</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> Age; &#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Height; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">higher</span><span class="params">(Person&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Height &gt; p.<span class="built_in">getHeight</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类成员函数使用运算符重载【只能有一个参数】</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Person&amp; p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用运算符重载</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">smaller</span><span class="params">(Person&amp; pa, Person&amp; pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return pa.Age &lt; pb.Age;//无法使用类内私有成员</span></span><br><span class="line">    <span class="keyword">return</span> pa.<span class="built_in">getAge</span>() &lt; pb.<span class="built_in">getAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类成员函数使用运算符重载【无法使用类内私有成员】但可以使用友元访问私有成员</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; pa, Person&amp; pb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//return pa.Age &lt; pb.Age;//【友元会破坏类的封装，不推荐】</span></span><br><span class="line">    <span class="keyword">return</span> pa.<span class="built_in">getAge</span>() &lt; pb.<span class="built_in">getAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Person&amp; pa, <span class="type">unsigned</span> <span class="type">short</span> age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pa.<span class="built_in">getAge</span>() &lt; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类成员函数使用运算符重载</span></span><br><span class="line"><span class="type">bool</span> Person::<span class="keyword">operator</span>&gt;(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Height &gt; p.Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">20</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">woman</span><span class="params">(<span class="number">50</span>, <span class="number">150</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">smaller</span>(man, woman)) std::cout &lt;&lt; <span class="string">&quot;富婆！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载后的两种调用方法【编译器实现】</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">operator</span>&lt;(man, woman)) std::cout &lt;&lt; <span class="string">&quot;富婆！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (man &lt; woman) std::cout &lt;&lt; <span class="string">&quot;富婆！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类成员函数</span></span><br><span class="line">    <span class="keyword">if</span> (man &gt; woman) std::cout &lt;&lt; <span class="string">&quot;更高！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-2-运算符重载的原则和时机"><a href="#5-1-2-运算符重载的原则和时机" class="headerlink" title="5.1.2 运算符重载的原则和时机"></a>5.1.2 运算符重载的原则和时机</h5><ul><li>运算符重载的意义</li><li>原则和限制</li><li>正确姿势【时机】</li></ul><p><strong>运算符重载的意义：</strong></p><p>（1）让类也支持原生的运算，比如<code>+-*／</code></p><p>（2）提升对程序的控制权，比如重载new、delete、new[]、delete[]</p><blockquote><p>运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率</p></blockquote><p><strong>运算符重载的限制:</strong></p><ul><li><p>不能自创运算符，比如 <code>===</code>、<code>=&lt;&gt;=</code>，只能重载现有运算符</p></li><li><p>以下运算符不能重载</p><ul><li>对象访问运算符<code>.</code>，例如<code>user.hp</code></li><li>作用域解析运算符<code>::</code>，例如<code>std::cout</code></li><li>求大小的运算符<code>sizeof</code>， 例如<code>sizeof(int)</code></li><li>条件运算符<code>?:</code>，例如<code>b=a&gt;c?100:200</code></li></ul></li><li><p>不能修改运算符本身的优先级、相关性</p></li><li><p>在C++17后，也不能修改运算符的操作数的计算顺序【比如，a&amp;&amp;b，是先算a还是先算b】；在C++17前，编译器可以自由选择如何计算（未定义行为）</p></li><li><p>除了<code>delete</code>/<code>delete[]</code>和<code>new</code>/<code>new[]</code>外，不能对原生数据类型【如<code>int</code>等】的其他运算符进行重载，比如把<code>char</code>类型的<code>+操作</code>定义为<code>-操作</code>【即不能把1+1定义为1-1】</p></li><li><p>除了new 和 delete 以为，其他运算符的arity【运算符关联的操作数的个数或者是关联的参数】一律不能修改</p></li></ul><p><strong>运算符重载的原则：</strong></p><ul><li>不要改变运算符本身的意义，比如把加法重载为减法</li><li>不建议重载逻辑运算符<code>&amp;&amp;</code>、<code>||</code>【涉及短路测试】、取址运算符<code>&amp;</code>【破坏指针特性】、逗号运算符</li></ul><blockquote><p>注意：重载后的逻辑运算符将不会进行短路测试</p><p>在C++17标准前，编译器可以自由决定先计算左操作数还是右操作数</p><p>在C++17后，计算的顺序规定为先计算左再计算右</p></blockquote><p><strong>运算符重载的通用语法</strong></p><p>（1）二元运算符的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#利用全局函数    </span><br><span class="line">    返回类型 <span class="keyword">operator</span>运算符(类型左操作数，类型右操作数)</span><br><span class="line">#利用类的成员函数</span><br><span class="line">    返回类型 <span class="keyword">operator</span>运算符(类型右操作数)</span><br></pre></td></tr></table></figure><p>（2）一元运算符的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#利用全局函数返回  </span><br><span class="line">    返回类型 <span class="keyword">operator</span>运算符(类型 操作数)</span><br><span class="line">#利用类的成员函数</span><br><span class="line">    返回类型 <span class="keyword">operator</span>运算符()</span><br></pre></td></tr></table></figure><p><strong>运算符重载的时机和一般约定</strong></p><p>有的运算符只能重载为类的成员函数，有些运算符只能重载为全局函数，有些运算符既可以重载为类的成员函数又可以重载为全局函数。</p><ul><li>如果一个运算符既可以重载为成员函数又可以重载为全局函数，我们一般推荐重载为<strong>类的成员函数</strong>。因为类的成员函数可以是虚函数，单全局函数不能是虚函数；且如果这个运算符不修改对象,应该将这个成员函数限定为<code>const</code></li><li>运算符重载的参数一般可以传递值或者引用。大部分情况下，能够传递引用就不要传递值，对于不会修改的值最好是限定为const，某些时候要善用使用右值引用&amp;&amp;作为参数</li><li>运算符重载的返回值一般来说可以是任何类型，但是尽量要符合运算符的原意。【比如把<code>&gt;</code>运算符返回指针类型、把<code>+</code>返回bool类型，不符合常理】</li></ul><h5 id="5-1-3-赋值运算符重载"><a href="#5-1-3-赋值运算符重载" class="headerlink" title="5.1.3 赋值运算符重载"></a>5.1.3 赋值运算符重载</h5><blockquote><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 <code>operator=</code>, 对属性进行值拷贝</li></ol></blockquote><p>如果类中有属性指向堆区，做赋值操作时也会出现<strong>深浅拷贝问题</strong></p><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载赋值运算符 </span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">        <span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回自身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄的指针</span></span><br><span class="line">    <span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p<span class="number">1.</span>m_Age &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p<span class="number">2.</span>m_Age &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p<span class="number">3.</span>m_Age &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int a = 10;</span></span><br><span class="line">    <span class="comment">//int b = 20;</span></span><br><span class="line">    <span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//c = b = a;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器自动提供的赋值运算符重载</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Role&amp; operator=(const Role&amp; role)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        hp = role.hp;</span></span><br><span class="line"><span class="comment">        mp = role.mp;</span></span><br><span class="line"><span class="comment">        return *this;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以显式地删除，禁用编译器提供的副本构造函数</span></span><br><span class="line">    <span class="comment">//Role&amp; operator=(const Role&amp; role) = delete;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role x, y;</span><br><span class="line">    x.hp = <span class="number">10</span>;</span><br><span class="line">    y = x;</span><br><span class="line">    std::cout &lt;&lt; y.hp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>赋值运算符=的重载，只能作为类成员函数进行重载</li><li>返回值是引用&amp;的目的，是为了解决 <code>z = x = y</code> 的问题，即y为x赋值后返回引用，再为z赋值【 <code>z = x = y</code> 的本质是 <code>z.operator=(x.operator=(y))</code>】【使用引用返回而不使用值传递，可以减少开销】</li></ul><h6 id="示例3：hstring"><a href="#示例3：hstring" class="headerlink" title="示例3：hstring"></a>示例3：hstring</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* hstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> length;<span class="comment">//不包含\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mem_len;<span class="comment">//内存长度【设置默认长度0x32】</span></span><br><span class="line">    <span class="comment">// 求字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> len&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//while(str[len++])</span></span><br><span class="line">        <span class="keyword">while</span> (str[len])</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>();<span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">unsigned</span> <span class="type">short</span> len);<span class="comment">//带缓冲区长度构造函数</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str); <span class="comment">//副本构造函数|委托构造</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;<span class="comment">//动态改变内容</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hstring&amp; str);<span class="comment">//重载=</span></span><br><span class="line">    <span class="comment">//hstring&amp; operator=(const char* str);//重载=：参数是字符串</span></span><br><span class="line">    <span class="comment">// 【写了就调用上面这个；不写此函数时，会调用带参构造函数，生成一个临时右值hstring实例，再调用第一个=重载函数】</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value);</span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; value);</span><br><span class="line">    <span class="comment">//hstring&amp; operator=(const float&amp; value);//现有知识无法完成</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring&amp; str);<span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ResetMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;<span class="comment">//重置缓冲区大小</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetMemoryLength</span><span class="params">()</span></span>;<span class="comment">//获取占用内存大小</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetLength</span><span class="params">()</span></span>;<span class="comment">//获取字符串长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数：释放堆区空间</span></span><br><span class="line">    ~<span class="built_in">hstring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载&gt;&gt;&lt;&lt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; str.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; cin, hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0x1ff</span>];</span><br><span class="line">    cin &gt;&gt; buffer;</span><br><span class="line">    str = buffer;</span><br><span class="line">    <span class="keyword">return</span> cin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hstring str1;</span><br><span class="line">    cout &lt;&lt; str<span class="number">1.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//190字节 需重新分配内存</span></span><br><span class="line">    <span class="function">hstring <span class="title">str2</span><span class="params">(<span class="string">&quot;你好！地球人！啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(str<span class="number">2.</span><span class="built_in">show</span>()) &lt;&lt; endl;<span class="comment">// 18</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; endl;<span class="comment">// 除了14字节的7个字符，还有乱码</span></span><br><span class="line"></span><br><span class="line">    <span class="function">hstring <span class="title">str3</span><span class="params">(str2)</span></span>;<span class="comment">//等价于hstring str4 = str3;//调用副本构造函数</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str<span class="number">3.</span><span class="built_in">setStr</span>(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str3 = str2;<span class="comment">// 当实例被创建之后，才是调用赋值运算符重载【注意：易混淆】【注意str3=str3;的易错】</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否再需要重载一次赋值运算符？不必</span></span><br><span class="line">    str3 = <span class="string">&quot;我爱西加加！我爱西加加！我爱西加加！我爱西加加！我爱西加加！我爱西加加！&quot;</span>;<span class="comment">// 当实例被创建之后，才是调用赋值运算符重载</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str3 = <span class="number">-4423</span>;</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">    str3 = (<span class="type">long</span> <span class="type">long</span>)<span class="number">9442323111112221</span>;</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载&lt;&lt;</span></span><br><span class="line">    str3 &lt;&lt; <span class="built_in">hstring</span>(<span class="string">&quot;我&quot;</span>) &lt;&lt; <span class="built_in">hstring</span>(<span class="string">&quot;来&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//重载&lt;&lt;</span></span><br><span class="line">    cin &gt;&gt; str3;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = <span class="built_in">getLength</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (length + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_len = length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dest = new char[mem_len];//曾写的bug代码</span></span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len];</span><br><span class="line">        <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dest, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(dest, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()<span class="comment">// 默认构造</span></span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;<span class="comment">//空字符串长度</span></span><br><span class="line">    mem_len = <span class="number">0x32</span>;<span class="comment">//50字节</span></span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带缓冲区长度构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">unsigned</span> <span class="type">short</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;<span class="comment">//空字符串长度</span></span><br><span class="line">    mem_len = len;<span class="comment">//50字节</span></span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//副本构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str) :<span class="built_in">hstring</span>() <span class="comment">//委托构造</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str.hstr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态改变内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::setStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str.hstr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符:int</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v_abs;</span><br><span class="line">    <span class="type">char</span> remainder, tmp;</span><br><span class="line">    <span class="comment">// 绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        v_abs = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v_abs = -value;</span><br><span class="line">    <span class="comment">// 转换为字符数组</span></span><br><span class="line">    <span class="keyword">while</span> (v_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        remainder = (v_abs % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (length + <span class="number">1</span> &lt; mem_len)</span><br><span class="line">        &#123;</span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len + <span class="number">0x32</span>];</span><br><span class="line">            <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, mem_len + <span class="number">0x32</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(newhstr, hstr, mem_len);</span><br><span class="line">            mem_len += <span class="number">0x32</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] hstr;</span><br><span class="line">            hstr = newhstr;</span><br><span class="line"></span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        v_abs /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hstr[length++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = hstr[i];</span><br><span class="line">        <span class="comment">//hstr[i] = hstr[length - i]; //逻辑错误</span></span><br><span class="line">        hstr[i] = hstr[length - <span class="number">1</span> - i];</span><br><span class="line">        hstr[length - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符:long long</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v_abs;</span><br><span class="line">    <span class="type">char</span> remainder, tmp;</span><br><span class="line">    <span class="comment">// 绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        v_abs = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v_abs = -value;</span><br><span class="line">    <span class="comment">// 转换为字符数组</span></span><br><span class="line">    <span class="keyword">while</span> (v_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        remainder = (v_abs % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (length + <span class="number">1</span> &lt; mem_len)</span><br><span class="line">        &#123;</span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len + <span class="number">0x32</span>];</span><br><span class="line">            <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, mem_len + <span class="number">0x32</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(newhstr, hstr, mem_len);</span><br><span class="line">            mem_len += <span class="number">0x32</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] hstr;</span><br><span class="line">            hstr = newhstr;</span><br><span class="line"></span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        v_abs /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hstr[length++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = hstr[i];</span><br><span class="line">        hstr[i] = hstr[length - <span class="number">1</span> - i];</span><br><span class="line">        hstr[length - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> newlen = <span class="built_in">getLength</span>(str.hstr);<span class="comment">//不带末尾0</span></span><br><span class="line">    <span class="keyword">if</span> (newlen + length + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[newlen + length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, newlen + length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(newhstr, hstr, length);</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = newhstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(hstr + length, str.hstr, newlen);</span><br><span class="line">    mem_len = newlen + length + <span class="number">1</span>;</span><br><span class="line">    length += newlen;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重置缓冲区大小</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hstring::ResetMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; mem_len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">memcpy</span>(newhstr, hstr, length);</span><br><span class="line">    mem_len = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取占用内存大小</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::GetMemoryLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mem_len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取字符串长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::GetLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作业1中的bug修改：使用单步调试解决</p></blockquote><h5 id="5-1-4-左移右移运算符重载"><a href="#5-1-4-左移右移运算符重载" class="headerlink" title="5.1.4 左移右移运算符重载"></a>5.1.4 左移右移运算符重载</h5><ul><li><p>作用：可以输出自定义数据类型</p></li><li><p>左移右移运算符可以重载为【类成员函数 | 全局函数】【二元运算符】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">类方法</span></span><br><span class="line">返回类型 operator&gt;&gt;(类型 操作数)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局函数【需要友元】</span></span><br><span class="line">返回类型 operator&gt;&gt;(类型 左操作数，类型 操作数右)</span><br></pre></td></tr></table></figure></li><li><p>hstring重载<code>&lt;&lt;</code>的例子在上一节中</p></li></ul><p>重载 <code>cout&lt;&lt;</code> 输出特定对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 使用友元是因为：一般都会将类变量私有化</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个：所以只能引用</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：重载左移运算符配合<strong>【友元】</strong>可以实现输出自定义数据类型</p><p>总结2：若要使用链式编程，如<code>endl</code> 换行，需要让运算符重载函数返回输出流的引用</p></blockquote><h5 id="5-1-5-下标运算符重载"><a href="#5-1-5-下标运算符重载" class="headerlink" title="5.1.5 下标运算符重载"></a>5.1.5 下标运算符重载</h5><ul><li>重载<code>[]</code></li><li>实现只读<code>[]</code>重载</li></ul><p>注意：</p><ul><li>下标运算符只能重载为类的方法：<code>返回类型 operator[](类型 操作数)</code></li><li>示例：访问 <code>hstring</code> <code>str</code> 的特定位置的字符，如 <code>str[2]</code>【见 5.1.3 示例3】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">char</span> nochar = <span class="number">-1</span>;<span class="comment">//使用c++17语法【解决越界标志】【也可以直接用#define实现】</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* hstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> length;<span class="comment">//不包含\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mem_len;<span class="comment">//内存长度【设置默认长度0x32】</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;<span class="comment">// 求字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span>;<span class="comment">// 复制字符串</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>();<span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> index) <span class="type">const</span>;<span class="comment">//重载下标运算符【如果不返回引用，即返回右值，则不能被修改】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：释放堆区空间</span></span><br><span class="line">    ~<span class="built_in">hstring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">hstring <span class="title">str3</span><span class="params">(<span class="string">&quot;1234&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//重载[]</span></span><br><span class="line">    <span class="comment">//str3[1] = &#x27;1&#x27;;//1【不支持中文】【不建议支持该功能，不安全 ：可以限定返回值为const】</span></span><br><span class="line">    cout &lt;&lt; str3[<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//11</span></span><br><span class="line">    <span class="keyword">if</span> (str3[<span class="number">10</span>] == hstring::nochar)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;越界！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求字符串长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//while(str[len++])</span></span><br><span class="line">    <span class="keyword">while</span> (str[len])</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = <span class="built_in">getLength</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (length + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_len = length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dest = new char[mem_len];//曾写的bug代码</span></span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len];</span><br><span class="line">        <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dest, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(dest, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>()<span class="comment">// 默认构造</span></span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;<span class="comment">//空字符串长度</span></span><br><span class="line">    mem_len = <span class="number">0x32</span>;<span class="comment">//50字节</span></span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载下标运算符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; hstring::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hstr[index];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//【一般使用#define来使代码易于阅读】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-6-函数调用运算符重载"><a href="#5-1-6-函数调用运算符重载" class="headerlink" title="5.1.6 函数调用运算符重载"></a>5.1.6 函数调用运算符重载</h5><ul><li>函数调用运算符 <code>()</code> 也可以重载【<code>&#123;&#125;</code>不可用重载】</li><li>只能重载为类成员函数</li><li>由于重载后使用的方式非常像函数的调用，因此称为<strong>仿函数</strong>【仿函数没有固定写法，非常灵活】<ul><li>重载称为<code>functor</code>函数对象</li><li>不限制参数个数</li><li>可以拥有默认实参</li></ul></li></ul><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">    MyPrint myFunc;</span><br><span class="line">    <span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd add;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匿名对象调用  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：hstring截取字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* hstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> length;<span class="comment">//不包含\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mem_len;<span class="comment">//内存长度【设置默认长度0x32】</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;<span class="comment">// 求字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span>;<span class="comment">// 复制字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>();<span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="function">hstring <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> start, <span class="type">const</span> <span class="type">unsigned</span> end)</span> <span class="type">const</span></span>;<span class="comment">//重载函数调用运算符()【闭区间】</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">show</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> hstr; &#125;</span><br><span class="line">    <span class="comment">// 析构函数：释放堆区空间</span></span><br><span class="line">    ~<span class="built_in">hstring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载&gt;&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; str.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局函数重载&gt;&gt;【右值作为参数】</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> hstring&amp;&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; str.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">hstring <span class="title">str</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">str</span>(<span class="number">2</span>, <span class="number">3</span>).<span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">str</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 此处可能出错【原因：重载的&lt;&lt;运算符需要的参数是一个hstring&amp;引用，而此处是一个hstring】</span></span><br><span class="line">    <span class="comment">//解决办法1：【不建议，因为引用节约内存】修改&lt;&lt;运算符重载的参数类型</span></span><br><span class="line">    <span class="comment">//解决办法2：【因为函数调用重载后，返回的是一个没有固定内存地址的hstirng，故不能作为引用传入】修改为右值传入</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求字符串长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//while(str[len++])</span></span><br><span class="line">    <span class="keyword">while</span> (str[len])</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复制字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = <span class="built_in">getLength</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (length + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_len = length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dest = new char[mem_len];//曾写的bug代码</span></span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len];</span><br><span class="line">        <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dest, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(dest, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>()<span class="comment">// 默认构造</span></span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;<span class="comment">//空字符串长度</span></span><br><span class="line">    mem_len = <span class="number">0x32</span>;<span class="comment">//50字节</span></span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数调用运算符()【闭区间】</span></span><br><span class="line"><span class="function">hstring <span class="title">hstring::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> start, <span class="type">const</span> <span class="type">unsigned</span> end)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;<span class="number">0</span> || start&gt;length - <span class="number">1</span> || end&lt;<span class="number">0</span> || start&gt;end) &#123;</span><br><span class="line">        <span class="comment">// end&gt;length默认只返回最大长度</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数不合法&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hstring</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> newlen;</span><br><span class="line">    <span class="keyword">if</span> (end &gt; length - <span class="number">1</span>)</span><br><span class="line">        newlen = length - start;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen = end - start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[newlen + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, newlen + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(newhstr, hstr + start, newlen);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hstring</span>(newhstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-7-加号运算符重载"><a href="#5-1-7-加号运算符重载" class="headerlink" title="5.1.7 加号运算符重载"></a>5.1.7 加号运算符重载</h5><p>作用：实现两个自定义数据类型相加的运算【同样都是二元算数运算符，适用于 <code>+-*/</code>】</p><ul><li>可以重载为类成员函数，也可以重载为全局函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">        temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">// 调用方法：Person p3 = operator+(p1, p2) </span></span><br><span class="line"><span class="comment">// 或 Person p3 = p1+p2</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//    Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//    temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//    temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//    return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 【复用函数名】</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p<span class="number">2.</span>m_A + val;</span><br><span class="line">    temp.m_B = p<span class="number">2.</span>m_B + val;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数方式</span></span><br><span class="line">    Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-8-关系运算符重载"><a href="#5-1-8-关系运算符重载" class="headerlink" title="5.1.8 关系运算符重载"></a>5.1.8 关系运算符重载</h5><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int a = 0;</span></span><br><span class="line">    <span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="5-2-运算符重载进阶"><a href="#5-2-运算符重载进阶" class="headerlink" title="5.2 运算符重载进阶"></a>5.2 运算符重载进阶</h4><h5 id="5-2-1-重载类型转换运算符（一）"><a href="#5-2-1-重载类型转换运算符（一）" class="headerlink" title="5.2.1 重载类型转换运算符（一）"></a>5.2.1 重载类型转换运算符（一）</h5><p>目标：</p><ul><li>实现类型转换运算符重载</li><li>解决类型转换运算符的多义性问题</li><li>类型转换与bool表达式的问题</li></ul><p>注意：</p><ul><li>类型转换运算符只能重载为类的成员函数</li><li>类型转换运算符，不能显式指定返回类型，但须有返回值【其返回值由类型转换的类型决定，即不能指定返回值】</li><li>语法：<code>operator 类型() const;</code></li></ul><blockquote><p>代码见 <code>hstring</code></p></blockquote><h5 id="5-2-2-重载类型转换运算符（二）"><a href="#5-2-2-重载类型转换运算符（二）" class="headerlink" title="5.2.2 重载类型转换运算符（二）"></a>5.2.2 重载类型转换运算符（二）</h5><p>解决隐式类型转换带来的<strong>多义性问题</strong>：在类型转换重载函数前加 <code>explicit</code> 关键字可以限制该函数禁止适用隐式转换【C++11】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">T</span>(<span class="type">int</span> val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>+(T x) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t1&#123; <span class="number">100</span> &#125;, t2&#123; <span class="number">200</span> &#125;;</span><br><span class="line">    <span class="comment">//int x = t1 + 100;//错误：有多个运算符 &quot;+&quot; 与这些操作数匹配</span></span><br><span class="line">    <span class="comment">//此处有两种可能：①t1隐式转为int，得到101 ②100被构造为临时T实例，调用+重载得到2 【即存在歧义】</span></span><br><span class="line">    <span class="type">int</span> x = t1 + <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">int</span>(t1)<span class="number">+100</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>bool</code>类型与<code>void*</code>的选择</strong></p><p>某些时候，我们为了表示某个类里的指针是否为空，可以重载该类的<code>void*</code>类型来实现如下操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure><p>但是其实也可以实现重载 bool类型转换来实现该操作，但是我们一般不推荐重载bool类型</p><h6 id="练习：hstirng"><a href="#练习：hstirng" class="headerlink" title="练习：hstirng"></a>练习：hstirng</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">char</span> nochar = <span class="number">-1</span>;<span class="comment">//使用c++17语法【解决越界标志】【也可以直接用#define实现】</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* hstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> length;<span class="comment">//不包含\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mem_len;<span class="comment">//内存长度【设置默认长度0x32】</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;<span class="comment">// 求字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span>;<span class="comment">// 复制字符串</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>();<span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">unsigned</span> <span class="type">short</span> len);<span class="comment">//带缓冲区长度构造函数</span></span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str); <span class="comment">//副本构造函数|委托构造</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;<span class="comment">//动态改变内容</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hstring&amp; str);<span class="comment">//重载=</span></span><br><span class="line">    <span class="comment">//hstring&amp; operator=(const char* str);//重载=：参数是字符串</span></span><br><span class="line">    <span class="comment">// 【写了就调用上面这个；不写此函数时，会调用带参构造函数，生成一个临时右值hstring实例，再调用第一个=重载函数】</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value);</span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; value);</span><br><span class="line">    <span class="comment">//hstring&amp; operator=(const float&amp; value);//现有知识无法完成</span></span><br><span class="line"></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring&amp; str);<span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>+(<span class="type">const</span> hstring&amp; str);<span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">int</span> value);<span class="comment">//实现链式编程的字符串加法【参数为int】</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ResetMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span></span>;<span class="comment">//重置缓冲区大小</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetMemoryLength</span><span class="params">()</span></span>;<span class="comment">//获取占用内存大小</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetLength</span><span class="params">()</span></span>;<span class="comment">//获取字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> index) <span class="type">const</span>;<span class="comment">//重载下标运算符【如果不返回引用，即返回右值，则不能被修改】</span></span><br><span class="line">    <span class="function">hstring <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> start, <span class="type">const</span> <span class="type">unsigned</span> end)</span> <span class="type">const</span></span>;<span class="comment">//重载函数调用运算符()【闭区间】</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span></span>;<span class="comment">//重载类型转换运算符</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="type">void</span>* ();<span class="comment">//重载void*用于判断是否为空【判断指针是否为空，推荐重载void*】</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span></span>;<span class="comment">//重载bool用于判断是否为空【不支持nullptr，但可用重载实现】</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数：释放堆区空间</span></span><br><span class="line">    ~<span class="built_in">hstring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载&gt;&gt;&lt;&lt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; str.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; cin, hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0x1ff</span>];</span><br><span class="line">    cin &gt;&gt; buffer;</span><br><span class="line">    str = buffer;</span><br><span class="line">    <span class="keyword">return</span> cin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hstring str1;</span><br><span class="line">    cout &lt;&lt; str<span class="number">1.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//190字节 需重新分配内存</span></span><br><span class="line">    <span class="function">hstring <span class="title">str2</span><span class="params">(<span class="string">&quot;你好！地球人！啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(str<span class="number">2.</span><span class="built_in">show</span>()) &lt;&lt; endl;<span class="comment">// 18</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; endl;<span class="comment">// 除了14字节的7个字符，还有乱码</span></span><br><span class="line"></span><br><span class="line">    <span class="function">hstring <span class="title">str3</span><span class="params">(str2)</span></span>;<span class="comment">//等价于hstring str4 = str3;//调用副本构造函数</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str<span class="number">3.</span><span class="built_in">setStr</span>(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str3 = str2;<span class="comment">// 当实例被创建之后，才是调用赋值运算符重载【注意：易混淆】【注意str3=str3;的易错】</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否再需要重载一次赋值运算符？不必</span></span><br><span class="line">    str3 = <span class="string">&quot;我爱西加加！我爱西加加！我爱西加加！我爱西加加！我爱西加加！我爱西加加！&quot;</span>;<span class="comment">// 当实例被创建之后，才是调用赋值运算符重载</span></span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str3 = <span class="number">-4423</span>;</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">    str3 = (<span class="type">long</span> <span class="type">long</span>)<span class="number">9442323111112221</span>;</span><br><span class="line">    cout &lt;&lt; str<span class="number">3.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载&lt;&lt;</span></span><br><span class="line">    str3 &lt;&lt; <span class="built_in">hstring</span>(<span class="string">&quot;我&quot;</span>) &lt;&lt; <span class="built_in">hstring</span>(<span class="string">&quot;来&quot;</span>) + <span class="string">&quot;了&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//重载&lt;&lt;</span></span><br><span class="line">    cin &gt;&gt; str3;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载[]</span></span><br><span class="line">    cout &lt;&lt; str3[<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//11</span></span><br><span class="line">    <span class="keyword">if</span> (str3[<span class="number">10</span>] == hstring::nochar)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;越界！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载()</span></span><br><span class="line">    <span class="function">hstring <span class="title">str4</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">str4</span>(<span class="number">2</span>, <span class="number">3</span>).<span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">str4</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载类型转换运算符int()</span></span><br><span class="line">    <span class="function">hstring <span class="title">str5</span><span class="params">(<span class="string">&quot;1234&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">int</span>(str5);</span><br><span class="line">    str5 = <span class="string">&quot;-12345&quot;</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">int</span>(str5);</span><br><span class="line">    str5 = <span class="string">&quot;sss&quot;</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="built_in">int</span>(str5);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载+</span></span><br><span class="line">    hstring str6;</span><br><span class="line">    cout &lt;&lt; str6 + <span class="number">123</span> &lt;&lt; endl;</span><br><span class="line">    str6 = str6 + <span class="number">123</span>;<span class="comment">// 出错：此处为自己给自己赋值的情况，结果造成字符串内存丢失【调用=重载出错:判断是否为本地址】</span></span><br><span class="line">    cout &lt;&lt; str6&lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; str6.GetLength()&lt;&lt; &quot;,&quot; &lt;&lt;str6.GetMemoryLength()&lt;&lt; endl;</span></span><br><span class="line">    str6 = str6 + (<span class="number">-123</span>);</span><br><span class="line">    cout &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空字符串【即指针是否为空：重载void*】</span></span><br><span class="line">    <span class="function">hstring <span class="title">str7</span><span class="params">(<span class="string">&quot;s&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (str7)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;空字符串！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非空字符串！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::getLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//while(str[len++])</span></span><br><span class="line">    <span class="keyword">while</span> (str[len])</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyStr</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = <span class="built_in">getLength</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (length + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_len = length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dest = new char[mem_len];//曾写的bug代码</span></span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len];</span><br><span class="line">        <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dest, <span class="number">0</span>, mem_len);</span><br><span class="line">        <span class="built_in">memcpy</span>(dest, source, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()<span class="comment">// 默认构造</span></span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;<span class="comment">//空字符串长度</span></span><br><span class="line">    mem_len = <span class="number">0x32</span>;<span class="comment">//50字节</span></span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带缓冲区长度构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">unsigned</span> <span class="type">short</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;<span class="comment">//空字符串长度</span></span><br><span class="line">    mem_len = len;<span class="comment">//50字节</span></span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//副本构造函数</span></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str) :<span class="built_in">hstring</span>() <span class="comment">//委托构造</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str.hstr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态改变内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::setStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CopyStr</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;str != <span class="keyword">this</span>)</span><br><span class="line">        <span class="built_in">CopyStr</span>(hstr, str.hstr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符:参数为int</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v_abs;</span><br><span class="line">    <span class="type">char</span> remainder, tmp;</span><br><span class="line">    <span class="comment">// 绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        v_abs = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v_abs = -value;</span><br><span class="line">    <span class="comment">// 转换为字符数组</span></span><br><span class="line">    <span class="keyword">while</span> (v_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        remainder = (v_abs % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (length + <span class="number">1</span> &lt; mem_len)</span><br><span class="line">        &#123;</span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len + <span class="number">0x32</span>];</span><br><span class="line">            <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, mem_len + <span class="number">0x32</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(newhstr, hstr, mem_len);</span><br><span class="line">            mem_len += <span class="number">0x32</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] hstr;</span><br><span class="line">            hstr = newhstr;</span><br><span class="line"></span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        v_abs /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hstr[length++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = hstr[i];</span><br><span class="line">        <span class="comment">//hstr[i] = hstr[length - i]; //逻辑错误</span></span><br><span class="line">        hstr[i] = hstr[length - <span class="number">1</span> - i];</span><br><span class="line">        hstr[length - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符:long long</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_len);</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v_abs;</span><br><span class="line">    <span class="type">char</span> remainder, tmp;</span><br><span class="line">    <span class="comment">// 绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        v_abs = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v_abs = -value;</span><br><span class="line">    <span class="comment">// 转换为字符数组</span></span><br><span class="line">    <span class="keyword">while</span> (v_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        remainder = (v_abs % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (length + <span class="number">1</span> &lt; mem_len)</span><br><span class="line">        &#123;</span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[mem_len + <span class="number">0x32</span>];</span><br><span class="line">            <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, mem_len + <span class="number">0x32</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(newhstr, hstr, mem_len);</span><br><span class="line">            mem_len += <span class="number">0x32</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] hstr;</span><br><span class="line">            hstr = newhstr;</span><br><span class="line"></span><br><span class="line">            hstr[length++] = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        v_abs /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hstr[length++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = hstr[i];</span><br><span class="line">        hstr[i] = hstr[length - <span class="number">1</span> - i];</span><br><span class="line">        hstr[length - <span class="number">1</span> - i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> newlen = <span class="built_in">getLength</span>(str.hstr);<span class="comment">//不带末尾0</span></span><br><span class="line">    <span class="keyword">if</span> (newlen + length + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[newlen + length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, newlen + length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(newhstr, hstr, length);</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = newhstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(hstr + length, str.hstr, newlen);</span><br><span class="line">    mem_len = newlen + length + <span class="number">1</span>;</span><br><span class="line">    length += newlen;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>+(<span class="type">const</span> hstring&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现链式编程的字符串加法</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> &lt;&lt; <span class="built_in">hstring</span>(str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现链式编程的字符串加法【参数为int】</span></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x20</span>]&#123; <span class="number">0</span> &#125;;<span class="comment">//缓冲区 -2147483648到2147483647</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> max_index&#123; <span class="number">0x1f</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> index&#123; max_index &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tmp_memsize&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isPositive = value &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> value_abs = value * (isPositive * <span class="number">2</span> - <span class="number">1</span>);<span class="comment">//绝对值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (value_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[index--] = value_abs % <span class="number">10</span> <span class="number">+48</span>;</span><br><span class="line">        value_abs /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isPositive) </span><br><span class="line">        buffer[index--] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    len = max_index - index;</span><br><span class="line">    tmp_memsize = length + len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length + len + <span class="number">1</span> &gt; mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* old_hstr = hstr;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[tmp_memsize];</span><br><span class="line">        <span class="built_in">memset</span>(hstr, <span class="number">0</span>, tmp_memsize);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, old_hstr, length);</span><br><span class="line">        <span class="keyword">delete</span>[] old_hstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(hstr + length, buffer+index<span class="number">+1</span>, len);</span><br><span class="line">    </span><br><span class="line">    length += len;</span><br><span class="line">    mem_len = tmp_memsize;</span><br><span class="line">    cout &lt;&lt; hstr &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; mem_len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓冲区大小</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hstring::ResetMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; mem_len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">memcpy</span>(newhstr, hstr, length);</span><br><span class="line">    mem_len = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取占用内存大小</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::GetMemoryLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mem_len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取字符串长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::GetLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载下标运算符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; hstring::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hstr[index];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//【一般使用#define来使代码易于阅读】</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数调用运算符()【闭区间】</span></span><br><span class="line"><span class="function">hstring <span class="title">hstring::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> start, <span class="type">const</span> <span class="type">unsigned</span> end)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;<span class="number">0</span> || start&gt;length - <span class="number">1</span> || end&lt;<span class="number">0</span> || start&gt;end) &#123;</span><br><span class="line">        <span class="comment">// end&gt;length默认只返回最大长度</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数不合法&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hstring</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> newlen;</span><br><span class="line">    <span class="keyword">if</span> (end &gt; length - <span class="number">1</span>)</span><br><span class="line">        newlen = length - start;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen = end - start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* newhstr = <span class="keyword">new</span> <span class="type">char</span>[newlen + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newhstr, <span class="number">0</span>, newlen + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(newhstr, hstr + start, newlen);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hstring</span>(newhstr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载类型转换运算符</span></span><br><span class="line"><span class="function">hstring::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要安全检查</span></span><br><span class="line">    <span class="comment">//从后往前</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int value&#123; 0 &#125;, multiple&#123; 1 &#125;;</span></span><br><span class="line"><span class="comment">    for (int i = length - 1; i &gt; 0; i--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (i != length - 1)</span></span><br><span class="line"><span class="comment">            multiple *= 10;</span></span><br><span class="line"><span class="comment">        value = value + (hstr[i] - &#x27;0&#x27;) * multiple;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (hstr[0] == &#x27;-&#x27;)</span></span><br><span class="line"><span class="comment">        return  -value;</span></span><br><span class="line"><span class="comment">    if (hstr[0] &lt;= &#x27;9&#x27; &amp;&amp; hstr[0]&gt;=&#x27;0&#x27;)</span></span><br><span class="line"><span class="comment">        return  value + (hstr[0] - &#x27;0&#x27;) * 10 * multiple;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//从前往后是另一种思路</span></span><br><span class="line">    <span class="type">int</span> value&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = hstr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>;<span class="comment">//true=1，从1开始</span></span><br><span class="line">    <span class="keyword">while</span> (hstr[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; hstr[i] &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        value = value * <span class="number">10</span> + (hstr[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    value = value * ((hstr[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="keyword">operator</span> <span class="type">void</span>* ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hstr;<span class="comment">//仅演示，实际不能直接去暴露，不安全</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">hstring::<span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hstr != <span class="literal">nullptr</span>;<span class="comment">//std::nullptr_t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-3-项目练习：防止游戏数据被修改"><a href="#5-2-3-项目练习：防止游戏数据被修改" class="headerlink" title="5.2.3 项目练习：防止游戏数据被修改"></a>5.2.3 项目练习：防止游戏数据被修改</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dimonds = <span class="number">2500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前钻石余额为：&quot;</span> &lt;&lt; dimonds &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        dimonds -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可使用 <code>cheat engin</code> 进行数据搜索、内存修改、汇编修改，极不安全。</p><p>本节的目标：设计一种加密的整型数据类型 <code>hint</code>，要求实现int的大部分功能，且防御CE。</p><blockquote><p>思路1：将int的四个连续字节打散存放</p><p>思路2：对数值加密存储</p></blockquote><p>以下是<strong>小作业</strong> <code>class hint</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> hint&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* mem[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hint</span>(<span class="type">int</span> value = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">hint</span>(<span class="type">const</span> hint&amp;);<span class="comment">//副本构造</span></span><br><span class="line">    ~<span class="built_in">hint</span>();</span><br><span class="line"></span><br><span class="line">    hint&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hint&amp;);</span><br><span class="line">    hint&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    hint&amp; <span class="keyword">operator</span>-(<span class="type">const</span> hint&amp;);</span><br><span class="line">    hint&amp; <span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    hint&amp; <span class="keyword">operator</span>+(<span class="type">const</span> hint&amp;);</span><br><span class="line">    hint&amp; <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// 重载之后，可以不用重载+-等</span></span><br><span class="line">    hint&amp; <span class="keyword">operator</span>++();<span class="comment">//前置++【在本身上操作，返回本身即可，无需值传递】</span></span><br><span class="line">    <span class="type">const</span> hint <span class="keyword">operator</span>++(<span class="type">int</span>);<span class="comment">//后置++【需要返回一个旧值的新副本】</span></span><br><span class="line">    <span class="comment">//此处加const后，operator int()也应该加const</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> hint&amp;);<span class="comment">//重载cout&lt;&lt;输出</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; in, hint&amp;);<span class="comment">//重载cin&gt;&gt;输出</span></span><br><span class="line">hint&amp; <span class="keyword">operator</span>--(hint&amp; val);<span class="comment">//全局重载前置--</span></span><br><span class="line">hint <span class="keyword">operator</span>--(hint&amp; val,<span class="type">int</span>);<span class="comment">//全局重载后置--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hint dimonds = <span class="number">1000</span>;</span><br><span class="line">    hint hp = dimonds;<span class="comment">//副本构造函数函数</span></span><br><span class="line">    std::cout &lt;&lt; hp &lt;&lt; std::endl;<span class="comment">//全局重载cout&lt;&lt;输出</span></span><br><span class="line">    dimonds = <span class="number">3000</span>;<span class="comment">//重载=</span></span><br><span class="line">    hp = dimonds;<span class="comment">//重载=</span></span><br><span class="line">    std::cout &lt;&lt; hp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; hp;</span><br><span class="line">    hint mp = dimonds - hp + <span class="number">100</span>;<span class="comment">//重载+-</span></span><br><span class="line">    std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; mp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ++hp<span class="number">+1</span>  &lt;&lt; std::endl;</span><br><span class="line">    hp = <span class="number">5</span> + hp++;<span class="comment">//此处需要 opeartor int()加const</span></span><br><span class="line">    std::cout &lt;&lt; hp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//hp++++;//使用const限制++次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int x = dimonds;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复原</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hint::show</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">char</span>* write = (<span class="type">char</span>*)&amp;value;</span><br><span class="line">    write[<span class="number">0</span>] = mem[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    write[<span class="number">1</span>] = mem[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    write[<span class="number">2</span>] = mem[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    write[<span class="number">3</span>] = mem[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处适用思路1：四字节打散存放</span></span><br><span class="line">hint::<span class="built_in">hint</span>(<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这样的连续IO极耗时，故更好的选择是根据程序中使用的hint次数，预分配好mem空间</span></span><br><span class="line">    mem[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    mem[<span class="number">1</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    mem[<span class="number">2</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    mem[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* read = (<span class="type">char</span>*)&amp;value;<span class="comment">//取value的64位地址8字节,赋值给char指针read，该指针指向一个字节空间</span></span><br><span class="line">    <span class="comment">// 打乱存储，恢复时逆向恢复</span></span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];<span class="comment">//mem[0]是指针，mem[0][0]是左值变量</span></span><br><span class="line">    <span class="comment">//mem[0][0] = read[3]^0x12;//低字节易被搜索，可以异或一个值</span></span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint::<span class="built_in">hint</span>(<span class="type">const</span> hint&amp; hobj)</span><br><span class="line">&#123;</span><br><span class="line">    mem[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    mem[<span class="number">1</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    mem[<span class="number">2</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    mem[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = hobj.mem[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = hobj.mem[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = hobj.mem[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = hobj.mem[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">hint::~<span class="built_in">hint</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> mem[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span> mem[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span> mem[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">delete</span> mem[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>=(<span class="type">const</span> hint&amp; hobj)</span><br><span class="line">&#123;</span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = hobj.mem[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = hobj.mem[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = hobj.mem[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = hobj.mem[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* read = (<span class="type">char</span>*)&amp;value;</span><br><span class="line"></span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>-(<span class="type">const</span> hint&amp; hobj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="keyword">this</span>-&gt;<span class="built_in">show</span>() - hobj.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* read = (<span class="type">char</span>*)&amp;value;</span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">int</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="keyword">this</span>-&gt;<span class="built_in">show</span>() - value;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* read = (<span class="type">char</span>*)&amp;val;</span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>+(<span class="type">const</span> hint&amp; hobj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="keyword">this</span>-&gt;<span class="built_in">show</span>() + hobj.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* read = (<span class="type">char</span>*)&amp;value;</span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">int</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="keyword">this</span>-&gt;<span class="built_in">show</span>() + value;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* read = (<span class="type">char</span>*)&amp;val;</span><br><span class="line">    mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">    mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">    mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">    mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">hint::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint&amp; hint::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> hint hint::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//a=b++ + c;等价于a=b+c;b=b+1</span></span><br><span class="line">    hint temp = *<span class="keyword">this</span>;<span class="comment">//调用构造函数hint(hint&amp;),这是默认的副本构造函数，如果没有写会出错</span></span><br><span class="line">    *<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">//注意：此处也会调用 副本构造函数hint(hint&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> hint&amp; hobj)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; hobj.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; in, hint&amp; hobj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    in &gt;&gt; value;</span><br><span class="line">    hobj = value;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">hint&amp; <span class="keyword">operator</span>--(hint&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有this指针</span></span><br><span class="line">    val = val - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint <span class="keyword">operator</span>--(hint&amp; val, <span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    hint temp = val;<span class="comment">//调用构造函数hint(hint&amp;),这是默认的副本构造函数，如果没有写会出错</span></span><br><span class="line">    val = val - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-2-4-递增运算符重载"><a href="#5-2-4-递增运算符重载" class="headerlink" title="5.2.4 递增运算符重载"></a>5.2.4 递增运算符重载</h5><p>作用： 通过重载递增运算符，实现自己的整型数据【可以重载为类方法或全局函数】</p><blockquote><p>使用const限制后置递增的次数为1，见<code>hint</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前置++</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">//先++</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//再返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置++[int代表占位参数，用于区分前置后置]</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">//先返回【值：局部变量：只能返回值】</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">    out &lt;&lt; myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个例子【hint】见上一节</p><blockquote><p>总结1： 前置递增返回引用，是为了可 <strong>重复递增</strong>【返回引用是保证一直对一个数据进行递增】</p><p>总结2：后置递增返回值</p></blockquote><h5 id="5-2-5-重载内存分配释放运算符"><a href="#5-2-5-重载内存分配释放运算符" class="headerlink" title="5.2.5 重载内存分配释放运算符"></a>5.2.5 重载内存分配释放运算符</h5><p>new 的工作原理：<code>Role* user = new Role();</code></p><ol><li>通过new分配内存空间【支持重载】</li><li>调用构造函数</li><li>返回指针</li></ol><p>delete 的工作原理：<code>delete user;</code></p><ol><li>调用析构函数</li><li>通过delete释放内存【支持重载】</li></ol><p>对 new <strong>重载的六种形式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重载的形式</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//禁止重载的两种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>* p)</span> <span class="keyword">noexcept</span></span>;<span class="comment">// 见下例中，可以指定分配的地址</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size, <span class="type">void</span>* p) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>另外，该运算符<strong>可重载为全局或类函数</strong>【重载为全局函数不推荐，极容易产生不可恢复的错误】</p><p><strong>基本用途：</strong></p><ul><li>重载内存分配释放运算符，主要用于解决游戏中内存优化的问题【俗称“卡顿”】。</li><li>为了方便和提高灵活性，可以重载带有额外参数的 new 和 delete 版本【须成套定义 】</li><li>对于 delete 来说，如果同时定义了带内存大小的和不带内存大小的函数，那么默认之后调用不带内存大小参数的 delete 函数</li></ul><blockquote><p>下面以子弹为例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blut</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x;<span class="comment">//三位坐标</span></span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">    <span class="type">float</span> h;</span><br><span class="line">    <span class="type">float</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bUse = <span class="literal">true</span>;<span class="comment">//子弹是否被使用【在new内存分配后，调用构造函数bUse才被置True】</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* adr)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* adr, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span></span>;<span class="comment">//size为编译器自动填充</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span>* txt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* adr, <span class="type">const</span> <span class="type">char</span>* txt)</span> <span class="keyword">noexcept</span></span>;<span class="comment">//手动调用不了，是由异常调用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span><span class="keyword">noexcept</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">blut</span>();<span class="comment">//先调用析构函数，在通过delete释放内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存池：假设最多只会出现100个子弹</span></span><br><span class="line"><span class="type">char</span>* mem_temp = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">char</span>* mem = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1000</span> * <span class="built_in">sizeof</span>(blut)] &#123;&#125;;<span class="comment">//初始化为0，bUser默认为false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//游戏中子弹的数量不确定</span></span><br><span class="line">    <span class="comment">//blut* b = new blut();</span></span><br><span class="line">    <span class="comment">//delete b;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////将内存分配到mem，即指定分配的地址【这样的内存不用自己释放】</span></span><br><span class="line">    <span class="comment">//blut* b1 = new(mem_temp) blut[10];</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; (void*)mem_temp &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; b1 &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//delete[] b1;</span></span><br><span class="line">    <span class="comment">// 但上面的写法，①频繁地进行内存分配，导致频繁的IO操作【卡顿】</span></span><br><span class="line">    <span class="comment">// ②会产生大量的内存碎片【导致闪退和内存奔溃】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决思路：提前分配内存空间【new默认在堆上进行内存分配】</span></span><br><span class="line">    <span class="comment">//作业：实现多个子弹的有序释放【最多同时1000个子弹】</span></span><br><span class="line">    blut* shot1 = <span class="built_in">new</span>(<span class="string">&quot;申请发射子弹！&quot;</span>) blut;</span><br><span class="line">    blut* shot2 = <span class="built_in">new</span>(<span class="string">&quot;申请发射子弹！&quot;</span>) blut;</span><br><span class="line">    <span class="keyword">delete</span> shot1;<span class="comment">//调用delete</span></span><br><span class="line">    blut* shot3 = <span class="built_in">new</span>(<span class="string">&quot;申请发射子弹！&quot;</span>) blut;</span><br><span class="line">    blut* shot4 = <span class="built_in">new</span>(<span class="string">&quot;申请发射子弹！&quot;</span>) blut;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; shot1 &lt;&lt; std::endl;<span class="comment">//00B75B4C</span></span><br><span class="line">    std::cout &lt;&lt; shot2 &lt;&lt; std::endl;<span class="comment">//00B75B60</span></span><br><span class="line">    std::cout &lt;&lt; shot3 &lt;&lt; std::endl;<span class="comment">//00B75B74</span></span><br><span class="line">    std::cout &lt;&lt; shot4 &lt;&lt; std::endl;<span class="comment">//00B75B88:相差20个字节，即blut的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* blut::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return new blut;//死循环，导致栈溢出stack overflow</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; size &lt;&lt; std::endl;//size大小由 【new blut;】 自动计算</span></span><br><span class="line">    <span class="comment">//return ::operator new(size);//全局的new</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;申请内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> mem;<span class="comment">//分配在已有空间上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> blut::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* adr)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//自动为static静态函数，无this，无法访问bUser</span></span><br><span class="line">    <span class="comment">//如何找到shot1子弹的存放位置</span></span><br><span class="line">    <span class="comment">//方法1：用adr地址，逐个对比找</span></span><br><span class="line">    <span class="comment">//方法2：使用析构函数去做【有意思！】</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* blut::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span>* txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; txt &lt;&lt; std::endl;</span><br><span class="line">    blut* bat = (blut*)mem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bat[i].bUse)<span class="comment">//可使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            bat[i].bUse = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> &amp;bat[i];</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> blut::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* adr, <span class="type">const</span> <span class="type">char</span>* txt)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用于异常调用，无法手动调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;带参释放内存&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blut::~<span class="built_in">blut</span>()</span><br><span class="line">&#123;</span><br><span class="line">    bUse = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; bUse &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>一旦重载，基本上所有形式都要重载【另一种解决办法：使用delete关键字手动删除默认的内存分配运算符函数】</li><li>重载的内存分配函数，自动转为 static 静态函数，因此访问不了类的成员变量【本质上，new之前连内存空间都没有，也更没有this指针】【同理，重载 delete 的操作在调用析构函数之后，访问类成员变量也没有意义】</li></ul><h4 id="5-3-阶段项目：hstring"><a href="#5-3-阶段项目：hstring" class="headerlink" title="5.3 阶段项目：hstring"></a>5.3 阶段项目：hstring</h4><p>创建一个字符串操作类，实现对字符串的增删改查【所有功能的new都是要有条件的】</p><p>要求：</p><ul><li>存储数据的时候使用缓冲区，使用缓冲区的目的是为了尽量减少频繁的NEW/DEL内存带来的资源损耗【<strong>缓冲区必须要有</strong>，new之前要加判断】</li><li>重载<code>+</code> 增加数据，增加数据要实现的形态： “123456789” + “abc” 得到 “123456789abc” 【最多new一次，new之前判断是否超过缓冲区，超过了才new】</li><li>重载<code>-</code>删除数据,增加数据要实现的形态：”123456789” - “456” 得到 “123789” 【函数中不使用new】</li><li>改数据 ：要求 “123456789” 34修改为 abc 得到 12abc56789 【最多new一次】</li><li>查 ：如<code>123456</code> 查 <code>34</code> 得到 位置 <code>2</code> 【不使用new】</li><li>重载 <code>=</code> 实现 int 转 hstring 字符串 【最多new一次】</li><li>不能使用库函数【memcpy、remove、memset可使用】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* hstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> length;<span class="comment">//真实长度|不带末尾\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mem_size = <span class="number">0x50</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">getStringLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyMem</span><span class="params">(<span class="type">char</span>* dist, <span class="type">const</span> <span class="type">char</span>* source)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>();</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp;);</span><br><span class="line">    ~<span class="built_in">hstring</span>();</span><br><span class="line"></span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    hstring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;<span class="comment">// 查：找不到返回-1</span></span><br><span class="line">    <span class="function">hstring&amp; <span class="title">modify</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source, <span class="type">const</span> <span class="type">char</span>* replace)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">hstring <span class="title">str1</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;<span class="comment">//默认构造</span></span><br><span class="line">    str1 = str1 + <span class="string">&quot;abc&quot;</span>; <span class="comment">//重载+(const char*)</span></span><br><span class="line">    hstring str2 = str1 + <span class="string">&quot;abc&quot;</span>;<span class="comment">//重写副本构造函数</span></span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; std::endl;<span class="comment">//show函数</span></span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.f</span>ind(<span class="string">&quot;345&quot;</span>) &lt;&lt; std::endl;<span class="comment">//show函数</span></span><br><span class="line">    str<span class="number">2.</span><span class="built_in">modify</span>(<span class="string">&quot;345&quot;</span>, <span class="string">&quot;bbbbbb&quot;</span>);<span class="comment">//modify函数</span></span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; std::endl;</span><br><span class="line">    str2 = str2 - <span class="string">&quot;789&quot;</span>;<span class="comment">//重载-</span></span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; std::endl;</span><br><span class="line">    str2 = <span class="number">-123456</span>;<span class="comment">//重载=</span></span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::getStringLength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[len++]);</span><br><span class="line">    <span class="keyword">return</span> len - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::CopyMem</span><span class="params">(<span class="type">char</span>* dist, <span class="type">const</span> <span class="type">char</span>* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sourceLen = <span class="built_in">getStringLength</span>(source);</span><br><span class="line">    <span class="comment">// 超出缓冲区大小，重新申请缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (sourceLen + <span class="number">1</span> &gt; mem_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        mem_size = sourceLen + <span class="number">1</span>;</span><br><span class="line">        hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_size];</span><br><span class="line">        <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr, source, sourceLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0</span>, mem_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(dist, source, sourceLen);</span><br><span class="line">    &#125;</span><br><span class="line">    length = sourceLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">hstring::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_size];</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_size);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyMem</span>(hstr, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; hobj) :<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CopyMem</span>(hstr, hobj.hstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::~<span class="built_in">hstring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] hstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> strlength = <span class="built_in">getStringLength</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (length + <span class="number">1</span> + strlength &gt; mem_size)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_size = length + <span class="number">1</span> + strlength;</span><br><span class="line">        <span class="type">char</span>* temp_hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_size];</span><br><span class="line">        <span class="built_in">memset</span>(temp_hstr, <span class="number">0</span>, mem_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_hstr, hstr, length);</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = temp_hstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(hstr + length, str, strlength);</span><br><span class="line">    length += strlength;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> position = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(str);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> strLength;</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strLength = <span class="built_in">getStringLength</span>(str);</span><br><span class="line">        <span class="built_in">memcpy</span>(hstr + position, hstr + position + strLength, length - position - strLength);</span><br><span class="line">        <span class="built_in">memset</span>(hstr+length-strLength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        length -= strLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">hstring&amp; hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//int最多11位，无需重新分配内存</span></span><br><span class="line">    <span class="built_in">memset</span>(hstr, <span class="number">0</span>, mem_size);</span><br><span class="line">    <span class="type">bool</span> isNegative = value &gt;= <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> val_abs = isNegative ? -value : value;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (val_abs)</span><br><span class="line">    &#123;</span><br><span class="line">        hstr[len++] = val_abs % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        val_abs /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    length = len;</span><br><span class="line">    <span class="keyword">if</span> (isNegative)</span><br><span class="line">    &#123;</span><br><span class="line">        hstr[len] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; hstr &lt;&lt;&quot;,&quot;&lt;&lt;length &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp = hstr[i];</span><br><span class="line">        hstr[i] = hstr[length<span class="number">-1</span>-i];</span><br><span class="line">        hstr[length - <span class="number">1</span> - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hstring::find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> strlen = <span class="built_in">getStringLength</span>(str);</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; strlen &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; strlen)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> str_pos&#123; <span class="number">0</span> &#125;, temp_i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - strlen + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp_i = i;</span><br><span class="line">        str_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最简单的字符串匹配算法</span></span><br><span class="line">        <span class="keyword">for</span> (str_pos; str_pos &lt; strlen; str_pos++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hstr[temp_i++] != str[str_pos])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (str_pos == strlen - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NotFound!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">hstring&amp; <span class="title">hstring::modify</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source, <span class="type">const</span> <span class="type">char</span>* replace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> position = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(source);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sourceLen, replaceLen;</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sourceLen = <span class="built_in">getStringLength</span>(source);</span><br><span class="line">        replaceLen = <span class="built_in">getStringLength</span>(replace);</span><br><span class="line">        <span class="type">char</span>* temp_hstr;</span><br><span class="line">        <span class="keyword">if</span> (length + replaceLen - sourceLen &gt; mem_size)</span><br><span class="line">        &#123;</span><br><span class="line">            mem_size = length + replaceLen - sourceLen + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp_hstr = <span class="keyword">new</span> <span class="type">char</span>[mem_size];</span><br><span class="line">        <span class="built_in">memset</span>(temp_hstr, <span class="number">0</span>, mem_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_hstr, hstr, position);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_hstr + position, replace, replaceLen);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp_hstr + position + replaceLen, hstr + position + sourceLen, length - position - sourceLen);</span><br><span class="line">        <span class="keyword">delete</span>[] hstr;</span><br><span class="line">        hstr = temp_hstr;</span><br><span class="line">        length = length + replaceLen - sourceLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h3 id="6-类的继承"><a href="#6-类的继承" class="headerlink" title="6  类的继承"></a>6 类的继承</h3><p><strong>继承是面向对象三大特性之一</strong>：有些类与类之间存在特殊的关系</p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候我们就可以考虑利用继承的技术，减少重复代码</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><p><strong>注意：</strong></p><ul><li>子类不能继承父类的构造函数、析构函数、重载赋值运算符【虽不能继承，但内容依然在子类中】</li><li><code>class object final&#123;&#125;;</code> <code>final</code>关键字阻止类被继承【<code>final</code> 可作为变量名】</li></ul><h4 id="6-1-继承的基本语法"><a href="#6-1-继承的基本语法" class="headerlink" title="6.1 继承的基本语法"></a>6.1 继承的基本语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> B;</span><br><span class="line"><span class="comment">//A 类称为子类 或 派生类</span></span><br><span class="line"><span class="comment">//B 类称为父类 或 基类</span></span><br></pre></td></tr></table></figure><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Java页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Python页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    CPP cp;</span><br><span class="line">    cp.<span class="built_in">header</span>();</span><br><span class="line">    cp.<span class="built_in">footer</span>();</span><br><span class="line">    cp.<span class="built_in">left</span>();</span><br><span class="line">    cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Java页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Python页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    CPP cp;</span><br><span class="line">    cp.<span class="built_in">header</span>();</span><br><span class="line">    cp.<span class="built_in">footer</span>();</span><br><span class="line">    cp.<span class="built_in">left</span>();</span><br><span class="line">    cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-继承方式"><a href="#6-2-继承方式" class="headerlink" title="6.2 继承方式"></a>6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式 父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承【原封不动地从父类类拿过来】</li><li>保护继承【仅限继承类内访问，本质作用是将基类的 public 成员变为 protected 成员】</li><li>私有继承【默认】</li></ul><p><img src="/.io//cpp1-3.png"></p><p><strong>注意：</strong></p><ul><li>可使用 <code>using 基类名称::基类中的成员名</code> 来修改继承来的成员的属性【值得注意的是，基类中的私有成员无法修改，因为无法访问，故仅可修改 public 和 potected 的成员】【破坏封装，建议少用】</li><li>继承访问属性的好处：①更好的封装父类成员；②可以在子类作为基础进行派生类的时候提供继承控制</li><li>尽量变量为 private，并提供 getter 和 setter</li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">        m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">        <span class="comment">//m_C; //不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">        m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">        <span class="comment">//m_C; //不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> :<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">        m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">        <span class="comment">//m_C; //不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">        <span class="comment">//m_A;</span></span><br><span class="line">        <span class="comment">//m_B;</span></span><br><span class="line">        <span class="comment">//m_C;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s1;</span><br><span class="line">    s<span class="number">1.</span>m_A; <span class="comment">//类外只能访问到公共权限</span></span><br><span class="line"></span><br><span class="line">    Son2 s2;</span><br><span class="line">    <span class="comment">//s.m_A; //不可访问</span></span><br><span class="line"></span><br><span class="line">    Son3 s3;</span><br><span class="line">    <span class="comment">//s3.m_A; //不可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-继承中的对象模型"><a href="#6-3-继承中的对象模型" class="headerlink" title="6.3 继承中的对象模型"></a>6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 4？12？16？？？</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用工具查看：</strong></p><p><img src="/.io//cpp1-4.png"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： <code>cl /d1 reportSingleClassLayout</code>查看的类名 所属文件名</p><p>效果如下图：</p><p><img src="/.io//cpp1-5.png"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，<strong>只是由编译器给隐藏后访问不到</strong></p></blockquote><h4 id="6-4-继承中构造和析构函数"><a href="#6-4-继承中构造和析构函数" class="headerlink" title="6.4 继承中构造和析构函数"></a>6.4 继承中构造和析构函数</h4><h5 id="6-4-1-派生类的构造和析构顺序"><a href="#6-4-1-派生类的构造和析构顺序" class="headerlink" title="6.4.1 派生类的构造和析构顺序"></a>6.4.1 派生类的构造和析构顺序</h5><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数。因此，父类和子类的<strong>构造和析构顺序</strong>是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">    Son s;</span><br><span class="line">    <span class="comment">// 构造：先父亲后儿子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：继承中先调用父类构造函数，再调用子类构造函数【即从基类开始构造】，析构顺序与构造相反</p><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="built_in">object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;object was created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">object</span>(<span class="type">const</span> object&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;object was created by copy\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mapobject</span> :<span class="keyword">public</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mapId;</span><br><span class="line">    <span class="built_in">mapobject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;mapobject was created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mapobject</span>(<span class="type">const</span> mapobject&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;mapobject was created by copy\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mapobject</span>(<span class="type">int</span> id) :mapId&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;mapobject was created by int\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">actobject</span> :<span class="keyword">public</span> mapobject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> mapobject::mapobject;<span class="comment">// 无论是public或private都是可以访问的，且继承了所有除父类默认构造函数以外的所有构造函数</span></span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="built_in">actobject</span>() :mapobject&#123; <span class="number">100</span> &#125;, damage&#123; <span class="number">20</span> &#125;<span class="comment">//可指定父类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;actobject was created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">actobject</span>(<span class="type">const</span> actobject&amp; obj):mapobject&#123;obj&#125;<span class="comment">//此处隐含类型转换，也算是继承的优点之一</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;actobject was created by copy\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    actobject obj;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    actobject obj2 = obj;<span class="comment">//只调用派生类的副本构造函数</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//且除非指定，只会调用父类的默认构造函数</span></span><br><span class="line">    <span class="comment">//可使用【参数列表的写法】指定父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制继承构造函数</span></span><br><span class="line">    actobject obj3&#123; <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-4-2-强制继承构造函数"><a href="#6-4-2-强制继承构造函数" class="headerlink" title="6.4.2 强制继承构造函数"></a>6.4.2 强制继承构造函数</h5><p>语法：<code>using 父类::构造函数名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">actobject</span> :<span class="keyword">public</span> mapobject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> mapobject::mapobject;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细示例见上，值得注意的是：</p><ul><li>无论<code>using</code>的写法，写在 <code>public</code> 或 <code>private</code> 里，都是可以访问的</li><li>继承了所有除父类默认构造函数以外的所有构造函数</li></ul><h4 id="6-5-继承中的同名成员问题"><a href="#6-5-继承中的同名成员问题" class="headerlink" title="6.5 继承中的同名成员问题"></a>6.5 继承中的同名成员问题</h4><h5 id="6-5-1-继承同名成员处理方式"><a href="#6-5-1-继承同名成员处理方式" class="headerlink" title="6.5.1 继承同名成员处理方式"></a>6.5.1 继承同名成员处理方式</h5><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到<strong>子类或父类中同名的数据</strong>呢？</p><ul><li>访问子类同名成员 <strong>直接访问即可</strong></li><li>访问父类同名成员 <strong>需要加作用域</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">    <span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 如果有更多层的继承，可以s.Base::Base2::func(19);等价于s.Base::func(10);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li><li>构成重载的成员函数在继承时，可能会被覆盖，即只继承一个同名函数。【可使用<code>using</code>语法引入所有自定义函数】</li></ol><h5 id="6-5-2-继承同名静态成员处理方式"><a href="#6-5-2-继承同名静态成员处理方式" class="headerlink" title="6.5.2 继承同名静态成员处理方式"></a>6.5.2 继承同名静态成员处理方式</h5><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p><strong>静态成员和非静态成员出现同名，处理方式一致</strong></p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="6-7-多继承问题"><a href="#6-7-多继承问题" class="headerlink" title="6.7 多继承问题"></a>6.7 多继承问题</h4><h5 id="6-7-1-多继承"><a href="#6-7-1-多继承" class="headerlink" title="6.7.1 多继承"></a>6.7.1 多继承</h5><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line">    <span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line">    Son s;</span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况【如果参数列表不同，那依然是同名情况】，子类使用时候要加作用域</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf bite!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf eat!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Man eat!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolfman</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> Man</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Wolf::eat;<span class="comment">//使用using指定</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">()</span><span class="comment">//变身</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        isWolf = !isWolf;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;变身!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isWolf = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Wolfman Jack;</span><br><span class="line">    Jack.<span class="built_in">bite</span>();</span><br><span class="line">    Jack.Man::<span class="built_in">eat</span>();</span><br><span class="line">    Jack.<span class="built_in">eat</span>();<span class="comment">//使用using指定</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-7-2-菱形继承"><a href="#6-7-2-菱形继承" class="headerlink" title="6.7.2 菱形继承"></a>6.7.2 菱形继承</h5><blockquote><p>多继承导致的<strong>重复继承问题</strong></p></blockquote><p><strong>菱形继承概念：</strong></p><p>​ 两个派生类继承同一个基类，又有某个类同时继承者两个派生类。这种继承被称为菱形继承，或者钻石继承。</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="/.io//cpp1-6.jpg"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。
</code></pre></li></ol><p><strong>示例：</strong>==利用虚继承解决==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="comment">// 此时，以上两个类保留一个指向Animal基类的vbptr[虚基类指针]</span></span><br><span class="line"><span class="comment">// 其指向vbtable[虚基类表]：记录偏移量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    <span class="comment">// 需要加作用域，否则不明确</span></span><br><span class="line">    st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 但数据只需要一份</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//cpp1-7.png"></p><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf bite!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf eat!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Man eat!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolfman</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> Man</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Wolf::eat;<span class="comment">//使用using指定</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">()</span><span class="comment">//变身</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        isWolf = !isWolf;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;变身!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isWolf = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Wolfman Jack;</span><br><span class="line">    Jack.<span class="built_in">bite</span>();</span><br><span class="line">    <span class="comment">//Jack.x = 250;//重复继承的问题【】</span></span><br><span class="line">    Jack.Wolf::x = <span class="number">250</span>;</span><br><span class="line">    std::cout &lt;&lt; Jack.Man::x &lt;&lt; std::endl;<span class="comment">//-858993460//继承自人，人继承自动物</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以使用虚基类来指出：基类在内存中只有一份</span></span><br><span class="line">    <span class="comment">// 加入virtual后，Jack.Man::x = 250</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h4 id="6-8-继承的本质"><a href="#6-8-继承的本质" class="headerlink" title="6.8 继承的本质"></a>6.8 继承的本质</h4><p>查看继承的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> data_2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data_3 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> data_4 = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object was created!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object -!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span> :<span class="keyword">public</span> <span class="keyword">virtual</span> Object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mdata_1 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> mdata_2 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mdata_3 = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> mdata_4 = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject was created!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject -!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThingObject</span> :<span class="keyword">public</span>  <span class="keyword">virtual</span> Object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mdata_1 = <span class="number">33</span>;</span><br><span class="line">    <span class="type">int</span> mdata_2 = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mdata_3 = <span class="number">44</span>;</span><br><span class="line">    <span class="type">int</span> mdata_4 = <span class="number">44</span>;</span><br><span class="line">    <span class="built_in">ThingObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ThingObject was created!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ThingObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ThingObject -!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPC</span> :<span class="keyword">public</span> MoveObject,<span class="keyword">public</span> ThingObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ndata_1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> ndata_2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ndata_3 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> ndata_4 = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">NPC</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NPC was created!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">NPC</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NPC -!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="comment">//读内存</span></span><br><span class="line">    <span class="type">int</span>* nRead = (<span class="type">int</span>*)&amp;obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj内存地址：&quot;</span> &lt;&lt; nRead &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(obj) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;内存地址：&quot;</span> &lt;&lt; &amp;nRead[i] &lt;&lt; <span class="string">&quot;，值：&quot;</span> &lt;&lt; nRead[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MoveObject mobj;</span><br><span class="line">    nRead = (<span class="type">int</span>*)&amp;mobj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj内存地址：&quot;</span> &lt;&lt; nRead &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(mobj) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;内存地址：&quot;</span> &lt;&lt; &amp;nRead[i] &lt;&lt; <span class="string">&quot;，值：&quot;</span> &lt;&lt; nRead[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多重继承</span></span><br><span class="line">    NPC npc;</span><br><span class="line">    <span class="comment">//npc.data_3 = 2;//重名不明确问题</span></span><br><span class="line">    nRead = (<span class="type">int</span>*)&amp;npc;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj内存地址：&quot;</span> &lt;&lt; nRead &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(npc) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;内存地址：&quot;</span> &lt;&lt; &amp;nRead[i] &lt;&lt; <span class="string">&quot;，值：&quot;</span> &lt;&lt; nRead[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用虚基类之后</span></span><br><span class="line">    <span class="comment">//内存分布情况为：先一个标志，然后存放MoveObject;再一个标志，然后存放ThingObject</span></span><br><span class="line">    <span class="comment">//然后存放NPC,最后存放Object【出现一次】</span></span><br><span class="line">    <span class="comment">//此处的标志：是一个指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="7-多态"><a href="#7-多态" class="headerlink" title="7  多态"></a>7 多态</h3><h4 id="7-1-多态的基本概念"><a href="#7-1-多态的基本概念" class="headerlink" title="7.1 多态的基本概念"></a>7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li><span style="background:#ff0"><strong>静态多态</strong>：函数重载【包含运算符重载】和函数模板，属于静态多态，复用函数名【静态多态的函数地址早绑定 - 编译阶段确定函数地址】</span></li><li><span style="background:#ff0"><strong>动态多态</strong>：派生类和虚函数实现运行时多态【动态多态的函数地址晚绑定 - 运行阶段确定函数地址】</span></li></ul><p>而动态多态中的派生类的多态，称为<strong>对象多态</strong>。分为：</p><ul><li>向上转型：父类 =&gt; 子类【隐含父类或根在下方 】【意为：用子类表达父类，一般正确。如：人是动物】</li><li>向下转型：子类 =&gt; 父类【意为：用父类表达子类，不一定成立。如：动物是人】【用的好是大神，用不好是沙雕】</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">    <span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(dog);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">beAct</span><span class="params">(Animal* ani)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal was acted\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">beAct</span><span class="params">(Animal* ani)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Human was acted\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Human laowang;</span><br><span class="line">    laowang.age = <span class="number">20</span>;</span><br><span class="line">    laowang.money = <span class="number">3000</span>;</span><br><span class="line">    Animal a1 = laowang;<span class="comment">//不推荐这样写，会发生内存截断【内存切片问题】警告|C26437|请勿使用切片(es.63)。</span></span><br><span class="line">    <span class="comment">//原则上直接丢掉也没有什么问题，但是对于虚函数直接丢掉，会丢失重要数据</span></span><br><span class="line">    std::cout &lt;&lt; a<span class="number">1.</span>age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下转型【子类=&gt;父类|用父类表达子类】</span></span><br><span class="line">    <span class="comment">//Human zhangsan = a1;//编译不通过，但如有相应的构造函数，即可通过编译</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的不发生内存截断的写法:指针和引用</span></span><br><span class="line">    Animal* a2 = &amp;laowang;<span class="comment">//【对象多态推荐写法】</span></span><br><span class="line">    <span class="comment">//Human* man1 = &amp;a2;//编译错误，man1指针会访问到不属于man1的内存</span></span><br><span class="line">    Human* man1 = (Human*) &amp; a2;<span class="comment">//强转后的目的不是操作内存，主要目的是用父类调用子类函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Animal* ptr;</span><br><span class="line">    std::cin &gt;&gt; id;</span><br><span class="line">    <span class="keyword">if</span> (id)</span><br><span class="line">        ptr = &amp;a1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ptr = &amp;laowang;</span><br><span class="line">    ptr-&gt;<span class="built_in">beAct</span>(ptr);<span class="comment">//动态多态：编译时不知道调用哪一个</span></span><br><span class="line">    <span class="comment">// 如果基类Animal的beAct函数没有virtual关键字，无论id为0或1，都是执行基类beAct函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数【重写：函数返回值类型、函数名、参数列表完全一致称为重写】</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><h4 id="7-2-虚函数"><a href="#7-2-虚函数" class="headerlink" title="7.2 虚函数"></a>7.2 虚函数</h4><h5 id="7-2-1-虚函数初识"><a href="#7-2-1-虚函数初识" class="headerlink" title="7.2.1 虚函数初识"></a>7.2.1 虚函数初识</h5><ul><li>虚函数：在类中使用 <code>virtual</code> 修饰了的成员函数</li><li>虚函数使用条件<ul><li>🔺<code>virtual</code> 只能写在类的内部声明或定义，不能把 <code>virtual</code> 写在类的外部定义中</li><li>🔺🔺调用<strong>类的对象</strong>是无法使用虚函数的，必须使用<strong>基类指针</strong>来实现虚函数的调用【比如下例中的Move函数，如果传入参数为对象实例而非对象指针，则报错；当然，可以改为引用，引用本质也是指针】【 本质上，此时传入的临时对象是个基类临时对象，即导致了内存切片】</li><li>🔺虚函数在派生类和基类中必须具有相同的<strong>返回值</strong>及<strong>参数列表</strong>【一个例外：协变，即参数列表依然相同，但基类返回一个基类指针，派生类重写时返回一个派生类指针或基类指针】</li><li>🔺虚函数不能是函数模板</li></ul></li><li>override &amp; final<ul><li>override：作为类成员函数后缀，确保该函数是重写父类虚函数而来【编译器会报错提醒虚函数重写错误，否则不会报错仅作为普通成员函数存在】【建议一定加！】</li><li>final：确保类不会被派生【虽然final可以作为变量名使用，但没必要】【可与override同时使用】</li></ul></li><li>成员保护<ul><li>如果基类的虚函数为私有函数，则派生类中无论是否是public重写虚函数，均无法使用该重写函数【建议使用私有虚函数，否则容易破环类的封装】</li><li>不是所有虚函数都要写在最基类中</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是NPC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是怪物&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不适用多态</span></span><br><span class="line"><span class="comment">void Move(MonsterObject* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj-&gt;Move();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void Move(NPCObject* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    obj-&gt;Move();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对象多态【此处参数必须为指针或引用】</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(MoveObject* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    NPCObject zhangsan;</span><br><span class="line">    <span class="built_in">Move</span>(&amp;snake);<span class="comment">//不使用虚函数时，为静态绑定，默认调用基类Move函数</span></span><br><span class="line">    <span class="built_in">Move</span>(&amp;zhangsan);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-2-多态案例：计算器"><a href="#7-2-2-多态案例：计算器" class="headerlink" title="7.2.2 多态案例：计算器"></a>7.2.2 多态案例：计算器</h5><p>案例描述：分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//普通实现测试</span></span><br><span class="line">    Calculator c;</span><br><span class="line">    c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">    c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建加法计算器</span></span><br><span class="line">    AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建减法计算器</span></span><br><span class="line">    abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建乘法计算器</span></span><br><span class="line">    abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h5 id="7-2-3-虚函数详解"><a href="#7-2-3-虚函数详解" class="headerlink" title="7.2.3 虚函数详解"></a>7.2.3 虚函数详解</h5><ul><li><p>在构造和析构函数中调用虚函数</p></li><li><p>调用虚函数的基类版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonsterObject::<span class="built_in">Move</span>();<span class="comment">//基类名::基类函数</span></span><br></pre></td></tr></table></figure></li><li><p>默认实参在虚函数中的错误</p></li><li><p>释放含有虚函数的派生对象【<code>7.5</code>节再次补充】</p></li></ul><p><strong>在构造和析构函数中调用虚函数</strong>【高频问题】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject construct:&quot;</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();<span class="comment">//此时正在构造基类，因此此处只能调用基类Move【故为静态绑定】</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject Moving&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Move</span>();<span class="comment">//相当于 this-&gt;Move();</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject deconstruct:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();<span class="comment">//MoveObject Moving【子类重写已经被析构】【静态绑定】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MonsterObject construct:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">test</span>();<span class="comment">//MonsterObject Moving</span></span><br><span class="line">        MonsterObject::<span class="built_in">test</span>();<span class="comment">//MonsterObject Moving</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MonsterObject Moving&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MonsterObject deconstruct:&quot;</span>  &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">Move</span>();<span class="comment">//MonsterObject Moving</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    snake.<span class="built_in">Move</span>();<span class="comment">//MonsterObject Moving</span></span><br><span class="line">    snake.<span class="built_in">test</span>();<span class="comment">//MonsterObject Moving!!!</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有以下结论：</span></span><br><span class="line"><span class="comment">    1、snake构造时，此处的两个this指针是相同的</span></span><br><span class="line"><span class="comment">    2、在基类构造函数中调用虚函数，调用的只能是基类函数【涉及安全问题】</span></span><br><span class="line"><span class="comment">    3、在构造完基类后，调用虚函数，调用的是重写后的虚函数</span></span><br><span class="line"><span class="comment">    4、在析构中同理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认实参在虚函数中的错误</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveObject Moving&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Auto  Move &quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MonsterObject Moving&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">3</span>)</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~~~auto  Move &quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject snake;</span><br><span class="line">    MoveObject* p = &amp;snake;</span><br><span class="line">    p-&gt;<span class="built_in">AutoMove</span>();<span class="comment">//必然调用重写后的函数，但默认值为基类虚函数默认值</span></span><br><span class="line">    <span class="comment">//【原因：默认参数是编译时赋值的，重写无法改变默认参数】</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放含有虚函数的派生对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">MoveObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~~~MoveObject deconstruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">MonsterObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~~~MonsterObject deconstruct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MoveObject* p = <span class="keyword">new</span> <span class="built_in">MonsterObject</span>();</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">//事实上只析构了一次：~~~MoveObject deconstruct</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete p; 等价于下面代码：</span></span><br><span class="line">    MoveObject* q = <span class="keyword">new</span> <span class="built_in">MonsterObject</span>();</span><br><span class="line">    q-&gt;~<span class="built_in">MoveObject</span>();<span class="comment">//q是基类指针，析构函数是非虚函数，那必然调用基类析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样很明显导致内存泄露，故使用虚析构函数【加virtual后】</span></span><br><span class="line">    MoveObject* r = <span class="keyword">new</span> <span class="built_in">MonsterObject</span>();</span><br><span class="line">    <span class="keyword">delete</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-对象多态详解"><a href="#7-3-对象多态详解" class="headerlink" title="7.3 对象多态详解"></a>7.3 对象多态详解</h4><blockquote><p>方法多态：多态类，而对象多态：类里有虚函数</p></blockquote><h5 id="7-3-1-对象多态类型转换"><a href="#7-3-1-对象多态类型转换" class="headerlink" title="7.3.1 对象多态类型转换"></a>7.3.1 对象多态类型转换</h5><ul><li>向上转型【基类指针转派生类指针】被允许【三种类型转换方法】</li><li>向下转型【派生类指针转基类指针】：不允许虚基类进行类型转换【原因待补充】</li><li>对多重继承问题，由于基类不明确，故不允许对象多态的类型转换【也存在特例】【尽量避免】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    vi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:<span class="keyword">public</span> MonsterObject&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>:MonsterObject&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span>:<span class="keyword">public</span> Wolf,<span class="keyword">public</span> Man&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan2</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> MoveObject &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject monster;</span><br><span class="line">    MoveObject* _move = &amp;monster;<span class="comment">//隐式类型转换 向上转型【基类-&gt;派生类】</span></span><br><span class="line">    <span class="comment">//MonsterObject* _pmonster = _move;//【不被允许】隐式类型转换 向下转型【派生类-&gt;基类】</span></span><br><span class="line">    MonsterObject* _pmonster = (MonsterObject*)_move;<span class="comment">//强制类型转换【默认认为程序员认可的行为】</span></span><br><span class="line">    MonsterObject* _ppmonster = <span class="built_in">static_cast</span>&lt;MonsterObject*&gt;(_move);<span class="comment">//c++自带类型转换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、上面是三种类型转换方式</span></span><br><span class="line"><span class="comment">    2、对象多态的【隐式类型转换和static_cast】：只能转public继承【可以用强制转换】</span></span><br><span class="line"><span class="comment">    3、对象多态的类型转换：不允许虚基类进行类型转换【向下转型】【原因待补充】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    WolfMan wm;</span><br><span class="line">    <span class="type">void</span>* ptr = &amp;wm;<span class="comment">//发生一次类型转换 WolfMan* -&gt; void*【指针的两个信息：类型和地址，此时类型信息丢失】</span></span><br><span class="line">    <span class="comment">//注意：c++17后的void* ptr;给其他变量赋值时，需要加强制转换【否则报错】因为面临类型丢失的问题</span></span><br><span class="line"></span><br><span class="line">    Wolf* pwlf = &amp;wm;<span class="comment">//向下转型 WolfMan* -&gt; Wolf*</span></span><br><span class="line">    Man* pman = &amp;wm;<span class="comment">//向下转型  WolfMan* -&gt; Man*</span></span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pwlf &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pman &lt;&lt; std::endl;<span class="comment">//0019FADF,0019FADF,0019FAE0</span></span><br><span class="line">    <span class="comment">// 即 ptr = pwlf != pman 故本质是运算，而不是简单的等于赋值</span></span><br><span class="line"></span><br><span class="line">    Wolf* pwlf2 = (Wolf*)ptr;<span class="comment">//void* -&gt; Wolf*【此时只有地址信息，故转换后的地址相同】</span></span><br><span class="line">    Man* pman2 = (Man*)ptr;<span class="comment">//void* -&gt; Man*</span></span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pwlf2 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pman2 &lt;&lt; std::endl;<span class="comment">//相等</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于此时的多重继承</span></span><br><span class="line">    <span class="comment">//_move = &amp;wm;//错误：基类不明确</span></span><br><span class="line">    <span class="comment">//_move = (MoveObject*) &amp;wm;//错误：基类不明确 强制类型转换也依然不允许</span></span><br><span class="line">    <span class="comment">//_move = static_cast&lt;MoveObject*&gt;(&amp;wm); //错误：基类不明确</span></span><br><span class="line">    <span class="comment">//原因：此处并非虚继承，内存中存在多个MoveObject内容</span></span><br><span class="line">    <span class="comment">//可能存在特例：如 WolfMan2直接继承了基类，但是转换后指向的是Wolf中的MoveObject</span></span><br><span class="line">    WolfMan2 wm2;</span><br><span class="line">    <span class="comment">//wm2.x = 250;//不明确</span></span><br><span class="line">    wm<span class="number">2.</span>::Wolf::MonsterObject::MoveObject:: x = <span class="number">250</span>;</span><br><span class="line">    wm<span class="number">2.</span>::MoveObject::x = <span class="number">350</span>;</span><br><span class="line">    _move = <span class="built_in">static_cast</span>&lt;MoveObject*&gt;(&amp;wm2);</span><br><span class="line">    std::cout &lt;&lt; _move-&gt;x &lt;&lt; std::endl;<span class="comment">//350</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-2-动态类型转换"><a href="#7-3-2-动态类型转换" class="headerlink" title="7.3.2 动态类型转换"></a>7.3.2 动态类型转换</h5><blockquote><p>上一节讲到的类型转换存在一些风险，这一节使用动态类型转换来规避风险</p></blockquote><p>语法：<code>dynamic_cast&lt;目标类型&gt;()</code></p><p>注意事项：</p><ul><li><code>dynamic_cast</code> 只能用于支持<strong>方法多态类型</strong>的指针【必须有虚函数】。如果转换成功，返回指针；转换失败返回<code>nullptr</code></li><li>一般动态转换分为两种情况：<ul><li>① 向下转换 <code>downcast</code></li><li>② 跨类转换 <code>crosscast</code></li></ul></li><li>注意不要转换 <code>this</code> 指针【写法正确，但基类太过依赖派生类】</li><li>当 <code>dynamic_cast</code> 用于转换引用时，转换失败将会抛出异常，一般不推荐转换引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move:MoveObjectMove&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">not_use_this_to_devert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if(dynamic_cast&lt;MonsterObject*&gt;((this)))</span></span><br><span class="line">        <span class="comment">//不推荐上面的写法，写法正确，但基类太过依赖派生类，不是什么好事</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">monsterMove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;monsterMove&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move:monsterMove&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">npcMove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;npcMove&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move:npcMove&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> :<span class="keyword">public</span> MonsterObject &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> :MonsterObject &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> Man &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan2</span> :<span class="keyword">public</span> Wolf, <span class="keyword">public</span> MoveObject &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BOSS</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WolfMan3</span> : <span class="keyword">public</span> Wolf, <span class="keyword">public</span> BOSS &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonsterObject monster;</span><br><span class="line">    MoveObject* _move = &amp;monster;<span class="comment">//隐式类型转换 向上转型【基类-&gt;派生类】</span></span><br><span class="line">    MonsterObject&amp; lMove = monster;<span class="comment">//对于指针的类型转换同样使用引用，但</span></span><br><span class="line"></span><br><span class="line">    _move = <span class="keyword">new</span> <span class="built_in">MoveObject</span>();</span><br><span class="line">    MonsterObject* _pmonster1 = <span class="built_in">static_cast</span>&lt;MonsterObject*&gt;(_move);<span class="comment">//向下转型【可以转但有风险，内存结构不一致】</span></span><br><span class="line">    MonsterObject* _pmonster2 = <span class="built_in">dynamic_cast</span>&lt;MonsterObject*&gt;(_move);<span class="comment">//会报错【必须报告多态类型，即必须要有虚函数】</span></span><br><span class="line">    <span class="comment">//显示：转换失败</span></span><br><span class="line">    <span class="keyword">if</span> (_pmonster2 == <span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二个例子</span></span><br><span class="line">    <span class="keyword">auto</span> _pmonster3 = <span class="built_in">dynamic_cast</span>&lt;MonsterObject*&gt;(_move);</span><br><span class="line">    <span class="keyword">auto</span> _pnpc = <span class="built_in">dynamic_cast</span>&lt;NPCObject*&gt;(_move);</span><br><span class="line">    <span class="keyword">if</span> (_pmonster3 != <span class="literal">nullptr</span>) _pmonster3-&gt;<span class="built_in">monsterMove</span>();</span><br><span class="line">    <span class="keyword">if</span> (_pnpc != <span class="literal">nullptr</span>) _pnpc-&gt;<span class="built_in">npcMove</span>();</span><br><span class="line">    <span class="comment">//应该使用虚函数来优化代码</span></span><br><span class="line">    _move-&gt;<span class="built_in">move</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三个例子</span></span><br><span class="line">    <span class="comment">//NPCObject&amp; lNPC = dynamic_cast&lt;NPCObject&amp;&gt;(monster);//报错未经处理的异常：std::bad_cast</span></span><br><span class="line">    <span class="comment">//原因：指针有空指针，引用没有空引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四个例子：跨类型转换【例子中，WolfMan3中继承的BOSS类】</span></span><br><span class="line">    <span class="comment">//MoveObject -&gt; BOSS?</span></span><br><span class="line">    WolfMan3 wm3;</span><br><span class="line">    MoveObject* _pmove = &amp;wm3;</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">dynamic_cast</span>&lt;WolfMan3*&gt;(_pmove);</span><br><span class="line">    std::cout &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">dynamic_cast</span>&lt;BOSS*&gt;(_pmove);<span class="comment">//即将MoveObject -&gt; BOSS【跨类转换】</span></span><br><span class="line">    std::cout &lt;&lt; p2 &lt;&lt; std::endl;<span class="comment">//本质是因为WolfMan3这块内存包含MoveObject和 BOSS</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-使用-typeid-调试多态"><a href="#7-3-3-使用-typeid-调试多态" class="headerlink" title="7.3.3 使用 typeid 调试多态"></a>7.3.3 使用 <code>typeid</code> 调试多态</h5><p><code>typeid</code> 得到类型的名称，使用的两个条件：</p><ul><li>基类有虚函数【为什么非要包含虚函数？| 最后一节解释】</li><li>指针解引用【为什么非要解除引用？】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> : <span class="keyword">public</span> MoveObject</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(a1).<span class="built_in">name</span>()&lt;&lt;std::endl;<span class="comment">//int</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a2;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(a2).<span class="built_in">name</span>() &lt;&lt; std::endl;<span class="comment">//__int64</span></span><br><span class="line">    <span class="comment">//故仅作调试，不稳定</span></span><br><span class="line"></span><br><span class="line">    MoveObject* _move = <span class="keyword">new</span> <span class="built_in">MoveObject</span>();</span><br><span class="line">    _move = <span class="keyword">new</span> <span class="built_in">MonsterObject</span>();</span><br><span class="line">    <span class="comment">//_move是MoveObject还是MonsterObject？</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(_move).<span class="built_in">name</span>() &lt;&lt; std::endl;<span class="comment">//class MoveObject *</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(*_move).<span class="built_in">name</span>() &lt;&lt; std::endl;<span class="comment">//class MoveObject</span></span><br><span class="line">    <span class="comment">//上面的输出说明，此时typeid不支持多态</span></span><br><span class="line">    <span class="comment">//想要typeid支持多态，需要在 基类 加入虚函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(_move).<span class="built_in">name</span>() &lt;&lt; std::endl;<span class="comment">//class MoveObject *</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(*_move).<span class="built_in">name</span>() &lt;&lt; std::endl;<span class="comment">//class MonsterObject </span></span><br><span class="line">    <span class="comment">// 因此，typeid可用的两个条件：①基类有虚函数 ②指针解引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用的例子</span></span><br><span class="line">    MonsterObject wolf;</span><br><span class="line">    MoveObject&amp; lMove = wolf;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(lMove).<span class="built_in">name</span>() &lt;&lt; std::endl;<span class="comment">//class MonsterObject</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">typeid</span>(lMove)== <span class="built_in">typeid</span>(MonsterObject))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Right!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-纯虚函数和抽象类"><a href="#7-4-纯虚函数和抽象类" class="headerlink" title="7.4 纯虚函数和抽象类"></a>7.4 纯虚函数和抽象类</h4><blockquote><p>纯虚函数 | 抽象类 | 接口类</p></blockquote><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。因此可以将虚函数改为<strong>纯虚函数</strong>。纯虚函数语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//virtual 返回值类型 函数名 （参数列表）= 0;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类也称为<span style="background:#ff0">抽象类</span></p><p><strong>抽象类特点</strong>：</p><ul><li>抽象类无法实例化对象，但可以使用<strong>抽象类指针和引用</strong>作为返回类型和参数类型</li><li>【建议】抽象类的构造函数因为不能实际使用，故一般推荐将抽象类的构造函数定义为 <code>protected</code></li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>接口类</strong>：类中只定义了一堆纯虚函数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">    <span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base * base = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">    base = <span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-4-1-多态案例二：制作饮品"><a href="#7-4-1-多态案例二：制作饮品" class="headerlink" title="7.4.1 多态案例二：制作饮品"></a>7.4.1 多态案例二：制作饮品</h5><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//规定流程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Boil</span>();</span><br><span class="line">        <span class="built_in">Brew</span>();</span><br><span class="line">        <span class="built_in">PourInCup</span>();</span><br><span class="line">        <span class="built_in">PutSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">    drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">    <span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-虚析构和纯虚析构"><a href="#7-5-虚析构和纯虚析构" class="headerlink" title="7.5 虚析构和纯虚析构"></a>7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p><strong>解决方式：</strong>将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构<strong>共性</strong>：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构<strong>区别</strong>：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚析构语法：</span></span><br><span class="line"><span class="keyword">virtual</span> ~类名()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚析构语法：</span></span><br><span class="line"><span class="keyword">virtual</span> ~类名() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义</span></span><br><span class="line">类名::~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">    <span class="comment">//virtual ~Animal()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">    <span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">    <span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p><br><h4 id="7-6-虚函数的实现机制"><a href="#7-6-虚函数的实现机制" class="headerlink" title="7.6 虚函数的实现机制"></a>7.6 虚函数的实现机制</h4><p><img src="/.io//cpp7-6.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//【unknown| x86】</span></span><br><span class="line">    <span class="type">int</span> HP;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AIM&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AIM die&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WOLF</span> :<span class="keyword">public</span> AIM</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WOLF&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wolf die&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;aoaoaoaoao~~~&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hack!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AIM* wolf = <span class="keyword">new</span> <span class="built_in">WOLF</span>();</span><br><span class="line">    wolf-&gt;<span class="built_in">Die</span>();<span class="comment">//Wolf die</span></span><br><span class="line">    wolf-&gt;<span class="built_in">Eat</span>();<span class="comment">//WOLF</span></span><br><span class="line">    <span class="comment">//如何实现？</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(AIM) &lt;&lt; std::endl;<span class="comment">//8，为什么4字节-&gt;8字节</span></span><br><span class="line">    std::cout &lt;&lt; wolf &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; &amp;wolf-&gt;HP &lt;&lt; std::endl;<span class="comment">//00FE45D8,00FE45DC【即在HP前加了点脏东西】</span></span><br><span class="line">    <span class="comment">//头部加了4字节的什么脏东西？【x86】</span></span><br><span class="line"></span><br><span class="line">    WOLF aWolf;</span><br><span class="line">    aWolf.<span class="built_in">Sound</span>();<span class="comment">//此处为this_call函数调用【普通的成员函数调用】</span></span><br><span class="line">    <span class="comment">// 从汇编见下个Block</span></span><br><span class="line">    <span class="comment">// 从汇编可知，4字节是指针，同理在x64下为8字节</span></span><br><span class="line">    <span class="comment">// 在具体来看，该指针指向一个表，即虚函数表【当然，每一个多态类都有自己的虚函数表】</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>* vtable = (<span class="type">unsigned</span>*)wolf;</span><br><span class="line">    std::cout &lt;&lt;std::hex&lt;&lt;  <span class="string">&quot;vTable:&quot;</span> &lt;&lt; vtable &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;vTable[0]:&quot;</span> &lt;&lt; vtable[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>* func = (<span class="type">unsigned</span>*)vtable[<span class="number">0</span>];</span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;eat:&quot;</span> &lt;&lt; func[<span class="number">0</span>] &lt;&lt; std::endl;<span class="comment">//f510dc</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;die:&quot;</span> &lt;&lt; func[<span class="number">1</span>] &lt;&lt; std::endl;<span class="comment">//f5115e</span></span><br><span class="line">    <span class="comment">// 调用地址同汇编中的eax内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试修改虚函数表</span></span><br><span class="line">    <span class="comment">//func[0] = (unsigned)Hack;//func[0]属性为只读，写入权限异常，需要调用windows API</span></span><br><span class="line">    <span class="comment">//使用windows API修改权限</span></span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(func, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    func[<span class="number">0</span>] = (<span class="type">unsigned</span>)Hack;</span><br><span class="line">    wolf-&gt;<span class="built_in">Eat</span>();<span class="comment">//Hack!</span></span><br><span class="line"></span><br><span class="line">    AIM* _aim = <span class="keyword">new</span> <span class="built_in">WOLF</span>();</span><br><span class="line">    _aim-&gt;<span class="built_in">Eat</span>();<span class="comment">//Hack!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有通过指针访问函数才会调用虚函数表</span></span><br><span class="line">    aWolf.<span class="built_in">Eat</span>();<span class="comment">//WOLF【不涉及指针，即编译时可确定地址】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编截取：【以<code>Sound</code>和<code>Die</code>为例】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 类普通成员函数 WOLF::Sound</span><br><span class="line">00A667EB  lea         ecx,[aWolf]  </span><br><span class="line">00A667EE  call        WOLF::Sound (0A61523h)  </span><br><span class="line"></span><br><span class="line"># 类多态成员函数 WOLF::Die</span><br><span class="line">    38:     wolf-&gt;Die();//Wolf die</span><br><span class="line">00A6674B  mov         eax,dword ptr [wolf]  #将头部加了的4字节的脏东西取出放入eax</span><br><span class="line">00A6674E  mov         edx,dword ptr [eax]   #这个脏东西是个地址，即指针[放入edx]</span><br><span class="line">00A66750  mov         esi,esp  </span><br><span class="line">00A66752  mov         ecx,dword ptr [wolf]  </span><br><span class="line">00A66755  mov         eax,dword ptr [edx+4] #将指针所指空间+4的位置放入eax</span><br><span class="line">00A66758  call        eax                      #调用函数【必然是Die的函数地址】</span><br><span class="line">00A6675A  cmp         esi,esp  </span><br><span class="line">00A6675C  call        __RTC_CheckEsp (0A61302h)  </span><br><span class="line"></span><br><span class="line"># 类多态成员函数 WOLF::Eat</span><br><span class="line">    39:     wolf-&gt;Eat();//WOLF</span><br><span class="line">00816761  mov         eax,dword ptr [wolf]  </span><br><span class="line">00816764  mov         edx,dword ptr [eax]  </span><br><span class="line">00816766  mov         esi,esp  </span><br><span class="line">00816768  mov         ecx,dword ptr [wolf]  </span><br><span class="line">0081676B  mov         eax,dword ptr [edx]  #将指针所指空间的位置放入eax</span><br><span class="line">0081676D  call        eax                     #调用函数【必然是Eat的函数地址】</span><br><span class="line">0081676F  cmp         esi,esp  </span><br><span class="line">00816771  call        __RTC_CheckEsp (0811302h)  </span><br></pre></td></tr></table></figure><p><strong>虚函数的性质总结</strong></p><ul><li>每一个多态类都有自己的虚函数表；对于某个类的多个实例，内存中只存一张虚函数表即可【也就是说，这N个实例对象内存的头部，都有一个相同的指针，即指向虚函数表的指针】【由于对该指针加密的成本过高，故为破解提供可能，如修改了虚函数表的内容】</li><li>通过修改虚函数表的数据可以实现劫持</li><li>只有通过指针访问函数才会调用虚函数表【不涉及指针，即与多态无关，即编译时可确定地址】</li></ul><br><h4 id="7-7-多态的补充"><a href="#7-7-多态的补充" class="headerlink" title="7.7 多态的补充"></a>7.7 多态的补充</h4><h5 id="7-7-1-类的成员函数的函数指针"><a href="#7-7-1-类的成员函数的函数指针" class="headerlink" title="7.7.1 类的成员函数的函数指针"></a>7.7.1 类的成员函数的函数指针</h5><p>回顾函数指针，只要形态一直，该指针就可以指向不同的函数【详解见 <code>3.4</code>节】</p><p>而对于类的成员函数，如何使用函数指针？【实际用的不是很多】【函数多态】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要提前声明！！！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WOLF</span>;</span><br><span class="line"><span class="comment">// 对于类成员函数的指针【最大的区别在于存在this指针】</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(WOLF::* ptrfunc_part)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WOLF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ptrfunc_part ptr_wolf;</span><br><span class="line">    <span class="built_in">WOLF</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_wolf = &amp;WOLF::groupUP1;</span><br><span class="line">        <span class="comment">//this-&gt;*ptr_wolf();//报错：明显调用的表达式前的括号必须具有(指针)函数类型 </span></span><br><span class="line">        (<span class="keyword">this</span>-&gt;*ptr_wolf)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">groupUP1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;狼成长到一阶段！\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">groupUP2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;狼成长到二阶段！\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">groupUP3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;狼成长到三阶段！\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态成员函数！\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于普通函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ptrfunc)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 同理对静态类成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ptrStatic)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*ptr1)() = printd;</span><br><span class="line">    <span class="comment">//typedef后</span></span><br><span class="line">    ptrfunc ptr2 = printd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类成员函数的指针</span></span><br><span class="line">    ptrfunc_part ptr3=&amp;WOLF::groupUP2;</span><br><span class="line">    WOLF* pwolf = <span class="keyword">new</span> <span class="built_in">WOLF</span>();</span><br><span class="line">    (pwolf-&gt;*ptr3)();<span class="comment">//狼成长到一阶段！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类成员函数的指针：也可能定义在类内部</span></span><br><span class="line">    <span class="comment">//对于静态类成员函数【由于其没有this指针，故写法同普通函数】</span></span><br><span class="line">    ptrStatic _count = WOLF::count;</span><br><span class="line">    _count();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-7-2-多态案例：电脑组装"><a href="#7-7-2-多态案例：电脑组装" class="headerlink" title="7.7.2 多态案例：电脑组装"></a>7.7.2 多态案例：电脑组装</h5><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算）、显卡（用于显示）、内存条（用于存储）</p><ul><li><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p></li><li><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p></li><li><p>测试时组装三台不同的电脑进行工作</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的计算函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的显示函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的存储函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cpu = cpu;</span><br><span class="line">        m_vc = vc;</span><br><span class="line">        m_mem = mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供工作的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">        m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">        m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">        m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">    ~<span class="built_in">Computer</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放CPU零件</span></span><br><span class="line">        <span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_cpu;</span><br><span class="line">            m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放显卡零件</span></span><br><span class="line">        <span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_vc;</span><br><span class="line">            m_vc = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放内存条零件</span></span><br><span class="line">        <span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_mem;</span><br><span class="line">            m_mem = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">    VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">    Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一台电脑零件</span></span><br><span class="line">    CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">    VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">    Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建第一台电脑</span></span><br><span class="line">    Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">    computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第二台电脑组装</span></span><br><span class="line">    Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">    computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第三台电脑组装</span></span><br><span class="line">    Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">    computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-文件操作"><a href="#8-文件操作" class="headerlink" title="8 文件操作"></a>8 文件操作</h3><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 <code>&lt; fstream &gt;</code></p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong> - 文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h4 id="8-1-文本文件"><a href="#8-1-文本文件" class="headerlink" title="8.1 文本文件"></a>8.1 文本文件</h4><h5 id="8-1-1-写文件"><a href="#8-1-1-写文件" class="headerlink" title="8.1.1 写文件"></a>8.1.1 写文件</h5><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary | ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 <code>fstream</code></li><li>读文件可以利用 <code>ofstream</code> ，或者<code>fstream</code>类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用<code>&lt;&lt;</code>可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h5 id="8-1-2-读文件"><a href="#8-1-2-读文件" class="headerlink" title="8.1.2 读文件"></a>8.1.2 读文件</h5><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    <span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">    <span class="comment">//string buf;</span></span><br><span class="line">    <span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)<span class="comment">// End of file</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h4 id="8-2-二进制文件"><a href="#8-2-二进制文件" class="headerlink" title="8.2 二进制文件"></a>8.2 二进制文件</h4><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 <code>ios::binary</code></p><h5 id="8-2-1-写文件"><a href="#8-2-1-写文件" class="headerlink" title="8.2.1 写文件"></a>8.2.1 写文件</h5><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建输出流对象【2|3为两种写法，这样可省略第三步】</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打开文件</span></span><br><span class="line">    <span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、写文件</span></span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li><li>写文件时，最好不要用 <code>string</code>，建议使用字符数组</li></ul><h5 id="8-2-2-读文件"><a href="#8-2-2-读文件" class="headerlink" title="8.2.2 读文件"></a>8.2.2 读文件</h5><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul><br><h3 id="9-编译器"><a href="#9-编译器" class="headerlink" title="9 编译器"></a>9 编译器</h3><h4 id="9-1-One-Definiton-Rule"><a href="#9-1-One-Definiton-Rule" class="headerlink" title="9.1 One Definiton Rule"></a>9.1 One Definiton Rule</h4><p>ODR，单一性原则，解决头文件嵌套问题【思想和概念，一系列规则构成】。</p><ul><li>转换单元</li><li>未定义行为</li></ul><p><strong>转换单元</strong>：我们写好的每个源文件(.cpp,.c)，将其所包含的头文件(<code>#include&lt;xx.h&gt;</code>)合并后,称为一个转换单元</p><p>编译器单独的将每一个转换单元生成为对应的对象文件(.obi)，对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象)；最后链接器将各个转换单元的对象文件链接起来，生成我们的目标程序。</p><p>比如在对象文件A中包含了定义在其他转换单元的引用，那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接，如果在所有的对象文件中都找不到这个定义，那么就会生成一个链接错误</p><blockquote><p>常识补充：</p><p>链接阶段错误：LNKXXXX</p><p>转换单元错误：Cxxxx【编译阶段】</p></blockquote><p><strong>未定义行为：</strong>C++标准未作规定的行为，称为未定义行为。其表现在执行结果不确定，在不同编译器下会有不同的效果。【如 <code>c = 2*a++ + ++a*6</code>】</p><p><strong>ODR</strong> 是一系列规则，程序中定义的每一个对象都有自己的规则。基本上，任何变量、函数、类、枚举、模板、<u>概念</u>（C++20）在每个转换单元中只允许有一个定义；非inline的函数或变量（C++17），在整个程序中，有且只有一个定义。</p><blockquote><p>const、static 的情况会例外，其只会在自己的转换单元才有效。</p></blockquote><p><strong>名称的链接属性：</strong>程序中的变量、函数、结构等都有自己的名字，这些名字具有不同的链接属性，链接器就是根据链接属性把各个对象文件链接起来。链接属性分三种：</p><ul><li>内部链接属性：该名称仅仅在本转换单元中有效</li><li>外部链接属性：该名称在其他的转换单元中也有效</li><li>无链接属性：该名称仅仅能够用于该名称的作用域内访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">6</span>; <span class="comment">// 内部链接属性：仅仅在本转换单元中有效</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span><span class="comment">// 内部链接属性【当然，去掉static，其具有外部链接属性】</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;<span class="comment">// 内部链接属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c = <span class="number">4</span>;<span class="comment">// 外部链接属性：在其他的转换单元中也有效</span></span><br><span class="line"><span class="comment">//inline int d = 10; //【c++17】不同于static，inline修饰变量的正确用法应该写在头文件里</span></span><br><span class="line"><span class="comment">// inline待补充</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用 <code>static</code> 强行将具有外部来链接属性的 <code>test()</code> 赋予内部链接属性，但这种做法不被推荐，目前仅被支持。而推荐使用<strong>未命名的命名空间</strong>【6.3 namespace 详解】来实现。</p><br><h4 id="9-2-define"><a href="#9-2-define" class="headerlink" title="9.2  #define"></a>9.2 #define</h4><p>五种用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ①定义常量：简单方便，无脑替换===================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A B  <span class="comment">// 将标识符A定义为B的别名【A的命名要求满足变量命名规则】</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 整数 int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 整数b int b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> float int<span class="comment">//错误示范，不要写</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ 定义常量：const定义常量：类型检查严格</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SCREEN_WIDTH&#123; <span class="number">1980</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②仅标识：该标识在编译时会被删除【本质相同，替换为空】==========</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Here</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Test_ <span class="comment">// 表示为测试变量</span></span></span><br><span class="line"><span class="comment">// 方便阅读【常见于windows API】</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _in_</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(_in_ <span class="type">int</span> a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③复杂表达式：类似于函数，但不同于函数，仅是宏替换==============</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(X,Y) X+Y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELEASE(x) delete[] x;x=nullptr; <span class="comment">// 减轻代码量【像内联函数】</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIGGER(X,Y) (X&gt;Y?X:Y) <span class="comment">// 不加括号在cout中处理不了</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ④输出字符串化:加#号【将X作字符串处理】======================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW(X) std::cout &lt;&lt; #X&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⑤输出字符串化:加##号【字符串连接】</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWLINK(X,Y) std::cout &lt;&lt; X##Y&lt;&lt;std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWFUN(X,Y) void X##Y()&#123;std::cout &lt;&lt; #X&lt;&lt;std::endl;&#125;</span></span><br><span class="line"><span class="built_in">SHOWFUN</span>(test,<span class="number">25</span>) <span class="comment">// 相当宏定义了一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⑥定义标志：如防止头文件嵌套================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> X</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    整数 a = <span class="number">2</span>;</span><br><span class="line">    整数b&#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> _Test_ c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止使用宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _Test_</span></span><br><span class="line">    <span class="comment">//int _Test_ d;//编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复杂表达式宏 例1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">SUM</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 复杂表达式宏 例2</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">RELEASE</span>(arr);</span><br><span class="line">    cout &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④字符串化</span></span><br><span class="line">    <span class="built_in">SHOW</span>(<span class="number">123</span>SSS_____SSS21);</span><br><span class="line">    <span class="built_in">SHOWLINK</span>(<span class="number">12</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test25</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言中经常通过 <code>#define</code> 定义常量。但在C++中有时候并不安全，而经常用 <code>const int a&#123;2&#125;;</code></p></blockquote><h4 id="9-3-namespace"><a href="#9-3-namespace" class="headerlink" title="9.3 namespace"></a>9.3 namespace</h4><p>为了避免命名冲突，将相关的函数、变量、结构体附加到一个特定的命名空间里，用于命名归类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;// 会将其中的所有命名引入</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//命名空间定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p&#123; <span class="number">0</span> &#125;;<span class="comment">//具有外部链接属性</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> q&#123; <span class="number">0</span> &#125;;<span class="comment">//具有内部链接属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间扩充</span></span><br><span class="line"><span class="keyword">namespace</span> t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h[<span class="number">20</span>];<span class="comment">//命名空间定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//value = 25;// 无法访问</span></span><br><span class="line">    t::value = <span class="number">25</span>;</span><br><span class="line">    <span class="type">int</span> cout&#123; <span class="number">0</span> &#125;;<span class="comment">// 若不写std</span></span><br><span class="line">    <span class="type">int</span> p&#123; <span class="number">250</span> &#125;;<span class="comment">//不具有链接属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 250 0</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot;,全局命名空间中的p=&quot;</span> &lt;&lt; ::p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> p;<span class="comment">//=0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ::p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局命名空间：</strong>所有具有链接属性的对象，只要没有定义命名空间，就默认定义在全局命名空间中，全局命名空间中。成员的访问不用显示的指定，当局部名称覆盖了全局名称时才需要显式的指定全局命名空间；</p><p><strong>命名空间扩展：</strong>多次定义并补充某名命名空间的命名定义。</p><p><strong>命名空间声明：</strong>可以在头文件进行命名空间的声明，源文件也可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件或源文件中</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> valuetmp;<span class="comment">//命名空间声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;<span class="comment">//命名空间内函数的声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">htd::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> htd::valuetmp&#123;<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> top</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> hack</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hack</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间嵌套：</strong>如上</p><p><strong>未命名的命名空间：</strong>为避免具有外部链接属性的命名冲突，以前使用 <code>static</code> 等来限制某函数仅在本文件中生效【目前不被推荐】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件中</span></span><br><span class="line"><span class="comment">// 未命名的命名空间：test()函数仅在本转换单元有效【本文件】</span></span><br><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hack!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间别名</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hack!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> newname = htd;</span><br></pre></td></tr></table></figure><p><strong>命名空间的别名：</strong>见上</p><h4 id="9-4-预处理指令逻辑"><a href="#9-4-预处理指令逻辑" class="headerlink" title="9.4  预处理指令逻辑"></a>9.4 预处理指令逻辑</h4><p><code>#ifdef、#ifndef、#else、#endif</code>；<code>#if、#elif、#else、#endif</code>。用于避免头文件嵌套、控制字符集、控制版本函数等。【<code>#if</code> 可以嵌套】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;emath.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE <span class="comment">//【配置属性|高级|字符集|调整字符集】</span></span></span><br><span class="line"><span class="type">wchar_t</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//UNICODE</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION==100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==101</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==(102+1)&amp;&amp;SWITCH</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5-预定义宏"><a href="#9-5-预定义宏" class="headerlink" title="9.5  预定义宏"></a>9.5 预定义宏</h4><blockquote><p>编译器提前定义的宏，不同编译器不同</p></blockquote><p><strong>标准预定义标识符：</strong></p><ul><li><code>__func__</code>【ISO C99 | ISO C++11】：返回函数名【用途：调试时需要记录异常由哪一个函数产生】</li></ul><p><strong>标准预定义宏：</strong></p><ul><li><code>__DATE__</code>【ISO C99 | ISO C++17】：源文件的编译日期</li><li><code>__TIME__</code>【ISO C99 | ISO C++17】：当前转换单元的转换时间</li><li><code>__FILE__</code>【ISO C99 | ISO C++17】：源文件的名称</li><li><code>__LINE__</code> 【ISO C99 | ISO C++17】：当前的行号</li><li><code>__cplusplus</code> 【ISO C99 | ISO C++17】：当翻译单元为C++时，cplusplus定义为一个整数文本，否则为未定义</li></ul><p><strong>MSVC预定义宏【仅常用 | 且为微软VS】：</strong></p><ul><li><code>_CHAR_UNSIGNED</code>：如果char类型为无符号，该宏定义为1否则为未定义</li><li><code>__COUNTER__</code>：从0开始，每次使用都会递增1</li><li><code>_DEBUG</code>：如果设置了/IDd/mDd /mTd该宏定义为1否则为未定义</li><li><code>__FUNCTION__</code>：函数名称不含修饰名</li><li><code>__FUNCDNAME__</code>：函数名称包含修饰名【如 <code>?add@@YAHHH@Z</code>】</li><li><code>__FUNCSIG__</code>：包含了函数签名的函数名【如 <code>int __cdecl add(int,int)</code>】</li><li><code>_WIN32</code>：当编译为32位ARM、64位ARM、X68或X64定义为1，否则为未定义【区分32/64】</li><li><code>_WIN64</code>：当编译为64位ARM或x64定义为1，否则未定义</li><li><code>__TIMESTAMP__</code>：最后一次源代码修改的时间和日期</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; __func__ &lt;&lt; std::endl;<span class="comment">//add</span></span><br><span class="line">    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;<span class="comment">//add</span></span><br><span class="line">    std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;<span class="comment">//?add@@YAHHH@Z【包含类型，用于函数重载】</span></span><br><span class="line">    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;<span class="comment">//int __cdecl add(int,int)</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; __func__ &lt;&lt; std::endl;<span class="comment">//main</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; __FILE__ &lt;&lt; std::endl;<span class="comment">//E:\About Chase\Art of Programming-2024\CPP\ConsoleApplication1\ConsoleApplication1\ConsoleApplication1.cpp</span></span><br><span class="line">    std::cout &lt;&lt; __TIME__ &lt;&lt; std::endl;<span class="comment">//16:53:28</span></span><br><span class="line">    std::cout &lt;&lt; __DATE__ &lt;&lt; std::endl;<span class="comment">//Mar 12 2024</span></span><br><span class="line">    std::cout &lt;&lt; __cplusplus &lt;&lt; std::endl;<span class="comment">//199711</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MSVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _CHAR_UNSIGNED</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char unsigned&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __COUNTER__;<span class="comment">//0</span></span><br><span class="line">    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;<span class="comment">//1</span></span><br><span class="line">    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG<span class="comment">//常用</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DEBUG MODE&quot;</span> &lt;&lt; std::endl;<span class="comment">//由此决定【配置|C/C++|代码生成|运行库】</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;WIN64&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;WIN32&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; __TIMESTAMP__ &lt;&lt; std::endl;<span class="comment">//Tue Mar 12 17:15:18 2024</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-6-调试"><a href="#9-6-调试" class="headerlink" title="9.6  调试"></a>9.6 调试</h4><p>编写好程序以后，可能会存在一些bug和错误。对于语法上的错误，编译器能够直接给出提示；而</p><p>对于逻辑上的错误，编译器不能够直接发现。</p><p>调试就是一个找错误和改错误的过程。为了方便调试，在编码风格上有几点小建议给大家：</p><ul><li>模块化</li><li>使用能够体现出具体意义的函数名和变量名</li><li>使用正确的缩进和代码块</li><li>良好的注释习惯</li></ul><blockquote><p>断点、逐语句、逐过程【跳过函数的逐句执行】、跳出【进入函数后直接跳出】</p><p>其他调试器：OllyDbg【OD，逆向调试器】、x96Dbg、WinDbg【较老，双机调试】</p></blockquote><p>使用预处理指令调试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG<span class="comment">//常用</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DEBUG MODE&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SWITCH<span class="comment">//常用</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DEBUG MODE&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br></pre></td></tr></table></figure><h4 id="9-7-assert"><a href="#9-7-assert" class="headerlink" title="9.7  assert"></a>9.7 assert</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assert(bool表达式)</span></span><br><span class="line"><span class="comment">// 若表达式=flase：调用std::abort()函数，弹出对话框</span></span><br><span class="line"><span class="comment">// assert宏 需要头文件cassert</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#define NDEBUG// 定义宏，使 assert无效【须在cassert.h之前】</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;输入整数：\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    std::cin &gt;&gt; a;</span><br><span class="line">    <span class="comment">// 在编译时，需要测试是否等于0【默认只能在Debug模式下可用】</span></span><br><span class="line">    <span class="built_in">assert</span>(a);</span><br><span class="line">    std::cout &lt;&lt; <span class="number">1000</span> / a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static_assert</code> 用于<strong>编译时</strong>检查条件：<code>static_assert(bool表达式，”错误信息“);</code></p><ul><li>不需要头文件</li><li>bool表达式只能是常量，因为如果是变量，在编译阶段根本无法知道值为多少</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//static_assert(a, &quot;wrong!&quot;);// 语法错误，只能是常量</span></span><br><span class="line">    <span class="comment">//static_assert(0, &quot;wrong!&quot;);// 正确例子</span></span><br><span class="line">    <span class="comment">//static_assert(x, &quot;wrong!&quot;);// 正确例子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真实场景：要求在release模式下，只能用32位编译</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>*) == <span class="number">4</span>, <span class="string">&quot;wrong!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="10-跨语言编程"><a href="#10-跨语言编程" class="headerlink" title="10  跨语言编程"></a>10 跨语言编程</h3><h4 id="10-1-C-调用汇编"><a href="#10-1-C-调用汇编" class="headerlink" title="10.1 C++调用汇编"></a>10.1 C++调用汇编</h4><h5 id="10-1-1-C-中使用汇编代码的时机和意义"><a href="#10-1-1-C-中使用汇编代码的时机和意义" class="headerlink" title="10.1.1 C++中使用汇编代码的时机和意义"></a>10.1.1 C++中使用汇编代码的时机和意义</h5><p>汇编语言本身等同于机器码。因此，汇编语言更容易编写出速度更快的代码，或者某些时候我们需要利用汇编代码完成某个操作，比如使用特殊的处理器MMX、SSE、AVX等，这些时候可以利用C++调用汇编代码。</p><p>但是大部分时候，我们并不需要用汇编代码来代替C++代码，现代编译器的优化技术已经非常成熟，我很少见到有人能写出比编译器编译的更好的汇编代码，除非你对指令集的所有细节已经非常了解；其次来讲，汇编代码的开发效率也远远小于C++。因此我们只是在某些特殊的场景使用汇编代码完成C/C++完成的不够好的功能。</p><p>不建议在C++中大量使用汇编代码的原因：</p><ul><li><p>降低代码的可移植性</p></li><li><p>降低代码的可维护性和阅读性</p></li></ul><p>实际上，我们也很少为了提升代码运行速度使用汇编代码。因为可以使用算法以及其他手段来提升我们的代码运算速度</p><h5 id="10-1-2-Microsoft-C-x86内联汇编"><a href="#10-1-2-Microsoft-C-x86内联汇编" class="headerlink" title="10.1.2 Microsoft C++ x86内联汇编"></a>10.1.2 Microsoft C++ x86内联汇编</h5><p>C++中使用汇编代码分为两张情况：</p><ul><li>内联汇编【直接在代码中使用汇编代码】</li><li>调用编译好的汇编模块【更适用于大范围使用的情况】</li></ul><p><strong>内联汇编器</strong></p><p>内联汇编器集成在编译器中，因此我们可以使用内联汇编器在C/C+代码中直接嵌入汇编代码【取决于编译器的支持】，而不需要单独去编译链接汇编代码。</p><p>另外，<code>AMD</code> 和 <code>x64</code> 架构不支持内联汇编，因此我们的探讨基于 x86 架构上使用 Visual c/C++内联汇编功能</p><p><strong>内联汇编器优缺点</strong></p><ul><li>内联汇编不需要单独的编译链接，所以比单独的汇编程序更加的方便</li><li>内联汇编代码可以使用代码中的C变量和函数，因此比较容易与C代码集成，完成C/C++不大容易完成的功能</li></ul><p>比如：① 利用fs寄存器读取进程信息；② 读取CPU序列号</p><p>但是内联汇编不适合大范围使用，如果大范围使用可以考虑专门写汇编代码模块，利用MASM编译，链接使用；其次来讲，内联汇编代码得到的是最终的汇编代码，因此可移植性不是很好</p><p><strong>语法：</strong></p><p>我们可以使用<code>_asm</code>关键字调用内联汇编，为了同以前的版本兼容，<code>_asm</code>等同于<code>__asm</code> 【除非指定了编译器选项/Za】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># _asm 汇编代码</span><br><span class="line">#例如 </span><br><span class="line">_asm mov eax,eax</span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">    mov eax,eax</span><br><span class="line">    mov eax,eax</span><br><span class="line">&#125;</span><br><span class="line">_asm mov eax,eax __asm mov eax,eax _asm mov eax,eax</span><br><span class="line">#_asm的大括号不会影响变量的使用范围</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以使用分号【;】或【//】或【/**/】为汇编添加注释</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">250</span>;</span><br><span class="line">    __asm mov eax, a; <span class="comment">//eax=a</span></span><br><span class="line">    __asm add eax, <span class="number">1</span>; eax = eax + <span class="number">1</span></span><br><span class="line">    __asm mov a, eax</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, <span class="number">1</span></span><br><span class="line">        mov a, eax</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//asm(&quot;mov eax, a&quot;)//C++标准语法，但一般不支持</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="10-1-3-asm中汇编编程规范"><a href="#10-1-3-asm中汇编编程规范" class="headerlink" title="10.1.3 __asm中汇编编程规范"></a>10.1.3 <code>__asm</code>中汇编编程规范</h5><ul><li>指令集</li><li><code>__asm</code> 与 <code>MASM</code></li><li><code>__asm</code> 与段引用：<code>__asm</code>中必须通过寄存器来引用段，不能通过段名称来访问</li><li>LENGTH SIZE TYPE</li><li><code>__asm</code> 调试【断点调试即可】</li></ul><p><strong>指令集</strong></p><p><code>_asm</code> 支持<code>Pentium4</code>和<code>AMD Athlon</code>所有操作码，支持<code>MMX</code>指令集</p><p>另外，可以利用<code>_emit</code>创建目标处理器支持的其他指令【即直接嵌入机器码】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm _emit Ox4A</span><br></pre></td></tr></table></figure><blockquote><p>如果通过<code>_emit</code>生成修改寄存器的值，编译器无法确定哪些寄存器受到影响，这个时候编译器容易做出错误判断，程序可能产生不可预测的行为</p></blockquote><p><code>__asm</code> <strong>与</strong> <code>MASM</code>【微软提供的编译器，专用于写汇编】</p><ul><li><p><code>__asm</code>支持<code>MASM</code>的所有表达式，但是<code>__asm</code>不能使用<code>MASM</code>指令定义数据对象，比如<code>DB DW DD DQ DT DF DUP</code></p></li><li><p><code>MASM</code>定义的结构和记录也不可以使用</p></li><li><p><code>__asm</code>不接受<code>STRUC RECORD WIDTH MASK</code>指令</p></li><li><p><code>__asm</code>支持<code>EVEN ALIGN</code></p></li></ul><p><strong>LENGTH SIZE TYPE</strong></p><p><code>LENGTH SIZE TYPE</code> 在<code>__asm</code>中可以使用，但是受到了限制。因为限制使用MASM指令，但是依然可以使用他们获取C++的类型信息</p><ul><li>LENGTH：获取数组元素的个数</li><li>SIZE：获取数组的大小</li><li>TYPE：获取数组元素的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">120</span>];</span><br><span class="line">    <span class="type">int</span> count, size_, type_;</span><br><span class="line">    <span class="comment">// 注意：size_\type为汇编中的关键字，故不能使用type作为变量，否则报错C2400 &quot;第一操作数&quot;中的内联汇编语法错误;找到&quot;,&quot;</span></span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov count, LENGTH a</span><br><span class="line">        mov size_, SIZE a</span><br><span class="line">        mov type_, TYPE a</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;<span class="comment">//元素个数120</span></span><br><span class="line">    std::cout &lt;&lt; size_ &lt;&lt; std::endl;<span class="comment">//数组大小480</span></span><br><span class="line">    std::cout &lt;&lt; type_ &lt;&lt; std::endl;<span class="comment">//元素大小4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-1-4-asm中C-C-编程规范"><a href="#10-1-4-asm中C-C-编程规范" class="headerlink" title="10.1.4 __asm中C/C++编程规范"></a>10.1.4 <code>__asm</code>中C/C++编程规范</h5><ul><li><code>__asm</code> 中可使用的C/C++内容<ul><li>符号、标签、变量、函数名称</li><li>常量【符号常量、enum成员】</li><li>宏、预处理指令</li><li>注释【三种注释】</li><li>类型名称【类名】</li><li>typedef</li></ul></li><li><code>__asm</code> 中使用运算符<ul><li><code>__asm</code>不能使用C/C++的专有运算符，比如<code>&lt;&lt; &gt;&gt;</code></li><li>但是C/C++ MASM共享的运算符，被解释为汇编语言运算符。比如，<code>[]</code>在C/C++中被解释为数组下标，但是在<code>__asm</code>中被解释为MASM索引运算符</li></ul></li><li><code>__asm</code> 中使用C/C++数据：如果C/C++类或者成员用有唯一的名称，<code>__asm</code>可以直接使用该名称来引用他；如果名称不算唯一，则需要加变量名称</li><li><code>__asm</code> 编写函数</li></ul><p>可使用内容示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return a + b;</span></span><br><span class="line">    <span class="comment">//编译器会在头尾添加默认的汇编代码来保证堆栈安全</span></span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> aRole;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123; <span class="number">250</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ca = <span class="number">5</span>;<span class="comment">//常量</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">6</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    Role r;</span><br><span class="line"></span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, a<span class="comment">//变量</span></span><br><span class="line">        add eax, <span class="number">1</span><span class="comment">//可用16进制符号0x或h</span></span><br><span class="line">        mov a, eax</span><br><span class="line">        call test<span class="comment">//函数</span></span><br><span class="line">        mov arr[<span class="number">8</span>], <span class="number">0</span><span class="comment">//此处的[]，意为MASM索引运算符，即8=2*4为字节数</span></span><br><span class="line"></span><br><span class="line">        lea eax, r</span><br><span class="line">        mov[eax].aRole, <span class="number">100</span><span class="comment">//mov [eax]r.aRole, 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jmp jmpA<span class="comment">//标签</span></span><br><span class="line">    &#125;</span><br><span class="line">    a++;</span><br><span class="line">jmpA:</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;<span class="comment">//251</span></span><br><span class="line">    std::cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; std::endl;<span class="comment">//3//0</span></span><br><span class="line">    std::cout &lt;&lt; r.aRole &lt;&lt; std::endl;<span class="comment">//100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">99</span>,<span class="number">1</span>)&lt;&lt; std::endl;<span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-1-5-asm中的优化和寄存器问题"><a href="#10-1-5-asm中的优化和寄存器问题" class="headerlink" title="10.1.5 __asm中的优化和寄存器问题"></a>10.1.5 <code>__asm</code>中的优化和寄存器问题</h5><ul><li>在内联汇编器中可以直接使用寄存器，但不推荐将寄存器作为变量【比如：<code>__asm</code>{} | C++代码 | <code>__asm</code>{}，在这种情况中不能保证寄存器未被使用】</li><li>函数调用约定<code>__fastcall</code> 会使用ecx/edx【<code>__fastcall</code>不建议包含<code>__asm</code>代码】</li><li>esp/ebp不建议私自改动</li></ul><p>涉及优化的问题：</p><ul><li><code>__asm</code>中的代码不会被编译器优化</li></ul><h5 id="10-1-6-declspec-naked"><a href="#10-1-6-declspec-naked" class="headerlink" title="10.1.6 __declspec(naked)"></a>10.1.6 __declspec(naked)</h5><p><code>10.1.4</code>节中使用<code>__asm</code>编写函数时发现，编译器会在<code>__asm</code>头尾加入一些默认汇编代码【编译器为了保障栈平衡】，可以使用<code>__declspec(naked)</code>【declare specification】来阻止编译器添加汇编代码。</p><p>使用<code>__declspec(naked)</code>声明的函数，编译器不会对该函数添加任何代码，并且该函数只能用汇编编写代码内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*_asm</span></span><br><span class="line"><span class="comment">    &#123;	//不能编译，缺少函数头尾</span></span><br><span class="line"><span class="comment">        mov eax, a</span></span><br><span class="line"><span class="comment">        add eax, b</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp,esp</span><br><span class="line"></span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, b</span><br><span class="line"></span><br><span class="line">        pop ebp</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;<span class="comment">//3//0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>C++主流程序员不会有</li><li><code>__declspec(naked)</code>不能用于数据定义、不能用于X64【不支持内联汇编】</li><li>函数指针【本质是地址】不具备<code>__declspec(naked)</code>属性</li><li>仅仅与函数定义有关，不用写在函数声明中</li></ul><br><h4 id="10-2-汇编补充知识"><a href="#10-2-汇编补充知识" class="headerlink" title="10.2 汇编补充知识"></a>10.2 汇编补充知识</h4><h5 id="10-2-1-常用指令"><a href="#10-2-1-常用指令" class="headerlink" title="10.2.1 常用指令"></a>10.2.1 常用指令</h5><p>lea指令</p><ul><li><code>return</code>一般使用 <code>eax</code> 传递来返回</li><li>栈中，esp为栈顶，栈顶以下为已使用的内存空间，上方可用【即小地址可用，不同架构可能不同】</li><li>栈中，ebp为栈底</li></ul><p>push指令，如 push 32</p><ol><li>esp = esp - 4</li><li>[esp] = 32</li></ol><p>pop指令，如 pop ebp</p><ol><li>xxx = [esp]</li><li>esp = esp + 4</li></ol><p>call 指令，如 call cd1020</p><ol><li>esp = esp - 4</li><li>[esp] = 【call 指令的下一条指令的地址】</li><li>CPU跳转cd1020</li></ol><p>ret 指令相当于pop出栈操作，能够拿到进入函数前的地址</p><br><h5 id="10-2-2-从函数角度理解栈"><a href="#10-2-2-从函数角度理解栈" class="headerlink" title="10.2.2 从函数角度理解栈"></a>10.2.2 从函数角度理解栈</h5><p>以下面的代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">250</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">Ave</span>(a, b);</span><br><span class="line">    c = c + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; Add &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">Add</span>(<span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应汇编为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">     4: int Ave(int a, int b)</span><br><span class="line">     5: &#123;</span><br><span class="line">00007FF6A5D01005 4C 24 08             and         al,8  </span><br><span class="line">     6:     a = a + 250;</span><br><span class="line">00007FF6A5D01008 8B 44 24 08          mov         eax,dword ptr [a]  </span><br><span class="line">00007FF6A5D0100C 05 FA 00 00 00       add         eax,0FAh  </span><br><span class="line">00007FF6A5D01011 89 44 24 08          mov         dword ptr [a],eax  </span><br><span class="line">     7:     return a + b;</span><br><span class="line">00007FF6A5D01015 8B 44 24 10          mov         eax,dword ptr [b]  </span><br><span class="line">00007FF6A5D01019 8B 4C 24 08          mov         ecx,dword ptr [a]  </span><br><span class="line">00007FF6A5D0101D 03 C8                add         ecx,eax  </span><br><span class="line">00007FF6A5D0101F 8B C1                mov         eax,ecx  </span><br><span class="line">     8: &#125;</span><br><span class="line">00007FF6A5D01021 C3                   ret  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     9: </span><br><span class="line">    10: int Add(int a, int b)</span><br><span class="line">    11: &#123;</span><br><span class="line">00007FF6A5D01030 89 54 24 10          mov         dword ptr [rsp+10h],edx  </span><br><span class="line">00007FF6A5D01034 89 4C 24 08          mov         dword ptr [rsp+8],ecx  </span><br><span class="line">00007FF6A5D01038 48 83 EC 38          sub         rsp,38h  </span><br><span class="line">    12:     int c = 250;</span><br><span class="line">00007FF6A5D0103C C7 44 24 20 FA 00 00 00 mov         dword ptr [c],0FAh  </span><br><span class="line">    13:     int d = Ave(a, b);</span><br><span class="line">00007FF6A5D01044 8B 54 24 48          mov         edx,dword ptr [b]  </span><br><span class="line">00007FF6A5D01048 8B 4C 24 40          mov         ecx,dword ptr [a]  </span><br><span class="line">00007FF6A5D0104C E8 AF FF FF FF       call        Ave (07FF6A5D01000h)  </span><br><span class="line">00007FF6A5D01051 89 44 24 24          mov         dword ptr [d],eax  </span><br><span class="line">    14:     c = c + d;</span><br><span class="line">00007FF6A5D01055 8B 44 24 24          mov         eax,dword ptr [d]  </span><br><span class="line">00007FF6A5D01059 8B 4C 24 20          mov         ecx,dword ptr [c]  </span><br><span class="line">00007FF6A5D0105D 03 C8                add         ecx,eax  </span><br><span class="line">00007FF6A5D0105F 8B C1                mov         eax,ecx  </span><br><span class="line">00007FF6A5D01061 89 44 24 20          mov         dword ptr [c],eax  </span><br><span class="line">    15:     return c;</span><br><span class="line">00007FF6A5D01065 8B 44 24 20          mov         eax,dword ptr [c]  </span><br><span class="line">    16: &#125;</span><br><span class="line">00007FF6A5D01069 48 83 C4 38          add         rsp,38h  </span><br><span class="line">00007FF6A5D0106D C3                   ret  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">    18: int main()</span><br><span class="line">    19: &#123;</span><br><span class="line">00007FF6A5D01070 48 83 EC 38          sub         rsp,38h  </span><br><span class="line">    20:     cout &lt;&lt; Add &lt;&lt; endl;</span><br><span class="line">00007FF6A5D01074 48 8D 15 B5 FF FF FF lea         rdx,[Add (07FF6A5D01030h)]  </span><br><span class="line">00007FF6A5D0107B 48 8B 0D 2E 10 00 00 mov         rcx,qword ptr [__imp_std::cout (07FF6A5D020B0h)]  </span><br><span class="line">00007FF6A5D01082 FF 15 20 10 00 00    call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6A5D020A8h)]  </span><br><span class="line">00007FF6A5D01088 48 8D 15 51 00 00 00 lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6A5D010E0h)]  </span><br><span class="line">00007FF6A5D0108F 48 8B C8             mov         rcx,rax  </span><br><span class="line">00007FF6A5D01092 FF 15 00 10 00 00    call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6A5D02098h)]  </span><br><span class="line">    21: </span><br><span class="line">    22:     system(&quot;pause&quot;);</span><br><span class="line">00007FF6A5D01098 48 8D 0D F1 11 00 00 lea         rcx,[__xmm@ffffffffffffffffffffffffffffffff+10h (07FF6A5D02290h)]  </span><br><span class="line">00007FF6A5D0109F FF 15 93 10 00 00    call        qword ptr [__imp_system (07FF6A5D02138h)]  </span><br><span class="line">    23: </span><br><span class="line">    24:     int x = Add(250, 50);</span><br><span class="line">00007FF6A5D010A5 BA 32 00 00 00       mov         edx,32h  </span><br><span class="line">00007FF6A5D010AA B9 FA 00 00 00       mov         ecx,0FAh  </span><br><span class="line">00007FF6A5D010AF E8 7C FF FF FF       call        Add (07FF6A5D01030h)  </span><br><span class="line">00007FF6A5D010B4 89 44 24 20          mov         dword ptr [x],eax  </span><br><span class="line">    25:     cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">00007FF6A5D010B8 8B 54 24 20          mov         edx,dword ptr [x]  </span><br><span class="line">00007FF6A5D010BC 48 8B 0D ED 0F 00 00 mov         rcx,qword ptr [__imp_std::cout (07FF6A5D020B0h)]  </span><br><span class="line">00007FF6A5D010C3 FF 15 D7 0F 00 00    call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6A5D020A0h)]  </span><br><span class="line">00007FF6A5D010C9 48 8D 15 10 00 00 00 lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6A5D010E0h)]  </span><br><span class="line">00007FF6A5D010D0 48 8B C8             mov         rcx,rax  </span><br><span class="line">00007FF6A5D010D3 FF 15 BF 0F 00 00    call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6A5D02098h)]  </span><br><span class="line">    26: </span><br><span class="line">    27:     return 0;</span><br><span class="line">00007FF6A5D010D9 33 C0                xor         eax,eax  </span><br><span class="line">    28: &#125;</span><br><span class="line">00007FF6A5D010DB 48 83 C4 38          add         rsp,38h  </span><br><span class="line">00007FF6A5D010DF C3                   ret</span><br></pre></td></tr></table></figure><br><h4 id="10-3-练习：获取CPU信息"><a href="#10-3-练习：获取CPU信息" class="headerlink" title="10.3 练习：获取CPU信息"></a>10.3 练习：获取CPU信息</h4><blockquote><p>Intel CPU</p></blockquote><p><img src="/.io//cpp10-1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetCPUInfo</span><span class="params">(<span class="type">char</span>* cpuMaker, <span class="type">int</span>&amp; Extern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> readEbx, readEcx, readEdx, readEax;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, <span class="number">0</span><span class="comment">//Intel约定:CPU制造商</span></span><br><span class="line">        cpuid</span><br><span class="line">        mov readEbx, ebx</span><br><span class="line">        mov readEcx, ecx</span><br><span class="line">        mov readEdx, edx</span><br><span class="line"></span><br><span class="line">        mov eax, <span class="number">1</span><span class="comment">//Intel约定:扩展信息</span></span><br><span class="line">        cpuid</span><br><span class="line">        mov readEax, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* writeInt = (<span class="type">int</span>*)cpuMaker;</span><br><span class="line">    writeInt[<span class="number">0</span>] = readEbx;</span><br><span class="line">    writeInt[<span class="number">1</span>] = readEdx;</span><br><span class="line">    writeInt[<span class="number">2</span>] = readEcx;</span><br><span class="line">    Extern = readEax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> Maker[<span class="number">0xff</span>]&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> ExternInfo;</span><br><span class="line">    <span class="built_in">GetCPUInfo</span>(Maker, ExternInfo);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CPU制造商：&quot;</span> &lt;&lt; Maker &lt;&lt; std::endl;<span class="comment">// CPU制造商：GenuineIntel</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CPU扩展信息：&quot;</span> &lt;&lt; ExternInfo &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(ExternInfo) &lt;&lt; std::endl;<span class="comment">//00000000000010010000011011101010</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Moustache 微信支付"><p>微信支付</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Moustache</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://hammerzer.github.io/2024/03/12/cpp-base-2/" title="CPP-BASE-2">https://hammerzer.github.io/2024/03/12/cpp-base-2/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/CPP%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> CPP基础</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2024/03/11/cpp-base-1/" rel="prev" title="CPP-BASE-1"><i class="fa fa-chevron-left"></i> CPP-BASE-1</a></div><div class="post-nav-item"><a href="/2024/03/13/cpp-base-3/" rel="next" title="CPP-BASE-3">CPP-BASE-3 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CONTENT-OUTLINE"><span class="nav-number">1.</span> <span class="nav-text">CONTENT OUTLINE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">二、C++ 核心编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">1 内存分区模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 程序运行前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 程序运行后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 new操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%90C%E3%80%91"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.4 动态内存分配【C】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.5 动态分配内存的风险</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">1.5.1 悬挂指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">1.5.2 内存碎片</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2、引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 引用的基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 引用注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 引用做函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4 引用做函数返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.5 引用的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.6.</span> <span class="nav-text">2.6 常量引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">2.2.7.</span> <span class="nav-text">2.7 右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F"><span class="nav-number">2.2.8.</span> <span class="nav-text">2.8 引用的其他注意</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-1-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.8.1.</span> <span class="nav-text">2.8.1 类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-2-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">2.2.8.2.</span> <span class="nav-text">2.8.2 指针和引用的异同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98"><span class="nav-number">2.3.</span> <span class="nav-text">3 函数提高</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 函数默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2 函数占位参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.3 函数的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%AD%A6%E4%B9%A0%E5%BA%95%E5%B1%82"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.3.1 学习底层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-%E4%BB%8E%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E6%A0%88"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">3.3.2 从函数的角度理解栈</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">2.3.4.</span> <span class="nav-text">3.4 函数指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">2.3.5.</span> <span class="nav-text">3.5 函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">3.5.1 函数重载概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">3.5.2 函数重载注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.3.6.</span> <span class="nav-text">3.6 函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-1-%E4%B8%BE%E4%BE%8B"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">3.6.1 举例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">3.6.2 函数模板和重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-3-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">3.6.3 函数模板参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-4-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.3.6.4.</span> <span class="nav-text">3.6.4 函数模板本质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%B8%87%E8%83%BD%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.6.5.</span> <span class="nav-text">3.6.5 练习：万能排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-%E6%8E%A8%E6%96%AD%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.3.7.</span> <span class="nav-text">3.7 推断函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-1-auto"><span class="nav-number">2.3.7.1.</span> <span class="nav-text">3.7.1 auto</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-2-decltype"><span class="nav-number">2.3.7.2.</span> <span class="nav-text">3.7.2 decltype</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-3-auto-gt-decltype-%E6%8B%96%E5%B0%BE"><span class="nav-number">2.3.7.3.</span> <span class="nav-text">3.7.3 auto-&gt;decltype 拖尾</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-4-%E6%8E%A8%E6%96%AD%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.7.4.</span> <span class="nav-text">3.7.4 推断函数模板的返回类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-number">2.3.8.</span> <span class="nav-text">3.8 C语言和C++联合编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-1-static-inline"><span class="nav-number">2.3.8.1.</span> <span class="nav-text">3.8.1 static inline</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-2-%E4%BB%8E%E7%BC%96%E8%AF%91%E5%99%A8%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="nav-number">2.3.8.2.</span> <span class="nav-text">3.8.2 从编译器角度理解定义和声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-3-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.8.3.</span> <span class="nav-text">3.8.3 头文件和源文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-4-extern"><span class="nav-number">2.3.8.4.</span> <span class="nav-text">3.8.4 extern</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-5-%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84SDK%EF%BC%9Ahongxin"><span class="nav-number">2.3.8.5.</span> <span class="nav-text">3.8.5 封装自己的SDK：hongxin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.3.8.6.</span> <span class="nav-text">3.8.6 自定义创建项目模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-7-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-number">2.3.8.7.</span> <span class="nav-text">3.8.7 函数调用约定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.</span> <span class="nav-text">4 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%B0%81%E8%A3%85"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1 封装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">4.1.1 封装的意义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-2-struct%E5%92%8Cclass%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">4.1.2 struct和class区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-3-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">4.1.3 成员属性设置为私有</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-4-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">4.1.4 成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-5-const"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">4.1.5 const</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2 对象的初始化和清理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">4.2.1 构造函数和析构函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-%E5%BC%95%E5%85%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">4.2.2 引入构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">4.2.3 构造函数的分类及调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">4.2.4 构造函数调用规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">4.2.5 深入理解构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-6-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">4.2.6 拷贝构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-7-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">4.2.7 深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-8-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">2.4.2.8.</span> <span class="nav-text">4.2.8 初始化列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-9-%E7%BB%83%E4%B9%A0%EF%BC%9Ahstring"><span class="nav-number">2.4.2.9.</span> <span class="nav-text">4.2.9 练习：hstring</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.4.3.</span> <span class="nav-text">4.3 类与对象的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">4.3.1 C++对象模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">4.3.2 this指针概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-3-%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">4.3.3 空指针访问成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">4.3.4 静态成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-5-malloc%E4%B8%8Enew%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.3.5.</span> <span class="nav-text">4.3.5 malloc与new的本质区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-6-%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3%E7%B1%BB"><span class="nav-number">2.4.3.6.</span> <span class="nav-text">4.3.6 从底层理解类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-7-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.4.3.7.</span> <span class="nav-text">4.3.7 自定义类的函数调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.4 友元</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">4.4.1 全局函数做友元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">4.4.2 类做友元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">4.4.3 成员函数做友元</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="nav-number">2.4.5.</span> <span class="nav-text">4.5 嵌套类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-1-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">4.5.1 类对象作为类成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-2-%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">4.5.2 局部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-2-%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">4.5.2 嵌套类的模块化问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.</span> <span class="nav-text">5 运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1 运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">5.1.1 运算符重载的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">5.1.2 运算符重载的原则和时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">5.1.3 赋值运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9Ahstring"><span class="nav-number">2.5.1.3.1.</span> <span class="nav-text">示例3：hstring</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-4-%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.4.</span> <span class="nav-text">5.1.4 左移右移运算符重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-5-%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.5.</span> <span class="nav-text">5.1.5 下标运算符重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-6-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.6.</span> <span class="nav-text">5.1.6 函数调用运算符重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-7-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.7.</span> <span class="nav-text">5.1.7 加号运算符重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-8-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.1.8.</span> <span class="nav-text">5.1.8 关系运算符重载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%9B%E9%98%B6"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2 运算符重载进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">5.2.1 重载类型转换运算符（一）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">5.2.2 重载类型转换运算符（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9Ahstirng"><span class="nav-number">2.5.2.2.1.</span> <span class="nav-text">练习：hstirng</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-3-%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%EF%BC%9A%E9%98%B2%E6%AD%A2%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">5.2.3 项目练习：防止游戏数据被修改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-4-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">5.2.4 递增运算符重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-%E9%87%8D%E8%BD%BD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.2.5.</span> <span class="nav-text">5.2.5 重载内存分配释放运算符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%9Ahstring"><span class="nav-number">2.5.3.</span> <span class="nav-text">5.3 阶段项目：hstring</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">2.6.</span> <span class="nav-text">6 类的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.6.1.</span> <span class="nav-text">6.1 继承的基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.2.</span> <span class="nav-text">6.2 继承方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.6.3.</span> <span class="nav-text">6.3 继承中的对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.4.</span> <span class="nav-text">6.4 继承中构造和析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-1-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">6.4.1 派生类的构造和析构顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-2-%E5%BC%BA%E5%88%B6%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">6.4.2 强制继承构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.5.</span> <span class="nav-text">6.5 继承中的同名成员问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-1-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">6.5.1 继承同名成员处理方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-2-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">6.5.2 继承同名静态成员处理方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.6.</span> <span class="nav-text">6.7 多继承问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-7-1-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">2.6.6.1.</span> <span class="nav-text">6.7.1 多继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-7-2-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">2.6.6.2.</span> <span class="nav-text">6.7.2 菱形继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.6.7.</span> <span class="nav-text">6.8 继承的本质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%A4%9A%E6%80%81"><span class="nav-number">2.7.</span> <span class="nav-text">7 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.1.</span> <span class="nav-text">7.1 多态的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.2.</span> <span class="nav-text">7.2 虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-1-%E8%99%9A%E5%87%BD%E6%95%B0%E5%88%9D%E8%AF%86"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">7.2.1 虚函数初识</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-2-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">7.2.2 多态案例：计算器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-3-%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">7.2.3 虚函数详解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.7.3.</span> <span class="nav-text">7.3 对象多态详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-1-%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">7.3.1 对象多态类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-2-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">7.3.2 动态类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-3-%E4%BD%BF%E7%94%A8-typeid-%E8%B0%83%E8%AF%95%E5%A4%9A%E6%80%81"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">7.3.3 使用 typeid 调试多态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">2.7.4.</span> <span class="nav-text">7.4 纯虚函数和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-1-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">7.4.1 多态案例二：制作饮品</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="nav-number">2.7.5.</span> <span class="nav-text">7.5 虚析构和纯虚析构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.6.</span> <span class="nav-text">7.6 虚函数的实现机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-7-%E5%A4%9A%E6%80%81%E7%9A%84%E8%A1%A5%E5%85%85"><span class="nav-number">2.7.7.</span> <span class="nav-text">7.7 多态的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-7-1-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">2.7.7.1.</span> <span class="nav-text">7.7.1 类的成员函数的函数指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-7-2-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85"><span class="nav-number">2.7.7.2.</span> <span class="nav-text">7.7.2 多态案例：电脑组装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.</span> <span class="nav-text">8 文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.1.</span> <span class="nav-text">8.1 文本文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-1-%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">8.1.1 写文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-2-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">8.1.2 读文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.2.</span> <span class="nav-text">8.2 二进制文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-2-1-%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">8.2.1 写文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-2-2-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">8.2.2 读文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">2.9.</span> <span class="nav-text">9 编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-One-Definiton-Rule"><span class="nav-number">2.9.1.</span> <span class="nav-text">9.1 One Definiton Rule</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-define"><span class="nav-number">2.9.2.</span> <span class="nav-text">9.2 #define</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-namespace"><span class="nav-number">2.9.3.</span> <span class="nav-text">9.3 namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E9%80%BB%E8%BE%91"><span class="nav-number">2.9.4.</span> <span class="nav-text">9.4 预处理指令逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-5-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="nav-number">2.9.5.</span> <span class="nav-text">9.5 预定义宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-6-%E8%B0%83%E8%AF%95"><span class="nav-number">2.9.6.</span> <span class="nav-text">9.6 调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-7-assert"><span class="nav-number">2.9.7.</span> <span class="nav-text">9.7 assert</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B"><span class="nav-number">2.10.</span> <span class="nav-text">10 跨语言编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-C-%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96"><span class="nav-number">2.10.1.</span> <span class="nav-text">10.1 C++调用汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-1-C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E6%9C%BA%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">10.1.1 C++中使用汇编代码的时机和意义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-2-Microsoft-C-x86%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-number">2.10.1.2.</span> <span class="nav-text">10.1.2 Microsoft C++ x86内联汇编</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-3-asm%E4%B8%AD%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="nav-number">2.10.1.3.</span> <span class="nav-text">10.1.3 __asm中汇编编程规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-4-asm%E4%B8%ADC-C-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="nav-number">2.10.1.4.</span> <span class="nav-text">10.1.4 __asm中C&#x2F;C++编程规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-5-asm%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.10.1.5.</span> <span class="nav-text">10.1.5 __asm中的优化和寄存器问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-6-declspec-naked"><span class="nav-number">2.10.1.6.</span> <span class="nav-text">10.1.6 __declspec(naked)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-%E6%B1%87%E7%BC%96%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="nav-number">2.10.2.</span> <span class="nav-text">10.2 汇编补充知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-2-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">2.10.2.1.</span> <span class="nav-text">10.2.1 常用指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-2-2-%E4%BB%8E%E5%87%BD%E6%95%B0%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E6%A0%88"><span class="nav-number">2.10.2.2.</span> <span class="nav-text">10.2.2 从函数角度理解栈</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-%E7%BB%83%E4%B9%A0%EF%BC%9A%E8%8E%B7%E5%8F%96CPU%E4%BF%A1%E6%81%AF"><span class="nav-number">2.10.3.</span> <span class="nav-text">10.3 练习：获取CPU信息</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Moustache" src="/images/180-180.png"><p class="site-author-name" itemprop="name">Moustache</p><div class="site-description" itemprop="description">我是小胡子</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">78</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/hammerzer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hammerzer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:stellar_lzu@163.com" title="E-Mail → mailto:stellar_lzu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Chase</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">1.9m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">29:01</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script size="300" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JRehDoQ6pHXV1zKg09AMNLFt-gzGzoHsz',
      appKey     : 'cRAt4W15KiQdrIuHlQrRrtIl',
      placeholder: "Just go go",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>